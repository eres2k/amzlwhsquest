<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMZL WHS Coordinator Quest</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #0a0a12;
            --accent-gold: #ffd700;
            --accent-cyan: #00ffff;
            --accent-orange: #ff9900;
        }

        body {
            margin: 0; padding: 0;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a12 50%, #000 100%);
            display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden;
            font-family: 'Press Start 2P', monospace; color: white; user-select: none;
        }

        #game-wrapper {
            position: relative; width: 768px; height: 672px;
            background: linear-gradient(135deg, #0f0f1a 0%, #000 100%);
            border: 4px solid #333;
            border-radius: 24px;
            box-shadow:
                0 0 60px rgba(255, 153, 0, 0.15),
                0 0 120px rgba(0, 255, 255, 0.08),
                inset 0 0 60px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #game-wrapper::before {
            content: '';
            position: absolute;
            top: -4px; left: -4px; right: -4px; bottom: -4px;
            background: linear-gradient(45deg, #ff9900, #00ffff, #ff00ff, #ff9900);
            background-size: 400% 400%;
            animation: borderGlow 8s ease infinite;
            border-radius: 28px;
            z-index: -1;
            opacity: 0.5;
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        #crt-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background:
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%),
                linear-gradient(90deg, rgba(255, 100, 0, 0.03), rgba(0, 255, 100, 0.02), rgba(100, 0, 255, 0.03));
            background-size: 100% 3px, 4px 100%; pointer-events: none; z-index: 900;
            animation: flicker 0.08s infinite, scanline 10s linear infinite;
        }

        @keyframes scanline {
            0% { background-position: 0 0, 0 0; }
            100% { background-position: 0 100%, 0 0; }
        }

        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(0,0,0,0.5) 80%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 901; border-radius: 20px;
        }

        @keyframes flicker {
            0%, 100% { opacity: 0.97; }
            50% { opacity: 1; }
        }

        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: flex-end; padding: 20px; box-sizing: border-box; z-index: 1000;
        }

        #dialog-box {
            width: 100%; min-height: 140px;
            background: linear-gradient(180deg, #0a1628 0%, #061020 100%);
            border: 3px solid #3b82f6;
            border-radius: 12px; display: none;
            flex-direction: row; padding: 16px; box-sizing: border-box;
            box-shadow:
                0 0 20px rgba(59, 130, 246, 0.4),
                6px 6px 0px rgba(0,0,0,0.6),
                inset 0 0 30px rgba(59, 130, 246, 0.1);
            pointer-events: auto;
        }

        #portrait {
            width: 64px; height: 64px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a14 100%);
            border: 3px solid #ffd700;
            border-radius: 8px;
            margin-right: 20px; flex-shrink: 0; image-rendering: pixelated;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        #text-content {
            flex-grow: 1; font-size: 13px; line-height: 1.7; color: #f0f0ff;
            text-shadow: 2px 2px 4px #000, 0 0 10px rgba(255, 255, 255, 0.1);
            white-space: pre-wrap;
        }

        #press-space-hint {
            font-size: 10px; color: #ffd700; margin-top: 10px;
            animation: blink 0.8s ease-in-out infinite; display: block;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }

        .gemini-badge {
            font-size: 9px; color: #00ffff; margin-bottom: 8px; display: none;
            text-transform: uppercase; text-shadow: 0 0 8px #00ffff;
            letter-spacing: 1px;
        }
        
        .loading-dots::after {
            content: ' .';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: ' .'; }
            40% { content: ' ..'; }
            60% { content: ' ...'; }
            80%, 100% { content: ''; }
        }
        
        /* Banner hidden as requested */
        #slogan-display {
            display: none; 
        }
        
        @keyframes blink { 50% { opacity: 0; } }

        .hud-text {
            position: absolute; top: 12px; right: 12px; color: white;
            text-align: right; text-shadow: 0 0 8px rgba(0,0,0,0.8), 2px 2px 4px black; font-size: 11px;
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(135deg, rgba(10, 15, 30, 0.95) 0%, rgba(5, 8, 20, 0.98) 100%);
            padding: 10px 14px; border: 2px solid #fbbf24; border-radius: 6px;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4), inset 0 0 15px rgba(0, 0, 0, 0.6), 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        .hud-text div:first-child { color: #ef4444; margin-bottom: 6px; letter-spacing: 1px; }
        .hud-text div:last-child { color: #22c55e; letter-spacing: 1px; }

        #boss-hud {
            position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
            width: 65%; display: none;
            background: linear-gradient(180deg, rgba(40, 10, 10, 0.9) 0%, rgba(20, 5, 5, 0.95) 100%);
            padding: 10px 16px; border-radius: 10px;
            border: 2px solid #dc2626;
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.4);
        }

        .boss-bar-bg {
            width: 100%; height: 14px;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #444; border-radius: 4px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
        }
        .boss-bar-fill {
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #ff4444 0%, #cc0000 50%, #aa0000 100%);
            transition: width 0.3s ease-out;
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5), inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }
        .boss-name {
            color: #ff4444; text-align: center; font-size: 11px; margin-bottom: 6px;
            text-shadow: 2px 2px 4px black, 0 0 10px rgba(255, 0, 0, 0.5);
            letter-spacing: 2px;
        }
        
        #ai-status {
            display: none !important; 
            position: absolute; top: 10px; left: 10px; font-size: 10px; color: #00ffff;
            background: rgba(0,0,0,0.8); padding: 4px; border: 1px solid #00ffff; pointer-events: none;
            z-index: 2000; 
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="ai-status">AI Status: Init</div>
        <canvas id="gameCanvas" width="256" height="224"></canvas>
        <div id="crt-overlay"></div>
        <div id="vignette"></div>

        <div id="ui-overlay">
            <div id="slogan-display"></div>

            <div class="hud-text" id="hud-layer" style="display:none;">
                <div style="color:#ff4444; margin-bottom:5px;">LIFE <span id="life-val">❤️❤️❤️❤️❤️</span></div>
                <div style="color:#44ff44;">HAZARDS: <span id="score-val">0/5</span></div>
            </div>
        
            <div id="boss-hud">
                <div class="boss-name" id="boss-name-el">BOSS NAME</div>
                <div class="boss-bar-bg"><div class="boss-bar-fill" id="boss-health-el"></div></div>
            </div>

            <div id="dialog-box">
                <canvas id="portrait" width="32" height="32"></canvas>
                <div style="display:flex; flex-direction:column; width:100%;">
                    <div id="gemini-badge" class="gemini-badge">✨ SIMON IS ANALYZING...</div>
                    <div id="text-content"></div>
                    <div id="press-space-hint">▼ PRESS SPACE</div>
                </div>
            </div>
        </div>
    </div>


<script type="module">
// --- CONFIG ---
let apiKey = null;
let apiKeyPromise = null;
const MODEL_NAME = "gemini-2.5-flash-lite";

// --- BANTER DATA ---
const BANTER_DB = {
    ops: [
        "TPH is down!", "Walk faster!", "No talking!", "VTO?",
        "Scan scan scan!", "Where's your vest?", "Audit panic!",
        "My bonus!", "TOT!", "Bad rate!", "Let's go!",
        "Chase blue line!", "Less chatter!", "Time is rate!", "Trim that idle!",
        "Metrics don't nap!", "Pick it up!", "Stay in lanes!"
    ],
    assoc: [
        "My feet...", "Break time?", "Box heavy...", "Ugh...",
        "Safety shoes hurt", "Where's HR?", "Need coffee...",
        "Too early...", "Night shift...", "Pizza party?",
        "Belt keeps eating me", "Where's my badge?", "Snacks when?",
        "Scanner dying...", "Stuck in pack?", "Shift never ends"
    ]
};

// --- CHARACTER DATA ---
const CHAR_DATA = {
    "Carrie": {
        role: "The 5S Monk",
        backstory: "Precision hawk who spots crooked tape from 50 meters and breathes calm into chaotic clusters.",
        attack: "Label Maker Burst",
        speed: 1.5,
        lives: 5
    },
    "Nevena": {
        role: "The Oracle",
        backstory: "Safety oracle who predicts mishaps, carries emergency Palatschinken, and documents everything twice.",
        attack: "Clipboard Shockwave",
        speed: 1.5,
        lives: 5
    },
    "Joao": {
        role: "The Siren",
        backstory: "Espresso cannon whose warnings ring louder than the fire alarm and kick energy through the floor.",
        attack: "Sonic Shout",
        speed: 1.5,
        lives: 5
    },
    "Roman": {
        role: "The Ghost",
        backstory: "Bald audit phantom. Appears, fixes, vanishes. Hazards straighten themselves when he is near.",
        attack: "Stealth Audit",
        speed: 1.5,
        lives: 5
    },
    "Erwin": {
        role: "The Manager",
        backstory: "Rolls in with a kid-sized Tesla and slides into briefings faster than gossip spreads.",
        attack: "Tesla Energy Pulse",
        speed: 2.0,
        lives: 1
    }
};

const ATTACKS = {
    "Carrie": { name: "Label Maker Burst", sprite: "attack_carrie", speed: 4.2, cooldown: 110, color: "#a855f7", text: "Aligned!" },
    "Nevena": { name: "Clipboard Shockwave", sprite: "attack_nevena", speed: 4.0, cooldown: 120, color: "#0ea5e9", text: "Documented!" },
    "Joao": { name: "Sonic Shout", sprite: "attack_joao", speed: 4.6, cooldown: 105, color: "#f97316", text: "Heard!" },
    "Roman": { name: "Stealth Audit Pulse", sprite: "attack_roman", speed: 4.0, cooldown: 115, color: "#94a3b8", text: "Noted." },
    "Erwin": { name: "Tesla Drift", sprite: "attack_erwin", speed: 5.0, cooldown: 140, color: "#22d3ee", text: "Zapped!" },
    default: { name: "Rule Book", sprite: "book", speed: 4.0, cooldown: 120, color: "#00ffff", text: "Hit!" }
};

function getAttackData(name) {
    return ATTACKS[name] || ATTACKS.default;
}

function getCharStats(name) {
    const data = CHAR_DATA[name] || {};
    return {
        speed: data.speed ?? 1.5,
        lives: data.lives ?? 5
    };
}

// --- SIMULATED AI DATABASE (FALLBACKS) ---
const SIMULATED_AI = {
    tips: [
        "Blocked exit? That box is your tombstone. Move it.",
        "Chemical spill? Entropy leaking. Contain it before you dissolve.",
        "Debris? Chaos on the floor leads to chaos in the soul. Clean it.",
        "Trip hazard? Gravity does not care about your excuses.",
        "Unstable stack? Newton is rolling in his grave. Fix it.",
        "Fire equipment blocked? Do you plan to fight fire with optimism?"
    ],
    runners: [
        "Halt! Kinetic energy is not your friend. Slow down.",
        "You are not a photon. You have mass. Walk.",
        "Running? I've seen glaciers move with more purpose.",
        "We fight entropy, not the clock. Walk."
    ],
    taunts: [
        "My spreadsheet predicts your failure!",
        "You cannot audit the inevitable!",
        "I am the final regulation!",
        "Compliance dropping... Termination imminent!",
        "Resistance is a safety violation!"
    ],
    simon_taunts: [
        "I AM THE SAFETY STANDARD!",
        "YOU CANNOT ESCAPE THE AUDIT!",
        "ENTROPY COMES FOR US ALL!",
        "YOUR PPE IS INSUFFICIENT!"
    ],
    simon_warnings: [
        "First warning: Stop flinging manuals. Compliance is not a contact sport.",
        "Final warning: Holster the rule books or I escalate this audit into a boss fight."
    ],
    reviews_win: [
        "Performance: IMPROBABLE. You survived. I am... adequately pleased.",
        "You fought chaos and won. For today.",
        "Adequate. Nothing to write up. Feels strange."
    ],
    reviews_loss: [
        "Performance: CATASTROPHIC. Entropy won.",
        "You failed. Gravity and stupidity destroyed us.",
        "Safety is binary. You are a zero."
    ]
};

// --- SIMON'S YARD SAFETY TIPS ---
const SIMON_YARD_TIPS = [
    "YARD SAFETY ALERT: Always use designated crosswalks. DSP vans have blind spots bigger than their ambition.",
    "CAUTION: The yard is NOT a shortcut. One associate versus a Prime van equals paperwork I don't want to file.",
    "REMINDER: Look both ways. Then look again. Those DSP drivers run on caffeine and impossible deadlines.",
    "YARD PROTOCOL: High-vis vests exist for a reason. Be seen or be statistics.",
    "CRITICAL: Vehicles have right of way. Your skeleton does not outweigh a delivery quota.",
    "SAFETY FIRST: If you hear a horn, MOVE. Don't stand there contemplating the meaning of life.",
    "PRO TIP: Headphones off in the yard. Music won't cushion the blow of a reversing semi.",
    "AUDIT NOTE: The yard claims more near-misses than I have patience. Stay alert, stay alive."
];

// --- JEFF YARD TAUNTS ---
const JEFF_YARD_TAUNTS = [
    "Come on then! I haven't got all day!",
    "You call that speed? My grandmother moves faster!",
    "The yard separates the workers from the WIMPS!",
    "Every second you waste costs the company money!",
    "I built this empire from NOTHING!",
    "You want a raise? EARN IT!",
    "Keep dodging! It's good entertainment!",
    "I've seen better coordination from interns!",
    "Tick tock! Your shift is almost OVER!",
    "Almost there... just kidding, you'll never make it!",
    "This is YOUR performance review!",
    "The trucks don't stop for ANYONE!",
    "MY DELIVERY FLEET IS UNSTOPPABLE!",
    "SAFETY? THAT'S NOT IN THE METRICS!",
    "PRODUCTIVITY OR TERMINATION!",
    "I CAN SEE YOUR TOT FROM HERE!",
    "YOUR RATE IS UNACCEPTABLE!",
    "CUSTOMER OBSESSION DEMANDS SACRIFICE!",
    "THINK BIG, DIE TRYING!",
    "NO BATHROOM BREAKS IN MY YARD!",
    "BIAS FOR ACTION MEANS RUN FASTER!",
    "I OWN THE CLOUDS AND THE GROUND!"
];

// --- JEFF CASTLE TAUNTS ---
const JEFF_CASTLE_TAUNTS = [
    "WELCOME TO MY FORTRESS OF EFFICIENCY!",
    "THIS CASTLE WAS BUILT ON PRIME SUBSCRIPTIONS!",
    "EVERY BRICK IS A WORKER'S DREAM... CRUSHED!",
    "YOU DARE ENTER THE BEZOS DOMAIN?!",
    "MY TOWERS REACH HIGHER THAN YOUR AMBITIONS!",
    "I WATCH EVERYTHING FROM UP HERE!",
    "THE ALGORITHMS DESIGNED THIS MAZE!",
    "PRODUCTIVITY FLOWS THROUGH THESE HALLS!",
    "NO UNION CAN SIEGE THESE WALLS!",
    "MY THRONE AWAITS... BUT YOU WON'T REACH IT!",
    "THIS IS WHERE WORKERS BECOME... OPTIMIZED!",
    "EACH STEP YOU TAKE, I GROW STRONGER!",
    "THE CASTLE IS MY FINAL WAREHOUSE!",
    "CUSTOMER OBSESSION BUILT THESE STONES!",
    "FEEL THE WEIGHT OF A TRILLION DOLLARS!",
    "MY DRONES PATROL THESE CORRIDORS!",
    "THE EXIT INTERVIEW IS AT THE TOP!",
    "ONLY THE WORTHY MEET MECHA JEFF!",
];

// --- BEZOS TAUNTS FOR BOSS FIGHT ---
const BEZOS_TAUNTS = [
    "Work harder, not smarter!",
    "Day One? Try Day DONE!",
    "No bathroom breaks in space!",
    "Prime delivery: FAILURE!",
    "Your metrics are TERRIBLE!",
    "Automate or ELIMINATE!",
    "I'm watching your IDLE TIME!",
    "Customer obsession DEMANDS speed!",
    "Move faster! Time is MONEY!",
    "Safety? I have insurance!",
    "Be peculiar! Like a PANCAKE!",
    "Invent and SIMPLIFY your exit!",
    "Ownership? I own EVERYTHING!",
    "Bias for ACTION not survival!",
    "Think BIG or go HOME!",
    "Frugality means NO raises!",
    "Deliver RESULTS or get REPLACED!",
    "Your TOT is UNACCEPTABLE!",
    "The yard IS the final exam!",
    "Automation never complains!"
];

// --- AI STATUS HELPERS ---
const aiStatusEl = document.getElementById('ai-status');
let aiStatus = "init";

function setAIStatus(message, level = 'info') {
    aiStatus = level;
    console.log(`[AI STATUS ${level}]: ${message}`);
}

function personalizeAIText(text) {
    if (!text) return text;
    const name = (typeof GAME !== 'undefined' && GAME.selectedChar) ? GAME.selectedChar : 'Coordinator';
    const patterns = [
        /\[\s*player\s*name\s*\]/gi,
        /\{\s*player\s*name\s*\}/gi,
        /<\s*player\s*name\s*>/gi,
        /player name/gi,
        /\[\s*player\s*\]/gi,
        /\{\s*player\s*\}/gi,
        /<\s*player\s*>/gi
    ];
    let cleaned = text;
    patterns.forEach(p => { cleaned = cleaned.replace(p, name); });
    return cleaned;
}

async function fetchApiKeyFromNetlify() {
    try {
        const res = await fetch('/.netlify/functions/get-gemini-key', { cache: 'no-store' });
        if (!res.ok) throw new Error(`Netlify key endpoint returned ${res.status}`);
        const data = await res.json();
        const key = (data && data.apiKey ? String(data.apiKey) : '').trim();
        if (!key) throw new Error('No apiKey field in Netlify response');
        apiKey = key;
        return apiKey;
    } catch (err) {
        return null;
    }
}

async function ensureApiKey() {
    if (apiKey) return apiKey;
    if (!apiKeyPromise) apiKeyPromise = fetchApiKeyFromNetlify();
    return apiKeyPromise;
}

// --- GEMINI API ---
async function callGemini(prompt, category = 'generic', context = {}) {
    const activeKey = await ensureApiKey();
    if (!activeKey) {
        return personalizeAIText(getRandomFallback(prompt, category, context));
    }

    const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${activeKey}`;
    const payload = { 
        contents: [{ 
            parts: [{ text: prompt }] 
        }] 
    };
    const timeout = new Promise((r) => setTimeout(() => r("TIMEOUT"), 10000));

    try {
        const fetchPromise = fetch(url, { 
            method: 'POST', 
            headers: { 'Content-Type': 'application/json' }, 
            body: JSON.stringify(payload) 
        });
        const response = await Promise.race([fetchPromise, timeout]);
        
        if (response === "TIMEOUT") return personalizeAIText(getRandomFallback(prompt, category, context));
        if (!response.ok) return personalizeAIText(getRandomFallback(prompt, category, context));
        
        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (text) return personalizeAIText(text.trim());
        return personalizeAIText(getRandomFallback(prompt, category, context));

    } catch (e) {
        return personalizeAIText(getRandomFallback(prompt, category, context));
    }
}

function getRandomFallback(prompt, category = 'generic', context = {}) {
    const hazardName = context.hazardName;
    const stats = context.stats;
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const is = (key) => category === key || prompt.includes(key);

    if (is("runners")) return pick(SIMULATED_AI.runners);
    if (is("simon_warning")) {
        const warnings = SIMULATED_AI.simon_warnings || [];
        const idx = Math.min(context.warningIndex || 0, warnings.length - 1);
        return warnings.length ? warnings[Math.max(0, idx)] : pick(SIMULATED_AI.taunts);
    }
    if (is("taunt")) { 
         if(prompt.includes("Simon")) return pick(SIMULATED_AI.simon_taunts);
         return pick(SIMULATED_AI.taunts);
    }
    if ((is("reviews_loss") || is("reviews_win")) && stats) {
        const time = stats.time ?? "?";
        const hazards = stats.hazards ?? "?";
        const books = stats.books ?? "?";
        const ops = stats.ops ?? "?";
        if (is("reviews_loss")) {
            return `Audit recap: ${hazards}/5 hazards, ${books} rule books thrown, ${ops} ops nudged in ${time}s. Safety tip: hydrate, then try again.`;
        }
        return `Victory recap: ${hazards}/5 hazards cleared in ${time}s, ${books} rule books launched, ${ops} ops redirected. Celebrate, then keep exits clear.`;
    }
    if (is("reviews_loss")) return pick(SIMULATED_AI.reviews_loss);
    if (is("reviews_win")) return pick(SIMULATED_AI.reviews_win);
    if (is("hazard") || is("tips")) {
        if(hazardName) return `Hazard "${hazardName}" cleared. Paperwork avoided.`;
        return pick(SIMULATED_AI.tips);
    }
    if (is("banter_ops")) return pick(BANTER_DB.ops);
    if (is("banter_assoc")) return pick(BANTER_DB.assoc);

    return pick(SIMULATED_AI.tips);
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16;
const MAP_W = 60;
const MAP_H = 40;

// --- TTS SYSTEM ---
const TTSSys = {
    synth: window.speechSynthesis,
    voice: null,
    init: function() {
        const loadVoices = () => {
            const voices = this.synth.getVoices();
            this.voice = voices.find(v => v.name.includes("Google US English")) || voices[0];
        };
        if (this.synth.onvoiceschanged !== undefined) this.synth.onvoiceschanged = loadVoices;
        loadVoices();
    },
    speak: function(text, speakerName = "System") {
        if (!this.synth || !text) return;
        this.synth.cancel(); 
        const utterance = new SpeechSynthesisUtterance(text);
        if (this.voice) utterance.voice = this.voice;
        
        if (speakerName.includes("Simon")) { utterance.pitch = 0.6; utterance.rate = 0.85; } 
        else if (["Carrie", "Nevena"].some(n => speakerName.includes(n))) { utterance.pitch = 1.2; }
        else { utterance.pitch = 0.9; }

        this.synth.speak(utterance);
    },
    cancel: function() { if (this.synth) this.synth.cancel(); }
};
TTSSys.init();


// --- AUDIO ---
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        if(!this.ctx) this.ctx = new AudioContext();
    },
    resume: function() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
    playTone: function(freq, type, duration, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol=0.1) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    sfx: {
        step: () => AudioSys.playNoise(0.05, 0.05),
        throw: () => AudioSys.playTone(400, 'square', 0.1, 0.1),
        hit: () => { AudioSys.playNoise(0.1, 0.2); AudioSys.playTone(100, 'sawtooth', 0.1, 0.2); },
        bossHit: () => { AudioSys.playNoise(0.2, 0.3); AudioSys.playTone(80, 'sawtooth', 0.2, 0.3); },
        alert: () => AudioSys.playTone(600, 'square', 0.2, 0.1),
        text: () => AudioSys.playTone(800, 'square', 0.03, 0.05),
        fix: () => { [440, 554, 659].forEach((f,i) => setTimeout(()=>AudioSys.playTone(f,'sine',0.2,0.1), i*100)); },
        hurt: () => AudioSys.playTone(150, 'sawtooth', 0.3, 0.2),
        start: () => { [440,440,440,660].forEach((f,i)=>setTimeout(()=>AudioSys.playTone(f,'square',0.2,0.2), i*150)); },
        angry: () => AudioSys.playTone(150, 'square', 0.5, 0.2),
        select: () => AudioSys.playTone(550, 'square', 0.1, 0.1),
        bossIntro: () => { 
            AudioSys.playTone(100, 'sawtooth', 1.0, 0.3);
            setTimeout(() => AudioSys.playTone(80, 'sawtooth', 1.0, 0.3), 200);
        },
        pop: () => AudioSys.playTone(1200, 'sine', 0.05, 0.1) // New pop sound for banter
    }
};

const MusicSys = {
    tracks: {
        title: new Audio('Pixel Reverie.mp3'),
        menu: new Audio('Game Over But Not Really.mp3'),
        ingame: new Audio('Pixel Warehouse Crawl.mp3'),
        boss: new Audio('Pixel Panic.mp3'),
        victory: new Audio('Pixel Victory.mp3')
    },
    currentName: null,
    currentRate: 1,
    init() {
        Object.values(this.tracks).forEach(a => {
            a.loop = true; a.volume = 0.35; a.preload = 'auto';
        });
    },
    play(name, rate = 1) {
        const track = this.tracks[name];
        if (!track) return;
        if (this.currentName === name) {
            this.currentRate = rate;
            track.playbackRate = rate;
            if (track.paused) track.play().catch(() => {});
            return;
        }
        if (this.currentName && this.currentName !== name) this.stop();
        this.currentName = name;
        this.currentRate = rate;
        track.playbackRate = rate;
        track.currentTime = 0;
        track.play().catch(() => {});
    },
    stop() {
        if (this.currentName && this.tracks[this.currentName]) {
            const current = this.tracks[this.currentName];
            current.pause(); current.currentTime = 0;
        }
        this.currentName = null;
    },
    resume() {
        if (this.currentName && this.tracks[this.currentName]?.paused) {
            this.tracks[this.currentName].playbackRate = this.currentRate || 1;
            this.tracks[this.currentName].play().catch(() => {});
        }
    }
};

// --- ASSETS ---
const GFX = {};
function generateAssets() {
    const c = (w,h,f) => { const c=document.createElement('canvas');c.width=w;c.height=h;f(c.getContext('2d'));return c;};

    // Enhanced logo with gradient and glow
    GFX.logo = c(48, 48, ctx => {
        // Gradient background
        const grad = ctx.createLinearGradient(0, 0, 48, 48);
        grad.addColorStop(0, '#ffd700');
        grad.addColorStop(0.5, '#f59e0b');
        grad.addColorStop(1, '#d97706');
        ctx.fillStyle = grad;
        ctx.fillRect(2, 2, 44, 44);
        // Border
        ctx.strokeStyle = '#92400e';
        ctx.lineWidth = 2;
        ctx.strokeRect(2, 2, 44, 44);
        // Inner shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(4, 4, 40, 40);
        // Text with shadow
        ctx.fillStyle = '#000';
        ctx.font = 'bold 28px monospace';
        ctx.fillText("EE", 9, 35);
        ctx.fillStyle = '#fff';
        ctx.fillText("EE", 7, 33);
    });

    // PREMIUM CHARACTER SPRITES - 16x16 with full detail
    GFX.chars = {
        "Carrie": c(16,16, ctx => {
            // Shadow base
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Hair with highlight
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,0,12,6);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(3,1,10,3);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(4,1,3,2); // Hair shine
            // Face with contour
            ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
            ctx.fillStyle = '#f5d0a0'; ctx.fillRect(6,6,4,3); // Highlight
            // Eyes with detail
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
            // Eyebrows
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(5,6,2,1); ctx.fillRect(9,6,2,1);
            // Mouth
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(7,9,2,1);
            // Headset
            ctx.fillStyle = '#22c55e'; ctx.fillRect(4,10,8,1);
            ctx.fillStyle = '#16a34a'; ctx.fillRect(3,8,1,3); ctx.fillRect(12,8,1,3);
            // Purple robe with shading
            ctx.fillStyle = '#7c3aed'; ctx.fillRect(2,11,12,5);
            ctx.fillStyle = '#8b5cf6'; ctx.fillRect(3,11,10,3);
            ctx.fillStyle = '#a78bfa'; ctx.fillRect(5,12,6,2); // Highlight
            // Sash
            ctx.fillStyle = '#c4b5fd'; ctx.fillRect(7,11,2,4);
            // Boots
            ctx.fillStyle = '#1e3a8a'; ctx.fillRect(3,15,4,1); ctx.fillRect(9,15,4,1);
            ctx.fillStyle = '#3b82f6'; ctx.fillRect(4,15,2,1); ctx.fillRect(10,15,2,1);
        }),
        "Nevena": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Brown hair with wave
            ctx.fillStyle = '#5c2d12'; ctx.fillRect(2,1,12,5);
            ctx.fillStyle = '#7c3d1a'; ctx.fillRect(3,2,10,3);
            ctx.fillStyle = '#9a5a32'; ctx.fillRect(2,2,3,4); // Side wave
            ctx.fillStyle = '#b8784a'; ctx.fillRect(3,2,2,2); // Highlight
            // Headband
            ctx.fillStyle = '#0284c7'; ctx.fillRect(3,2,10,2);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,2,8,1);
            // Face
            ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
            ctx.fillStyle = '#f5c89a'; ctx.fillRect(6,6,4,3);
            // Eyes
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
            // Glasses frame
            ctx.strokeStyle = '#475569'; ctx.lineWidth = 0.5;
            ctx.strokeRect(5,7,2,2); ctx.strokeRect(9,7,2,2);
            ctx.fillStyle = '#475569'; ctx.fillRect(7,8,2,0.5);
            // Mouth
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(7,9,2,1);
            // Red jacket with detail
            ctx.fillStyle = '#991b1b'; ctx.fillRect(2,11,12,5);
            ctx.fillStyle = '#b91c1c'; ctx.fillRect(3,11,10,3);
            ctx.fillStyle = '#dc2626'; ctx.fillRect(4,12,8,2);
            // Clipboard
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(12,12,3,3);
            ctx.fillStyle = '#fcd34d'; ctx.fillRect(12,12,2,2);
            ctx.fillStyle = '#92400e'; ctx.fillRect(13,13,1,1);
            // Boots
            ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
            ctx.fillStyle = '#374151'; ctx.fillRect(5,15,1,1); ctx.fillRect(10,15,1,1);
        }),
        "Joao": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Spiky black hair
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(4,0,8,4);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(5,1,6,2);
            ctx.fillRect(5,-1,2,2); ctx.fillRect(9,-1,2,2); // Spikes
            // Face
            ctx.fillStyle = '#c4956a'; ctx.fillRect(4,4,8,6);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,5,6,4);
            ctx.fillStyle = '#e8b888'; ctx.fillRect(6,5,4,3);
            // Eyes with energy
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
            // Eyebrows (expressive)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(5,5,2,1); ctx.fillRect(9,5,2,1);
            // Open mouth (shouting)
            ctx.fillStyle = '#8b4513'; ctx.fillRect(6,8,4,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(7,8,2,1);
            // Mic headset
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(3,8,1,3);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(2,10,2,2);
            // Orange hi-vis vest
            ctx.fillStyle = '#c2410c'; ctx.fillRect(2,10,12,6);
            ctx.fillStyle = '#ea580c'; ctx.fillRect(3,10,10,4);
            ctx.fillStyle = '#f97316'; ctx.fillRect(4,11,8,2);
            // Reflective strips
            ctx.fillStyle = '#fef08a'; ctx.fillRect(3,11,10,1);
            ctx.fillStyle = '#fef08a'; ctx.fillRect(3,13,10,1);
            // Shoes
            ctx.fillStyle = '#0369a1'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(5,15,1,1); ctx.fillRect(10,15,1,1);
        }),
        "Roman": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Bald head with shine
            ctx.fillStyle = '#c4956a'; ctx.fillRect(4,2,8,8);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,3,6,6);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,3,4,4);
            ctx.fillStyle = '#f5deb3'; ctx.fillRect(6,2,3,2); // Shine
            // Eyes (narrow, mysterious)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,5,2,1); ctx.fillRect(9,5,2,1);
            ctx.fillStyle = '#64748b'; ctx.fillRect(5,5,1,1); ctx.fillRect(9,5,1,1);
            // Stern mouth
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(6,7,4,1);
            // Dark stealth coat
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,10,12,6);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(3,10,10,4);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(4,11,8,2);
            // Collar
            ctx.fillStyle = '#374151'; ctx.fillRect(5,10,6,1);
            // Silver cuffs
            ctx.fillStyle = '#6b7280'; ctx.fillRect(2,13,3,2); ctx.fillRect(11,13,3,2);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(3,13,1,1); ctx.fillRect(12,13,1,1);
            // Dark boots
            ctx.fillStyle = '#0b1224'; ctx.fillRect(3,15,4,1); ctx.fillRect(9,15,4,1);
        }),
        "Erwin": c(16,16, ctx => {
            // Shadow under Tesla
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(1,14,14,2);
            // Tesla body - sleek design
            ctx.fillStyle = '#3f3f46'; ctx.fillRect(1,8,14,6);
            ctx.fillStyle = '#52525b'; ctx.fillRect(2,9,12,4);
            ctx.fillStyle = '#71717a'; ctx.fillRect(3,9,10,2);
            // Hood with reflection
            ctx.fillStyle = '#4b5563'; ctx.fillRect(2,7,12,3);
            ctx.fillStyle = '#6b7280'; ctx.fillRect(4,7,8,2);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(5,7,3,1);
            // Windshield glow
            ctx.fillStyle = '#0891b2'; ctx.fillRect(3,9,10,2);
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(4,9,8,1);
            ctx.fillStyle = '#67e8f9'; ctx.fillRect(6,9,4,1);
            // Wheels with detail
            ctx.fillStyle = '#000'; ctx.fillRect(1,12,4,3); ctx.fillRect(11,12,4,3);
            ctx.fillStyle = '#27272a'; ctx.fillRect(2,12,2,2); ctx.fillRect(12,12,2,2);
            ctx.fillStyle = '#71717a'; ctx.fillRect(2,13,1,1); ctx.fillRect(13,13,1,1);
            // Headlights
            ctx.fillStyle = '#fef08a'; ctx.fillRect(1,10,1,2); ctx.fillRect(14,10,1,2);
            // Erwin face above
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,3,6,5);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,4,4,3);
            // Hair
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,2,6,3);
            ctx.fillStyle = '#2d2d2d'; ctx.fillRect(6,2,4,2);
            // Beard
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(6,6,4,2);
            // Eyes with smirk
            ctx.fillStyle = '#000'; ctx.fillRect(6,4,1,1); ctx.fillRect(9,4,1,1);
            ctx.fillStyle = '#fff'; ctx.fillRect(6,4,1,1);
            // Smirk
            ctx.fillStyle = '#f59e0b'; ctx.fillRect(7,5,2,1);
        })
    };

    // ENHANCED ATTACK PROJECTILES
    GFX.attacks = {
        "Carrie": c(14,14, ctx => {
            // Label maker projectile with glow
            const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
            grad.addColorStop(0, '#e879f9');
            grad.addColorStop(0.5, '#a855f7');
            grad.addColorStop(1, '#7c3aed');
            ctx.fillStyle = grad;
            ctx.fillRect(1,4,12,6);
            ctx.fillStyle = '#c4b5fd';
            ctx.fillRect(2,5,10,4);
            ctx.fillStyle = '#10b981';
            ctx.fillRect(6,2,2,10);
            // Label detail
            ctx.fillStyle = '#fff';
            ctx.fillRect(4,6,6,2);
        }),
        "Nevena": c(14,14, ctx => {
            // Clipboard shockwave
            ctx.fillStyle = '#0369a1';
            ctx.fillRect(2,2,10,10);
            const grad = ctx.createLinearGradient(0, 0, 14, 14);
            grad.addColorStop(0, '#f8fafc');
            grad.addColorStop(1, '#e2e8f0');
            ctx.fillStyle = grad;
            ctx.fillRect(3,3,8,8);
            // Paper lines
            ctx.fillStyle = '#334155';
            ctx.fillRect(4,4,6,1);
            ctx.fillRect(4,6,5,1);
            ctx.fillRect(4,8,4,1);
            // Checkmark
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(8,7,2,3);
            ctx.fillRect(6,9,2,1);
        }),
        "Joao": c(14,14, ctx => {
            // Sonic shout waves
            const grad = ctx.createLinearGradient(0, 0, 14, 0);
            grad.addColorStop(0, '#ea580c');
            grad.addColorStop(0.5, '#f97316');
            grad.addColorStop(1, '#fb923c');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.moveTo(0,7); ctx.lineTo(6,2); ctx.lineTo(6,12); ctx.fill();
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath(); ctx.moveTo(4,7); ctx.lineTo(10,1); ctx.lineTo(10,13); ctx.fill();
            ctx.fillStyle = '#22d3ee';
            ctx.beginPath(); ctx.moveTo(8,7); ctx.lineTo(14,3); ctx.lineTo(14,11); ctx.fill();
            // Inner ring
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(7,7,2,0,Math.PI*2); ctx.stroke();
        }),
        "Roman": c(14,14, ctx => {
            // Stealth audit pulse
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(7,7,6,0,Math.PI*2); ctx.stroke();
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(7,7,4,0,Math.PI*2); ctx.stroke();
            ctx.fillStyle = '#1e293b';
            ctx.beginPath(); ctx.arc(7,7,2,0,Math.PI*2); ctx.fill();
            // Crosshair
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(6,0,2,3); ctx.fillRect(6,11,2,3);
            ctx.fillRect(0,6,3,2); ctx.fillRect(11,6,3,2);
        }),
        "Erwin": c(14,14, ctx => {
            // Tesla energy pulse
            const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
            grad.addColorStop(0, '#67e8f9');
            grad.addColorStop(0.5, '#22d3ee');
            grad.addColorStop(1, '#0891b2');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(7, 7, 6, 0, Math.PI*2); ctx.fill();
            // Electric arcs
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(7, 1); ctx.lineTo(5, 4); ctx.lineTo(9, 6); ctx.lineTo(7, 9);
            ctx.stroke();
            // Center core
            ctx.fillStyle = '#f0f9ff';
            ctx.beginPath(); ctx.arc(7, 7, 2, 0, Math.PI*2); ctx.fill();
        })
    };
    // IMPROVED SIMON SPRITE
    GFX.simon = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Hair with detail
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(3,0,10,5);
        ctx.fillStyle = '#2d2d2d'; ctx.fillRect(4,1,8,3);
        ctx.fillStyle = '#3d3d3d'; ctx.fillRect(5,1,3,2); // Highlight
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,3);
        // Glasses
        ctx.fillStyle = '#000'; ctx.fillRect(4,6,3,2); ctx.fillRect(9,6,3,2);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(5,6,1,1); ctx.fillRect(10,6,1,1);
        ctx.fillStyle = '#475569'; ctx.fillRect(7,7,2,1);
        // Serious mouth
        ctx.fillStyle = '#8b6b5a'; ctx.fillRect(6,8,4,1);
        // Gold WHS jacket
        ctx.fillStyle = '#b45309'; ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#d97706'; ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(4,11,8,2);
        // WHS badge
        ctx.fillStyle = '#fff'; ctx.fillRect(5,12,6,2);
        ctx.fillStyle = '#000'; ctx.font = '3px monospace';
        // Boots
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });
    GFX.simonFace = c(32,32, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simon,0,0,16,16,0,0,32,32); });

    // ENHANCED SIMON BOSS - 32x32 detailed sprite
    GFX.simonBoss = c(32,32, ctx => {
        // Dark background aura
        const aura = ctx.createRadialGradient(16, 16, 4, 16, 16, 16);
        aura.addColorStop(0, 'rgba(234, 179, 8, 0.3)');
        aura.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = aura;
        ctx.fillRect(0, 0, 32, 32);
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath(); ctx.ellipse(16, 30, 10, 3, 0, 0, Math.PI*2); ctx.fill();
        // Hair
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,2,16,8);
        ctx.fillStyle = '#2d2d2d'; ctx.fillRect(10,3,12,5);
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(8,8,16,10);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(10,10,12,6);
        // Angry eyebrows
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(10,10,4,2); ctx.fillRect(18,10,4,2);
        // Glasses (glowing red)
        ctx.fillStyle = '#1e293b'; ctx.fillRect(10,12,5,4); ctx.fillRect(17,12,5,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,13,3,2); ctx.fillRect(18,13,3,2);
        ctx.fillStyle = '#475569'; ctx.fillRect(15,14,2,1);
        // Stern mouth
        ctx.fillStyle = '#5c4033'; ctx.fillRect(12,17,8,2);
        // Gold WHS uniform
        ctx.fillStyle = '#92400e'; ctx.fillRect(6,18,20,14);
        ctx.fillStyle = '#b45309'; ctx.fillRect(8,18,16,10);
        ctx.fillStyle = '#d97706'; ctx.fillRect(10,20,12,6);
        // Large badge
        ctx.fillStyle = '#fff'; ctx.fillRect(11,22,10,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(13,23,6,2);
    });

    // IMPROVED OPS MANAGER NPC
    GFX.ops = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Slicked hair
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#2d2d2d'; ctx.fillRect(5,2,6,2);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,3);
        // Beady eyes
        ctx.fillStyle = '#000'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
        // Frown
        ctx.fillStyle = '#8b6b5a'; ctx.fillRect(6,8,4,1);
        // Red manager polo
        ctx.fillStyle = '#991b1b'; ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#b91c1c'; ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,11,8,2);
        // Collar
        ctx.fillStyle = '#fff'; ctx.fillRect(6,10,4,1);
        // Boots
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    // ENHANCED BOSS SPRITES
    GFX.boss_manager = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,0,12,6);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(3,1,10,4);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
        ctx.fillStyle = '#000'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,11,12,5);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(3,11,10,3);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,11,2,4);
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_inspector = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Grey hair
        ctx.fillStyle = '#6b7280'; ctx.fillRect(3,0,10,5);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(4,1,8,3);
        ctx.fillStyle = '#d4d4d4'; ctx.fillRect(5,1,3,2);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,3);
        // Stern eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
        // Yellow inspector jacket
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#eab308'; ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(4,11,8,2);
        // Badge
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(6,12,4,2);
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_compliance = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Dark hair
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(3,0,10,5);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(4,1,8,3);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(5,4,6,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,5,4,4);
        // Calculating eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(6,6,1,2); ctx.fillRect(9,6,1,2);
        // Cyan suit
        ctx.fillStyle = '#0891b2'; ctx.fillRect(3,10,10,6);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,10,8,4);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(5,11,6,2);
        // Tie
        ctx.fillStyle = '#14b8a6'; ctx.fillRect(7,10,2,5);
        ctx.fillStyle = '#a855f7'; ctx.fillRect(5,15,2,1); ctx.fillRect(9,15,2,1);
    });

    GFX.boss_regional = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Styled hair
        ctx.fillStyle = '#1e1b4b'; ctx.fillRect(2,0,12,6);
        ctx.fillStyle = '#312e81'; ctx.fillRect(3,1,10,4);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
        // Eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
        // Purple exec suit
        ctx.fillStyle = '#4c1d95'; ctx.fillRect(3,10,10,6);
        ctx.fillStyle = '#6d28d9'; ctx.fillRect(4,10,8,4);
        ctx.fillStyle = '#8b5cf6'; ctx.fillRect(5,11,6,2);
        // Gold tie
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(7,10,2,5);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_sebastian = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Bald/short hair
        ctx.fillStyle = '#f5d0a0'; ctx.fillRect(5,1,6,7);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,2,4,5);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(6,1,3,2); // Shine
        // Eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(6,4,1,1); ctx.fillRect(9,4,1,1);
        // Smile
        ctx.fillStyle = '#8b6b5a'; ctx.fillRect(7,6,2,1);
        // Blue Amazon polo
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(2,8,12,8);
        ctx.fillStyle = '#2563eb'; ctx.fillRect(3,8,10,6);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(4,9,8,4);
        // Orange smile logo
        ctx.fillStyle = '#f97316'; ctx.fillRect(6,11,4,2);
        ctx.fillStyle = '#fb923c'; ctx.fillRect(9,10,2,3);
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_jelly = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Pink hair
        ctx.fillStyle = '#be185d'; ctx.fillRect(3,0,10,6);
        ctx.fillStyle = '#db2777'; ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#ec4899'; ctx.fillRect(5,1,3,2);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,3);
        // Friendly eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
        // Smile
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(6,8,4,1);
        // Green HR jacket
        ctx.fillStyle = '#166534'; ctx.fillRect(3,10,10,6);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(4,10,8,4);
        ctx.fillStyle = '#4ade80'; ctx.fillRect(5,11,6,2);
        // Badge
        ctx.fillStyle = '#fff'; ctx.fillRect(5,12,6,2);
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_avetta = c(16,16, ctx => {
        // AI platform - robotic look
        ctx.fillStyle = 'rgba(34, 211, 238, 0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 6, 2, 0, 0, Math.PI*2); ctx.fill();
        // Main body
        ctx.fillStyle = '#0f172a'; ctx.fillRect(2,2,12,12);
        ctx.fillStyle = '#1e293b'; ctx.fillRect(3,3,10,10);
        // Glowing screen
        const screenGrad = ctx.createLinearGradient(4, 4, 12, 12);
        screenGrad.addColorStop(0, '#0ea5e9');
        screenGrad.addColorStop(1, '#22d3ee');
        ctx.fillStyle = screenGrad;
        ctx.fillRect(4,4,8,8);
        // Data lines
        ctx.fillStyle = '#67e8f9';
        ctx.fillRect(5,5,6,1);
        ctx.fillRect(5,7,5,1);
        ctx.fillRect(5,9,4,1);
        // Center indicator
        ctx.fillStyle = '#34d399';
        ctx.fillRect(9,7,2,3);
        // Warning light
        ctx.fillStyle = '#fcd34d';
        ctx.fillRect(7,10,2,1);
    });

    GFX.boss_bot = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Robot body
        ctx.fillStyle = '#374151'; ctx.fillRect(2,2,12,12);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(3,3,10,10);
        ctx.fillStyle = '#6b7280'; ctx.fillRect(4,4,8,8);
        // Visor
        ctx.fillStyle = '#1e293b'; ctx.fillRect(3,5,10,3);
        // Glowing eyes
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,6,3,2);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(5,6,1,1);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(9,6,3,2);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(10,6,1,1);
        // Mouth grille
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(5,10,6,2);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(6,10,1,2); ctx.fillRect(8,10,1,2); ctx.fillRect(10,10,1,2);
        // Antenna
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(7,0,2,3);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,0,2,1);
    });

    GFX.mechaJeff = c(64,64, ctx => {
        // Dark background plate
        ctx.fillStyle = '#050810'; ctx.fillRect(0,0,64,64);
        // Mecha body frame with gradient effect
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(8,32,48,28);
        ctx.fillStyle = '#252b3d'; ctx.fillRect(12,34,40,24);
        // Body armor plates
        ctx.fillStyle = '#3d4556'; ctx.fillRect(14,36,36,20);
        ctx.fillStyle = '#4a5568'; ctx.fillRect(16,38,32,16);
        // Amazon logo on chest (glowing)
        ctx.fillStyle = '#ff9900'; ctx.fillRect(24,42,16,8);
        ctx.fillStyle = '#ffb347'; ctx.fillRect(26,44,12,4);
        // Glowing arc smile
        ctx.fillStyle = '#ff6600'; ctx.fillRect(32,46,8,4);
        ctx.fillStyle = '#ff9900'; ctx.fillRect(38,44,4,8);
        // Shoulder cannons
        ctx.fillStyle = '#374151'; ctx.fillRect(2,28,12,24);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(4,30,8,20);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(5,34,6,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(6,35,4,4);
        ctx.fillStyle = '#374151'; ctx.fillRect(50,28,12,24);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(52,30,8,20);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(53,34,6,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(54,35,4,4);
        // Neck/collar chrome
        ctx.fillStyle = '#6b7280'; ctx.fillRect(18,28,28,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(20,29,24,4);
        // Bald dome with shine
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(20,8,24,22);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(22,6,20,8);
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(26,4,12,6);
        // Head shine highlight
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(24,6,8,4);
        // Evil eyebrows
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(22,14,8,3); ctx.fillRect(34,14,8,3);
        // Glowing red eyes
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(24,18,6,6); ctx.fillRect(34,18,6,6);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(25,19,4,4); ctx.fillRect(35,19,4,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(26,20,2,2); ctx.fillRect(36,20,2,2);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(26,26,12,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(28,27,8,1);
        // Ear pieces
        ctx.fillStyle = '#4b5563'; ctx.fillRect(16,14,4,10); ctx.fillRect(44,14,4,10);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(17,16,2,6); ctx.fillRect(45,16,2,6);
        // Legs
        ctx.fillStyle = '#374151'; ctx.fillRect(18,56,10,8); ctx.fillRect(36,56,10,8);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(20,58,6,6); ctx.fillRect(38,58,6,6);
    });
    // IMPROVED ASSOCIATE NPC
    GFX.assoc = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Hair
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#52525b';
        ctx.fillRect(5,2,6,2);
        // Face
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a';
        ctx.fillRect(5,6,6,3);
        // Eyes
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(5,6,2,2);
        ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,6,1,1);
        ctx.fillRect(9,6,1,1);
        // Yellow safety vest
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(4,11,8,2);
        // Reflective strips
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(3,11,10,1);
        ctx.fillRect(3,13,10,1);
        // Boots
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(4,15,3,1);
        ctx.fillRect(9,15,3,1);
    });

    // IMPROVED RUNNER NPC (with motion blur effect)
    GFX.runner = c(16,16, ctx => {
        // Motion blur shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(0, 14, 16, 2);
        // Motion lines
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillRect(0, 8, 3, 1);
        ctx.fillRect(0, 11, 2, 1);
        ctx.fillRect(13, 6, 3, 1);
        ctx.fillRect(14, 9, 2, 1);
        // Hair (windswept)
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(3,1,10,4);
        ctx.fillStyle = '#52525b';
        ctx.fillRect(4,2,8,2);
        // Face (leaning forward)
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(5,5,8,5);
        ctx.fillStyle = '#e8c49a';
        ctx.fillRect(6,6,6,3);
        // Wide eyes
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(6,6,2,2);
        ctx.fillRect(10,6,2,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(7,6,1,1);
        ctx.fillRect(11,6,1,1);
        // Yellow vest
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(3,10,11,6);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(4,10,9,4);
        // Reflective strips
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(4,11,9,1);
        ctx.fillRect(4,13,9,1);
        // Running legs
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,14,3,2);
        ctx.fillRect(11,14,3,2);
    });

    GFX.van = c(34,18, ctx => {
        ctx.fillStyle = '#020617'; ctx.fillRect(0,12,34,6);
        ctx.fillStyle = '#0b1224'; ctx.fillRect(1,10,32,8);
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(2,4,30,10);
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(2,10,30,2);
        ctx.fillStyle = '#2563eb'; ctx.fillRect(4,6,26,8);
        ctx.fillStyle = '#60a5fa'; ctx.fillRect(6,7,14,5);
        ctx.fillStyle = '#c7d2fe'; ctx.fillRect(20,6,8,6);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(22,9,6,2);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(6,14,8,4); ctx.fillRect(22,14,8,4);
        ctx.fillStyle = '#eab308'; ctx.fillRect(4,12,2,2); ctx.fillRect(28,12,2,2);
        ctx.fillStyle = '#f8fafc'; ctx.fillRect(14,5,2,2);
        ctx.fillStyle = '#0f172a'; ctx.font = '6px monospace'; ctx.fillText('DSP', 6, 11);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(0,15,4,3); ctx.fillRect(30,15,4,3);
    });

    GFX.truck = c(52,20, ctx => {
        ctx.fillStyle = '#020617'; ctx.fillRect(0,14,52,6);
        ctx.fillStyle = '#0b1224'; ctx.fillRect(1,12,50,8);
        ctx.fillStyle = '#cbd5e1'; ctx.fillRect(4,4,44,12);
        ctx.fillStyle = '#e5e7eb'; ctx.fillRect(6,6,40,10);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(6,8,18,8);
        ctx.fillStyle = '#f8fafc'; ctx.fillRect(24,8,24,8);
        ctx.fillStyle = '#dbeafe'; ctx.fillRect(6,6,14,3);
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(8,6,20,2);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(8,12,34,2);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(10,15,10,4); ctx.fillRect(34,15,10,4);
        ctx.fillStyle = '#facc15'; ctx.fillRect(4,4,4,10);
        ctx.fillStyle = '#0f172a'; ctx.font = '7px monospace'; ctx.fillText('PRIME', 22, 13);
        ctx.fillStyle = '#64748b'; ctx.fillRect(2,10,6,6);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(40,6,6,2);
        ctx.fillStyle = '#c2410c'; ctx.fillRect(0,16,52,1);
    });

    GFX.flyingBox = c(14,14, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,3,12,10);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,2,10,10);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(2,6,10,2);
        ctx.fillStyle = '#111827'; ctx.fillRect(4,4,2,2); ctx.fillRect(8,4,2,2);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(6,1,2,2);
    });
    
    GFX.clutter = { cart: c(16,16, ctx => { ctx.fillStyle = '#444'; ctx.fillRect(2,6,12,8); ctx.fillStyle = '#8b4513'; ctx.fillRect(4,4,8,6); }), coffee: c(8,8, ctx => { ctx.fillStyle='#fff'; ctx.fillRect(2,2,4,5); }), paper: c(8,8, ctx => { ctx.fillStyle='#eee'; ctx.fillRect(1,3,6,4); }), tape: c(8,8, ctx => { ctx.fillStyle='#d97706'; ctx.beginPath(); ctx.arc(4,4,3,0,Math.PI*2); ctx.fill(); }) };
   GFX.hazards = {
    // --- Liquids / Spills (Amazon yellow warning) ---
    spill: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.ellipse(8,11,7,4,0,0,Math.PI*2); ctx.fill();
        // Dark base
        ctx.fillStyle = '#b91c1c';
        ctx.beginPath(); ctx.ellipse(8,10,6,4,0,0,Math.PI*2); ctx.fill();
        // Main puddle (red hazmat)
        ctx.fillStyle = '#dc2626';
        ctx.beginPath(); ctx.ellipse(8,9,5,3,0,0,Math.PI*2); ctx.fill();
        // Highlight
        ctx.fillStyle = '#ef4444';
        ctx.beginPath(); ctx.ellipse(6,8,2,1.5,0,0,Math.PI*2); ctx.fill();
        // Warning reflection
        ctx.fillStyle = '#fecaca';
        ctx.fillRect(9,9,2,1);
    }),

    // --- Amazon Box ---
    box: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(2,6,13,10);
        // Main box (Amazon brown)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(1,4,13,10);
        // Front face
        ctx.fillStyle = '#a16207';
        ctx.fillRect(2,5,11,8);
        // Top flaps
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,3,11,2);
        // Amazon tape (Prime blue)
        ctx.fillStyle = '#0284c7';
        ctx.fillRect(4,7,6,2);
        // Smile arrow
        ctx.fillStyle = '#f97316';
        ctx.fillRect(5,10,4,1);
        ctx.fillRect(8,9,1,1);
        // Barcode label
        ctx.fillStyle = '#fff';
        ctx.fillRect(9,5,3,3);
        ctx.fillStyle = '#111';
        ctx.fillRect(10,6,1,1);
    }),

    // --- Chemical drum / hazmat ---
    drum: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8,14,5,2,0,0,Math.PI*2); ctx.fill();
        // Body (safety blue)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(4,3,8,10);
        // Top
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath(); ctx.ellipse(8,3,4,2,0,0,Math.PI*2); ctx.fill();
        // Bands
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(4,5,8,1);
        ctx.fillRect(4,10,8,1);
        // Hazard diamond
        ctx.fillStyle = '#facc15';
        ctx.fillRect(6,6,4,3);
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(7,7,2,1);
    }),

    // --- Tall pallet stacks ---
    tall_pallet: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(4,14,10,2);
        // Main stack (Amazon orange)
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(3,1,10,13);
        // Box layers
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(4,2,8,3);
        ctx.fillRect(4,6,8,3);
        ctx.fillRect(4,10,8,3);
        // Tape highlights
        ctx.fillStyle = '#0284c7';
        ctx.fillRect(5,3,2,1); ctx.fillRect(9,3,2,1);
        ctx.fillRect(5,7,2,1); ctx.fillRect(9,7,2,1);
        // Pallet base (wood)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(2,13,12,2);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(3,13,2,2); ctx.fillRect(7,13,2,2); ctx.fillRect(11,13,2,2);
    }),

    // --- Debris / broken pallets ---
    debris: c(16,16, ctx => {
        // Scattered packing material
        ctx.fillStyle = '#d6d3d1';
        ctx.fillRect(2,8,4,2); ctx.fillRect(10,10,3,2);
        // Main broken plank
        ctx.save();
        ctx.translate(8,8);
        ctx.rotate(0.35);
        ctx.fillStyle = '#78350f';
        ctx.fillRect(-6,-2,12,4);
        ctx.fillStyle = '#92400e';
        ctx.fillRect(-5,-1,10,2);
        ctx.restore();
        // Scattered nails/screws
        ctx.fillStyle = '#71717a';
        ctx.fillRect(4,12,1,2); ctx.fillRect(11,11,2,1);
        // Cardboard chunk
        ctx.fillStyle = '#a16207';
        ctx.fillRect(1,4,3,3);
    }),

    // --- Conveyor / chute (Amazon FC style) ---
    conveyor: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(2,12,13,3);
        // Frame (industrial gray)
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(1,5,14,8);
        // Belt surface
        ctx.fillStyle = '#374151';
        ctx.fillRect(2,6,12,6);
        // Belt segments
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(3,7,2,4); ctx.fillRect(7,7,2,4); ctx.fillRect(11,7,2,4);
        // Rollers
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(2,5,3,1); ctx.fillRect(11,5,3,1);
        // Jammed package (Amazon brown)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(5,3,6,4);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(6,4,4,2);
        // Warning light
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(1,4,2,2);
    }),

    // --- Scanner Battery / charging station ---
    battery: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(4,13,9,3);
        // Battery body
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,5,10,8);
        ctx.fillStyle = '#374151';
        ctx.fillRect(4,6,8,6);
        // Terminals (yellow)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(5,3,2,3); ctx.fillRect(9,3,2,3);
        // Lightning symbol
        ctx.fillStyle = '#facc15';
        ctx.fillRect(7,6,2,1); ctx.fillRect(6,7,1,2); ctx.fillRect(7,8,2,1); ctx.fillRect(9,9,1,2);
        // Warning label
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,10,6,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(7,11,2,1);
    }),

    // --- Extension Cord / scanner cord ---
    cord: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.ellipse(8,13,6,2,0,0,Math.PI*2); ctx.fill();
        // Coiled yellow cable
        ctx.strokeStyle = '#eab308';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(2,4);
        ctx.bezierCurveTo(5,10,8,2,11,8);
        ctx.bezierCurveTo(13,12,15,6,14,10);
        ctx.stroke();
        // Cable highlight
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(3,3); ctx.bezierCurveTo(6,8,9,2,12,6);
        ctx.stroke();
        // Plug
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(12,8,3,4);
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(13,12,1,2);
    }),

    // --- Amazon Tote / bin ---
    tote: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(3,13,11,3);
        // Main body (Amazon yellow)
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,5,12,9);
        // Front face
        ctx.fillStyle = '#eab308';
        ctx.fillRect(3,6,10,7);
        // Rim
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,4,12,2);
        // Handle cutouts
        ctx.fillStyle = '#92400e';
        ctx.fillRect(4,5,3,1); ctx.fillRect(9,5,3,1);
        // Label area
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,8,6,3);
        // Barcode
        ctx.fillStyle = '#111';
        ctx.fillRect(6,9,4,1);
    }),

    // --- Stretch wrap / shrink wrap ---
    wrap: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(3,12,10,3);
        // Crumpled wrap
        ctx.fillStyle = '#e2e8f0';
        ctx.beginPath();
        ctx.moveTo(2,5); ctx.lineTo(14,4); ctx.lineTo(13,12); ctx.lineTo(3,13);
        ctx.closePath(); ctx.fill();
        // Texture lines
        ctx.fillStyle = '#cbd5e1';
        ctx.fillRect(4,6,8,1); ctx.fillRect(5,9,6,1);
        // Stretched tension
        ctx.fillStyle = '#f1f5f9';
        ctx.fillRect(6,7,4,2);
        // Torn edge
        ctx.fillStyle = '#94a3b8';
        ctx.fillRect(10,10,3,2);
    }),

    // --- Roller cage / Gaylord cage ---
    cage: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(4,14,9,2);
        // Frame (blue warehouse cage)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(2,2,12,12);
        // Wire mesh pattern
        ctx.fillStyle = '#3b82f6';
        for (let x = 3; x <= 12; x += 2) { ctx.fillRect(x,3,1,10); }
        for (let y = 4; y <= 11; y += 2) { ctx.fillRect(3,y,10,1); }
        // Contents visible
        ctx.fillStyle = '#92400e';
        ctx.fillRect(5,6,3,4); ctx.fillRect(9,7,3,3);
        // Caster wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(3,13,2,2); ctx.fillRect(11,13,2,2);
    }),

    // --- Flat cart / Amazon blue cart ---
    cart: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(3,13,11,3);
        // Platform (Amazon blue)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(2,9,12,4);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(2,8,12,2);
        // Handle frame
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,3,2,6);
        ctx.fillRect(3,3,9,2);
        ctx.fillRect(11,3,2,3);
        // Grip
        ctx.fillStyle = '#f97316';
        ctx.fillRect(4,3,7,1);
        // Wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(3,12,3,3); ctx.fillRect(10,12,3,3);
        ctx.fillStyle = '#374151';
        ctx.fillRect(4,13,1,1); ctx.fillRect(11,13,1,1);
    }),

    // --- Fire door / emergency exit ---
    door: c(16,16, ctx => {
        // Frame
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(3,1,10,14);
        // Door panel (safety green)
        ctx.fillStyle = '#15803d';
        ctx.fillRect(4,2,8,12);
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(5,3,6,10);
        // Window
        ctx.fillStyle = '#0c4a6e';
        ctx.fillRect(6,3,4,3);
        ctx.fillStyle = '#0ea5e9';
        ctx.fillRect(7,4,2,1);
        // Push bar
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,8,6,2);
        // EXIT sign
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(6,11,4,2);
        // Wedge blocking (hazard!)
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(4,14); ctx.lineTo(8,14); ctx.lineTo(8,12); ctx.closePath();
        ctx.fill();
    }),

    // --- Loading dock ---
    dock: c(16,16, ctx => {
        // Shadow/pit
        ctx.fillStyle = '#020617';
        ctx.fillRect(1,8,14,7);
        // Dock plate
        ctx.fillStyle = '#374151';
        ctx.fillRect(2,9,12,5);
        // Diamond plate texture
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(3,10,2,1); ctx.fillRect(6,10,2,1); ctx.fillRect(9,10,2,1); ctx.fillRect(12,10,2,1);
        ctx.fillRect(4,12,2,1); ctx.fillRect(7,12,2,1); ctx.fillRect(10,12,2,1);
        // Yellow safety edge
        ctx.fillStyle = '#eab308';
        ctx.fillRect(2,8,12,2);
        // Warning stripes
        ctx.fillStyle = '#111';
        ctx.fillRect(4,8,2,2); ctx.fillRect(8,8,2,2); ctx.fillRect(12,8,2,2);
        // Edge bumper
        ctx.fillStyle = '#f97316';
        ctx.fillRect(1,6,3,2); ctx.fillRect(12,6,3,2);
    }),

    // --- Facility hazard / bollard ---
    facility: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8,15,4,2,0,0,Math.PI*2); ctx.fill();
        // Column base
        ctx.fillStyle = '#374151';
        ctx.fillRect(5,12,6,3);
        // Main column (safety yellow)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(5,2,6,11);
        // Warning stripes
        ctx.fillStyle = '#111';
        ctx.fillRect(5,4,6,2); ctx.fillRect(5,8,6,2); ctx.fillRect(5,12,6,1);
        // Top cap
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(5,1,6,2);
        // Reflector
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(6,5,4,1);
    }),

    // --- Unsafe worker behavior ---
    npc: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath(); ctx.ellipse(8,15,5,2,0,0,Math.PI*2); ctx.fill();
        // Head
        ctx.fillStyle = '#facc15';
        ctx.beginPath();
        ctx.arc(8,4,3,0,Math.PI*2);
        ctx.fill();
        // Body (Amazon hi-vis vest)
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(5,7,6,7);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(6,8,4,5);
        // Hi-vis reflective stripes
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(5,8,6,1); ctx.fillRect(5,11,6,1);
        // Phone in hand (distracted!)
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(11,6,3,5);
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(12,7,1,3);
        // Legs
        ctx.fillStyle = '#1e3a8a';
        ctx.fillRect(6,13,2,2); ctx.fillRect(8,13,2,2);
    }),

    // --- PIT Forklift ---
    forklift: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(5,13,10,3);
        // Main body (Amazon orange)
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(3,7,8,6);
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(4,8,6,4);
        // Cabin/cage
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,4,7,4);
        ctx.fillStyle = '#374151';
        ctx.fillRect(4,5,5,2);
        // Windshield
        ctx.fillStyle = '#0c4a6e';
        ctx.fillRect(5,5,3,2);
        // Mast
        ctx.fillStyle = '#374151';
        ctx.fillRect(10,2,2,11);
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(11,3,1,9);
        // Forks
        ctx.fillStyle = '#eab308';
        ctx.fillRect(11,11,4,1); ctx.fillRect(11,13,4,1);
        // Wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(3,12,3,3); ctx.fillRect(7,12,3,3);
        // Warning light
        ctx.fillStyle = '#f97316';
        ctx.fillRect(5,4,2,1);
    }),

    // --- DSP Van / yard hazard ---
    yard: c(16,16, ctx => {
        // Asphalt
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(0,6,16,10);
        // Lane markings
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,10,3,1); ctx.fillRect(7,10,3,1); ctx.fillRect(12,10,3,1);
        // Prime van body
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(3,3,10,7);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(4,4,8,5);
        // Windshield
        ctx.fillStyle = '#0c4a6e';
        ctx.fillRect(10,4,3,3);
        // Prime smile logo
        ctx.fillStyle = '#f97316';
        ctx.fillRect(5,6,4,1); ctx.fillRect(8,5,1,1);
        // Wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(4,9,2,3); ctx.fillRect(10,9,2,3);
        // Headlights
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(11,8,2,1);
    }),

    // --- Compliance / audit clipboard ---
    compliance: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(4,13,9,3);
        // Clipboard board
        ctx.fillStyle = '#92400e';
        ctx.fillRect(3,2,10,13);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(4,3,8,11);
        // Metal clip
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(6,1,4,3);
        ctx.fillStyle = '#d4d4d8';
        ctx.fillRect(7,2,2,1);
        // Paper
        ctx.fillStyle = '#f5f5f4';
        ctx.fillRect(5,4,6,9);
        // Checklist lines
        ctx.fillStyle = '#71717a';
        ctx.fillRect(6,5,4,1); ctx.fillRect(6,7,4,1); ctx.fillRect(6,9,3,1);
        // Red X marks (violations!)
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(10,5,1,1); ctx.fillRect(10,7,1,1);
        // Warning stamp
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(6,10,4,2);
    }),

    // --- Box cutter / safety blade ---
    blade: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(4,12,10,3);
        // Handle (safety orange)
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(2,7,9,4);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(3,8,7,2);
        // Grip ridges
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(4,8,1,2); ctx.fillRect(6,8,1,2); ctx.fillRect(8,8,1,2);
        // Blade (exposed!)
        ctx.fillStyle = '#d4d4d8';
        ctx.fillRect(10,8,4,2);
        ctx.fillStyle = '#a1a1aa';
        ctx.fillRect(11,8,3,1);
        // Blade edge (sharp!)
        ctx.fillStyle = '#e4e4e7';
        ctx.fillRect(13,8,1,2);
        // Guard tab
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(10,7,1,4);
    }),

    // --- Pallet Jack / Manual Pump Truck ---
    jack: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 14, 6, 2, 0, 0, Math.PI*2); ctx.fill();
        // Fork base (yellow safety color)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(2,10,12,3);
        // Fork tines
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,12,3,2);
        ctx.fillRect(11,12,3,2);
        // Main body/pump
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(6,5,4,6);
        // Handle
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(7,2,2,4);
        ctx.fillRect(6,2,4,1);
        // Wheels
        ctx.fillStyle = '#111827';
        ctx.fillRect(3,13,2,2);
        ctx.fillRect(11,13,2,2);
        // Small steering wheel
        ctx.fillStyle = '#374151';
        ctx.fillRect(7,8,2,1);
    })
};
    // ENHANCED FIRE EXIT DOOR
    GFX.door = c(16,16, ctx => {
        // Door frame shadow
        ctx.fillStyle = '#064e3b';
        ctx.fillRect(1,0,14,16);
        // Door frame
        ctx.fillStyle = '#065f46';
        ctx.fillRect(2,1,12,14);
        // Main door panel
        const doorGrad = ctx.createLinearGradient(3, 0, 13, 0);
        doorGrad.addColorStop(0, '#10b981');
        doorGrad.addColorStop(0.5, '#34d399');
        doorGrad.addColorStop(1, '#10b981');
        ctx.fillStyle = doorGrad;
        ctx.fillRect(3,2,10,12);
        // Window with glow
        ctx.fillStyle = '#0d9488';
        ctx.fillRect(4,3,8,4);
        ctx.fillStyle = '#5eead4';
        ctx.fillRect(5,4,6,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,4,3,1);
        // Handle
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(10,8,3,2);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(11,8,1,2);
        // EXIT text indicator
        ctx.fillStyle = '#ecfdf5';
        ctx.fillRect(5,10,6,2);
    });

    // ENHANCED WAREHOUSE FLOOR - industrial concrete look
    GFX.floor = c(16,16, ctx => {
        // Base concrete
        const floorGrad = ctx.createLinearGradient(0, 0, 16, 16);
        floorGrad.addColorStop(0, '#44444f');
        floorGrad.addColorStop(0.5, '#3c3c47');
        floorGrad.addColorStop(1, '#38383f');
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0,0,16,16);
        // Tile pattern
        ctx.fillStyle = '#3a3a42';
        ctx.fillRect(0,0,8,8);
        ctx.fillRect(8,8,8,8);
        // Subtle texture
        ctx.fillStyle = '#4a4a55';
        ctx.fillRect(2,2,4,4);
        ctx.fillRect(10,10,4,4);
        // Grout lines
        ctx.fillStyle = '#2d2d35';
        ctx.fillRect(7,0,2,16);
        ctx.fillRect(0,7,16,2);
        // Wear marks
        ctx.fillStyle = '#35353d';
        ctx.fillRect(4,4,2,2);
        ctx.fillRect(11,3,1,1);
        ctx.fillRect(3,12,2,1);
        // Edge shadow
        ctx.fillStyle = '#28282e';
        ctx.fillRect(0,15,16,1);
        ctx.fillRect(15,0,1,16);
    });

    // ENHANCED WAREHOUSE WALL - industrial cinder block
    GFX.wall = c(16,16, ctx => {
        // Base wall color
        const wallGrad = ctx.createLinearGradient(0, 0, 0, 16);
        wallGrad.addColorStop(0, '#3d3530');
        wallGrad.addColorStop(0.5, '#4a4138');
        wallGrad.addColorStop(1, '#3a322c');
        ctx.fillStyle = wallGrad;
        ctx.fillRect(0,0,16,16);
        // Cinder block pattern
        ctx.fillStyle = '#4e443c';
        ctx.fillRect(1,1,6,6);
        ctx.fillRect(9,1,6,6);
        ctx.fillRect(1,9,6,6);
        ctx.fillRect(9,9,6,6);
        // Block highlights
        ctx.fillStyle = '#5d5248';
        ctx.fillRect(2,2,4,4);
        ctx.fillRect(10,2,4,4);
        ctx.fillRect(2,10,4,4);
        ctx.fillRect(10,10,4,4);
        // Block texture
        ctx.fillStyle = '#6d6258';
        ctx.fillRect(3,3,2,2);
        ctx.fillRect(11,3,2,2);
        ctx.fillRect(3,11,2,2);
        ctx.fillRect(11,11,2,2);
        // Mortar lines
        ctx.fillStyle = '#2a241f';
        ctx.fillRect(0,0,16,1);
        ctx.fillRect(0,8,16,1);
        ctx.fillRect(7,0,2,16);
        // Shadow effects
        ctx.fillStyle = '#1a1612';
        ctx.fillRect(0,7,16,1);
        ctx.fillRect(0,15,16,1);
    });
    // ENHANCED WAREHOUSE SHELF - industrial racking
    GFX.shelf = c(16,16, ctx => {
        // Vertical posts with shading
        ctx.fillStyle = '#92400e';
        ctx.fillRect(0,0,4,16);
        ctx.fillRect(12,0,4,16);
        ctx.fillStyle = '#b45309';
        ctx.fillRect(1,0,3,16);
        ctx.fillRect(13,0,3,16);
        ctx.fillStyle = '#d97706';
        ctx.fillRect(2,0,1,16);
        ctx.fillRect(13,0,1,16);
        // Horizontal shelves with depth
        ctx.fillStyle = '#a16207';
        ctx.fillRect(0,4,16,4);
        ctx.fillRect(0,11,16,4);
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(1,5,14,2);
        ctx.fillRect(1,12,14,2);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(2,5,12,1);
        ctx.fillRect(2,12,12,1);
        // Shelf items
        ctx.fillStyle = '#78350f';
        ctx.fillRect(4,2,3,2);
        ctx.fillRect(9,2,3,2);
        ctx.fillRect(5,9,4,2);
        // Safety labels
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(6,6,4,1);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(2,5,12,1); ctx.fillRect(2,11,12,1);
    });
    // ENHANCED RULE BOOK projectile
    GFX.book = c(10,10, ctx => {
        // Book shadow
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(2,2,8,8);
        // Book cover
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(0,0,8,8);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(1,1,6,6);
        // Book spine
        ctx.fillStyle = '#15803d';
        ctx.fillRect(0,0,2,8);
        // Pages
        ctx.fillStyle = '#f8fafc';
        ctx.fillRect(2,1,5,6);
        // Text lines
        ctx.fillStyle = '#64748b';
        ctx.fillRect(3,2,3,1);
        ctx.fillRect(3,4,2,1);
        // WHS badge
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(3,5,2,2);
    });

    // ENHANCED REQUEST projectile (from ops managers)
    GFX.req = c(12,12, ctx => {
        // Glow effect
        ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
        ctx.beginPath();
        ctx.arc(6, 6, 6, 0, Math.PI * 2);
        ctx.fill();
        // Diamond shape
        ctx.fillStyle = '#fef2f2';
        ctx.beginPath();
        ctx.moveTo(6,0);
        ctx.lineTo(12,6);
        ctx.lineTo(6,12);
        ctx.lineTo(0,6);
        ctx.closePath();
        ctx.fill();
        // Inner diamond
        ctx.fillStyle = '#fecaca';
        ctx.beginPath();
        ctx.moveTo(6,2);
        ctx.lineTo(10,6);
        ctx.lineTo(6,10);
        ctx.lineTo(2,6);
        ctx.closePath();
        ctx.fill();
        // Exclamation mark
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,3,2,4);
        ctx.fillRect(5,8,2,2);
    });
    // ENHANCED BOSS PROJECTILE
    GFX.bossProj = c(14,14, ctx => {
        // Outer glow
        const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
        grad.addColorStop(0, '#f5d0fe');
        grad.addColorStop(0.3, '#e879f9');
        grad.addColorStop(0.6, '#c026d3');
        grad.addColorStop(1, '#86198f');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(7, 7, 6, 0, Math.PI * 2);
        ctx.fill();
        // Core
        ctx.fillStyle = '#fdf4ff';
        ctx.beginPath();
        ctx.arc(7, 7, 2, 0, Math.PI * 2);
        ctx.fill();
        // Sparkle effect
        ctx.fillStyle = '#fff';
        ctx.fillRect(6, 1, 2, 2);
        ctx.fillRect(6, 11, 2, 2);
        ctx.fillRect(1, 6, 2, 2);
        ctx.fillRect(11, 6, 2, 2);
    });

    // Hidden level assets - HIGH QUALITY SNES style
    GFX.van = c(32,22, ctx => {
        // Main body outline
        ctx.fillStyle = '#0a3d5c'; ctx.fillRect(0,1,32,19);
        // Main body - Amazon blue with gradient effect
        ctx.fillStyle = '#146eb4'; ctx.fillRect(1,2,30,17);
        ctx.fillStyle = '#1e7fc4'; ctx.fillRect(1,2,30,2); // Top highlight
        ctx.fillStyle = '#0a4d7c'; ctx.fillRect(1,17,30,2); // Bottom shadow
        // Windshield (angled)
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(2,4,11,8);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(3,5,9,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(4,6,7,4);
        // Side windows
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(14,5,7,7);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(15,6,5,5);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(15,6,4,4);
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(22,5,7,7);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(23,6,5,5);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(23,6,4,4);
        // Amazon smile arrow
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(15,13,10,2);
        ctx.fillRect(23,13,2,3);
        // Front grille
        ctx.fillStyle = '#222'; ctx.fillRect(2,11,4,3);
        // Wheels (detailed)
        ctx.fillStyle = '#000'; ctx.fillRect(5,19,6,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(6,19,4,3);
        ctx.fillStyle = '#444'; ctx.fillRect(7,20,2,1);
        ctx.fillStyle = '#000'; ctx.fillRect(21,19,6,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(22,19,4,3);
        ctx.fillStyle = '#444'; ctx.fillRect(23,20,2,1);
        // Highlights
        ctx.fillStyle = '#fff'; ctx.fillRect(2,3,2,1); ctx.fillRect(5,5,1,2);
    });
    GFX.truck = c(42,26, ctx => {
        // Outline
        ctx.fillStyle = '#4a2511'; ctx.fillRect(0,1,42,23);
        // Main body - brown with shading
        ctx.fillStyle = '#8b4513'; ctx.fillRect(1,2,40,21);
        ctx.fillStyle = '#a0522d'; ctx.fillRect(1,2,40,3); // Top highlight
        ctx.fillStyle = '#5d2a0a'; ctx.fillRect(1,20,40,3); // Bottom shadow
        // Cab section
        ctx.fillStyle = '#654321'; ctx.fillRect(1,3,14,15);
        // Windshield
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(2,5,13,9);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(3,6,11,7);
        ctx.fillStyle = '#6a9fbe'; ctx.fillRect(4,7,9,5);
        // Cargo section windows
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(17,6,9,8);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(18,7,7,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(19,8,5,4);
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(28,6,9,8);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(29,7,7,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(30,8,5,4);
        // Amazon logo (large on side)
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(18,15,18,4);
        ctx.fillRect(32,15,4,5);
        ctx.fillStyle = '#000';
        ctx.font = '6px monospace';
        ctx.fillText('PRIME', 20, 18);
        // Front grille
        ctx.fillStyle = '#222'; ctx.fillRect(2,13,6,4);
        // Wheels (detailed)
        ctx.fillStyle = '#000'; ctx.fillRect(7,23,7,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,23,5,3);
        ctx.fillStyle = '#555'; ctx.fillRect(9,24,3,1);
        ctx.fillStyle = '#000'; ctx.fillRect(29,23,7,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(30,23,5,3);
        ctx.fillStyle = '#555'; ctx.fillRect(31,24,3,1);
        // Highlights
        ctx.fillStyle = '#fff'; ctx.fillRect(2,3,3,1); ctx.fillRect(5,6,1,3);
    });
    GFX.bezosHead = c(24,24, ctx => {
        // Shadow base
        ctx.fillStyle = '#0a0a14'; ctx.fillRect(2,2,20,20);
        // Bald head with shading
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,3,16,17);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,4,14,14);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(6,5,12,12);
        // Head shine highlight
        ctx.fillStyle = '#faebd7'; ctx.fillRect(7,4,8,4);
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(8,5,5,2);
        // Evil eyebrows (angled)
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(7,9,5,2); ctx.fillRect(12,9,5,2);
        ctx.fillRect(6,10,1,1); ctx.fillRect(17,10,1,1);
        // Eyes with glint
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,12,4,3); ctx.fillRect(12,12,4,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(9,13,1,1); ctx.fillRect(13,13,1,1);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,17,8,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(9,17,6,1);
        // Ears
        ctx.fillStyle = '#d4a574'; ctx.fillRect(2,11,3,5); ctx.fillRect(19,11,3,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(3,12,2,3); ctx.fillRect(19,12,2,3);
    });
    // Jeff character for yard level - full body standing with arms crossed
    GFX.jeffYard = c(48,48, ctx => {
        // Transparent background - no fill needed
        // Legs (dark pants)
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(16,38,6,10); ctx.fillRect(26,38,6,10);
        ctx.fillStyle = '#2d3748'; ctx.fillRect(17,39,4,9); ctx.fillRect(27,39,4,9);
        // Shoes
        ctx.fillStyle = '#0f0f0f'; ctx.fillRect(15,46,8,2); ctx.fillRect(25,46,8,2);
        // Body (expensive suit jacket)
        ctx.fillStyle = '#1a2744'; ctx.fillRect(12,22,24,18);
        ctx.fillStyle = '#223050'; ctx.fillRect(14,24,20,14);
        // Suit lapels
        ctx.fillStyle = '#0f1a2e'; ctx.fillRect(20,24,2,12); ctx.fillRect(26,24,2,12);
        // White shirt underneath
        ctx.fillStyle = '#e8e8e8'; ctx.fillRect(21,24,6,10);
        ctx.fillStyle = '#ffffff'; ctx.fillRect(22,25,4,8);
        // Tie
        ctx.fillStyle = '#dc2626'; ctx.fillRect(23,25,2,8);
        ctx.fillStyle = '#b91c1c'; ctx.fillRect(23,33,2,3);
        // Arms crossed (in front of body)
        ctx.fillStyle = '#1a2744'; ctx.fillRect(10,26,28,8);
        ctx.fillStyle = '#223050'; ctx.fillRect(11,27,26,6);
        // Hands (flesh tone)
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(10,28,4,4); ctx.fillRect(34,28,4,4);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(11,29,2,2); ctx.fillRect(35,29,2,2);
        // Neck
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,18,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(21,19,6,4);
        // Head (bald)
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,2,20,18);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,3,16,15);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(18,4,12,12);
        // Dome shine
        ctx.fillStyle = '#faebd7'; ctx.fillRect(20,3,8,4);
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(22,3,4,2);
        // Eyebrows (arrogant raised)
        ctx.fillStyle = '#3f3f46'; ctx.fillRect(18,8,5,2); ctx.fillRect(25,8,5,2);
        // Eyes (looking down smugly)
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(19,11,4,3); ctx.fillRect(25,11,4,3);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(20,12,2,2); ctx.fillRect(26,12,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(20,12,1,1); ctx.fillRect(26,12,1,1);
        // Smug smirk
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(20,16,8,2);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(21,16,6,1);
        // One corner raised (smirk)
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(26,15,3,1);
        // Ears
        ctx.fillStyle = '#d4a574'; ctx.fillRect(12,10,3,6); ctx.fillRect(33,10,3,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(13,11,2,4); ctx.fillRect(33,11,2,4);
    });
    GFX.mechaBezos = c(48,48, ctx => {
        // Base plate
        ctx.fillStyle = '#0a0f18'; ctx.fillRect(0,0,48,48);
        // Mecha body with armor
        ctx.fillStyle = '#2d3748'; ctx.fillRect(8,22,32,20);
        ctx.fillStyle = '#3d4a5c'; ctx.fillRect(10,24,28,16);
        ctx.fillStyle = '#4a5568'; ctx.fillRect(12,26,24,12);
        // Amazon logo chest (glowing)
        ctx.fillStyle = '#ff9900'; ctx.fillRect(18,28,12,8);
        ctx.fillStyle = '#ffb347'; ctx.fillRect(20,30,8,4);
        ctx.fillStyle = '#ff6600'; ctx.fillRect(26,32,4,4);
        // Shoulder cannons with glow
        ctx.fillStyle = '#374151'; ctx.fillRect(0,22,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,24,6,14);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(3,28,4,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,29,2,2);
        ctx.fillStyle = '#374151'; ctx.fillRect(38,22,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(40,24,6,14);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(41,28,4,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(42,29,2,2);
        // Neck chrome
        ctx.fillStyle = '#6b7280'; ctx.fillRect(14,18,20,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(16,19,16,4);
        // Bald dome with highlight
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(14,2,20,18);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(16,1,16,8);
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(20,0,8,4);
        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(18,2,6,3);
        // Evil eyebrows
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(16,8,6,2); ctx.fillRect(26,8,6,2);
        // Glowing red eyes
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(17,11,5,5); ctx.fillRect(26,11,5,5);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(18,12,3,3); ctx.fillRect(27,12,3,3);
        ctx.fillStyle = '#ff4444'; ctx.fillRect(19,13,1,1); ctx.fillRect(28,13,1,1);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(19,17,10,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(21,17,6,1);
        // Ear sensors
        ctx.fillStyle = '#4b5563'; ctx.fillRect(10,8,4,8); ctx.fillRect(34,8,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,10,2,4); ctx.fillRect(35,10,2,4);
        // Legs
        ctx.fillStyle = '#374151'; ctx.fillRect(14,42,8,6); ctx.fillRect(26,42,8,6);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(16,44,4,4); ctx.fillRect(28,44,4,4);
    });
    GFX.bezosProj = c(12,12, ctx => { ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(6,6,5,0,Math.PI*2); ctx.fill(); ctx.fillStyle = '#ff9900'; ctx.beginPath(); ctx.arc(6,6,3,0,Math.PI*2); ctx.fill(); });
    GFX.drone = c(16,16, ctx => {
        // Drone body
        ctx.fillStyle = '#2a2a2a'; ctx.fillRect(4,6,8,4);
        // Propellers
        ctx.fillStyle = '#444'; ctx.fillRect(2,4,3,8); ctx.fillRect(11,4,3,8);
        // Eye/camera
        ctx.fillStyle = '#ff0000'; ctx.fillRect(7,7,2,2);
        // Amazon logo
        ctx.fillStyle = '#ff9900'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
    });

    // === NEW WAREHOUSE ATMOSPHERE SPRITES ===

    // Animated Conveyor Belt (horizontal)
    GFX.conveyorBelt = c(16,16, ctx => {
        // Belt frame
        ctx.fillStyle = '#374151'; ctx.fillRect(0,4,16,8);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(1,5,14,6);
        // Belt surface with ridges
        ctx.fillStyle = '#1f2937';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect(i * 2, 6, 1, 4);
        }
        // Rollers at ends
        ctx.fillStyle = '#6b7280'; ctx.fillRect(0,4,2,8); ctx.fillRect(14,4,2,8);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(0,6,2,4); ctx.fillRect(14,6,2,4);
        // Safety stripe
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(0,3,16,1); ctx.fillRect(0,12,16,1);
    });

    // Package on conveyor (small)
    GFX.packageSmall = c(12,12, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,2,10,9);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,3,8,7);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,5,4,2); // tape
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(3,3,6,1); // label
    });

    // Package on conveyor (large)
    GFX.packageLarge = c(16,14, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,2,14,11);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,3,12,9);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(2,2,12,2); // flap
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(5,6,6,2); // tape
        ctx.fillStyle = '#111'; ctx.fillRect(7,8,2,2); // barcode
    });

    // Manual Pallet Jack
    GFX.palletJack = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 14, 6, 2, 0, 0, Math.PI*2); ctx.fill();
        // Fork tines (yellow safety)
        ctx.fillStyle = '#eab308'; ctx.fillRect(2,10,12,3);
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,12,3,2); ctx.fillRect(11,12,3,2);
        // Main pump body (red)
        ctx.fillStyle = '#dc2626'; ctx.fillRect(6,5,4,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,6,2,4);
        // Handle
        ctx.fillStyle = '#1f2937'; ctx.fillRect(7,2,2,4);
        ctx.fillStyle = '#374151'; ctx.fillRect(6,2,4,1);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(3,13,2,2); ctx.fillRect(11,13,2,2);
    });

    // Pallet Jack with Load
    GFX.palletJackLoaded = c(16,20, ctx => {
        // Pallet on top
        ctx.fillStyle = '#92400e'; ctx.fillRect(1,0,14,3);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,1,12,2);
        // Boxes on pallet
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,3,6,6);
        ctx.fillStyle = '#a16207'; ctx.fillRect(3,4,4,4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(3,3,4,1); // tape
        ctx.fillStyle = '#78350f'; ctx.fillRect(8,4,6,5);
        ctx.fillStyle = '#a16207'; ctx.fillRect(9,5,4,3);
        // Fork tines
        ctx.fillStyle = '#eab308'; ctx.fillRect(2,10,12,3);
        // Pump body
        ctx.fillStyle = '#dc2626'; ctx.fillRect(6,13,4,4);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(3,16,2,2); ctx.fillRect(11,16,2,2);
    });

    // Worker pushing cart
    GFX.cartWorker = c(20,16, ctx => {
        // Cart first (behind worker)
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(10,8,9,6);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(11,7,7,5);
        // Packages on cart
        ctx.fillStyle = '#a16207'; ctx.fillRect(11,4,3,4);
        ctx.fillStyle = '#78350f'; ctx.fillRect(14,5,4,3);
        // Cart wheels
        ctx.fillStyle = '#111'; ctx.fillRect(11,13,2,2); ctx.fillRect(17,13,2,2);
        // Worker shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(5, 15, 4, 2, 0, 0, Math.PI*2); ctx.fill();
        // Worker body (hi-vis)
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,7,6,8);
        ctx.fillStyle = '#eab308'; ctx.fillRect(3,8,4,6);
        // Reflective strips
        ctx.fillStyle = '#fef08a'; ctx.fillRect(3,9,4,1); ctx.fillRect(3,12,4,1);
        // Head
        ctx.fillStyle = '#d4a574'; ctx.fillRect(3,3,4,4);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(3,2,4,2); // hair
        // Arms pushing
        ctx.fillStyle = '#d4a574'; ctx.fillRect(7,8,3,1);
    });

    // Package handler scanning
    GFX.packageHandler = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(6, 15, 4, 2, 0, 0, Math.PI*2); ctx.fill();
        // Body (hi-vis)
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,7,8,8);
        ctx.fillStyle = '#eab308'; ctx.fillRect(3,8,6,6);
        ctx.fillStyle = '#fef08a'; ctx.fillRect(3,9,6,1); ctx.fillRect(3,12,6,1);
        // Head
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,3,4,4);
        ctx.fillStyle = '#3f3f46'; ctx.fillRect(4,2,4,2); // cap
        // Scanner in hand
        ctx.fillStyle = '#111'; ctx.fillRect(10,6,4,6);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(11,7,2,1); // screen
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,11,2,1); // laser
        // Package being scanned
        ctx.fillStyle = '#a16207'; ctx.fillRect(10,12,5,3);
    });

    // Pallet stack (multiple boxes)
    GFX.palletStack = c(16,16, ctx => {
        // Pallet base
        ctx.fillStyle = '#92400e'; ctx.fillRect(1,13,14,3);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,14,12,1);
        // Bottom layer boxes
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,9,5,4); ctx.fillRect(8,9,6,4);
        ctx.fillStyle = '#a16207'; ctx.fillRect(3,10,3,2); ctx.fillRect(9,10,4,2);
        // Top layer boxes
        ctx.fillStyle = '#b45309'; ctx.fillRect(3,5,4,4); ctx.fillRect(8,6,5,3);
        ctx.fillStyle = '#d97706'; ctx.fillRect(4,6,2,2); ctx.fillRect(9,7,3,1);
        // Labels
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,7,2,1); ctx.fillRect(10,7,2,1);
    });

    // Sorting station
    GFX.sortStation = c(16,16, ctx => {
        // Main station body
        ctx.fillStyle = '#374151'; ctx.fillRect(1,6,14,9);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,7,12,7);
        // Chute openings
        ctx.fillStyle = '#1f2937'; ctx.fillRect(3,8,3,5); ctx.fillRect(7,8,3,5); ctx.fillRect(11,8,3,5);
        // Labels above chutes
        ctx.fillStyle = '#22c55e'; ctx.fillRect(3,6,3,2);
        ctx.fillStyle = '#eab308'; ctx.fillRect(7,6,3,2);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,6,3,2);
        // Top scanner bar
        ctx.fillStyle = '#111'; ctx.fillRect(2,3,12,3);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,4,8,1);
    });

    // Conveyor junction
    GFX.conveyorJunction = c(16,16, ctx => {
        // Cross pattern
        ctx.fillStyle = '#374151'; ctx.fillRect(0,5,16,6); ctx.fillRect(5,0,6,16);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(1,6,14,4); ctx.fillRect(6,1,4,14);
        // Center platform
        ctx.fillStyle = '#6b7280'; ctx.fillRect(5,5,6,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(6,6,4,4);
        // Direction arrows
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,7,2,2); ctx.fillRect(12,7,2,2);
        ctx.fillRect(7,2,2,2); ctx.fillRect(7,12,2,2);
    });

    // Warehouse signage
    GFX.signPick = c(16,10, ctx => {
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('PICK', 2, 7);
    });

    GFX.signPack = c(16,10, ctx => {
        ctx.fillStyle = '#16a34a'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('PACK', 2, 7);
    });

    GFX.signShip = c(16,10, ctx => {
        ctx.fillStyle = '#dc2626'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('SHIP', 2, 7);
    });

    // Floor arrow markings
    GFX.floorArrow = c(16,16, ctx => {
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(8, 2); ctx.lineTo(14, 8); ctx.lineTo(10, 8);
        ctx.lineTo(10, 14); ctx.lineTo(6, 14); ctx.lineTo(6, 8);
        ctx.lineTo(2, 8);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#92400e'; ctx.lineWidth = 1; ctx.stroke();
    });

    // === YARD LEVEL NEW SPRITES ===

    // Forklift (moving obstacle)
    GFX.forkliftMoving = c(24,20, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(2,17,20,3);
        // Main body
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(6,8,12,9);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(7,9,10,7);
        // Cabin
        ctx.fillStyle = '#1f2937'; ctx.fillRect(7,4,10,5);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(8,5,8,3);
        // Mast
        ctx.fillStyle = '#374151'; ctx.fillRect(2,2,4,15);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(3,3,2,13);
        // Forks
        ctx.fillStyle = '#1f2937'; ctx.fillRect(0,15,6,2); ctx.fillRect(0,13,6,2);
        // Pallet on forks
        ctx.fillStyle = '#92400e'; ctx.fillRect(0,8,6,5);
        ctx.fillStyle = '#a16207'; ctx.fillRect(1,9,4,3);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(8,16,4,3); ctx.fillRect(14,16,4,3);
        // Warning light
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(10,3,4,2);
    });

    // Power-up: Speed Boost
    GFX.powerSpeed = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#22d3ee');
        grad.addColorStop(0.5, '#0891b2');
        grad.addColorStop(1, 'rgba(8, 145, 178, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Lightning bolt
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(9, 2); ctx.lineTo(5, 8); ctx.lineTo(8, 8);
        ctx.lineTo(6, 14); ctx.lineTo(12, 7); ctx.lineTo(9, 7);
        ctx.closePath();
        ctx.fill();
    });

    // Power-up: Shield
    GFX.powerShield = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#a855f7');
        grad.addColorStop(0.5, '#7c3aed');
        grad.addColorStop(1, 'rgba(124, 58, 237, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Shield shape
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(8, 2); ctx.lineTo(13, 5); ctx.lineTo(13, 9);
        ctx.lineTo(8, 14); ctx.lineTo(3, 9); ctx.lineTo(3, 5);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#7c3aed'; ctx.fillRect(7, 6, 2, 4);
    });

    // Power-up: Extra Life
    GFX.powerLife = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#f87171');
        grad.addColorStop(0.5, '#dc2626');
        grad.addColorStop(1, 'rgba(220, 38, 38, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Heart
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(8, 13);
        ctx.bezierCurveTo(2, 8, 2, 3, 8, 6);
        ctx.bezierCurveTo(14, 3, 14, 8, 8, 13);
        ctx.fill();
    });

    // Collectible package (bonus points)
    GFX.collectPackage = c(14,14, ctx => {
        // Sparkle glow
        ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
        ctx.beginPath(); ctx.arc(7, 7, 7, 0, Math.PI*2); ctx.fill();
        // Box
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(2,3,10,9);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(3,4,8,7);
        // Smile logo
        ctx.fillStyle = '#ff9900'; ctx.fillRect(4,7,6,2);
        ctx.fillRect(8,7,2,3);
        // Sparkles
        ctx.fillStyle = '#fff';
        ctx.fillRect(1, 1, 2, 1); ctx.fillRect(11, 2, 2, 1);
        ctx.fillRect(0, 10, 1, 2); ctx.fillRect(12, 11, 2, 1);
    });

    // Safety barrier
    GFX.safetyBarrier = c(16,12, ctx => {
        // Posts
        ctx.fillStyle = '#1f2937'; ctx.fillRect(1,0,3,12); ctx.fillRect(12,0,3,12);
        // Warning stripes
        for (let i = 0; i < 4; i++) {
            ctx.fillStyle = i % 2 === 0 ? '#fbbf24' : '#111';
            ctx.fillRect(4, i * 3, 8, 3);
        }
    });

    // Loading dock door
    GFX.dockDoor = c(32,24, ctx => {
        // Door frame
        ctx.fillStyle = '#374151'; ctx.fillRect(0,0,32,24);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,2,28,20);
        // Segmented door
        for (let i = 0; i < 4; i++) {
            ctx.fillStyle = i % 2 === 0 ? '#6b7280' : '#9ca3af';
            ctx.fillRect(3, 3 + i * 4, 26, 4);
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(3, 3 + i * 4 + 3, 26, 1);
        }
        // Door number
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace';
        ctx.fillText('D1', 12, 14);
    });

    // Yard pedestrian
    GFX.yardPedestrian = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Legs
        ctx.fillStyle = '#1f2937'; ctx.fillRect(5,12,2,3); ctx.fillRect(9,12,2,3);
        // Body (hi-vis)
        ctx.fillStyle = '#16a34a'; ctx.fillRect(3,6,10,7);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(4,7,8,5);
        // Reflective X
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(4,7,1,5); ctx.fillRect(11,7,1,5);
        ctx.fillRect(4,9,8,1);
        // Head with hard hat
        ctx.fillStyle = '#d4a574'; ctx.fillRect(5,3,6,4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(4,1,8,3);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(5,2,6,1);
    });
}
// --- GAME STATE ---
const GAME = {
    state: 'LOGO',
    stateTimer: 0,
    nextState: 'PLAY',
    ticks: 0,
    player: null,
    selectedChar: "Carrie",
    charList: ["Carrie", "Nevena", "Joao", "Roman", "Erwin"],
    charIndex: 0,
    camera: { x: 0, y: 0 },
    map: [], clutter: [], entities: [], projectiles: [], particles: [], floatingTexts: [],
    activeIssues: [],
    issuesFixed: 0, lives: 5, genId: 0, gameOverTriggered: false, simonHits: 0, boss: null, pendingBossIntro: false,
    shake: 0, flash: 0,
    dialogText: "", dialogVisible: "", dialogTimer: 0,
    splashTimer: 0, aiResultText: null,
    startTime: 0, booksFired: 0, opsPushed: 0,
    lastAIBanterTime: 0, // Throttle AI requests
    fireExitDoor: null, // Hidden level door position
    froggerVehicles: [], // Vehicles array (deprecated, kept for compatibility)
    jeffTaunt: "", // Current Jeff taunt
    jeffTauntTimer: 0, // Timer for taunt display

    // === NEW WAREHOUSE ATMOSPHERE ===
    conveyorBelts: [], // Animated conveyor belt positions
    packages: [], // Moving packages on conveyors
    palletJacks: [], // Moving pallet jacks
    cartWorkers: [], // Workers pushing carts
    palletStacks: [], // Static pallet stacks
    sortStations: [], // Sorting station positions
    warehouseSigns: [], // Zone signage

    // === YARD LEVEL ENHANCEMENTS ===
    powerUps: [], // Power-ups in yard level
    collectibles: [], // Collectible packages
    forklifts: [], // Moving forklift obstacles
    playerPowerUp: null, // Current active power-up
    powerUpTimer: 0, // Power-up duration timer
    score: 0, // Bonus score from collectibles
    yardPedestrians: [], // NPC pedestrians in yard

    bossTypes: [
        { name: "Labour Inspector", sprite: "boss_inspector", hp: 10, speed: 1.2, attackDelay: 50, title: "The Enforcer", desc: "Checks every corner.", attackName: "Citation Storm" },
        { name: "Compliance Auditor", sprite: "boss_compliance", hp: 12, speed: 0.8, attackDelay: 70, title: "The Watcher", desc: "Nothing escapes.", attackName: "Audit Trail" },
        { name: "Sebastian Sprigade", sprite: "boss_sebastian", hp: 15, speed: 1.0, attackDelay: 60, title: "Delivery Station Mgr", desc: "Obsessed with TPH.", attackName: "Volume Spike" },
        { name: "Regional OPS MGR", sprite: "boss_regional", hp: 14, speed: 0.6, attackDelay: 90, title: "The Executive", desc: "Metrics first.", attackName: "Budget Cut" },
        { name: "Avetta Platform", sprite: "boss_avetta", hp: 18, speed: 0.4, attackDelay: 100, title: "Risk Mgmt AI", desc: "Judges all.", attackName: "Compliance Block" },
        { name: "Jelena \"Jelly\"", sprite: "boss_jelly", hp: 13, speed: 0.9, attackDelay: 65, title: "HR Guardian", desc: "HR legend who never forgets a policy.", attackName: "Policy Shock" }
    ]
};

const HAZARD_POOL = [
    // === POWERED INDUSTRIAL TRUCKS (PITs) ===
    { name: "Speeding PIT Operator", type: "forklift" },
    { name: "Forklift With Blocked View", type: "forklift" },
    { name: "Reach Truck Cutting Corner", type: "forklift" },
    { name: "Order Picker Too High", type: "forklift" },
    { name: "Turret Truck Near Pedestrians", type: "forklift" },
    { name: "Clamp Truck Overloaded", type: "forklift" },
    { name: "PIT Operator Without Seatbelt", type: "forklift" },

    // === PACK & SHIP HAZARDS ===
    { name: "Overflowing SLAM Line", type: "conveyor" },
    { name: "Jammed AFE Chute", type: "conveyor" },
    { name: "SIOC Avalanche", type: "box" },
    { name: "Crushed Jiffy Mailer Pile", type: "debris" },
    { name: "Tape Gun Left Running", type: "blade" },
    { name: "Poly Bag Explosion", type: "wrap" },
    { name: "Gift Wrap Station Chaos", type: "debris" },
    { name: "Dunnage Bag Mountain", type: "debris" },

    // === INBOUND & RECEIVE ===
    { name: "Unbroken-Down Gaylord", type: "tall_pallet" },
    { name: "Vendor Pallet Leaning", type: "tall_pallet" },
    { name: "Receive Dock Gap", type: "dock" },
    { name: "Trailer Without Wheel Chocks", type: "dock" },
    { name: "Dock Plate Not Secured", type: "dock" },
    { name: "Mixed SKU Nightmare Pallet", type: "tall_pallet" },
    { name: "Shrink Wrap Tornado", type: "wrap" },

    // === PROBLEM SOLVE CHAOS ===
    { name: "Problem Solve Cart Avalanche", type: "cart" },
    { name: "ASIN Research Black Hole", type: "tote" },
    { name: "Damaged Out Pile Growing", type: "box" },
    { name: "Research Bin Overflow", type: "tote" },
    { name: "Missing Label Saga", type: "compliance" },

    // === FLOOR HAZARDS ===
    { name: "Ice Pack Leak Trail", type: "spill" },
    { name: "Crushed Fragile Item Spill", type: "spill" },
    { name: "Leaking Liquid Hazmat", type: "spill" },
    { name: "Sweeper Missed This Spot", type: "spill" },
    { name: "Energy Drink Explosion", type: "spill" },
    { name: "Smoothie Shrapnel Zone", type: "spill" },
    { name: "Coffee Ring of Standup Past", type: "spill" },
    { name: "Wet Floor No Sign", type: "spill" },

    // === STOW & STORAGE ===
    { name: "Overstuffed Prime Bin", type: "tote" },
    { name: "Top Stock About to Fall", type: "tall_pallet" },
    { name: "Heavy Item Stowed High", type: "tall_pallet" },
    { name: "Bin Capacity Ignored", type: "box" },
    { name: "Unstable Rack Section", type: "tall_pallet" },
    { name: "Random Cage Contents", type: "cage" },

    // === PICK & COUNT ===
    { name: "Scanner Cord Trip Wire", type: "cord" },
    { name: "Pick Cart Wheel Failure", type: "cart" },
    { name: "Tote Stack Too Tall", type: "tote" },
    { name: "Mystery SKU in Wrong Bin", type: "box" },
    { name: "Cycle Count Chaos", type: "compliance" },

    // === EQUIPMENT & TOOLS ===
    { name: "Box Cutter Without Guard", type: "blade" },
    { name: "Frayed Scanner Holster", type: "cord" },
    { name: "Broken Safety Ladder", type: "facility" },
    { name: "Missing Step Stool", type: "facility" },
    { name: "Unsecured Extension Cord", type: "cord" },
    { name: "Charging Station Overload", type: "battery" },
    { name: "Dead Battery Pile", type: "battery" },

    // === FIRE & EMERGENCY ===
    { name: "Blocked Fire Exit", type: "door" },
    { name: "Fire Extinguisher Hidden", type: "door" },
    { name: "Emergency Shower Blocked", type: "facility" },
    { name: "First Aid Kit Empty", type: "compliance" },
    { name: "AED Signage Covered", type: "facility" },

    // === ERGONOMIC HAZARDS ===
    { name: "Overreaching Associate", type: "npc" },
    { name: "Improper Lifting Technique", type: "npc" },
    { name: "Continuous Repetitive Motion", type: "npc" },
    { name: "Standing Mat Missing", type: "facility" },
    { name: "Keyboard at Wrong Height", type: "facility" },

    // === PEOPLE & BEHAVIOR ===
    { name: "Phone Walker on Floor", type: "npc" },
    { name: "Manager Speed Walk Mode", type: "npc" },
    { name: "New Hire Wrong Way Traffic", type: "npc" },
    { name: "Peak Season Burnout Zone", type: "npc" },
    { name: "Ambassador Training Cluster", type: "npc" },
    { name: "VTO Line Blocking Path", type: "npc" },

    // === OUTBOUND & SHIPPING ===
    { name: "Trailer Loaded Unevenly", type: "dock" },
    { name: "Smalls Bag Landslide", type: "debris" },
    { name: "Rollers Not Locked", type: "cage" },
    { name: "Cart Wall Collapse Risk", type: "cart" },
    { name: "CPT Rush Hour Chaos", type: "conveyor" },
    { name: "Sortation System Jam", type: "conveyor" },

    // === COMPLIANCE & DOCUMENTATION ===
    { name: "Safety Audit Due Tomorrow", type: "compliance" },
    { name: "Training Expired Badge", type: "compliance" },
    { name: "PPE Checklist Skipped", type: "compliance" },
    { name: "Incident Near-Miss Unreported", type: "compliance" },
    { name: "OSHA Log Update Pending", type: "compliance" },
    { name: "Lockout Tagout Forgotten", type: "compliance" },
];

function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function pickRandomHazards(count) {
    const picks = shuffleArray([...HAZARD_POOL]);
    return picks.slice(0, Math.min(count, picks.length));
}

function randomDoorPlacement() {
    const side = ['top', 'bottom', 'left', 'right'][Math.floor(Math.random() * 4)];
    const buffer = 2;
    let doorX = 0, doorY = 0, hazardX = 0, hazardY = 0;

    if (side === 'top') {
        doorY = 0; doorX = Math.floor(Math.random() * (MAP_W - buffer * 2)) + buffer;
        hazardX = doorX; hazardY = 1;
    } else if (side === 'bottom') {
        doorY = MAP_H - 1; doorX = Math.floor(Math.random() * (MAP_W - buffer * 2)) + buffer;
        hazardX = doorX; hazardY = MAP_H - 2;
    } else if (side === 'left') {
        doorX = 0; doorY = Math.floor(Math.random() * (MAP_H - buffer * 2)) + buffer;
        hazardX = 1; hazardY = doorY;
    } else {
        doorX = MAP_W - 1; doorY = Math.floor(Math.random() * (MAP_H - buffer * 2)) + buffer;
        hazardX = MAP_W - 2; hazardY = doorY;
    }

    return { doorX, doorY, hazardX, hazardY };
}

function isTileFree(tx, ty) {
    if (GAME.map[ty][tx] !== 0) return false;
    return !GAME.activeIssues.some(h => Math.round(h.x / TILE_SIZE) === tx && Math.round(h.y / TILE_SIZE) === ty);
}

function pickRandomFloorTile() {
    let attempts = 0;
    while (attempts < 500) {
        const tx = Math.floor(Math.random() * (MAP_W - 2)) + 1;
        const ty = Math.floor(Math.random() * (MAP_H - 2)) + 1;
        if (isTileFree(tx, ty)) return { tx, ty };
        attempts++;
    }
    return { tx: 1, ty: 1 };
}

// --- INPUT ---
const KEYS = { up: false, down: false, left: false, right: false, action: false };
window.addEventListener('keydown', e => {
    if(e.key==='w'||e.key==='ArrowUp') KEYS.up=true;
    if(e.key==='s'||e.key==='ArrowDown') KEYS.down=true;
    if(e.key==='a'||e.key==='ArrowLeft') KEYS.left=true;
    if(e.key==='d'||e.key==='ArrowRight') KEYS.right=true;
    if(e.code==='Space') { if(!KEYS.action) handleAction(); KEYS.action=true; }
});
window.addEventListener('keyup', e => {
    if(e.key==='w'||e.key==='ArrowUp') KEYS.up=false;
    if(e.key==='s'||e.key==='ArrowDown') KEYS.down=false;
    if(e.key==='a'||e.key==='ArrowLeft') KEYS.left=false;
    if(e.key==='d'||e.key==='ArrowRight') KEYS.right=false;
    if(e.code==='Space') KEYS.action=false;
});

function handleAction() {
    AudioSys.init(); AudioSys.resume(); MusicSys.init(); MusicSys.resume(); updateMusicForState();
    if (GAME.state === 'LOSE_SPLASH' || GAME.state === 'WIN_SPLASH') return;
    if (GAME.state === 'LOGO') { advanceState(); }
    else if (['INTRO', 'STORY'].includes(GAME.state)) { AudioSys.sfx.start(); advanceState(); }
    else if (['TITLE', 'HOWTO'].includes(GAME.state)) {
        GAME.state = (GAME.state==='TITLE')?'HOWTO':'SELECT'; AudioSys.sfx.select(); updateMusicForState();
    }
    else if (GAME.state === 'SELECT') { AudioSys.sfx.select(); GAME.selectedChar = GAME.charList[GAME.charIndex]; resetGame(); }
    else if (GAME.state === 'DIALOG') {
        if (GAME.dialogVisible.length < GAME.dialogText.length) {
            GAME.dialogVisible = GAME.dialogText; document.getElementById('text-content').innerText = GAME.dialogVisible;
        } else {
            closeDialog();
            // Check if transitioning to yard level
            if (GAME.nextState === 'YARD_INTRO') {
                GAME.state = 'YARD_INTRO';
                GAME.stateTimer = 0;
                startYardLevel();
            }
        }
    }
    else if (GAME.state === 'VISITOR_SPLASH') { initBossEncounter(); }
    else if (GAME.state === 'BOSS_INTRO') { GAME.state = 'BOSS'; GAME.nextState = 'BOSS'; updateMusicForState(); }
    else if (GAME.state === 'BEZOS_INTRO') { GAME.state = 'BEZOS_BOSS'; GAME.nextState = 'BEZOS_BOSS'; updateMusicForState(); }
    else if (GAME.state === 'MECHA_BOSS_INTRO') { GAME.state = 'MECHA_BOSS'; GAME.nextState = 'MECHA_BOSS'; updateMusicForState(); }
    else if (GAME.state === 'THRONE_CONFRONTATION') {
        // Throne confrontation cutscene with dialogue
        const scene = GAME.throneScene;
        if (!scene) return;

        scene.dialogueTimer++;

        // Phase 0: Zoom in / setup (frames 0-30, faster transition)
        if (scene.phase === 0 && GAME.stateTimer >= 30) {
            scene.phase = 1; // Move to dialogue phase
            scene.dialogueTimer = 0;
        }
        // Phase 1: Dialogue sequence
        else if (scene.phase === 1) {
            // Advance dialogue every 45 frames (faster pacing)
            if (scene.dialogueTimer >= 45) {
                scene.dialogueIndex++;
                scene.dialogueTimer = 0;

                // Check if dialogue is complete
                if (scene.dialogueIndex >= scene.dialogues.length) {
                    scene.phase = 2; // Move to transformation
                    GAME.stateTimer = 0;
                }
            }
        }
        // Phase 2: Transition to transformation
        else if (scene.phase === 2 && GAME.stateTimer >= 30) {
            GAME.state = 'MECHA_TRANSFORM';
            GAME.stateTimer = 0;
        }
    }
    else if (GAME.state === 'MECHA_TRANSFORM') {
        // Only allow skip after animation has played for a bit
        if (GAME.stateTimer > 200) {
            beginMechaEncounter(); // Proceed to Mecha boss fight
        }
    }
    else if (GAME.state === 'YARD_INTRO') { startYardLevel(); }
    else if (GAME.state === 'GAMEOVER' || GAME.state === 'WIN') {
        document.getElementById('boss-hud').style.display = 'none'; GAME.state = 'TITLE'; updateMusicForState();
    }
    else if (GAME.state === 'BEZOS_WIN') {
        GAME.state = 'TITLE'; updateMusicForState();
    }
    else if (GAME.state === 'PLAY' || GAME.state === 'BOSS' || GAME.state === 'BEZOS_BOSS' || GAME.state === 'MECHA_BOSS') {
        if (GAME.state === 'PLAY' && tryInteract()) return;
        throwBook();
    }
}

function init() {
    generateAssets();
    GAME.state = 'LOGO';
    updateMusicForState();
    requestAnimationFrame(loop);
}

function advanceState() {
    GAME.stateTimer = 0;
    if (GAME.state === 'LOGO') GAME.state = 'INTRO';
    else if (GAME.state === 'INTRO') GAME.state = 'STORY';
    else if (GAME.state === 'STORY') GAME.state = 'TITLE';
    else if (GAME.state === 'TITLE') GAME.state = 'HOWTO'; 
    updateMusicForState();
}

function resetGame() {
    GAME.state = 'PLAY';
    GAME.genId++;
    GAME.gameOverTriggered = false;
    const stats = getCharStats(GAME.selectedChar);
    GAME.player = { x: 100, y: 100, dir: 0, speed: stats.speed, iframe: 0, cooldown: 0, cooldownMax: 120 };
    GAME.entities = []; GAME.projectiles = []; GAME.particles = []; GAME.floatingTexts = [];
    GAME.activeIssues = []; GAME.clutter = [];
    GAME.issuesFixed = 0; GAME.lives = stats.lives; GAME.simonHits = 0; GAME.boss = null; GAME.pendingBossIntro = false;
    GAME.hiddenDoor = null; GAME.yard = null; GAME.mecha = null;
    GAME.nextState = 'PLAY'; GAME.aiResultText = null;
    GAME.startTime = Date.now(); GAME.booksFired = 0; GAME.opsPushed = 0;
    
    generateMap();
    GAME.entities.push({ type: 'simon', x: 100, y: 80, w: 16, h: 16 });
    document.getElementById('hud-layer').style.display = 'block'; updateHud();
    document.getElementById('boss-hud').style.display = 'none';
    
    // --- CHANGED: SHOW LOADING STATE INSTEAD OF HARDCODED TEXT ---
    const currentGen = GAME.genId;
    showThinking("Simon Unglaube", GFX.simonFace); // Shows "..." dialog

    callGemini(`You are Simon Unglaube, WHS Senior Regional Manager for Amazon MEU. Greet ${GAME.selectedChar} with dry humor and one quick, relevant safety reminder for starting the shift. Keep it witty. Max 18 words.`, "intro").then(text => {
        if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
             let finalText = text.replace(/\[.*?\]/g, GAME.selectedChar);
             showDialog(finalText, "Simon Unglaube", GFX.simonFace, true);
        }
    });
    updateMusicForState();
}

function generateMap() {
    GAME.map = [];
    // Reset warehouse atmosphere arrays
    GAME.conveyorBelts = [];
    GAME.packages = [];
    GAME.palletJacks = [];
    GAME.cartWorkers = [];
    GAME.palletStacks = [];
    GAME.sortStations = [];
    GAME.warehouseSigns = [];

    for(let y=0; y<MAP_H; y++) {
        GAME.map[y] = [];
        for(let x=0; x<MAP_W; x++) {
            if (x===0 || x===MAP_W-1 || y===0 || y===MAP_H-1) GAME.map[y][x] = 1;
            else if (x > 5 && x < 55 && y % 5 === 0 && x % 3 !== 0) GAME.map[y][x] = 2;
            else {
                GAME.map[y][x] = 0;
                if (Math.random() < 0.05) {
                    const type = ['coffee','paper','tape'][Math.floor(Math.random()*3)];
                    GAME.clutter.push({x: x*TILE_SIZE + 4, y: y*TILE_SIZE + 4, type: type});
                }
            }
        }
    }
    for(let y=15; y<25; y++) for(let x=25; x<35; x++) GAME.map[y][x] = 0;

    // === ADD CONVEYOR BELT LANES ===
    // Horizontal conveyor lanes through the warehouse
    const conveyorLanes = [8, 18, 28]; // Y positions for conveyor lanes
    conveyorLanes.forEach(laneY => {
        for (let x = 6; x < 54; x++) {
            if (x % 3 !== 0) { // Gap for crossing
                GAME.conveyorBelts.push({
                    x: x * TILE_SIZE,
                    y: laneY * TILE_SIZE,
                    dir: laneY === 18 ? -1 : 1 // Alternate directions
                });
            }
        }
    });

    // === SPAWN MOVING PACKAGES ON CONVEYORS ===
    for (let i = 0; i < 12; i++) {
        const laneY = conveyorLanes[Math.floor(Math.random() * conveyorLanes.length)];
        GAME.packages.push({
            x: Math.random() * (48 * TILE_SIZE) + 6 * TILE_SIZE,
            y: laneY * TILE_SIZE - 4,
            speed: (laneY === 18 ? -0.5 : 0.5) + Math.random() * 0.2,
            type: Math.random() < 0.5 ? 'small' : 'large'
        });
    }


    // === SPAWN CART WORKERS ===
    for (let i = 0; i < 4; i++) {
        const startY = 10 + i * 8;
        GAME.cartWorkers.push({
            x: 8 * TILE_SIZE,
            y: startY * TILE_SIZE,
            targetX: 50 * TILE_SIZE,
            dir: 1, // 1 = right, -1 = left
            speed: 0.6 + Math.random() * 0.2,
            pauseTimer: 0
        });
    }

    // === ADD PALLET STACKS (static decoration) ===
    const palletPositions = [
        {x: 4, y: 4}, {x: 4, y: 12}, {x: 4, y: 22}, {x: 4, y: 32},
        {x: 55, y: 4}, {x: 55, y: 12}, {x: 55, y: 22}, {x: 55, y: 32},
        {x: 12, y: 35}, {x: 22, y: 35}, {x: 38, y: 35}, {x: 48, y: 35}
    ];
    palletPositions.forEach(pos => {
        if (pos.x < MAP_W - 1 && pos.y < MAP_H - 1) {
            GAME.palletStacks.push({
                x: pos.x * TILE_SIZE,
                y: pos.y * TILE_SIZE
            });
        }
    });

    // === ADD SORTING STATIONS ===
    GAME.sortStations.push(
        { x: 15 * TILE_SIZE, y: 3 * TILE_SIZE },
        { x: 35 * TILE_SIZE, y: 3 * TILE_SIZE },
        { x: 25 * TILE_SIZE, y: 36 * TILE_SIZE }
    );

    // === ADD WAREHOUSE ZONE SIGNS ===
    GAME.warehouseSigns.push(
        { x: 10 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'pick' },
        { x: 30 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'pack' },
        { x: 50 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'ship' }
    );

    const door = randomDoorPlacement();
    GAME.map[door.doorY][door.doorX] = 3;
    GAME.map[door.hazardY][door.hazardX] = 0;
    GAME.fireExitDoor = { x: door.doorX * TILE_SIZE, y: door.doorY * TILE_SIZE }; // Store door position for hidden level
    GAME.activeIssues.push({ x: door.hazardX*TILE_SIZE, y: door.hazardY*TILE_SIZE, data: {name: "Blocked Exit", type: "box"}, fixed: false });

    spawnEntity('runner'); spawnEntity('runner');

    const hazardList = pickRandomHazards(5);
    hazardList.forEach(rHazard => {
        const { tx, ty } = pickRandomFloorTile();
        GAME.activeIssues.push({ x: tx*TILE_SIZE, y: ty*TILE_SIZE, data: rHazard, fixed: false });
    });
    for(let i=0; i<8; i++) spawnEntity('ops');
    for(let i=0; i<10; i++) spawnEntity('assoc');
}

function spawnEntity(type) {
    let tx, ty;
    do { tx = Math.floor(Math.random()*(MAP_W-2))+1; ty = Math.floor(Math.random()*(MAP_H-2))+1; } while(GAME.map[ty][tx]!==0);
    GAME.entities.push({ type:type, x:tx*TILE_SIZE, y:ty*TILE_SIZE, dir:0, timer:0 });
}

function initSimonBoss() {
    GAME.state = 'BOSS_INTRO';
    AudioSys.sfx.bossIntro();
    GAME.boss = {
        name: "MEGA SIMON", sprite: "simonBoss", hp: 25, speed: 1.5, attackDelay: 30, 
        title: "THE WHS FINAL BOSS", desc: "He is not impressed.", attackName: "TERMINATION PROTOCOL",
        tauntsTriggered: [], tauntThresholds: [0.75, 0.5, 0.25], maxHp: 25,
        x: MAP_W * TILE_SIZE / 2, y: MAP_H * TILE_SIZE / 2, timer: 0 
    };
    GAME.entities = []; GAME.projectiles = [];
    updateMusicForState();
}

function initBossEncounter() {
    GAME.state = 'BOSS_INTRO';
    GAME.stateTimer = 0;
    GAME.pendingBossIntro = false;
    GAME.nextState = 'BOSS';
    AudioSys.sfx.bossIntro();
    const bossData = GAME.bossTypes[Math.floor(Math.random() * GAME.bossTypes.length)];
    GAME.boss = { ...bossData, x: MAP_W * TILE_SIZE / 2, y: MAP_H * TILE_SIZE / 2, w: 32, h: 32, maxHp: bossData.hp, timer: 0, tauntsTriggered: [], tauntThresholds: [0.75, 0.5, 0.25] };
    GAME.entities = []; GAME.projectiles = [];
    document.getElementById('boss-name-el').innerText = GAME.boss.name;
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function startYardLevel() {
    GAME.state = 'YARD_LEVEL';
    GAME.stateTimer = 0;
    const yardHeight = 650; // Yard section height
    const castleHeight = 700; // Castle section height (massive castle!)
    const h = yardHeight + castleHeight; // Total level height
    const castleStart = yardHeight; // Where castle begins (lower Y = higher on screen)
    GAME.yard = {
        height: h,
        yardHeight: yardHeight,
        castleStart: castleStart,
        cameraY: 0,
        playerX: canvas.width / 2 - 8,
        playerY: h - 32,
        startY: h - 32, // Remember starting position for reset
        speed: getCharStats(GAME.selectedChar).speed * 0.95,
        vehicles: [],
        forklifts: [], // Forklift hazards
        hazardZones: [], // Environmental hazard zones
        transformationTriggered: false, // Track if Mecha transformation cutscene started
        inCastle: false, // Track if player entered castle
        castleEntered: false, // Track if castle entry message shown
        // Jeff taunting system - now more dynamic
        jeffTaunt: JEFF_YARD_TAUNTS[Math.floor(Math.random() * JEFF_YARD_TAUNTS.length)],
        jeffTauntTimer: 0,
        jeffAnimFrame: 0, // Animation frame for Jeff
        progressTaunt: "", // Special taunt based on player progress
        // Extended vehicle lanes - more challenging gauntlet with varied patterns (in yard section only)
        lanes: [
            { y: h - 70, dir: 1, speed: 0.85, timer: 75, type: 'truck' },
            { y: h - 120, dir: -1, speed: 1.0, timer: 65, type: 'van' },
            { y: h - 170, dir: 1, speed: 1.1, timer: 55, type: 'mixed' },
            { y: h - 230, dir: -1, speed: 0.9, timer: 80, type: 'truck' },
            { y: h - 290, dir: 1, speed: 1.2, timer: 50, type: 'van' },
            { y: h - 350, dir: -1, speed: 1.0, timer: 60, type: 'mixed' },
            { y: h - 410, dir: 1, speed: 1.15, timer: 55, type: 'van' },
            { y: h - 470, dir: -1, speed: 0.95, timer: 70, type: 'truck' },
            { y: h - 530, dir: 1, speed: 1.25, timer: 45, type: 'van' },
            { y: h - 590, dir: -1, speed: 1.1, timer: 50, type: 'mixed' }
        ],
        // Forklift crossing zones
        forkliftZones: [
            { y: h - 200, timer: 180, active: false },
            { y: h - 380, timer: 240, active: false },
            { y: h - 520, timer: 200, active: false }
        ],
        // Static hazard areas (puddles, debris) - in yard section
        staticHazards: [
            { x: 30, y: h - 150, type: 'puddle' },
            { x: 180, y: h - 260, type: 'debris' },
            { x: 80, y: h - 440, type: 'puddle' },
            { x: 150, y: h - 550, type: 'debris' }
        ],
        // Castle section hazards
        castleDrones: [], // Patrol drones in castle
        castleLasers: [], // Laser barriers
        castleGuards: [], // Stationary guard turrets
        castlePlatforms: [ // Moving platforms player can use/avoid
            { x: 20, y: castleStart - 100, w: 40, dir: 1, speed: 0.8 },
            { x: 150, y: castleStart - 200, w: 50, dir: -1, speed: 1.0 },
            { x: 80, y: castleStart - 320, w: 45, dir: 1, speed: 0.9 },
            { x: 30, y: castleStart - 450, w: 55, dir: -1, speed: 1.1 },
            { x: 120, y: castleStart - 550, w: 40, dir: 1, speed: 1.2 }
        ],
        // Castle laser barriers that pulse on/off
        castleLaserBarriers: [
            { y: castleStart - 150, onTime: 60, offTime: 90, timer: 0, active: true },
            { y: castleStart - 280, onTime: 50, offTime: 80, timer: 30, active: false },
            { y: castleStart - 400, onTime: 70, offTime: 70, timer: 50, active: true },
            { y: castleStart - 520, onTime: 40, offTime: 100, timer: 20, active: false }
        ],
        // Castle patrol drones initialization
        droneSpawnTimer: 0
    };

    // Initialize castle guard turrets
    const y = GAME.yard;
    y.castleGuards = [
        { x: 10, y: castleStart - 180, fireTimer: 60, fireRate: 80 },
        { x: canvas.width - 26, y: castleStart - 250, fireTimer: 40, fireRate: 90 },
        { x: 10, y: castleStart - 350, fireTimer: 20, fireRate: 70 },
        { x: canvas.width - 26, y: castleStart - 480, fireTimer: 0, fireRate: 85 },
        { x: 10, y: castleStart - 600, fireTimer: 50, fireRate: 75 }
    ];

    GAME.player.speed = GAME.yard.speed;
    GAME.projectiles = [];
    GAME.particles = [];
    GAME.floatingTexts = [];
    updateMusicForState();

    // Show Simon's yard safety tip
    const safetyTip = SIMON_YARD_TIPS[Math.floor(Math.random() * SIMON_YARD_TIPS.length)];
    showDialog(safetyTip, "Simon Unglaube", GFX.simonFace, true);
    GAME.nextState = 'YARD_LEVEL';
}

function beginMechaEncounter() {
    GAME.state = 'MECHA_BOSS_INTRO';
    GAME.stateTimer = 0;
    // Completely redesigned Mecha Boss with multiple phases
    GAME.mecha = {
        hp: 48,
        maxHp: 48,
        x: canvas.width / 2 - 32,
        y: 18,
        baseY: 18,
        timer: 0,
        // Phase system: 0=Prime Missiles, 1=Drone Swarm, 2=Package Rain, 3=Laser Grid, 4=Ground Slam
        currentPhase: 0,
        phaseTimer: 0,
        phaseDuration: 280,
        phaseTransition: false,
        transitionTimer: 0,
        // Attack state
        attackCooldown: 0,
        projectiles: [],
        shadows: [],
        beam: null,
        beams: [], // Multiple beams for laser grid
        // Movement pattern
        moveDir: 1,
        moveTimer: 0,
        bobOffset: 0,
        // Enrage at low HP
        enraged: false,
        enrageFlash: 0,
        // Dash attack
        dashing: false,
        dashTarget: null,
        dashSpeed: 0,
        // Ground slam
        slamming: false,
        slamTimer: 0,
        slamY: 18,
        // Phase names for announcements
        phaseNames: ['PRIME STRIKE', 'DRONE SWARM', 'PACKAGE STORM', 'LASER GRID', 'GROUND SLAM'],
        phaseTaunts: [
            "PRIME DELIVERY INCOMING!",
            "RELEASE THE DRONES!",
            "BOXES FROM THE SKY!",
            "LASER PRECISION!",
            "FEEL THE EARTH SHAKE!"
        ]
    };
    GAME.player.x = canvas.width / 2 - 8;
    GAME.player.y = canvas.height - 28;
    GAME.boss = { name: 'MECHA JEFF', hp: 48, maxHp: 48 };
    document.getElementById('boss-name-el').innerText = 'MECHA JEFF';
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function startCredits() {
    GAME.state = 'CREDITS';
    GAME.stateTimer = 0;
    GAME.boss = null;
    document.getElementById('boss-hud').style.display = 'none';
    GAME.projectiles = [];
    GAME.particles = [];
    GAME.floatingTexts = [];
    updateMusicForState();
}

function queueVisitorSplash() {
    if (GAME.pendingBossIntro || GAME.boss) return;
    GAME.pendingBossIntro = true;
    GAME.nextState = 'VISITOR_SPLASH';
}

function showVisitorSplash() {
    GAME.state = 'VISITOR_SPLASH';
    GAME.stateTimer = 0;
    GAME.nextState = 'BOSS_INTRO';
    AudioSys.sfx.bossIntro();
    updateMusicForState();
}

function initMechaBezos() {
    GAME.state = 'BEZOS_INTRO';
    GAME.stateTimer = 0;
    AudioSys.sfx.bossIntro();

    GAME.boss = {
        name: "MECHA JEFF BEZOS",
        sprite: "mechaBezos",
        hp: 40,
        maxHp: 40,
        speed: 1.2,
        attackDelay: 50,
        title: "THE ULTIMATE BOSS",
        desc: "Automation has gone too far!",
        attackName: "AUTOMATION PROTOCOL",
        x: 104,
        y: 60,
        w: 48,
        h: 48,
        timer: 0,
        attackPhase: 0, // Tracks which attack pattern (0-2)
        laserAngle: 0, // For laser sweep attack
        droneSpawnTimer: 0,
        tauntsTriggered: [],
        tauntThresholds: [0.75, 0.5, 0.25]
    };

    GAME.player.x = 120;
    GAME.player.y = 180;
    GAME.entities = [];
    GAME.projectiles = [];
    GAME.froggerVehicles = [];

    document.getElementById('boss-name-el').innerText = "MECHA JEFF BEZOS";
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function updateMechaBezos() {
    const b = GAME.boss;
    if (!b) return;

    b.timer++;

    // Initialize new boss properties if not set
    if (!b.enraged) b.enraged = false;
    if (!b.tauntTimer) b.tauntTimer = 0;
    if (!b.fallingPackages) b.fallingPackages = [];
    if (!b.shockwaveTimer) b.shockwaveTimer = 0;
    if (!b.dashTarget) b.dashTarget = null;
    if (!b.dashCooldown) b.dashCooldown = 0;

    // === ENRAGE MODE when HP < 10 ===
    if (b.hp <= 10 && !b.enraged) {
        b.enraged = true;
        b.speed *= 1.5;
        GAME.flash = 15;
        GAME.shake = 20;
        spawnFloatingText(b.x + 24, b.y - 10, "ENRAGED!", "#ff0000");
        AudioSys.sfx.bossIntro();
    }

    // === FALLING PACKAGE HAZARDS ===
    if (b.timer % 90 === 0 && b.attackPhase >= 1) {
        // Spawn falling packages from top of screen
        for (let i = 0; i < (b.enraged ? 3 : 2); i++) {
            b.fallingPackages.push({
                x: Math.random() * 220 + 18,
                y: -20,
                vy: 2 + Math.random() * 1,
                w: 14,
                h: 14
            });
        }
    }

    // Update falling packages
    for (let i = b.fallingPackages.length - 1; i >= 0; i--) {
        const pkg = b.fallingPackages[i];
        pkg.y += pkg.vy;

        // Remove if off screen
        if (pkg.y > 240) {
            b.fallingPackages.splice(i, 1);
            continue;
        }

        // Check collision with player
        if (GAME.player.iframe === 0 &&
            GAME.player.x < pkg.x + pkg.w && GAME.player.x + 16 > pkg.x &&
            GAME.player.y < pkg.y + pkg.h && GAME.player.y + 16 > pkg.y) {
            GAME.lives--;
            GAME.player.iframe = 60;
            updateHud();
            AudioSys.sfx.hurt();
            GAME.shake = 6;
            b.fallingPackages.splice(i, 1);
            spawnFloatingText(GAME.player.x, GAME.player.y - 16, "PRIME DELIVERY!", "#ff9900");
            if (GAME.lives <= 0) {
                triggerGameOver("PRIME DELIVERED!");
            }
        }
    }

    // === BOSS DASH ATTACK (new mechanic) ===
    if (b.dashCooldown > 0) b.dashCooldown--;
    if (b.enraged && b.dashCooldown === 0 && b.timer % 180 === 0) {
        // Start dash attack
        b.dashTarget = { x: GAME.player.x, y: GAME.player.y };
        b.dashCooldown = 200;
        spawnFloatingText(b.x + 24, b.y - 16, "PRIME NOW!", "#ff4444");
        AudioSys.sfx.alert();
    }

    // Execute dash
    if (b.dashTarget) {
        const dx = b.dashTarget.x - b.x;
        const dy = b.dashTarget.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 10) {
            b.x += (dx / dist) * 5; // Fast dash speed
            b.y += (dy / dist) * 5;
        } else {
            b.dashTarget = null;
            // Shockwave on landing
            b.shockwaveTimer = 30;
            GAME.shake = 10;
            // Spawn ring of projectiles
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                GAME.projectiles.push({
                    type: 'bezos_missile',
                    x: b.x + 24,
                    y: b.y + 24,
                    vx: Math.cos(angle) * 2.5,
                    vy: Math.sin(angle) * 2.5,
                    life: 80,
                    boss: true
                });
            }
        }
    } else {
        // Normal movement toward player
        const dx = GAME.player.x - b.x;
        const dy = GAME.player.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 60) {
            b.x += (dx / dist) * b.speed;
            b.y += (dy / dist) * b.speed;
        }
    }

    // === TAUNT MECHANIC ===
    b.tauntTimer++;
    if (b.tauntTimer > 300 && !b.taunting) {
        b.taunting = true;
        const taunts = [
            "YOUR METRICS ARE UNACCEPTABLE!",
            "TWO-DAY SHIPPING... FOR YOUR DOOM!",
            "PRIME DIRECTIVE: ELIMINATE!",
            "CUSTOMER OBSESSION... WITH DESTRUCTION!",
            "BEZOS PROTOCOL ENGAGED!"
        ];
        const taunt = taunts[Math.floor(Math.random() * taunts.length)];
        spawnFloatingText(b.x + 24, b.y - 20, taunt.substring(0, 20), "#ff9900");
        b.tauntTimer = 0;
        setTimeout(() => { if (b) b.taunting = false; }, 1000);
    }

    // Switch attack phases based on HP
    if (b.hp > 26) b.attackPhase = 0; // Phase 1: Missile Spread
    else if (b.hp > 13) b.attackPhase = 1; // Phase 2: Laser Sweep
    else b.attackPhase = 2; // Phase 3: Drone Swarm

    // === ATTACK PHASE 1: PRIME MISSILE SPREAD ===
    const attackDelay = b.enraged ? Math.floor(b.attackDelay * 0.7) : b.attackDelay;
    if (b.attackPhase === 0 && b.timer % attackDelay === 0) {
        // Fire missiles in a spread pattern
        const missileCount = b.enraged ? 12 : 8;
        for (let i = 0; i < missileCount; i++) {
            const angle = (i / missileCount) * Math.PI * 2;
            const vx = Math.cos(angle) * 3;
            const vy = Math.sin(angle) * 3;
            GAME.projectiles.push({
                type: 'bezos_missile',
                x: b.x + 24,
                y: b.y + 24,
                vx: vx,
                vy: vy,
                life: 120,
                boss: true
            });
        }
        AudioSys.sfx.throw();
    }

    // === ATTACK PHASE 2: LASER SWEEP ===
    if (b.attackPhase === 1) {
        const laserSpeed = b.enraged ? 0.08 : 0.05;
        b.laserAngle += laserSpeed;
        // Fire laser beam every few frames
        const laserRate = b.enraged ? 5 : 8;
        if (b.timer % laserRate === 0) {
            const vx = Math.cos(b.laserAngle) * 4;
            const vy = Math.sin(b.laserAngle) * 4;
            GAME.projectiles.push({
                type: 'bezos_laser',
                x: b.x + 24,
                y: b.y + 24,
                vx: vx,
                vy: vy,
                life: 40,
                boss: true
            });
            if (b.timer % 16 === 0) AudioSys.sfx.alert();
        }
    }

    // === ATTACK PHASE 3: DRONE SWARM ===
    if (b.attackPhase === 2) {
        b.droneSpawnTimer++;
        const droneRate = b.enraged ? 35 : 50;
        if (b.droneSpawnTimer > droneRate) {
            b.droneSpawnTimer = 0;
            // Spawn a drone that homes in on player
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 100;
            GAME.entities.push({
                type: 'drone',
                x: b.x + 24 + Math.cos(angle) * spawnDist,
                y: b.y + 24 + Math.sin(angle) * spawnDist,
                w: 16,
                h: 16,
                speed: b.enraged ? 2.0 : 1.5,
                hp: 2
            });
            AudioSys.sfx.pop();
        }

        // Update drones - they home in on player
        GAME.entities.forEach(drone => {
            if (drone.type === 'drone') {
                const dx = GAME.player.x - drone.x;
                const dy = GAME.player.y - drone.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    drone.x += (dx / dist) * drone.speed;
                    drone.y += (dy / dist) * drone.speed;
                }

                // Drone collision with player
                if (GAME.player.iframe === 0 && Math.hypot(drone.x - GAME.player.x, drone.y - GAME.player.y) < 14) {
                    GAME.lives--;
                    GAME.player.iframe = 60;
                    updateHud();
                    AudioSys.sfx.hurt();
                    GAME.shake = 8;
                    drone.hp = 0; // Destroy drone on impact

                    if (GAME.lives <= 0) {
                        triggerGameOver("AUTOMATED OUT OF EXISTENCE!");
                    }
                }
            }
        });

        // Player can destroy drones
        for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
            const proj = GAME.projectiles[i];
            if (proj.type === 'attack') {
                for (let j = GAME.entities.length - 1; j >= 0; j--) {
                    const drone = GAME.entities[j];
                    if (drone.type === 'drone' && Math.hypot(proj.x - drone.x, proj.y - drone.y) < 12) {
                        drone.hp--;
                        if (drone.hp <= 0) {
                            GAME.entities.splice(j, 1);
                            AudioSys.sfx.hit();
                        }
                        GAME.projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }
    }

    // Check player projectiles hitting boss
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const proj = GAME.projectiles[i];
        if (proj.type === 'attack' &&
            proj.x >= b.x && proj.x <= b.x + b.w &&
            proj.y >= b.y && proj.y <= b.y + b.h) {
            b.hp--;
            updateBossHud();
            AudioSys.sfx.bossHit();
            GAME.shake = 5;
            GAME.projectiles.splice(i, 1);
            spawnParticle(proj.x, proj.y, '#ff9900', 5);

            if (b.hp <= 0) {
                winBezosLevel();
            }
        }
    }

    // Check boss projectiles hitting player
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const proj = GAME.projectiles[i];
        if ((proj.type === 'bezos_missile' || proj.type === 'bezos_laser') && GAME.player.iframe === 0) {
            if (Math.hypot(proj.x - GAME.player.x, proj.y - GAME.player.y) < 16) {
                GAME.lives--;
                GAME.player.iframe = 60;
                updateHud();
                AudioSys.sfx.hurt();
                GAME.shake = 8;
                GAME.projectiles.splice(i, 1);

                if (GAME.lives <= 0) {
                    triggerGameOver("AUTOMATED OUT OF EXISTENCE!");
                }
            }
        }
    }
}

function winBezosLevel() {
    GAME.state = 'BEZOS_WIN';
    GAME.stateTimer = 0;
    GAME.boss = null;
    document.getElementById('boss-hud').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';
    AudioSys.sfx.start();
    MusicSys.play('victory');
}

// === WAREHOUSE ATMOSPHERE UPDATE ===
function updateWarehouseAtmosphere() {
    // Update moving packages on conveyors
    GAME.packages.forEach(pkg => {
        pkg.x += pkg.speed;
        // Wrap around when off screen
        if (pkg.speed > 0 && pkg.x > 54 * TILE_SIZE) {
            pkg.x = 6 * TILE_SIZE;
        } else if (pkg.speed < 0 && pkg.x < 6 * TILE_SIZE) {
            pkg.x = 54 * TILE_SIZE;
        }
    });

    // Update cart workers
    GAME.cartWorkers.forEach(worker => {
        if (worker.pauseTimer > 0) {
            worker.pauseTimer--;
            return;
        }

        worker.x += worker.dir * worker.speed;

        // Randomly pause to simulate work
        if (Math.random() < 0.002) {
            worker.pauseTimer = 60 + Math.random() * 60; // 1-2 second pause
        }

        // Turn around at edges
        if (worker.dir > 0 && worker.x > 50 * TILE_SIZE) {
            worker.dir = -1;
            worker.pauseTimer = 30; // Brief pause when turning
        } else if (worker.dir < 0 && worker.x < 8 * TILE_SIZE) {
            worker.dir = 1;
            worker.pauseTimer = 30;
        }
    });
}

// === YARD LEVEL POWER-UP AND COLLECTIBLE UPDATE ===
function updateYardPowerUps() {
    const p = GAME.player;

    // Update power-up timer
    if (GAME.playerPowerUp) {
        GAME.powerUpTimer--;
        if (GAME.powerUpTimer <= 0) {
            // Remove power-up effects
            if (GAME.playerPowerUp === 'speed') {
                p.speed = getCharStats(GAME.selectedChar).speed * 0.9;
            }
            GAME.playerPowerUp = null;
        }
    }

    // Check power-up collection
    for (let i = GAME.powerUps.length - 1; i >= 0; i--) {
        const pu = GAME.powerUps[i];
        if (Math.hypot(pu.x - p.x, pu.y - p.y) < 16) {
            AudioSys.sfx.fix();
            GAME.powerUps.splice(i, 1);

            if (pu.type === 'speed') {
                GAME.playerPowerUp = 'speed';
                GAME.powerUpTimer = 300; // 5 seconds
                p.speed = getCharStats(GAME.selectedChar).speed * 1.5;
                spawnFloatingText(p.x, p.y - 16, "SPEED BOOST!", "#22d3ee");
            } else if (pu.type === 'shield') {
                GAME.playerPowerUp = 'shield';
                GAME.powerUpTimer = 180; // 3 seconds
                p.iframe = 180; // Temporary invincibility
                spawnFloatingText(p.x, p.y - 16, "SHIELD!", "#a855f7");
            } else if (pu.type === 'life') {
                GAME.lives = Math.min(GAME.lives + 1, 5);
                updateHud();
                spawnFloatingText(p.x, p.y - 16, "+1 LIFE!", "#f87171");
            }
        }
    }

    // Check collectible package collection
    for (let i = GAME.collectibles.length - 1; i >= 0; i--) {
        const col = GAME.collectibles[i];
        if (Math.hypot(col.x - p.x, col.y - p.y) < 16) {
            AudioSys.sfx.pop();
            GAME.collectibles.splice(i, 1);
            GAME.score += 100;
            spawnFloatingText(col.x, col.y - 10, "+100", "#ffd700");
        }
    }

    // Update forklifts
    GAME.forklifts.forEach(fl => {
        fl.x += fl.speed;
        if (fl.speed > 0 && fl.x > 256) fl.x = -fl.w;
        if (fl.speed < 0 && fl.x < -fl.w) fl.x = 256;

        // Check collision with player
        if (p.iframe === 0 &&
            p.x < fl.x + fl.w && p.x + 16 > fl.x &&
            p.y < fl.y + fl.h && p.y + 16 > fl.y) {
            p.iframe = 90;
            GAME.lives--;
            updateHud();
            AudioSys.sfx.hurt();
            GAME.shake = 15;
            GAME.flash = 12;
            p.x = 128;
            p.y = 200;
            spawnFloatingText(p.x, p.y - 20, "FORKLIFT!", "#fbbf24");
            if (GAME.lives <= 0) {
                triggerGameOver("RUN OVER BY FORKLIFT!");
            }
        }
    });
}

function update() {
    GAME.ticks++;
    GAME.stateTimer++;
    if (GAME.shake > 0) GAME.shake--;
    if (GAME.flash > 0) GAME.flash--;

    if (GAME.state === 'LOSE_SPLASH' || GAME.state === 'WIN_SPLASH') {
        GAME.splashTimer--;
        const ready = GAME.aiResultText !== null;
        const waitedEnough = GAME.splashTimer <= 0;
        const fallbackTimer = -600;

        if (ready && waitedEnough) {
            const isWin = GAME.state === 'WIN_SPLASH';
            const speaker = isWin ? "Simon Unglaube" : "Simon Unglaube";
            let finalText = GAME.aiResultText.replace(/\[.*?\]/g, GAME.selectedChar);
            let header = isWin ? `OUTSTANDING!\n"${finalText}"\n` : `AUDIT FAILED\n"${finalText}"\n`;
            let stats = `\nStats:\nTime Spent: ${Math.floor((Date.now() - GAME.startTime)/1000)}s\nSafety Rules used: ${GAME.booksFired}\nOPS pushed back: ${GAME.opsPushed}\n(Press Space)`;
            showDialog(header + stats, speaker, GFX.simonFace, true);
            GAME.state = 'DIALOG'; GAME.nextState = 'TITLE';
        } else if (!ready && GAME.splashTimer <= fallbackTimer) {
            GAME.aiResultText = 'System could not load live review. Using cached performance log.';
        }
        return;
    }

    if (GAME.state === 'LOGO' && GAME.stateTimer > 240) advanceState();
    
    if (GAME.state === 'SELECT') {
        let changed = false;
        if (KEYS.left && GAME.ticks % 10 === 0) { GAME.charIndex--; AudioSys.sfx.step(); changed = true; }
        if (KEYS.right && GAME.ticks % 10 === 0) { GAME.charIndex++; AudioSys.sfx.step(); changed = true; }
        if (changed) {
            if (GAME.charIndex < 0) GAME.charIndex = GAME.charList.length - 1;
            if (GAME.charIndex >= GAME.charList.length) GAME.charIndex = 0;
            TTSSys.speak(GAME.charList[GAME.charIndex], "System");
        }
        return;
    }

    if (GAME.state === 'DIALOG') {
        if (GAME.dialogVisible.length < GAME.dialogText.length) {
            if (GAME.ticks % 2 === 0) {
                GAME.dialogVisible += GAME.dialogText[GAME.dialogVisible.length];
                document.getElementById('text-content').innerText = GAME.dialogVisible;
                AudioSys.sfx.text();
            }
        }
        return;
    }

    if (['LOGO', 'INTRO', 'STORY', 'TITLE', 'HOWTO', 'BOSS_INTRO', 'VISITOR_SPLASH', 'BEZOS_INTRO', 'MECHA_TRANSFORM'].includes(GAME.state)) return;

    // Bezos victory screen
    if (GAME.state === 'BEZOS_WIN') {
        // Auto-advance after delay
        if (GAME.stateTimer > 300) {
            GAME.state = 'TITLE';
            updateMusicForState();
        }
        return;
    }

    if (GAME.state === 'PLAY' || GAME.state === 'BOSS' || GAME.state === 'BEZOS_BOSS') {
        updatePlayer(); updateProjectiles(); updateParticles(); updateFloatingTexts();
        updateCamera();
    }

    if (GAME.state === 'PLAY') {
        updateEntities();
        updateWarehouseAtmosphere(); // Update warehouse atmosphere (packages, kivas, cart workers)
    }
    if (GAME.state === 'BOSS') updateBoss();
    if (GAME.state === 'BEZOS_BOSS') updateMechaBezos();

    // Yard level and Mecha boss updates
    if (GAME.state === 'YARD_LEVEL') updateYardLevel();
    if (GAME.state === 'MECHA_BOSS') updateMechaBattle();
}

function updatePlayer() {
    const p = GAME.player;
    if (p.iframe>0) p.iframe--; if (p.cooldown>0) p.cooldown--;
    let dx=0, dy=0;
    if (KEYS.up) dy = -p.speed; if (KEYS.down) dy = p.speed; if (KEYS.left) dx = -p.speed; if (KEYS.right) dx = p.speed;
    if (dx!==0 && dy!==0) { dx *= 0.707; dy *= 0.707; }
    if (dx!==0 || dy!==0) {
        // In Bezos boss mode, no collision detection with walls
        if (GAME.state === 'BEZOS_BOSS') {
            p.x = Math.max(0, Math.min(240, p.x + dx));
            p.y = Math.max(0, Math.min(208, p.y + dy));
        } else {
            if (!checkCol(p.x+dx, p.y)) p.x+=dx;
            if (!checkCol(p.x, p.y+dy)) p.y+=dy;
        }
        if (GAME.ticks % 20 === 0) { AudioSys.sfx.step(); spawnParticle(p.x+8, p.y+16, '#555', 0); }
    }
}

function updateYardLevel() {
    if (!GAME.yard) return;
    const y = GAME.yard;
    GAME.player.x = y.playerX; GAME.player.y = y.playerY;

    // Check if player is in castle section
    const inCastle = y.playerY < y.castleStart;
    if (inCastle && !y.inCastle) {
        y.inCastle = true;
        if (!y.castleEntered) {
            y.castleEntered = true;
            spawnFloatingText(y.playerX, y.playerY - 30, "ENTERING BEZOS CASTLE!", "#ff9900");
            AudioSys.sfx.bossIntro();
        }
    }

    // Update Jeff taunt at top - now with progress-based taunts
    y.jeffTauntTimer++;
    y.jeffAnimFrame++;

    // Progress-based dynamic taunts (use castle taunts when in castle)
    const progress = 1 - (y.playerY / y.height);
    if (progress > 0.9 && !y.nearTauntShown) {
        y.nearTauntShown = true;
        y.jeffTaunt = "YOU'RE AT MY THRONE ROOM! PREPARE FOR TRANSFORMATION!";
        AudioSys.sfx.alert();
    } else if (progress > 0.7 && !y.almostTauntShown) {
        y.almostTauntShown = true;
        y.jeffTaunt = "THE TOP OF MY CASTLE AWAITS... IF YOU SURVIVE!";
        AudioSys.sfx.alert();
    } else if (progress > 0.5 && !y.halfwayTauntShown) {
        y.halfwayTauntShown = true;
        y.jeffTaunt = "WELCOME TO MY FORTRESS! YOU WON'T LEAVE ALIVE!";
        AudioSys.sfx.pop();
    } else if (y.jeffTauntTimer > 100) { // Regular taunt rotation
        // Use castle taunts when in castle, yard taunts otherwise
        const taunts = y.inCastle ? JEFF_CASTLE_TAUNTS : JEFF_YARD_TAUNTS;
        y.jeffTaunt = taunts[Math.floor(Math.random() * taunts.length)];
        y.jeffTauntTimer = 0;
        AudioSys.sfx.pop();
    }

    let dx = 0, dy = 0;
    if (KEYS.up) dy = -y.speed; if (KEYS.down) dy = y.speed; if (KEYS.left) dx = -y.speed; if (KEYS.right) dx = y.speed;
    if (dx!==0 && dy!==0) { dx *= 0.707; dy *= 0.707; }

    // Check for static hazard slowdown (puddles slow you down) - only in yard section
    let inHazard = false;
    if (y.staticHazards && !y.inCastle) {
        y.staticHazards.forEach(h => {
            if (Math.abs(y.playerX - h.x) < 20 && Math.abs(y.playerY - h.y) < 20) {
                if (h.type === 'puddle') {
                    dx *= 0.5; dy *= 0.5; // Slow down in puddles
                    inHazard = true;
                }
            }
        });
    }

    y.playerX = Math.max(0, Math.min(canvas.width - 16, y.playerX + dx));
    y.playerY = Math.max(10, Math.min(y.height - 22, y.playerY + dy));
    GAME.player.x = y.playerX; GAME.player.y = y.playerY;

    const viewAnchor = y.playerY - canvas.height * 0.55;
    y.cameraY = Math.max(0, Math.min(y.height - canvas.height, viewAnchor));

    // === YARD SECTION UPDATES (only when in yard) ===
    if (!y.inCastle) {
        // Spawn vehicles in lanes with varied types
        y.lanes.forEach(lane => {
            lane.timer--;
            if (lane.timer <= 0) {
                let type;
                if (lane.type === 'truck') type = 'truck';
                else if (lane.type === 'van') type = 'van';
                else type = Math.random() < 0.55 ? 'van' : 'truck';

                const w = type === 'van' ? 34 : 52;
                const h = type === 'van' ? 16 : 20;
                const x = lane.dir === 1 ? -w : canvas.width + w;
                y.vehicles.push({ type, x, y: lane.y - h/2, w, h, dir: lane.dir, speed: lane.speed + Math.random()*0.25 });
                lane.timer = 50 + Math.random() * 60;
            }
        });

        // Update forklift zones
        if (y.forkliftZones) {
            y.forkliftZones.forEach(zone => {
                zone.timer--;
                if (zone.timer <= 0) {
                    zone.active = !zone.active;
                    zone.timer = zone.active ? 60 : (150 + Math.random() * 100);
                    if (zone.active && Math.abs(y.playerY - zone.y) < 100) {
                        // Spawn a forklift
                        const dir = Math.random() < 0.5 ? 1 : -1;
                        y.forklifts.push({
                            x: dir === 1 ? -30 : canvas.width + 30,
                            y: zone.y - 10,
                            dir: dir,
                            speed: 1.5 + Math.random() * 0.5,
                            w: 28, h: 20
                        });
                        AudioSys.sfx.alert();
                    }
                }
            });
        }
    }

    // Update forklifts (can still be on screen when transitioning)
    for (let i = y.forklifts.length - 1; i >= 0; i--) {
        const f = y.forklifts[i];
        f.x += f.dir * f.speed;
        if (f.x < -60 || f.x > canvas.width + 60) { y.forklifts.splice(i, 1); continue; }
        // Forklift collision
        if (Math.abs((f.x + f.w/2) - (y.playerX + 8)) < (f.w/2 + 4) && Math.abs((f.y + f.h/2) - (y.playerY + 8)) < (f.h/2 + 4)) {
            if (GAME.player.iframe <= 0) {
                GAME.lives--; GAME.flash = 15; GAME.shake = 20; AudioSys.sfx.hurt(); updateHud();
                // Teleport to start - no iframe needed since player is repositioned
                y.playerX = canvas.width / 2 - 8;
                y.playerY = y.startY;
                y.inCastle = false;
                y.cameraY = Math.max(0, y.height - canvas.height);
                spawnFloatingText(y.playerX, y.playerY - 20, "FORKLIFT! NO PEDESTRIANS!", "#ff4444");
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('FORKLIFT INCIDENT!'); return; }
            }
        }
    }

    // Vehicle collision - FULL RESET to starting position
    for (let i = y.vehicles.length - 1; i >= 0; i--) {
        const v = y.vehicles[i];
        v.x += v.dir * v.speed;
        if (v.x < -80 || v.x > canvas.width + 80) { y.vehicles.splice(i,1); continue; }
        if (Math.abs((v.x + v.w/2) - (y.playerX + 8)) < (v.w/2 + 5) && Math.abs((v.y + v.h/2) - (y.playerY + 8)) < (v.h/2 + 5)) {
            if (GAME.player.iframe <= 0) {
                GAME.lives--; GAME.flash = 12; GAME.shake = 15; AudioSys.sfx.hurt(); updateHud();
                // FULL RESET - player goes back to starting position, no iframe since teleporting
                y.playerX = canvas.width / 2 - 8;
                y.playerY = y.startY;
                y.inCastle = false;
                y.cameraY = Math.max(0, y.height - canvas.height);
                spawnFloatingText(y.playerX, y.playerY - 20, "WATCH THE TRAFFIC!", "#ff4444");
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('FLATTENED BY LOGISTICS!'); return; }
            }
        }
    }

    // === CASTLE SECTION UPDATES ===
    if (y.inCastle) {
        // Update castle moving platforms
        if (y.castlePlatforms) {
            y.castlePlatforms.forEach(p => {
                p.x += p.dir * p.speed;
                if (p.x <= 0 || p.x + p.w >= canvas.width) {
                    p.dir *= -1;
                }
            });
        }

        // Update castle laser barriers
        if (y.castleLaserBarriers) {
            y.castleLaserBarriers.forEach(barrier => {
                barrier.timer++;
                if (barrier.active && barrier.timer >= barrier.onTime) {
                    barrier.active = false;
                    barrier.timer = 0;
                } else if (!barrier.active && barrier.timer >= barrier.offTime) {
                    barrier.active = true;
                    barrier.timer = 0;
                    AudioSys.sfx.alert();
                }

                // Collision with active laser barrier
                if (barrier.active && Math.abs(y.playerY - barrier.y) < 8 && GAME.player.iframe <= 0) {
                    GAME.lives--; GAME.flash = 15; GAME.shake = 12; AudioSys.sfx.hurt(); updateHud();
                    GAME.player.iframe = 60;
                    spawnFloatingText(y.playerX, y.playerY - 20, "LASER BARRIER!", "#ff4444");
                    if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('VAPORIZED BY SECURITY!'); return; }
                }
            });
        }

        // Update castle guard turrets and their projectiles
        if (y.castleGuards) {
            y.castleGuards.forEach(guard => {
                guard.fireTimer++;
                // Only fire if player is within vertical range
                if (guard.fireTimer >= guard.fireRate && Math.abs(y.playerY - guard.y) < 150) {
                    guard.fireTimer = 0;
                    // Fire projectile toward player
                    const dirX = guard.x < canvas.width / 2 ? 1 : -1;
                    if (!y.castleProjectiles) y.castleProjectiles = [];
                    y.castleProjectiles.push({
                        x: guard.x + 8,
                        y: guard.y + 6,
                        vx: dirX * 2.5,
                        vy: 0,
                        life: 120
                    });
                    AudioSys.sfx.throw();
                }
            });
        }

        // Update castle projectiles
        if (y.castleProjectiles) {
            for (let i = y.castleProjectiles.length - 1; i >= 0; i--) {
                const proj = y.castleProjectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.life--;

                if (proj.life <= 0 || proj.x < -20 || proj.x > canvas.width + 20) {
                    y.castleProjectiles.splice(i, 1);
                    continue;
                }

                // Collision with player
                if (Math.abs(proj.x - (y.playerX + 8)) < 12 && Math.abs(proj.y - (y.playerY + 8)) < 12) {
                    if (GAME.player.iframe <= 0) {
                        GAME.lives--; GAME.flash = 10; GAME.shake = 8; AudioSys.sfx.hurt(); updateHud();
                        GAME.player.iframe = 60;
                        y.castleProjectiles.splice(i, 1);
                        spawnFloatingText(y.playerX, y.playerY - 20, "GUARD TURRET!", "#ff4444");
                        if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('TERMINATED BY SECURITY!'); return; }
                    }
                }
            }
        }

        // Spawn patrol drones periodically
        y.droneSpawnTimer++;
        if (y.droneSpawnTimer > 180 && y.castleDrones.length < 3) {
            y.droneSpawnTimer = 0;
            const droneY = y.castleStart - 100 - Math.random() * 500;
            if (droneY > 80) { // Don't spawn too close to Jeff
                y.castleDrones.push({
                    x: Math.random() < 0.5 ? -20 : canvas.width + 20,
                    y: droneY,
                    dir: Math.random() < 0.5 ? 1 : -1,
                    speed: 1.2 + Math.random() * 0.5,
                    pulseTimer: 0
                });
            }
        }

        // Update patrol drones
        for (let i = y.castleDrones.length - 1; i >= 0; i--) {
            const drone = y.castleDrones[i];
            drone.x += drone.dir * drone.speed;
            drone.pulseTimer++;

            // Slight homing toward player Y
            if (Math.abs(drone.y - y.playerY) > 30) {
                drone.y += (y.playerY > drone.y ? 0.3 : -0.3);
            }

            // Remove if off screen
            if ((drone.dir === 1 && drone.x > canvas.width + 40) || (drone.dir === -1 && drone.x < -40)) {
                y.castleDrones.splice(i, 1);
                continue;
            }

            // Collision with player
            if (Math.abs(drone.x - (y.playerX + 8)) < 14 && Math.abs(drone.y - (y.playerY + 8)) < 14) {
                if (GAME.player.iframe <= 0) {
                    GAME.lives--; GAME.flash = 12; GAME.shake = 10; AudioSys.sfx.hurt(); updateHud();
                    GAME.player.iframe = 60;
                    y.castleDrones.splice(i, 1);
                    spawnFloatingText(y.playerX, y.playerY - 20, "PATROL DRONE!", "#22d3ee");
                    if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('DRONE STRIKE!'); return; }
                }
            }
        }

    }

    // Trigger THRONE CONFRONTATION CUTSCENE when player gets close to Jeff on throne
    if (y.playerY <= 80 && !y.transformationTriggered) {
        y.transformationTriggered = true;
        GAME.state = 'THRONE_CONFRONTATION';
        GAME.stateTimer = 0;
        GAME.throneScene = {
            phase: 0, // 0=zoom in, 1=dialogue, 2=transformation
            dialogueIndex: 0,
            dialogues: [
                { speaker: 'BEZOS', text: "SO... YOU MADE IT THROUGH MY GAUNTLET.", color: '#ff9900' },
                { speaker: 'BEZOS', text: "IMPRESSIVE. BUT FUTILE.", color: '#ff9900' },
                { speaker: 'PLAYER', text: "YOUR REIGN OF TERROR ENDS HERE, BEZOS!", color: '#38bdf8' },
                { speaker: 'BEZOS', text: "YOU THINK YOU CAN STOP ME?", color: '#ff9900' },
                { speaker: 'BEZOS', text: "I AM THE PRIME! THE ALPHA! THE OMEGA!", color: '#dc2626' },
                { speaker: 'BEZOS', text: "WITNESS MY TRUE FORM!", color: '#dc2626' }
            ],
            dialogueTimer: 0
        };
        AudioSys.sfx.bossIntro();
        return;
    }
}

function updateMechaBattle() {
    const m = GAME.mecha; if (!m) return;
    const p = GAME.player;
    if (p.iframe>0) p.iframe--; if (p.cooldown>0) p.cooldown--;

    // Player movement
    let dx = 0, dy = 0;
    if (KEYS.up) dy = -p.speed; if (KEYS.down) dy = p.speed; if (KEYS.left) dx = -p.speed; if (KEYS.right) dx = p.speed;
    if (dx!==0 && dy!==0) { dx *= 0.707; dy *= 0.707; }
    p.x = Math.max(4, Math.min(canvas.width - 20, p.x + dx));
    p.y = Math.max(40, Math.min(canvas.height - 20, p.y + dy));

    m.timer++;
    m.bobOffset = Math.sin(m.timer * 0.05) * 3;
    if (m.attackCooldown > 0) m.attackCooldown--;

    // Enrage mode at low HP
    if (m.hp <= 12 && !m.enraged) {
        m.enraged = true;
        m.phaseDuration = 200; // Faster phases
        GAME.shake = 20;
        spawnFloatingText(m.x + 32, m.y, "ENRAGED!", "#ff0000");
        AudioSys.sfx.bossIntro();
    }
    if (m.enraged) m.enrageFlash = (m.enrageFlash + 1) % 20;

    // Phase transition handling
    if (m.phaseTransition) {
        m.transitionTimer++;
        if (m.transitionTimer >= 60) {
            m.phaseTransition = false;
            m.transitionTimer = 0;
            m.phaseTimer = 0;
            // Announce new phase with attack warning
            const phaseWarnings = {
                0: { text: "MISSILES!", color: "#dc2626" },
                1: { text: "DRONES!", color: "#22d3ee" },
                2: { text: "PRIME DROP!", color: "#f59e0b" },
                3: { text: "LASER GRID!", color: "#38bdf8" },
                4: { text: "GROUND SLAM!", color: "#a855f7" }
            };
            const warning = phaseWarnings[m.currentPhase];
            spawnFloatingText(canvas.width / 2 - 40, 60, warning.text, warning.color);
        }
        return; // Pause attacks during transition
    }

    m.phaseTimer++;

    // Boss movement - sway side to side
    m.moveTimer++;
    if (m.moveTimer > 60) {
        m.moveTimer = 0;
        m.moveDir *= -1;
    }
    if (!m.slamming && !m.dashing) {
        const targetX = canvas.width / 2 - 32 + m.moveDir * 60;
        m.x += (targetX - m.x) * 0.02;
        m.y = m.baseY + m.bobOffset;
    }

    // Phase-specific attack patterns
    const attackRate = m.enraged ? 0.7 : 1.0;

    // Initialize attack announcement tracking
    if (!m.lastAnnounce) m.lastAnnounce = { phase: -1, timer: 0 };

    // PHASE 0: Prime Missiles - Homing missiles from shoulders
    if (m.currentPhase === 0) {
        if (m.timer % Math.floor(70 * attackRate) === 0 && m.attackCooldown <= 0) {
            const angle = Math.atan2(p.y - m.y, p.x - m.x);
            for (let i = -1; i <= 1; i += 2) {
                m.projectiles.push({
                    type: 'missile',
                    x: m.x + 32 + i * 24,
                    y: m.y + 20,
                    vx: Math.cos(angle + i * 0.3) * 1.5,
                    vy: Math.sin(angle + i * 0.3) * 1.5,
                    life: 180,
                    trail: []
                });
            }
            AudioSys.sfx.throw();
        }
    }

    // PHASE 1: Drone Swarm - Multiple homing drones
    if (m.currentPhase === 1) {
        const activeDrones = m.projectiles.filter(pr => pr.type === 'drone').length;
        if (m.timer % Math.floor(50 * attackRate) === 0 && activeDrones < (m.enraged ? 5 : 3)) {
            m.projectiles.push({
                type: 'drone',
                x: m.x + 32 + (Math.random() - 0.5) * 40,
                y: m.y + 24,
                vx: 0, vy: 0.3,
                life: 400,
                pulseTimer: 0
            });
            AudioSys.sfx.pop();
        }
    }

    // PHASE 2: Package Rain - Boxes rain from above with shadows
    if (m.currentPhase === 2) {
        if (m.timer % Math.floor(35 * attackRate) === 0) {
            const targetX = p.x + (Math.random() - 0.5) * 80;
            m.shadows.push({ x: Math.max(10, Math.min(canvas.width - 30, targetX)), timer: 45 });
        }
    }

    // PHASE 3: Laser Grid - Multiple sweeping beams
    if (m.currentPhase === 3) {
        if (m.timer % Math.floor(100 * attackRate) === 0 && m.beams.length < 3) {
            const beamCount = m.enraged ? 3 : 2;
            for (let i = 0; i < beamCount; i++) {
                m.beams.push({
                    x: (canvas.width / (beamCount + 1)) * (i + 1) - 7,
                    telegraph: 50,
                    active: 35,
                    sweepDir: i % 2 === 0 ? 1 : -1,
                    sweepSpeed: 0.8
                });
            }
            AudioSys.sfx.alert();
        }
    }

    // PHASE 4: Ground Slam - Boss slams down and creates shockwave
    if (m.currentPhase === 4) {
        if (!m.slamming && m.timer % Math.floor(120 * attackRate) === 0) {
            m.slamming = true;
            m.slamTimer = 0;
            m.slamY = m.y;
            AudioSys.sfx.alert();
        }

        if (m.slamming) {
            m.slamTimer++;
            if (m.slamTimer < 30) {
                // Wind up
                m.y = m.slamY - m.slamTimer * 0.5;
            } else if (m.slamTimer < 45) {
                // Slam down
                m.y = m.slamY - 15 + (m.slamTimer - 30) * 4;
                if (m.slamTimer === 44) {
                    GAME.shake = 25;
                    AudioSys.sfx.hurt();
                    // Create shockwave
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        m.projectiles.push({
                            type: 'shockwave',
                            x: m.x + 32,
                            y: canvas.height - 20,
                            vx: Math.cos(angle) * 2.5,
                            vy: Math.sin(angle) * 0.5 - 0.5,
                            life: 80
                        });
                    }
                }
            } else if (m.slamTimer < 80) {
                // Recovery
                m.y = m.baseY + 30 - (m.slamTimer - 45) * 0.85;
            } else {
                m.slamming = false;
                m.y = m.baseY;
            }
        }
    }

    // Phase cycling
    if (m.phaseTimer >= m.phaseDuration) {
        m.currentPhase = (m.currentPhase + 1) % 5;
        m.phaseTransition = true;
        m.shadows = [];
        m.beams = [];
        m.slamming = false;
    }

    // Update projectiles
    for (let i = m.projectiles.length - 1; i >= 0; i--) {
        const pr = m.projectiles[i];

        if (pr.type === 'missile') {
            // Slight homing
            const angle = Math.atan2(p.y - pr.y, p.x - pr.x);
            pr.vx = pr.vx * 0.95 + Math.cos(angle) * 0.08;
            pr.vy = pr.vy * 0.95 + Math.sin(angle) * 0.08;
            pr.trail.push({ x: pr.x, y: pr.y });
            if (pr.trail.length > 8) pr.trail.shift();
        } else if (pr.type === 'drone') {
            pr.pulseTimer = (pr.pulseTimer || 0) + 1;
            const angle = Math.atan2(p.y - pr.y, p.x - pr.x);
            const targetVx = Math.cos(angle) * 0.5;
            const targetVy = Math.sin(angle) * 0.5;
            pr.vx = pr.vx * 0.92 + targetVx * 0.08;
            pr.vy = pr.vy * 0.92 + targetVy * 0.08;
        } else if (pr.type === 'box') {
            pr.vy += 0.06;
            pr.rotation = (pr.rotation || 0) + 0.1;
        } else if (pr.type === 'shockwave') {
            pr.vy += 0.1; // Gravity
        }

        pr.x += pr.vx || 0;
        pr.y += pr.vy || 0;
        pr.life = (pr.life || 200) - 1;

        if (pr.y > canvas.height + 40 || pr.x < -40 || pr.x > canvas.width + 40 || pr.life <= 0) {
            m.projectiles.splice(i, 1);
            continue;
        }

        // Collision with player
        const hitW = pr.type === 'shockwave' ? 8 : 10;
        const hitH = pr.type === 'shockwave' ? 6 : 10;
        if (Math.abs((pr.x + hitW/2) - (p.x + 8)) < (hitW/2 + 6) && Math.abs((pr.y + hitH/2) - (p.y + 8)) < (hitH/2 + 6)) {
            if (p.iframe <= 0) {
                GAME.lives--;
                p.iframe = 90;
                GAME.flash = 10;
                GAME.shake = 8;
                AudioSys.sfx.hurt();
                updateHud();
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) {
                    triggerGameOver('OVERWHELMED BY MECHA JEFF!');
                    return;
                }
            }
            if (pr.type !== 'shockwave') m.projectiles.splice(i, 1);
        }
    }

    // Update shadows (package warning indicators)
    for (let i = m.shadows.length - 1; i >= 0; i--) {
        m.shadows[i].timer--;
        if (m.shadows[i].timer <= 0) {
            const x = m.shadows[i].x;
            m.projectiles.push({
                type: 'box',
                x, y: -16,
                vy: 1.8,
                vx: (Math.random() - 0.5) * 0.5,
                life: 200,
                rotation: 0
            });
            m.shadows.splice(i, 1);
            AudioSys.sfx.throw();
        }
    }

    // Update beams (laser grid)
    for (let i = m.beams.length - 1; i >= 0; i--) {
        const beam = m.beams[i];
        if (beam.telegraph > 0) {
            beam.telegraph--;
        } else if (beam.active > 0) {
            beam.active--;
            beam.x += beam.sweepDir * beam.sweepSpeed;
            // Collision
            if (p.x + 12 > beam.x && p.x < beam.x + 14 && p.iframe <= 0) {
                GAME.lives--;
                p.iframe = 90;
                GAME.flash = 12;
                AudioSys.sfx.hurt();
                updateHud();
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) {
                    triggerGameOver('VAPORIZED!');
                    return;
                }
            }
        } else {
            m.beams.splice(i, 1);
        }
    }

    // Player projectile hits on boss
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const a = GAME.projectiles[i];
        a.x += a.vx;
        a.y += a.vy;
        a.life--;
        if (a.x < -20 || a.x > canvas.width + 20 || a.y < -20 || a.y > canvas.height + 20 || a.life <= 0) {
            GAME.projectiles.splice(i, 1);
            continue;
        }
        // Hit detection on boss
        if (Math.abs((a.x + 6) - (m.x + 32)) < 36 && Math.abs((a.y + 6) - (m.y + 32)) < 36) {
            m.hp--;
            GAME.boss.hp = m.hp;
            updateBossHud();
            GAME.projectiles.splice(i, 1);
            AudioSys.sfx.bossHit();
            spawnFloatingText(m.x + 32, m.y + 12, 'HIT!', '#ff2e63');

            // Spawn hit particles
            for (let j = 0; j < 4; j++) {
                spawnParticle(m.x + 32 + (Math.random() - 0.5) * 20, m.y + 32 + (Math.random() - 0.5) * 20, '#ff9900', 1);
            }

            if (m.hp <= 0) {
                GAME.nextState = 'CREDITS';
                showDialog('Impressive. You actually crushed Evil Jeff Bezos. Audit notes: flawless. The warehouse is safe... for now.', 'Simon Unglaube', GFX.simonFace);
                return;
            }
        }
    }
}

// --- BANTER SYSTEM ---
function spawnFloatingText(x, y, text, color='#fff') {
    GAME.floatingTexts.push({
        x: x + 8, y: y, 
        text: text, color: color, 
        life: 210, vy: -0.2 // Slower, longer life (3.5s)
    });
    AudioSys.sfx.pop();
}

function triggerBanter(entity) {
    if (!entity || Math.random() > 0.8) return; // Don't trigger every time
    
    const now = Date.now();
    const useAI = (now - GAME.lastAIBanterTime > 15000) && (Math.random() < 0.3); // 30% chance if cooldown over
    const category = (entity.type === 'ops') ? 'banter_ops' : 'banter_assoc';
    
    if (useAI && apiKey) {
        GAME.lastAIBanterTime = now;
        let prompt = "";
        if (entity.type === 'ops') prompt = "Short, funny bark (max 3 words) from an Amazon Warehouse Ops Manager yelling about productivity.";
        else prompt = "Short, funny thought (max 3 words) from a tired Amazon Warehouse Associate.";

        // ASYNC CALL - DOES NOT BLOCK GAME
        callGemini(prompt, category).then(text => {
            // Check if entity still alive/relevant, otherwise just spawn near player or drop
            if (GAME.entities.includes(entity)) {
                 spawnFloatingText(entity.x, entity.y, text, (entity.type==='ops'?'#ffcc00':'#ccc'));
            }
        });
    } else {
        // Hardcoded fallback
        const text = getRandomFallback(category, category);
        spawnFloatingText(entity.x, entity.y, text, (entity.type==='ops'?'#ffcc00':'#ccc'));
    }
}

function updateEntities() {
    GAME.entities.forEach(e => {
        if (e.type === 'simon') return;
        
        // Banter Trigger (Random Chance)
        if (Math.random() < 0.002) triggerBanter(e); // Low chance per tick

        if (e.type === 'ops') {
            let d = Math.hypot(GAME.player.x - e.x, GAME.player.y - e.y);
            if (d < 100) {
                if (GAME.player.x > e.x) e.x += 0.4; else e.x -= 0.4;
                if (GAME.player.y > e.y) e.y += 0.4; else e.y -= 0.4;
            }
            if (d < 80 && Math.random() < 0.01) {
                let angle = Math.atan2(GAME.player.y - e.y, GAME.player.x - e.x);
                GAME.projectiles.push({ type: 'req', x: e.x, y: e.y, vx: Math.cos(angle)*2, vy: Math.sin(angle)*2, life: 80 });
                AudioSys.sfx.alert();
            }
        }
        if (e.type === 'assoc') {
            if (Math.random() < 0.02) e.dir = Math.floor(Math.random()*4);
            let s = 0.3;
            if (e.dir===0) e.y-=s; else if(e.dir===1) e.y+=s; else if(e.dir===2) e.x-=s; else e.x+=s;
        }
        if (e.type === 'runner') {
            if (Math.random() < 0.05) e.dir = Math.floor(Math.random()*4);
            let s = 0.8; 
            let nx = e.x, ny = e.y;
            if (e.dir===0) ny-=s; else if(e.dir===1) ny+=s; else if(e.dir===2) nx-=s; else nx+=s;
            if (!checkCol(nx, ny)) { e.x = nx; e.y = ny; } else e.dir = Math.floor(Math.random()*4); 
        }
    });
}

function updateBoss() {
    const b = GAME.boss; const p = GAME.player;
    document.getElementById('boss-hud').style.display = 'block'; document.getElementById('boss-name-el').innerText = b.name; updateBossHud();
    
    let hpPct = b.hp / b.maxHp;
    if (b.tauntThresholds.length > 0 && hpPct < b.tauntThresholds[0]) {
         b.tauntThresholds.shift(); 
         const currentGen = GAME.genId;
         let prompt = b.name === "SIMON UNGLAUBE" ? "Simon Unglaube final warning. Max 25 words." : `Taunt from boss ${b.name}. Max 25 words.`;
         
         let portrait = b.name.includes("Simon") ? GFX.simonBoss : GFX.boss_manager;
         
         // --- CHANGED: IMMEDIATE PAUSE WITH LOADING DIALOG ---
         showThinking(b.name, portrait);

         callGemini(prompt, "taunt").then(text => {
            if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
                 showDialog(text, b.name, portrait, true);
            }
        });
    }
    if (isNaN(b.x) || isNaN(b.y)) return;
    let dx = 0, dy = 0; let dist = Math.hypot(p.x - b.x, p.y - b.y);
    if (dist > 50) {
        let angle = Math.atan2(p.y - b.y, p.x - b.x);
        dx = Math.cos(angle) * b.speed; dy = Math.sin(angle) * b.speed;
        if (!checkCol(b.x + dx, b.y)) b.x += dx; if (!checkCol(b.x, b.y + dy)) b.y += dy;
    }
    b.timer++;
    if (b.timer > b.attackDelay) {
        b.timer = 0;
        for (let i = -1; i <= 1; i++) {
            let angle = Math.atan2(p.y - b.y, p.x - b.x) + (i * 0.3);
            GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*10, y: b.y + 16 + Math.sin(angle)*10, vx: Math.cos(angle)*2.5, vy: Math.sin(angle)*2.5, life: 100, boss: true, grace: 10 });
        }
        AudioSys.sfx.alert(); GAME.shake = 5; 
    }
}

function updateProjectiles() {
    for(let i=GAME.projectiles.length-1; i>=0; i--) {
        let p = GAME.projectiles[i];
        p.x += p.vx; p.y += p.vy; p.life--; if(p.grace > 0) p.grace--;
        // Skip wall collision check in Bezos boss level
        if (GAME.state !== 'BEZOS_BOSS') {
            if (p.grace <= 0 && checkCol(p.x, p.y)) { GAME.projectiles.splice(i,1); continue; }
        }
        if (p.life <= 0) { GAME.projectiles.splice(i,1); continue; }
        if ((p.type === 'req') && Math.hypot(p.x-GAME.player.x, p.y-GAME.player.y) < 10) {
            if (GAME.player.iframe<=0) {
                GAME.lives--; GAME.player.iframe = 120; GAME.shake = 10; GAME.flash = 10; AudioSys.sfx.hurt(); updateHud();
                if (GAME.lives<=0 && !GAME.gameOverTriggered) triggerGameOver("OVERWHELMED!");
            }
            GAME.projectiles.splice(i,1);
        }
        if (p.type === 'attack') {
            const attackMeta = getAttackData(p.owner);
            if (GAME.state === 'BOSS' && GAME.boss) {
                if (Math.hypot(p.x - (GAME.boss.x+16), p.y - (GAME.boss.y+16)) < 24) {
                    GAME.boss.hp--; updateBossHud(); AudioSys.sfx.bossHit(); GAME.shake = 5; spawnParticle(p.x, p.y, attackMeta.color || '#ff0000', -2); GAME.projectiles.splice(i,1);
                    spawnFloatingText(GAME.boss.x+16, GAME.boss.y+8, attackMeta.text || 'Hit!', attackMeta.color || '#ff0000');
                    if (GAME.boss.hp <= 0) winGame(); continue;
                }
            }
            if (GAME.state === 'PLAY') {
                let simon = GAME.entities.find(e => e.type === 'simon');
                if (simon && Math.hypot(p.x-simon.x, p.y-simon.y) < 12) {
                     GAME.simonHits++; AudioSys.sfx.angry(); GAME.projectiles.splice(i,1);
                     if (GAME.simonHits <= 2) {
                         const warningIndex = GAME.simonHits - 1;
                         const currentGen = GAME.genId;
                         GAME.nextState = 'PLAY';

                         // --- CHANGED: REMOVED HARDCODED FALLBACK DISPLAY. SHOW LOADING. ---
                         showThinking("Simon Unglaube", GFX.simonFace);

                         callGemini(`You are Simon Unglaube. Deliver a ${warningIndex === 0 ? "first" : "final"} warning to the coordinator who keeps throwing rule books at you. Keep it sharp, under 24 words.`, "simon_warning", { warningIndex }).then(text => {
                             if (GAME.genId === currentGen && GAME.state === 'DIALOG') {
                                  showDialog(text, "Simon Unglaube", GFX.simonFace, true);
                             }
                         });
                     }
                     else if (GAME.simonHits >= 3) initSimonBoss();
                     continue;
                }
                let hit = false;
                GAME.entities.forEach(e => {
                    if (e.type === 'ops' && Math.hypot(p.x-e.x, p.y-e.y) < 12) {
                        e.type = 'assoc'; AudioSys.sfx.hit(); spawnParticle(e.x, e.y, attackMeta.color || '#fff', -2); GAME.opsPushed++;
                        spawnFloatingText(e.x, e.y, attackMeta.text || "My Rates!", attackMeta.color || "#ff0000");
                        hit = true;
                    }
                });
                if (hit) GAME.projectiles.splice(i,1);
            }
        }
    }
}

function updateParticles() {
    for(let i=GAME.particles.length-1; i>=0; i--) {
        let p = GAME.particles[i]; p.life--; p.x += p.vx; p.y += p.vy; p.vy += 0.2;
        if (p.y > p.groundY) { p.y = p.groundY; p.vy *= -0.6; }
        if (p.life <= 0) GAME.particles.splice(i,1);
    }
}

function updateFloatingTexts() {
    for(let i=GAME.floatingTexts.length-1; i>=0; i--) {
        let t = GAME.floatingTexts[i];
        t.y += t.vy; t.life--;
        if (t.life <= 0) GAME.floatingTexts.splice(i,1);
    }
}

function spawnParticle(x, y, color, forceY = 0) {
    GAME.particles.push({
        x: x,
        y: y,
        color: color,
        life: 50 + Math.random() * 20,
        vx: (Math.random() - 0.5) * 3,
        vy: forceY || (Math.random() * -3 - 1),
        groundY: y + 5,
        size: 1 + Math.random() * 2,
        alpha: 1
    });
}

// Enhanced particle burst for special effects
function spawnParticleBurst(x, y, colors, count) {
    for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        const speed = 1 + Math.random() * 2;
        const color = colors[Math.floor(Math.random() * colors.length)];
        GAME.particles.push({
            x: x,
            y: y,
            color: color,
            life: 30 + Math.random() * 30,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1,
            groundY: y + 20,
            size: 1 + Math.random() * 2,
            alpha: 1
        });
    }
}

// Sparkle effect for special moments
function spawnSparkles(x, y, color) {
    for (let i = 0; i < 8; i++) {
        GAME.particles.push({
            x: x + (Math.random() - 0.5) * 10,
            y: y + (Math.random() - 0.5) * 10,
            color: color,
            life: 20 + Math.random() * 20,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 3,
            groundY: y + 30,
            size: 1 + Math.random(),
            alpha: 1,
            sparkle: true
        });
    }
}

function throwBook() {
    const p = GAME.player; if (p.cooldown > 0) return; const attackMeta = getAttackData(GAME.selectedChar); p.cooldown = attackMeta.cooldown || 120; p.cooldownMax = attackMeta.cooldown || 120; GAME.booksFired++;
    const speed = attackMeta.speed || 4;
    let vx=0, vy=0;
    if (GAME.state === 'BOSS' && GAME.boss) {
        let angle = Math.atan2((GAME.boss.y+16) - p.y, (GAME.boss.x+16) - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed;
    } else if (GAME.state === 'MECHA_BOSS' && GAME.mecha) {
        let angle = Math.atan2((GAME.mecha.y+32) - p.y, (GAME.mecha.x+32) - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed;
    } else {
        let target = null; let minDist = 200;
        GAME.entities.forEach(e => { if (e.type === 'ops') { let d = Math.hypot(e.x - p.x, e.y - p.y); if (d < minDist) { minDist = d; target = e; } } });
        if (target) { let angle = Math.atan2(target.y - p.y, target.x - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed; }
        else { if (KEYS.up) vy=-speed; else if (KEYS.down) vy=speed; else if (KEYS.left) vx=-speed; else vx=speed; }
    }
    GAME.projectiles.push({ type:'attack', owner: GAME.selectedChar, sprite: attackMeta.sprite, color: attackMeta.color, x:p.x+8, y:p.y+8, vx, vy, life:attackMeta.life || 40, text: attackMeta.text }); AudioSys.sfx.throw();
}

function tryInteract() {
    const p = GAME.player;

    // Check if player is near fire exit door after exactly 4 hazards cleared
    if (GAME.issuesFixed >= 4 && GAME.fireExitDoor && Math.hypot(p.x - GAME.fireExitDoor.x, p.y - GAME.fireExitDoor.y) < 20) {
        AudioSys.sfx.alert();
        showDialog("You found the hidden exit!\n\nYou step through the fire door into the Amazon yard...", "System", null, false);
        GAME.nextState = 'YARD_INTRO';
        return true;
    }

    for (let i=0; i<GAME.entities.length; i++) {
        let e = GAME.entities[i];
        if (e.type === 'runner' && Math.hypot(p.x-e.x, p.y-e.y) < 20) {
             e.type = 'assoc'; GAME.issuesFixed++; updateHud(); AudioSys.sfx.fix();
             spawnFloatingText(e.x, e.y, "Safe!", "#00ff00");

             if (GAME.issuesFixed >= 5) { queueVisitorSplash(); }

             // SIMON COMMENTARY
             const currentGen = GAME.genId;

             // --- CHANGED: Show thinking state immediately for responsiveness ---
             showThinking("Simon Unglaube", GFX.simonFace);

             callGemini(
                 "You are Simon Unglaube, WHS Senior Regional Manager. The player stopped a runner. Praise the player with dry, professional humor and add a witty safety reminder about slowing down. Max 22 words.",
                 "runners"
             ).then(tip => {
                if (GAME.genId === currentGen) showDialog(`Fixed: Runner!\n${tip}`, "Simon Unglaube", GFX.simonFace, true);
             });
             return true;
        }
    }
    for(let h of GAME.activeIssues) {
        if (!h.fixed && Math.hypot(p.x-h.x, p.y-h.y) < 20) {
            h.fixed = true; GAME.issuesFixed++; updateHud(); AudioSys.sfx.fix();
            if (h.hiddenDoor && GAME.hiddenDoor) GAME.hiddenDoor.unlocked = true;
            spawnFloatingText(h.x, h.y, "Fixed!", "#00ff00");

            if (GAME.issuesFixed >= 5) { queueVisitorSplash(); }

            // SIMON COMMENTARY
            const currentGen = GAME.genId;

            // --- CHANGED: Show thinking state immediately ---
            showThinking("Simon Unglaube", GFX.simonFace);

            callGemini(
                `You are Simon Unglaube, WHS Senior Regional Manager. A hazard "${h.data.name}" was fixed. Praise the player with dry, professional humor and share one specific safety tip tied to that hazard. Max 32 words.`,
                "hazard",
                { hazardName: h.data.name }
            ).then(tip => {
                if (GAME.genId === currentGen) showDialog(`Fixed: ${h.data.name}!\n${tip}`, "Simon Unglaube", GFX.simonFace, true);
            });
            return true;
        }
    }
    if (GAME.hiddenDoor && GAME.hiddenDoor.unlocked) {
        const dx = GAME.player.x - GAME.hiddenDoor.doorX * TILE_SIZE;
        const dy = GAME.player.y - GAME.hiddenDoor.doorY * TILE_SIZE;
        if (Math.hypot(dx, dy) < 18) {
            GAME.state = 'YARD_INTRO';
            GAME.stateTimer = 0;
            GAME.nextState = 'YARD_LEVEL';
            GAME.projectiles = [];
            updateMusicForState();
            return true;
        }
    }
    return false;
}

function triggerGameOver(reason) {
    GAME.gameOverTriggered = true; GAME.nextState = 'TITLE'; GAME.state = 'LOSE_SPLASH'; GAME.splashTimer = 260; GAME.aiResultText = null; GAME.stateTimer = 0;
    document.getElementById('boss-hud').style.display = 'none'; document.getElementById('dialog-box').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';
    const time = Math.floor((Date.now() - GAME.startTime)/1000); const currentGen = GAME.genId;
    if (reason === "FIRED!") { GAME.aiResultText = "Terminated for unsafe behavior."; }
    else {
        const stats = { time, hazards: GAME.issuesFixed, books: GAME.booksFired, ops: GAME.opsPushed };
        callGemini(`You are Simon Unglaube, WHS Senior Regional Manager. Coordinator failed after ${time}s with ${GAME.issuesFixed}/5 hazards fixed, ${GAME.booksFired} rule books thrown, ${GAME.opsPushed} ops pushed. Deliver a scathing yet funny performance review that weaves those stats into a safety lesson. Max 50 words.`, "reviews_loss", { stats }).then(review => {
             if (GAME.genId === currentGen) { GAME.aiResultText = review; }
        });
    }
}

function winGame() {
    AudioSys.sfx.start(); MusicSys.play('victory'); GAME.nextState = 'TITLE'; GAME.state = 'WIN_SPLASH'; GAME.splashTimer = 260; GAME.aiResultText = null; GAME.stateTimer = 0;
    document.getElementById('boss-hud').style.display = 'none'; document.getElementById('dialog-box').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';
    const currentGen = GAME.genId; const time = Math.floor((Date.now() - GAME.startTime)/1000);
    const stats = { time, hazards: GAME.issuesFixed, books: GAME.booksFired, ops: GAME.opsPushed };
    callGemini(`You are Simon Unglaube, WHS Senior Regional Manager. Coordinator won in ${time}s clearing ${GAME.issuesFixed}/5 hazards, tossing ${GAME.booksFired} rule books, redirecting ${GAME.opsPushed} ops. Give warm but witty praise plus one practical safety takeaway using those stats. Max 55 words.`, "reviews_win", { stats }).then(praise => {
        if (GAME.genId === currentGen) GAME.aiResultText = praise;
    });
}

function updateBossHud() { if(GAME.boss) document.getElementById('boss-health-el').style.width = Math.max(0, (GAME.boss.hp / GAME.boss.maxHp) * 100) + '%'; }

function checkCol(x, y) {
    let tx = Math.floor((x+8)/TILE_SIZE); let ty = Math.floor((y+8)/TILE_SIZE);
    if (tx<0||tx>=MAP_W||ty<0||ty>=MAP_H) return true;
    return GAME.map[ty][tx] !== 0;
}

function updateHud() { document.getElementById('life-val').innerText = "❤️".repeat(Math.max(0, GAME.lives)); document.getElementById('score-val').innerText = GAME.issuesFixed + "/5"; }

function showDialog(text, speaker, portrait, isAI = false) {
    GAME.state = 'DIALOG'; GAME.dialogText = (speaker ? speaker + ":\n" : "") + text; GAME.dialogVisible = "";
    const box = document.getElementById('dialog-box'); const badge = document.getElementById('gemini-badge'); const port = document.getElementById('portrait'); const pCtx = port.getContext('2d');
    box.style.display = 'flex'; document.getElementById('text-content').innerText = ""; 
    badge.style.display = isAI ? 'block' : 'none';
    badge.innerHTML = isAI ? "✨ SIMON IS ANALYZING..." : ""; // Reset badge text
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,32,32);
    if (portrait) pCtx.drawImage(portrait, 0, 0); else { pCtx.fillStyle='#fff'; pCtx.fillText("!", 10, 20); }
    AudioSys.sfx.text();
    if (speaker) TTSSys.speak(text.replace(speaker + ":\n", "").replace(/\n/g, ' '), speaker);
}

// --- NEW FUNCTION: Show "Thinking" state ---
function showThinking(speaker, portrait) {
    GAME.state = 'DIALOG';
    GAME.dialogText = ""; // No typed text yet
    GAME.dialogVisible = "";
    const box = document.getElementById('dialog-box');
    const badge = document.getElementById('gemini-badge');
    const port = document.getElementById('portrait');
    const pCtx = port.getContext('2d');
    
    box.style.display = 'flex';
    document.getElementById('text-content').innerHTML = "<span class='loading-dots'>PROCESSING</span>"; // Loading animation
    
    badge.style.display = 'block';
    badge.innerText = "✨ UPLINK ESTABLISHED...";
    
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,32,32);
    if (portrait) pCtx.drawImage(portrait, 0, 0);
    
    AudioSys.sfx.text();
}

function closeDialog() {
    TTSSys.cancel(); AudioSys.sfx.step(); document.getElementById('dialog-box').style.display = 'none';
    GAME.state = GAME.nextState;

    if (GAME.state === 'VISITOR_SPLASH') { showVisitorSplash(); return; }

    // Only start yard level if not already initialized (prevents infinite loop)
    if (GAME.state === 'YARD_LEVEL' && !GAME.yard) { startYardLevel(); return; }
    if (GAME.state === 'MECHA_BOSS_INTRO') { beginMechaEncounter(); return; }
    if (GAME.state === 'CREDITS') { startCredits(); return; }

    if (GAME.state === 'PLAY' && GAME.pendingBossIntro && !GAME.boss) {
        showVisitorSplash();
        return;
    }
    if (GAME.state === 'PLAY' && GAME.issuesFixed >= 5 && !GAME.boss && !GAME.pendingBossIntro) {
        queueVisitorSplash();
        showVisitorSplash();
        return;
    }

    updateMusicForState();
}

function updateMusicForState() {
    let rate = 1;
    let track = 'title';

    if (['LOGO', 'INTRO', 'STORY', 'TITLE'].includes(GAME.state)) track = 'title';
    else if (['HOWTO', 'SELECT'].includes(GAME.state)) track = 'menu';
    else if (['PLAY', 'YARD_INTRO', 'YARD_LEVEL'].includes(GAME.state)) track = 'ingame';
    else if (GAME.state === 'VISITOR_SPLASH') track = 'boss';
    else if (GAME.state === 'BOSS' || GAME.state === 'BOSS_INTRO') track = 'boss';
    else if (GAME.state === 'MECHA_BOSS' || GAME.state === 'MECHA_BOSS_INTRO' || GAME.state === 'MECHA_TRANSFORM' || GAME.state === 'THRONE_CONFRONTATION') { track = 'boss'; rate = 0.85; }
    else if (GAME.state === 'CREDITS') track = 'victory';

    MusicSys.play(track, rate);
}

function drawSnesSplash(isWin) {
    const t = GAME.stateTimer;
    const primary = isWin ? '#0d1b4c' : '#2d0a0f';
    const accent = isWin ? '#7dd3fc' : '#f87171';
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, isWin ? '#0a102a' : '#1a0408');
    gradient.addColorStop(0.5, primary);
    gradient.addColorStop(1, '#000');
    ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Moving scanlines
    for (let y = 0; y < canvas.height; y += 8) {
        const offset = Math.sin((t / 8) + y * 0.12) * 3;
        ctx.fillStyle = `rgba(255,255,255,${isWin ? 0.05 : 0.04})`;
        ctx.fillRect(offset, y, canvas.width, 2);
    }

    // Mode-7 style horizon lines
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height * 0.65);
    for (let i = 0; i < 18; i++) {
        const scale = (i + 1) / 18;
        const wave = Math.sin((t / 10) + i * 0.6) * 4;
        const w = canvas.width * (1.1 - scale * 0.6);
        const y = i * 12 + wave;
        ctx.strokeStyle = `${accent}80`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-w / 2, y);
        ctx.lineTo(w / 2, y);
        ctx.stroke();
    }
    ctx.restore();

    // Star glints
    for (let i = 0; i < 14; i++) {
        const x = (Math.sin((t + i * 13) / 6) * 0.5 + 0.5) * canvas.width;
        const y = (i * 37 + t * 2) % canvas.height;
        const alpha = 0.25 + ((i % 3) * 0.1);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillRect(x, y, 2, 2);
        ctx.fillRect(x - 2, y, 6, 1);
        ctx.fillRect(x, y - 2, 1, 6);
    }

    ctx.textAlign = 'center';
    ctx.fillStyle = '#000';
    ctx.font = '22px monospace';
    const text = isWin ? 'COMPLIANT!' : 'TERMINATED';
    const shadowOffsets = [[2,2],[-2,2],[2,-2],[-2,-2]];
    shadowOffsets.forEach(([dx, dy]) => ctx.fillText(text, canvas.width/2 + dx, canvas.height/2 - 6 + dy));

    ctx.fillStyle = accent;
    ctx.fillText(text, canvas.width/2, canvas.height/2 - 6);
    ctx.font = '11px monospace';
    ctx.fillStyle = '#fef9c3';
    const sub = isWin ? 'CALCULATING SAFETY SCORE...' : 'PREPARING EXIT INTERVIEW...';
    ctx.fillText(sub, canvas.width/2, canvas.height/2 + 20);
    ctx.textAlign = 'start';
}

function drawYardLevel() {
    const y = GAME.yard;
    const camY = y ? y.cameraY || 0 : 0;
    const yardHeight = y ? y.height : canvas.height;

    ctx.save();
    ctx.translate(0, -camY);

    // === MASSIVE THRONE ROOM AT TOP (200 pixels tall) ===
    const throneRoomHeight = 200;

    // Dark throne room background with gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, throneRoomHeight);
    skyGrad.addColorStop(0, '#030308');
    skyGrad.addColorStop(0.2, '#080812');
    skyGrad.addColorStop(0.5, '#0f0f1e');
    skyGrad.addColorStop(0.8, '#1a1a2e');
    skyGrad.addColorStop(1, '#0b1224');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, canvas.width, throneRoomHeight);

    // === THRONE ROOM FLOOR TILES ===
    // Checkered marble floor pattern
    for (let ty = 120; ty < throneRoomHeight; ty += 16) {
        for (let tx = 0; tx < canvas.width; tx += 16) {
            const isEven = ((tx / 16) + (ty / 16)) % 2 === 0;
            ctx.fillStyle = isEven ? '#1a1a28' : '#252535';
            ctx.fillRect(tx, ty, 16, 16);
            // Tile shine
            ctx.fillStyle = isEven ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.01)';
            ctx.fillRect(tx + 1, ty + 1, 6, 6);
        }
    }

    // === RED CARPET LEADING TO THRONE ===
    const carpetWidth = 60;
    const carpetX = canvas.width / 2 - carpetWidth / 2;
    // Carpet base
    ctx.fillStyle = '#7f1d1d';
    ctx.fillRect(carpetX, 80, carpetWidth, throneRoomHeight - 80);
    // Carpet highlight stripe
    ctx.fillStyle = '#991b1b';
    ctx.fillRect(carpetX + 8, 80, carpetWidth - 16, throneRoomHeight - 80);
    // Carpet golden trim
    ctx.fillStyle = '#b45309';
    ctx.fillRect(carpetX, 80, 4, throneRoomHeight - 80);
    ctx.fillRect(carpetX + carpetWidth - 4, 80, 4, throneRoomHeight - 80);
    // Carpet decorative patterns
    ctx.fillStyle = '#fbbf24';
    for (let py = 100; py < throneRoomHeight; py += 30) {
        ctx.fillRect(carpetX + 20, py, 20, 2);
        ctx.fillRect(carpetX + 25, py + 4, 10, 2);
    }

    // === MASSIVE PILLARS ON SIDES ===
    if (y) {
        const animFrame = y.jeffAnimFrame || 0;

        // Draw pillars on both sides
        for (let side = 0; side < 2; side++) {
            const pillarX = side === 0 ? 15 : canvas.width - 35;

            // Pillar base
            ctx.fillStyle = '#1f1f35';
            ctx.fillRect(pillarX - 5, throneRoomHeight - 30, 30, 30);
            ctx.fillStyle = '#2a2a45';
            ctx.fillRect(pillarX, throneRoomHeight - 25, 20, 25);

            // Pillar shaft
            ctx.fillStyle = '#252540';
            ctx.fillRect(pillarX, 20, 20, throneRoomHeight - 50);
            ctx.fillStyle = '#2d2d50';
            ctx.fillRect(pillarX + 3, 20, 14, throneRoomHeight - 50);
            // Pillar highlight
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            ctx.fillRect(pillarX + 4, 20, 4, throneRoomHeight - 50);

            // Pillar capital (top decoration)
            ctx.fillStyle = '#3a3a55';
            ctx.fillRect(pillarX - 4, 15, 28, 10);
            ctx.fillStyle = '#ff9900';
            ctx.fillRect(pillarX + 2, 12, 16, 4);

            // Torch on pillar
            const torchY = 60;
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(pillarX + 7, torchY, 6, 20);
            // Torch flame (animated)
            const flameHeight = 12 + Math.sin(animFrame * 0.2) * 3;
            const flameGrad = ctx.createRadialGradient(pillarX + 10, torchY - 5, 2, pillarX + 10, torchY - 5, flameHeight);
            flameGrad.addColorStop(0, 'rgba(255, 200, 50, 0.9)');
            flameGrad.addColorStop(0.3, 'rgba(255, 100, 0, 0.7)');
            flameGrad.addColorStop(0.7, 'rgba(200, 50, 0, 0.4)');
            flameGrad.addColorStop(1, 'rgba(100, 0, 0, 0)');
            ctx.fillStyle = flameGrad;
            ctx.beginPath();
            ctx.arc(pillarX + 10, torchY - 5, flameHeight, 0, Math.PI * 2);
            ctx.fill();
            // Flame core
            ctx.fillStyle = '#ffff80';
            ctx.fillRect(pillarX + 8, torchY - 8, 4, 6);
        }

        // === WALL BANNERS ===
        // Left banner
        ctx.fillStyle = '#4a1010';
        ctx.fillRect(50, 25, 24, 50);
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(54, 30, 16, 40);
        // Amazon arrow on banner
        ctx.fillStyle = '#4a1010';
        ctx.beginPath();
        ctx.moveTo(54, 55); ctx.quadraticCurveTo(62, 62, 70, 52); ctx.lineTo(70, 55);
        ctx.quadraticCurveTo(62, 66, 54, 58); ctx.fill();

        // Right banner
        ctx.fillStyle = '#4a1010';
        ctx.fillRect(canvas.width - 74, 25, 24, 50);
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(canvas.width - 70, 30, 16, 40);
        ctx.fillStyle = '#4a1010';
        ctx.beginPath();
        ctx.moveTo(canvas.width - 70, 55); ctx.quadraticCurveTo(canvas.width - 62, 62, canvas.width - 54, 52);
        ctx.lineTo(canvas.width - 54, 55); ctx.quadraticCurveTo(canvas.width - 62, 66, canvas.width - 70, 58); ctx.fill();

        // === ELEVATED THRONE PLATFORM ===
        const throneX = canvas.width / 2;
        const throneY = 35;

        // Stepped platform
        ctx.fillStyle = '#1a1520';
        ctx.fillRect(throneX - 70, 78, 140, 8);
        ctx.fillStyle = '#201828';
        ctx.fillRect(throneX - 60, 70, 120, 10);
        ctx.fillStyle = '#281e30';
        ctx.fillRect(throneX - 50, 62, 100, 10);

        // === MASSIVE GOLDEN THRONE ===
        // Throne backing - imposing structure
        ctx.fillStyle = '#2d1810';
        ctx.fillRect(throneX - 55, throneY - 25, 110, 75);
        ctx.fillStyle = '#4a2818';
        ctx.fillRect(throneX - 50, throneY - 20, 100, 65);
        ctx.fillStyle = '#5a3520';
        ctx.fillRect(throneX - 45, throneY - 15, 90, 55);

        // Throne spires (taller, more imposing)
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(throneX - 52, throneY - 50, 12, 40);
        ctx.fillRect(throneX + 40, throneY - 50, 12, 40);
        // Spire tips
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(throneX - 52, throneY - 50);
        ctx.lineTo(throneX - 46, throneY - 70);
        ctx.lineTo(throneX - 40, throneY - 50);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(throneX + 40, throneY - 50);
        ctx.lineTo(throneX + 46, throneY - 70);
        ctx.lineTo(throneX + 52, throneY - 50);
        ctx.fill();
        // Gems on spires
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(throneX - 49, throneY - 45, 6, 6);
        ctx.fillRect(throneX + 43, throneY - 45, 6, 6);

        // Amazon logo on throne (glowing and pulsing)
        const logoPulse = Math.sin(animFrame * 0.08) * 0.2 + 0.8;
        ctx.fillStyle = `rgba(255, 153, 0, ${logoPulse})`;
        ctx.fillRect(throneX - 25, throneY, 50, 22);
        ctx.fillStyle = '#ffb347';
        ctx.fillRect(throneX - 20, throneY + 3, 40, 16);
        // Amazon arrow/smile (bigger)
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.moveTo(throneX - 15, throneY + 14);
        ctx.quadraticCurveTo(throneX, throneY + 24, throneX + 15, throneY + 11);
        ctx.lineTo(throneX + 20, throneY + 14);
        ctx.quadraticCurveTo(throneX, throneY + 30, throneX - 18, throneY + 17);
        ctx.fill();

        // Ornate throne armrests
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(throneX - 48, throneY + 30, 14, 25);
        ctx.fillRect(throneX + 34, throneY + 30, 14, 25);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(throneX - 45, throneY + 33, 8, 19);
        ctx.fillRect(throneX + 37, throneY + 33, 8, 19);

        // === MENACING GLOW BEHIND BEZOS ===
        const jeffX = canvas.width / 2 - 24;
        const jeffY = throneY + 5;
        const bobY = Math.sin(animFrame * 0.04) * 2;

        const glowSize = 60 + Math.sin(animFrame * 0.06) * 10;
        const glowGrad = ctx.createRadialGradient(jeffX + 24, jeffY + 24 + bobY, 8, jeffX + 24, jeffY + 24 + bobY, glowSize);
        glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.7)');
        glowGrad.addColorStop(0.3, 'rgba(220, 38, 38, 0.4)');
        glowGrad.addColorStop(0.6, 'rgba(139, 0, 0, 0.2)');
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(jeffX + 24, jeffY + 24 + bobY, glowSize, 0, Math.PI * 2);
        ctx.fill();

        // === DRAW BEZOS ON THRONE ===
        ctx.drawImage(GFX.jeffYard, jeffX, jeffY + bobY);

        // === TAUNT SPEECH BUBBLE ===
        const tauntX = 6;
        const tauntY = 95;
        const tauntW = canvas.width - 12;
        const tauntH = 22;

        // Bubble background with red border
        ctx.fillStyle = 'rgba(10, 5, 15, 0.95)';
        ctx.fillRect(tauntX, tauntY, tauntW, tauntH);
        ctx.strokeStyle = '#dc2626';
        ctx.lineWidth = 2;
        ctx.strokeRect(tauntX, tauntY, tauntW, tauntH);
        // Inner glow
        ctx.strokeStyle = 'rgba(255, 153, 0, 0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(tauntX + 2, tauntY + 2, tauntW - 4, tauntH - 4);

        // "BEZOS:" label
        ctx.fillStyle = '#ff9900';
        ctx.font = '6px "Press Start 2P"';
        ctx.textAlign = 'left';
        ctx.fillText('BEZOS:', tauntX + 4, tauntY + 14);

        // Taunt text
        ctx.fillStyle = '#ffffff';
        ctx.font = '5px "Press Start 2P"';
        const displayTaunt = (y.jeffTaunt || "COME CLOSER... IF YOU DARE!").substring(0, 32);
        ctx.fillText(displayTaunt, tauntX + 52, tauntY + 14);
        ctx.textAlign = 'left';

        // === AMBIENT PARTICLES (dust motes in light) ===
        for (let i = 0; i < 5; i++) {
            const px = (animFrame * 0.3 + i * 50) % canvas.width;
            const py = 30 + Math.sin(animFrame * 0.02 + i * 2) * 40;
            ctx.fillStyle = 'rgba(255, 200, 100, 0.3)';
            ctx.fillRect(px, py, 2, 2);
        }
    }

    // asphalt base with SNES-style tiling and parallax skyline (starts after throne room)
    ctx.fillStyle = '#0b1224'; ctx.fillRect(0, throneRoomHeight, canvas.width, yardHeight - throneRoomHeight);
    ctx.fillStyle = '#0f172a';
    for (let ty = throneRoomHeight; ty < yardHeight + 16; ty += 16) {
        for (let tx = (ty % 32 === 0 ? 0 : 8); tx < canvas.width; tx += 16) {
            ctx.fillRect(tx, ty, 12, 12);
        }
    }
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    for (let ty = throneRoomHeight; ty < yardHeight; ty += 8) {
        for (let tx = 4; tx < canvas.width; tx += 16) ctx.fillRect(tx, ty + ((tx + ty) % 16 === 0 ? 2 : 0), 2, 2);
    }

    // Warning stripes at throne room entrance
    ctx.fillStyle = '#facc15';
    for (let x = 0; x < canvas.width; x += 16) {
        ctx.fillRect(x, throneRoomHeight - 5, 8, 5);
    }
    ctx.fillStyle = '#0f0f0f';
    for (let x = 8; x < canvas.width; x += 16) {
        ctx.fillRect(x, throneRoomHeight - 5, 8, 5);
    }

    // curbs and dock edges (at bottom of yard)
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0, yardHeight - 18, canvas.width, 18);
    ctx.fillStyle = '#334155'; ctx.fillRect(0, yardHeight - 22, canvas.width, 4);
    ctx.fillStyle = '#64748b'; for (let x=0; x<canvas.width; x+=14) ctx.fillRect(x, yardHeight - 16, 8, 3);

    // lane bands and markings
    if (y) {
        ctx.setLineDash([8, 10]);
        ctx.strokeStyle = '#facc15'; ctx.lineWidth = 2;
        y.lanes.forEach(lane => {
            ctx.fillStyle = '#0f172a'; ctx.fillRect(0, lane.y - 20, canvas.width, 40);
            ctx.fillStyle = '#111827'; ctx.fillRect(0, lane.y - 14, canvas.width, 28);
            ctx.beginPath(); ctx.moveTo(0, lane.y); ctx.lineTo(canvas.width, lane.y); ctx.stroke();
            ctx.fillStyle = '#1e293b'; ctx.fillRect(0, lane.y - 22, canvas.width, 2);
            ctx.fillStyle = '#1e293b'; ctx.fillRect(0, lane.y + 20, canvas.width, 2);
        });
        ctx.setLineDash([]);
    }

    // palettes at bottom of yard
    ctx.fillStyle = '#f97316'; for (let x=10; x<canvas.width; x+=60) ctx.fillRect(x, yardHeight - 36, 8, 16);
    ctx.fillStyle = '#9ca3af'; for (let x=6; x<canvas.width; x+=50) ctx.fillRect(x, yardHeight - 48, 14, 6);

    if (y) {
        // Draw static hazards (puddles, debris)
        if (y.staticHazards) {
            y.staticHazards.forEach(h => {
                if (h.type === 'puddle') {
                    // Oil/water puddle
                    ctx.fillStyle = 'rgba(30, 64, 175, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(h.x + 12, h.y + 8, 18, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(96, 165, 250, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(h.x + 10, h.y + 6, 8, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Warning icon
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = '6px "Press Start 2P"';
                    ctx.fillText('!', h.x + 10, h.y - 2);
                } else if (h.type === 'debris') {
                    // Debris pile
                    ctx.fillStyle = '#78716c';
                    ctx.fillRect(h.x, h.y + 8, 24, 8);
                    ctx.fillStyle = '#a8a29e';
                    ctx.fillRect(h.x + 2, h.y + 4, 8, 10);
                    ctx.fillRect(h.x + 12, h.y + 6, 10, 8);
                    ctx.fillStyle = '#d6d3d1';
                    ctx.fillRect(h.x + 4, h.y + 6, 4, 4);
                }
            });
        }

        // Draw forklift zone warnings
        if (y.forkliftZones) {
            y.forkliftZones.forEach(zone => {
                if (zone.active || zone.timer < 40) {
                    const pulse = Math.sin(GAME.ticks * 0.2) * 0.3 + 0.5;
                    ctx.fillStyle = `rgba(234, 179, 8, ${pulse * 0.3})`;
                    ctx.fillRect(0, zone.y - 15, canvas.width, 30);
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(0, zone.y);
                    ctx.lineTo(canvas.width, zone.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
        }

        // Draw vehicles
        y.vehicles.forEach(v => {
            const sprite = v.type === 'van' ? GFX.van : GFX.truck;
            ctx.drawImage(sprite, v.x, v.y);
        });

        // Draw forklifts
        if (y.forklifts) {
            y.forklifts.forEach(f => {
                // Forklift body
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(f.x, f.y, 28, 16);
                ctx.fillStyle = '#d97706';
                ctx.fillRect(f.x + 2, f.y + 2, 24, 12);
                // Cage
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(f.x + 4, f.y + 2, 8, 10);
                ctx.fillStyle = '#374151';
                ctx.fillRect(f.x + 5, f.y + 3, 6, 8);
                // Forks
                ctx.fillStyle = '#6b7280';
                const forkX = f.dir === 1 ? f.x + 24 : f.x - 8;
                ctx.fillRect(forkX, f.y + 12, 10, 3);
                ctx.fillRect(forkX, f.y + 8, 10, 3);
                // Wheels
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(f.x + 4, f.y + 14, 6, 4);
                ctx.fillRect(f.x + 18, f.y + 14, 6, 4);
                // Warning light
                const lightPulse = Math.sin(GAME.ticks * 0.3) > 0;
                ctx.fillStyle = lightPulse ? '#ef4444' : '#7f1d1d';
                ctx.fillRect(f.x + 12, f.y - 2, 4, 4);
            });
        }

        // === CASTLE SECTION RENDERING (below throne room) ===
        if (y.castleStart) {
            const castleY = y.castleStart;

            // Castle entrance gate - massive archway (at bottom of castle section)
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, castleY - 80, canvas.width, 80);

            // Castle entrance arch
            ctx.fillStyle = '#2d2d44';
            ctx.fillRect(canvas.width / 2 - 40, castleY - 60, 80, 60);
            ctx.fillStyle = '#3d3d5c';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, castleY - 60, 40, Math.PI, 0);
            ctx.fill();

            // Castle wall base (starts after throne room at y=200)
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, throneRoomHeight, canvas.width, castleY - throneRoomHeight - 80);

            // Castle brickwork texture (starts after throne room)
            ctx.fillStyle = '#2a2a40';
            for (let ty = throneRoomHeight; ty < castleY - 80; ty += 16) {
                for (let tx = 0; tx < canvas.width; tx += 20) {
                    const offset = (Math.floor(ty / 16) % 2) * 10;
                    ctx.fillRect(tx + offset, ty, 18, 14);
                }
            }

            // Castle side towers (start after throne room)
            ctx.fillStyle = '#1f1f35';
            ctx.fillRect(0, throneRoomHeight, 30, castleY - throneRoomHeight);
            ctx.fillRect(canvas.width - 30, throneRoomHeight, 30, castleY - throneRoomHeight);

            // Tower details (windows)
            ctx.fillStyle = '#0ea5e9';
            for (let ty = throneRoomHeight + 20; ty < castleY; ty += 60) {
                ctx.fillRect(8, ty, 14, 8);
                ctx.fillRect(canvas.width - 22, ty, 14, 8);
            }

            // Banner/flags on towers (at top of castle section)
            ctx.fillStyle = '#ff9900';
            ctx.fillRect(12, throneRoomHeight + 5, 6, 20);
            ctx.fillRect(canvas.width - 18, throneRoomHeight + 5, 6, 20);
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.moveTo(18, throneRoomHeight + 5); ctx.lineTo(30, throneRoomHeight + 10); ctx.lineTo(18, throneRoomHeight + 20); ctx.fill();
            ctx.beginPath();
            ctx.moveTo(canvas.width - 12, throneRoomHeight + 5); ctx.lineTo(canvas.width - 24, throneRoomHeight + 10); ctx.lineTo(canvas.width - 12, throneRoomHeight + 20); ctx.fill();

            // Draw castle platforms
            if (y.castlePlatforms) {
                y.castlePlatforms.forEach(p => {
                    // Platform glow
                    ctx.fillStyle = 'rgba(14, 165, 233, 0.3)';
                    ctx.fillRect(p.x - 2, p.y - 2, p.w + 4, 12);
                    // Platform body
                    ctx.fillStyle = '#38bdf8';
                    ctx.fillRect(p.x, p.y, p.w, 8);
                    ctx.fillStyle = '#0ea5e9';
                    ctx.fillRect(p.x + 2, p.y + 2, p.w - 4, 4);
                    // Platform edges
                    ctx.fillStyle = '#7dd3fc';
                    ctx.fillRect(p.x, p.y, 4, 8);
                    ctx.fillRect(p.x + p.w - 4, p.y, 4, 8);
                });
            }

            // Draw laser barriers
            if (y.castleLaserBarriers) {
                y.castleLaserBarriers.forEach(barrier => {
                    if (barrier.active) {
                        // Active laser - dangerous
                        const pulse = Math.sin(GAME.ticks * 0.3) * 0.2 + 0.8;
                        ctx.fillStyle = `rgba(239, 68, 68, ${pulse * 0.3})`;
                        ctx.fillRect(30, barrier.y - 10, canvas.width - 60, 20);
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(30, barrier.y - 3, canvas.width - 60, 6);
                        ctx.fillStyle = '#fca5a5';
                        ctx.fillRect(30, barrier.y - 1, canvas.width - 60, 2);
                        // Emitter nodes
                        ctx.fillStyle = '#dc2626';
                        ctx.fillRect(26, barrier.y - 6, 8, 12);
                        ctx.fillRect(canvas.width - 34, barrier.y - 6, 8, 12);
                    } else {
                        // Inactive - safe to pass
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                        ctx.fillRect(30, barrier.y - 2, canvas.width - 60, 4);
                        ctx.fillStyle = '#166534';
                        ctx.fillRect(26, barrier.y - 6, 8, 12);
                        ctx.fillRect(canvas.width - 34, barrier.y - 6, 8, 12);
                    }
                });
            }

            // Draw guard turrets
            if (y.castleGuards) {
                y.castleGuards.forEach(guard => {
                    // Turret base
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(guard.x, guard.y, 16, 16);
                    ctx.fillStyle = '#4b5563';
                    ctx.fillRect(guard.x + 2, guard.y + 2, 12, 12);
                    // Turret barrel
                    const dirX = guard.x < canvas.width / 2 ? 1 : -1;
                    ctx.fillStyle = '#6b7280';
                    if (dirX === 1) {
                        ctx.fillRect(guard.x + 12, guard.y + 5, 10, 6);
                    } else {
                        ctx.fillRect(guard.x - 6, guard.y + 5, 10, 6);
                    }
                    // Warning light
                    const charging = guard.fireTimer > guard.fireRate - 20;
                    ctx.fillStyle = charging ? '#ef4444' : '#22c55e';
                    ctx.fillRect(guard.x + 6, guard.y - 2, 4, 4);
                });
            }

            // Draw castle projectiles
            if (y.castleProjectiles) {
                y.castleProjectiles.forEach(proj => {
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(proj.x - 4, proj.y - 3, 8, 6);
                    ctx.fillStyle = '#f59e0b';
                    ctx.fillRect(proj.x - 2, proj.y - 1, 4, 2);
                });
            }

            // Draw patrol drones
            if (y.castleDrones) {
                y.castleDrones.forEach(drone => {
                    const pulse = Math.sin(drone.pulseTimer * 0.15) * 2;
                    // Drone body
                    ctx.fillStyle = '#22d3ee';
                    ctx.fillRect(drone.x - 8 - pulse/2, drone.y - 8 - pulse/2, 16 + pulse, 16 + pulse);
                    ctx.fillStyle = '#0ea5e9';
                    ctx.fillRect(drone.x - 5, drone.y - 5, 10, 10);
                    // Eye
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(drone.x - 2, drone.y - 2, 4, 4);
                    // Propellers
                    const propPhase = Math.floor(drone.pulseTimer / 2) % 2;
                    ctx.fillStyle = '#94a3b8';
                    if (propPhase === 0) {
                        ctx.fillRect(drone.x - 14, drone.y - 2, 6, 4);
                        ctx.fillRect(drone.x + 8, drone.y - 2, 6, 4);
                    } else {
                        ctx.fillRect(drone.x - 2, drone.y - 14, 4, 6);
                        ctx.fillRect(drone.x - 2, drone.y + 8, 4, 6);
                    }
                });
            }

        }
    }

    // Draw player
    if (GAME.player.iframe > 0 && GAME.player.iframe % 6 < 3) {
        ctx.globalAlpha = 0.5;
    }
    ctx.drawImage(GFX.chars[GAME.selectedChar], GAME.player.x, GAME.player.y);
    ctx.globalAlpha = 1;

    // Goal text
    ctx.fillStyle = '#facc15';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('GOAL', 8, 8);

    ctx.restore();

    // Progress indicator (fixed position, not scrolling)
    if (y) {
        const progress = 1 - (y.playerY / y.height);
        const barWidth = 8;
        const barHeight = canvas.height - 40;
        const barX = canvas.width - 14;
        const barY = 20;

        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

        // Track
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // Progress fill
        const fillHeight = barHeight * progress;
        const gradient = ctx.createLinearGradient(0, barY + barHeight - fillHeight, 0, barY + barHeight);
        gradient.addColorStop(0, '#22c55e');
        gradient.addColorStop(1, '#16a34a');
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY + barHeight - fillHeight, barWidth, fillHeight);

        // Player marker
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(barX - 3, barY + barHeight - fillHeight - 2, barWidth + 6, 4);

        // Labels
        ctx.fillStyle = '#facc15';
        ctx.font = '4px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('JEFF', barX + barWidth / 2, barY - 4);
        ctx.fillStyle = '#22c55e';
        ctx.fillText('START', barX + barWidth / 2, barY + barHeight + 10);
        ctx.textAlign = 'left';
    }
}

function drawMechaBattle() {
    const m = GAME.mecha;

    // === CASTLE THRONE ROOM BACKGROUND ===
    // Base castle wall color - changes when enraged
    let wallColor = '#1a1a2e';
    let accentColor = '#2a2a40';
    if (m && m.enraged) {
        const pulse = Math.sin(GAME.ticks * 0.1) * 0.15;
        wallColor = `rgb(${Math.floor(40 + pulse * 30)}, ${Math.floor(15 + pulse * 10)}, ${Math.floor(25 + pulse * 15)})`;
        accentColor = `rgb(${Math.floor(60 + pulse * 20)}, ${Math.floor(25 + pulse * 10)}, ${Math.floor(35 + pulse * 10)})`;
    }

    // Castle wall background
    ctx.fillStyle = wallColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Stone brick pattern
    ctx.fillStyle = accentColor;
    for (let ty = 0; ty < canvas.height; ty += 16) {
        for (let tx = 0; tx < canvas.width; tx += 20) {
            const offset = (Math.floor(ty / 16) % 2) * 10;
            ctx.fillRect(tx + offset, ty, 18, 14);
        }
    }

    // Castle pillars on sides
    ctx.fillStyle = '#151525';
    ctx.fillRect(0, 0, 24, canvas.height);
    ctx.fillRect(canvas.width - 24, 0, 24, canvas.height);
    ctx.fillStyle = '#252538';
    ctx.fillRect(4, 0, 16, canvas.height);
    ctx.fillRect(canvas.width - 20, 0, 16, canvas.height);

    // Pillar decorations
    ctx.fillStyle = '#ff9900';
    for (let py = 20; py < canvas.height; py += 40) {
        ctx.fillRect(8, py, 8, 6);
        ctx.fillRect(canvas.width - 16, py, 8, 6);
    }

    // Throne room banners
    ctx.fillStyle = '#dc2626';
    ctx.fillRect(40, 0, 20, 50);
    ctx.fillRect(canvas.width - 60, 0, 20, 50);
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(44, 20, 12, 8);
    ctx.fillRect(canvas.width - 56, 20, 12, 8);
    // Banner tips
    ctx.beginPath();
    ctx.moveTo(40, 50); ctx.lineTo(50, 65); ctx.lineTo(60, 50); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(canvas.width - 60, 50); ctx.lineTo(canvas.width - 50, 65); ctx.lineTo(canvas.width - 40, 50); ctx.fill();

    // Castle window arches with ominous glow
    const windowGlow = m && m.enraged ? 'rgba(220, 38, 38, 0.4)' : 'rgba(14, 165, 233, 0.3)';
    ctx.fillStyle = windowGlow;
    ctx.fillRect(80, 10, 30, 25);
    ctx.fillRect(canvas.width - 110, 10, 30, 25);
    ctx.beginPath();
    ctx.arc(95, 10, 15, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(canvas.width - 95, 10, 15, Math.PI, 0);
    ctx.fill();

    // Throne room floor with perspective tiles
    const floorGradient = ctx.createLinearGradient(0, 35, 0, canvas.height);
    floorGradient.addColorStop(0, '#1f1f35');
    floorGradient.addColorStop(1, '#0f0f20');
    ctx.fillStyle = floorGradient;
    ctx.fillRect(0, 35, canvas.width, canvas.height - 35);

    // Floor tile grid with perspective effect
    ctx.strokeStyle = m && m.enraged ? '#4a1515' : '#2d2d48';
    ctx.lineWidth = 1;
    for (let x = 24; x < canvas.width - 24; x += 24) {
        ctx.beginPath();
        ctx.moveTo(x, 35);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 35; y < canvas.height; y += 18) {
        ctx.beginPath();
        ctx.moveTo(24, y);
        ctx.lineTo(canvas.width - 24, y);
        ctx.stroke();
    }

    // Golden carpet runner in center
    ctx.fillStyle = m && m.enraged ? '#7f1d1d' : '#92400e';
    ctx.fillRect(canvas.width / 2 - 30, 35, 60, canvas.height - 35);
    ctx.fillStyle = m && m.enraged ? '#dc2626' : '#f59e0b';
    ctx.fillRect(canvas.width / 2 - 26, 35, 52, canvas.height - 35);
    // Carpet pattern
    ctx.fillStyle = m && m.enraged ? '#7f1d1d' : '#b45309';
    for (let cy = 45; cy < canvas.height; cy += 30) {
        ctx.fillRect(canvas.width / 2 - 20, cy, 40, 8);
    }

    // Arena edge glow line
    ctx.fillStyle = m && m.enraged ? '#dc2626' : '#ff9900';
    ctx.fillRect(24, 33, canvas.width - 48, 3);

    // Phase transition overlay
    if (m && m.phaseTransition) {
        const alpha = Math.min(0.6, m.transitionTimer / 30);
        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Phase name announcement
        if (m.transitionTimer > 20) {
            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillStyle = '#ff9900';
            const shake = Math.sin(m.transitionTimer * 0.5) * 2;
            ctx.fillText(m.phaseNames[m.currentPhase], canvas.width / 2 + shake, canvas.height / 2 - 10);
            ctx.font = '6px "Press Start 2P"';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(m.phaseTaunts[m.currentPhase], canvas.width / 2, canvas.height / 2 + 10);
            ctx.restore();
        }
    }

    // Draw boss with enrage glow
    if (m) {
        // Enrage aura
        if (m.enraged && m.enrageFlash < 10) {
            ctx.fillStyle = 'rgba(220, 38, 38, 0.3)';
            ctx.beginPath();
            ctx.arc(m.x + 32, m.y + 32, 45 + Math.sin(GAME.ticks * 0.1) * 5, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.drawImage(GFX.mechaJeff, m.x, m.y);
    }

    // Draw player
    if (GAME.player.iframe > 0 && GAME.player.iframe % 6 < 3) {
        ctx.globalAlpha = 0.5;
    }
    ctx.drawImage(GFX.chars[GAME.selectedChar], GAME.player.x, GAME.player.y);
    ctx.globalAlpha = 1;

    if (m) {
        // Draw shadows (package warning indicators)
        m.shadows.forEach(s => {
            const pulse = Math.sin(s.timer * 0.2) * 0.3 + 0.5;
            ctx.fillStyle = `rgba(239, 68, 68, ${pulse})`;
            ctx.beginPath();
            ctx.ellipse(s.x + 8, canvas.height - 16, 12 - s.timer * 0.15, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            // Warning X
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(s.x + 2, canvas.height - 22);
            ctx.lineTo(s.x + 14, canvas.height - 10);
            ctx.moveTo(s.x + 14, canvas.height - 22);
            ctx.lineTo(s.x + 2, canvas.height - 10);
            ctx.stroke();
        });

        // Draw projectiles
        m.projectiles.forEach(pr => {
            if (pr.type === 'missile') {
                // Draw trail
                if (pr.trail) {
                    for (let i = 0; i < pr.trail.length; i++) {
                        const t = pr.trail[i];
                        const alpha = i / pr.trail.length * 0.6;
                        ctx.fillStyle = `rgba(255, 100, 50, ${alpha})`;
                        ctx.fillRect(t.x + 3, t.y + 3, 4, 4);
                    }
                }
                // Missile body
                ctx.fillStyle = '#dc2626';
                ctx.fillRect(pr.x, pr.y, 10, 10);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(pr.x + 2, pr.y + 2, 6, 6);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(pr.x + 4, pr.y + 4, 2, 2);
            }
            if (pr.type === 'drone') {
                const pulse = Math.sin((pr.pulseTimer || 0) * 0.1) * 2;
                ctx.fillStyle = '#22d3ee';
                ctx.fillRect(pr.x - pulse/2, pr.y - pulse/2, 12 + pulse, 12 + pulse);
                ctx.fillStyle = '#0ea5e9';
                ctx.fillRect(pr.x + 2, pr.y + 2, 8, 8);
                // Propeller animation
                ctx.fillStyle = '#ffffff';
                const propAngle = (pr.pulseTimer || 0) % 4;
                if (propAngle < 2) {
                    ctx.fillRect(pr.x - 3, pr.y + 5, 4, 2);
                    ctx.fillRect(pr.x + 11, pr.y + 5, 4, 2);
                } else {
                    ctx.fillRect(pr.x + 4, pr.y - 3, 4, 2);
                    ctx.fillRect(pr.x + 4, pr.y + 13, 4, 2);
                }
            }
            if (pr.type === 'box') {
                ctx.save();
                ctx.translate(pr.x + 7, pr.y + 7);
                ctx.rotate(pr.rotation || 0);
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(-7, -7, 14, 14);
                ctx.fillStyle = '#92400e';
                ctx.fillRect(-5, 3, 10, 2);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(-5, -5, 10, 3);
                ctx.restore();
            }
            if (pr.type === 'shockwave') {
                ctx.fillStyle = '#a855f7';
                ctx.beginPath();
                ctx.arc(pr.x, pr.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#e879f9';
                ctx.beginPath();
                ctx.arc(pr.x, pr.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // Draw beams (laser grid)
        m.beams.forEach(beam => {
            if (beam.telegraph > 0) {
                // Telegraph warning line
                const pulse = Math.sin(beam.telegraph * 0.3) * 0.2 + 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.fillRect(beam.x, 35, 14, canvas.height - 35);
                // Warning text
                ctx.fillStyle = '#ff0000';
                ctx.font = '4px "Press Start 2P"';
                ctx.fillText('!', beam.x + 5, 50);
            } else {
                // Active beam
                ctx.fillStyle = 'rgba(14, 165, 233, 0.6)';
                ctx.fillRect(beam.x - 2, 35, 18, canvas.height - 35);
                ctx.fillStyle = '#38bdf8';
                ctx.fillRect(beam.x + 2, 35, 10, canvas.height - 35);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(beam.x + 5, 35, 4, canvas.height - 35);
            }
        });
    }

    // Draw player projectiles (attacks)
    GAME.projectiles.forEach(proj => {
        if (proj.type === 'attack') {
            const sprite = (GFX.attacks && GFX.attacks[proj.owner]) ? GFX.attacks[proj.owner] : GFX.book;
            // Glow effect behind projectile
            ctx.fillStyle = proj.color || '#00ffff';
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.arc(proj.x + 6, proj.y + 6, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            // Draw the projectile sprite
            ctx.drawImage(sprite, proj.x, proj.y);
        }
    });

    // Particles
    GAME.particles.forEach(p => {
        const alpha = p.alpha || (p.life / 50);
        ctx.globalAlpha = Math.min(1, alpha);
        if (p.sparkle) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(p.x - 1, p.y, 3, 1);
            ctx.fillRect(p.x, p.y - 1, 1, 3);
        }
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size || 2, p.size || 2);
        ctx.globalAlpha = 1;
    });

    // Floating texts
    GAME.floatingTexts.forEach(t => {
        ctx.fillStyle = t.color;
        ctx.font = '6px "Press Start 2P"';
        ctx.fillText(t.text, t.x, t.y);
    });
}

// === THRONE CONFRONTATION CUTSCENE ===
function drawThroneConfrontation() {
    const t = GAME.stateTimer;
    const scene = GAME.throneScene;
    if (!scene) return;

    // Dark throne room background
    const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGrad.addColorStop(0, '#050510');
    bgGrad.addColorStop(0.3, '#0a0a18');
    bgGrad.addColorStop(0.7, '#1a1a2e');
    bgGrad.addColorStop(1, '#0b1224');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Dramatic torchlight flicker
    const flickerIntensity = 0.1 + Math.sin(t * 0.15) * 0.05;
    ctx.fillStyle = `rgba(255, 120, 40, ${flickerIntensity})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw the massive throne in the center-top
    const throneX = canvas.width / 2;
    const throneY = 40;

    // Throne backing - massive golden structure
    ctx.fillStyle = '#2d1810';
    ctx.fillRect(throneX - 60, throneY - 15, 120, 80);
    ctx.fillStyle = '#4a2818';
    ctx.fillRect(throneX - 55, throneY - 10, 110, 70);

    // Throne spires (taller, more imposing)
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(throneX - 58, throneY - 40, 10, 35);
    ctx.fillRect(throneX + 48, throneY - 40, 10, 35);
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.moveTo(throneX - 58, throneY - 40);
    ctx.lineTo(throneX - 53, throneY - 55);
    ctx.lineTo(throneX - 48, throneY - 40);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(throneX + 48, throneY - 40);
    ctx.lineTo(throneX + 53, throneY - 55);
    ctx.lineTo(throneX + 58, throneY - 40);
    ctx.fill();

    // Amazon logo on throne (glowing and pulsing)
    const logoPulse = Math.sin(t * 0.08) * 0.2 + 0.8;
    ctx.fillStyle = `rgba(255, 153, 0, ${logoPulse})`;
    ctx.fillRect(throneX - 25, throneY + 5, 50, 20);
    ctx.fillStyle = '#ffb347';
    ctx.fillRect(throneX - 20, throneY + 8, 40, 14);
    // Amazon arrow/smile
    ctx.fillStyle = '#ff6600';
    ctx.beginPath();
    ctx.moveTo(throneX - 15, throneY + 18);
    ctx.quadraticCurveTo(throneX, throneY + 28, throneX + 15, throneY + 15);
    ctx.lineTo(throneX + 20, throneY + 18);
    ctx.quadraticCurveTo(throneX, throneY + 32, throneX - 18, throneY + 20);
    ctx.fill();

    // Ornate throne armrests
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(throneX - 52, throneY + 40, 16, 25);
    ctx.fillRect(throneX + 36, throneY + 40, 16, 25);

    // Menacing glow behind Bezos
    const glowSize = 60 + Math.sin(t * 0.06) * 10;
    const glowGrad = ctx.createRadialGradient(throneX, throneY + 45, 10, throneX, throneY + 45, glowSize);
    glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.6)');
    glowGrad.addColorStop(0.4, 'rgba(220, 38, 38, 0.3)');
    glowGrad.addColorStop(0.7, 'rgba(139, 0, 0, 0.15)');
    glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(throneX, throneY + 45, glowSize, 0, Math.PI * 2);
    ctx.fill();

    // Draw Jeff Bezos on throne (larger, more imposing)
    const jeffBob = Math.sin(t * 0.04) * 2;
    ctx.save();
    ctx.translate(throneX, throneY + 35 + jeffBob);
    ctx.scale(1.5, 1.5);
    ctx.drawImage(GFX.jeffYard, -24, -24);
    ctx.restore();

    // Draw player character at bottom facing Bezos
    const playerY = canvas.height - 50;
    const playerX = canvas.width / 2;
    const playerBob = Math.sin(t * 0.06) * 1;
    ctx.save();
    ctx.translate(playerX, playerY + playerBob);
    ctx.scale(1.3, 1.3);
    ctx.drawImage(GFX.chars[GAME.selectedChar], -8, -8);
    ctx.restore();

    // VS text or confrontation indicator
    if (scene.phase >= 1) {
        ctx.fillStyle = '#dc2626';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        const vsFlash = Math.sin(t * 0.1) > 0 ? '#ff4444' : '#dc2626';
        ctx.fillStyle = vsFlash;
        ctx.fillText('VS', canvas.width / 2, canvas.height / 2 - 10);
    }

    // Dialogue box
    if (scene.phase >= 1 && scene.dialogueIndex < scene.dialogues.length) {
        const dialogue = scene.dialogues[scene.dialogueIndex];

        // Dialogue box background
        const boxY = canvas.height - 70;
        const boxH = 55;
        ctx.fillStyle = 'rgba(10, 5, 15, 0.95)';
        ctx.fillRect(10, boxY, canvas.width - 20, boxH);

        // Border color based on speaker
        ctx.strokeStyle = dialogue.speaker === 'BEZOS' ? '#ff9900' : '#38bdf8';
        ctx.lineWidth = 2;
        ctx.strokeRect(10, boxY, canvas.width - 20, boxH);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        ctx.strokeRect(12, boxY + 2, canvas.width - 24, boxH - 4);

        // Speaker name
        ctx.fillStyle = dialogue.color;
        ctx.font = '7px "Press Start 2P"';
        ctx.textAlign = 'left';
        ctx.fillText(dialogue.speaker + ':', 18, boxY + 16);

        // Dialogue text (with typewriter effect - faster)
        const charCount = Math.min(dialogue.text.length, Math.floor(scene.dialogueTimer * 1.5));
        const displayText = dialogue.text.substring(0, charCount);
        ctx.fillStyle = '#ffffff';
        ctx.font = '6px "Press Start 2P"';
        // Word wrap the text
        const words = displayText.split(' ');
        let line = '';
        let lineY = boxY + 30;
        words.forEach(word => {
            const testLine = line + word + ' ';
            if (ctx.measureText(testLine).width > canvas.width - 40) {
                ctx.fillText(line, 18, lineY);
                line = word + ' ';
                lineY += 12;
            } else {
                line = testLine;
            }
        });
        ctx.fillText(line, 18, lineY);
    }

    // Phase 2: Dramatic transition effect before transformation
    if (scene.phase === 2) {
        const fadeProgress = GAME.stateTimer / 30;
        ctx.fillStyle = `rgba(255, 100, 0, ${fadeProgress * 0.5})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Energy crackling around Bezos
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2 + t * 0.1;
            const dist = 30 + Math.sin(t * 0.2 + i) * 10;
            const ex = throneX + Math.cos(angle) * dist;
            const ey = throneY + 45 + Math.sin(angle) * dist;
            ctx.fillStyle = i % 2 === 0 ? '#ffff00' : '#ff6600';
            ctx.beginPath();
            ctx.arc(ex, ey, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    ctx.textAlign = 'left';
}

// === MECHA TRANSFORMATION CUTSCENE ===
function drawMechaTransform() {
    const t = GAME.stateTimer;

    // Dark dramatic background
    ctx.fillStyle = '#050508';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Lightning flashes
    if (t % 30 < 5 || (t > 60 && t % 20 < 3) || (t > 120 && t % 15 < 4)) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Dramatic lines radiating from center
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
    for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2 + t * 0.02;
        const len = 50 + Math.sin(t * 0.1 + i) * 30;
        ctx.strokeStyle = i % 2 === 0 ? '#ff9900' : '#dc2626';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
        ctx.stroke();
    }
    ctx.restore();

    // Phase 1: Power surge (frames 0-80)
    if (t < 80) {
        const scale = 1 + Math.sin(t * 0.2) * 0.1;
        const shakeX = (Math.random() - 0.5) * (t / 20);
        const shakeY = (Math.random() - 0.5) * (t / 20);

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
        ctx.scale(scale, scale);
        ctx.drawImage(GFX.jeffYard, -24 + shakeX, -24 + shakeY);
        ctx.restore();

        // Warning text
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        const warningFlash = Math.sin(t * 0.15) > 0;
        if (warningFlash) {
            ctx.fillText('!! WARNING !!', canvas.width / 2, 180);
        }
        ctx.fillStyle = '#ff9900';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('TRANSFORMATION', canvas.width / 2, 195);
    }
    // Phase 2: Transformation (frames 80-160)
    else if (t < 160) {
        const progress = (t - 80) / 80;
        const shakeIntensity = 10 + progress * 20;

        // Intense shaking
        const shakeX = (Math.random() - 0.5) * shakeIntensity;
        const shakeY = (Math.random() - 0.5) * shakeIntensity;

        // Morphing between sprites
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);

        // Glowing energy effect
        const glowGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 80);
        glowGrad.addColorStop(0, `rgba(255, 153, 0, ${0.8 - progress * 0.3})`);
        glowGrad.addColorStop(0.5, `rgba(220, 38, 38, ${0.5})`);
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 80, 0, Math.PI * 2);
        ctx.fill();

        // Draw morphing sprites
        if (progress < 0.5) {
            ctx.globalAlpha = 1 - progress * 2;
            ctx.drawImage(GFX.jeffYard, -24 + shakeX, -24 + shakeY);
        }
        ctx.globalAlpha = Math.min(1, progress * 2);
        ctx.drawImage(GFX.mechaBezos, -24 + shakeX, -24 + shakeY);
        ctx.globalAlpha = 1;

        ctx.restore();

        // Text
        const texts = ['NOW WITNESS...', 'TRUE POWER...', 'FINAL FORM!'];
        const textIdx = Math.min(2, Math.floor(progress * 3));
        ctx.fillStyle = progress > 0.7 ? '#ff4444' : '#ff9900';
        ctx.font = '11px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(texts[textIdx], canvas.width / 2, 185);
    }
    // Phase 3: Mecha Reveal (frames 160+)
    else {
        const revealProgress = Math.min(1, (t - 160) / 60);

        // Epic glow
        const glowGrad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2 - 20, 20, canvas.width / 2, canvas.height / 2 - 20, 100);
        glowGrad.addColorStop(0, 'rgba(220, 38, 38, 0.6)');
        glowGrad.addColorStop(0.5, 'rgba(255, 153, 0, 0.3)');
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2 - 20, 100, 0, Math.PI * 2);
        ctx.fill();

        // Mecha Bezos revealed
        const scale = 1 + Math.sin(t * 0.1) * 0.05;
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
        ctx.scale(scale, scale);
        ctx.drawImage(GFX.mechaJeff, -32, -32);
        ctx.restore();

        // Title text
        ctx.fillStyle = '#ff4444';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('MECHA JEFF BEZOS', canvas.width / 2, 175);

        ctx.fillStyle = '#ff9900';
        ctx.font = '9px monospace';
        ctx.fillText('AUTOMATION PROTOCOL ACTIVATED', canvas.width / 2, 195);

        // Continue prompt after delay
        if (t > 200) {
            ctx.fillStyle = '#fff';
            ctx.font = '8px "Press Start 2P"';
            const blink = Math.sin(t * 0.15) > 0;
            if (blink) ctx.fillText('[PRESS SPACE]', canvas.width / 2, 215);
        }
    }

    ctx.textAlign = 'left';
}

function drawCredits() {
    const t = GAME.stateTimer;
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.fillStyle = '#1f2937'; ctx.fillRect(6,6,canvas.width-12, canvas.height-12);
    ctx.drawImage(GFX.erwinFace, canvas.width/2 - 48, 12, 96, 96);
    ctx.fillStyle = '#eab308'; ctx.font = '10px monospace'; ctx.textAlign = 'center';
    ctx.fillText('CONGRATULATIONS! HIDDEN LEVEL CLEARED.', canvas.width/2, 118);

    const credits = [
        'Lead Developer: Erwin Esener',
        'Art Director: Erwin Esener',
        'Sound Engineer: Erwin Esener',
        'QA Lead: Erwin Esener',
        'Logistics Wizard: Erwin Esener',
        'Catering: Erwin Esener',
        'Moral Support: Erwin Esener',
        'Everything Else: Erwin Esener'
    ];
    const startY = canvas.height + 20 - t * 0.25;
    ctx.fillStyle = '#fff'; ctx.font = '9px monospace';
    credits.forEach((line, i) => { ctx.fillText(line, canvas.width/2, startY + i*16); });
    ctx.textAlign = 'left';
    if (GAME.stateTimer > 600) {
        ctx.fillStyle = '#94a3b8'; ctx.font = '8px monospace';
        ctx.fillText('[SPACE TO SKIP]', 8, canvas.height - 10);
    }
}

function draw() {
    if (GAME.state === 'LOSE_SPLASH') { drawSnesSplash(false); return; }
    if (GAME.state === 'WIN_SPLASH') { drawSnesSplash(true); return; }

    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
    let dxShake = 0, dyShake = 0;
    if (GAME.shake > 0) { dxShake = (Math.random() - 0.5) * GAME.shake; dyShake = (Math.random() - 0.5) * GAME.shake; }
    ctx.save(); ctx.translate(dxShake, dyShake);

    if (GAME.state === 'LOGO') { 
        let alpha = 1.0; if(GAME.stateTimer < 30) alpha = GAME.stateTimer / 30; if(GAME.stateTimer > 200) alpha = (240 - GAME.stateTimer) / 40;
        ctx.globalAlpha = Math.max(0, Math.min(1, alpha)); let offset = Math.max(0, 100 - GAME.stateTimer * 2);
        ctx.drawImage(GFX.logo, 28 - offset, 90);
        if (GAME.stateTimer > 80) { ctx.fillStyle = '#fff'; ctx.font = '10px monospace'; ctx.fillText("ERWIN ESENER", 80, 105); ctx.fillStyle = '#eab308'; ctx.font = '14px monospace'; ctx.fillText("PRODUCTIONS", 80, 125); }
        if(GAME.stateTimer > 60 && GAME.stateTimer < 65) { ctx.fillStyle='white'; ctx.fillRect(0,0,256,224); }
        ctx.restore(); return; 
    }
    if (GAME.state === 'INTRO') { 
        ctx.fillStyle='#eab308'; ctx.fillText("THE WAREHOUSE...", 20, 60); ctx.fillStyle='#fff';
        ctx.fillText("Ops Managers obsess over rates.", 20, 90); ctx.fillText("They throw Crazy Requests.", 20, 110);
        ctx.fillText("You must protect Safety.", 20, 130); ctx.fillText("Stop runners. Fix hazards.", 20, 150);
        ctx.fillStyle='#888'; ctx.fillText("[SPACE TO SKIP]", 80, 200); ctx.restore(); return; 
    }
    if (GAME.state === 'STORY') {
        ctx.fillStyle='#eab308'; ctx.font='10px monospace'; ctx.fillText("MISSION BRIEFING", 20, 40); ctx.fillStyle='#fff';
        ctx.fillText("Simon Unglaube asks you to:", 20, 70); ctx.fillText("- Do the safety audit", 20, 90);
        ctx.fillText("- Dodge crazy Ops requests", 20, 110); ctx.fillText("- Push back with rules", 20, 130);
        ctx.fillText("- Deal with 'visitors'", 20, 150); ctx.fillStyle='#888'; ctx.fillText("[PRESS SPACE]", 80, 200); ctx.restore(); return;
    }
    if (GAME.state === 'TITLE') {
        const t = GAME.stateTimer;

        // Premium animated background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.3, '#0a1525');
        grad.addColorStop(0.6, '#0f172a');
        grad.addColorStop(1, '#0a0a18');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated stars
        for (let i = 0; i < 30; i++) {
            const x = (i * 37 + t * 0.3) % canvas.width;
            const y = (i * 61) % canvas.height;
            const twinkle = Math.sin(t * 0.1 + i) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255,255,255,${twinkle * 0.6})`;
            ctx.fillRect(x, y, 1, 1);
        }

        // Animated grid lines with perspective
        const offset = (t * 1.2) % 32;
        ctx.strokeStyle = 'rgba(34, 211, 238, 0.15)';
        ctx.lineWidth = 1;
        for (let i = -1; i < 16; i++) {
            const y = i * 16 + offset;
            const alpha = 0.1 + (y / canvas.height) * 0.2;
            ctx.strokeStyle = `rgba(34, 211, 238, ${alpha})`;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        for (let i = 0; i < 17; i++) {
            ctx.strokeStyle = 'rgba(34, 211, 238, 0.1)';
            ctx.beginPath();
            ctx.moveTo(i * 16, 0);
            ctx.lineTo(i * 16, canvas.height);
            ctx.stroke();
        }

        // Warehouse silhouette at bottom
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(0, 180, canvas.width, 44);
        ctx.fillStyle = '#1a1a2e';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect(i * 32 + 4, 185, 24, 35);
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(i * 32 + 8, 190, 16, 12);
            ctx.fillStyle = '#1a1a2e';
        }

        ctx.textAlign = 'center';

        // Title glow effect
        const glowIntensity = Math.sin(t * 0.08) * 0.3 + 0.7;
        ctx.shadowColor = '#ff9900';
        ctx.shadowBlur = 15 * glowIntensity;

        // Title with multiple layers
        ctx.font = '16px "Press Start 2P"';
        ctx.fillStyle = '#7c2d12';
        ctx.fillText('AMZL WHS QUEST', canvas.width / 2 + 2, 44);
        ctx.fillStyle = '#ea580c';
        ctx.fillText('AMZL WHS QUEST', canvas.width / 2 + 1, 43);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText('AMZL WHS QUEST', canvas.width / 2, 42);
        ctx.shadowBlur = 0;

        // Subtitle with glow
        ctx.shadowColor = '#22d3ee';
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#22d3ee';
        ctx.font = '7px "Press Start 2P"';
        ctx.fillText('SAFETY COORDINATOR EDITION', canvas.width / 2, 60);
        ctx.shadowBlur = 0;

        // Animated character showcase
        const charIdx = Math.floor(t / 90) % 5;
        const chars = ['Carrie', 'Nevena', 'Joao', 'Roman', 'Erwin'];
        const charName = chars[charIdx];
        const charBounce = Math.sin(t * 0.15) * 3;
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(GFX.chars[charName], canvas.width / 2 - 16, 85 + charBounce, 32, 32);
        ctx.restore();

        // Animated prompt with pulse
        const blink = Math.sin(t * 0.12) > 0;
        const pulseScale = 1 + Math.sin(t * 0.1) * 0.05;
        if (blink) {
            ctx.fillStyle = '#fff';
            ctx.font = '9px "Press Start 2P"';
            ctx.fillText('PRESS SPACE', canvas.width / 2, 140);
        }

        // Decorative lines
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(40, 155, 176, 2);
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(60, 160, 136, 1);

        // Credits with style
        ctx.fillStyle = '#64748b';
        ctx.font = '7px monospace';
        ctx.fillText('CREATED BY ERWIN ESENER', canvas.width / 2, 175);
        ctx.fillStyle = '#475569';
        ctx.font = '6px monospace';
        ctx.fillText('© 2024 ERWIN ESENER PRODUCTIONS', canvas.width / 2, 220);

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'HOWTO') {
        const t = GAME.stateTimer;
        // Background gradient
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a1525');
        grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Panel background
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);

        // Title with glow
        ctx.textAlign = 'center';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#fbbf24';
        ctx.font = '14px "Press Start 2P"';
        ctx.fillText('HOW TO PLAY', canvas.width / 2, 35);
        ctx.shadowBlur = 0;

        ctx.textAlign = 'left';
        ctx.font = '9px "Press Start 2P"';

        // Controls section
        ctx.fillStyle = '#22d3ee';
        ctx.fillText('WASD / ARROWS', 25, 65);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '8px monospace';
        ctx.fillText('Navigate the warehouse floor', 25, 80);

        ctx.fillStyle = '#22d3ee';
        ctx.font = '9px "Press Start 2P"';
        ctx.fillText('SPACE', 25, 105);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '8px monospace';
        ctx.fillText('Interact with hazards / Attack', 25, 120);

        // Goal section
        ctx.fillStyle = '#ef4444';
        ctx.font = '9px "Press Start 2P"';
        ctx.fillText('YOUR MISSION:', 25, 150);
        ctx.fillStyle = '#fbbf24';
        ctx.font = '8px monospace';
        ctx.fillText('1. Find and fix 5 safety hazards', 25, 165);
        ctx.fillText('2. Dodge crazy Ops requests!', 25, 180);
        ctx.fillText('3. Defeat the surprise visitor', 25, 195);

        // Animated prompt
        const blink = Math.sin(t * 0.12) > 0;
        if (blink) {
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.font = '8px "Press Start 2P"';
            ctx.fillText('[PRESS SPACE TO CONTINUE]', canvas.width / 2, 215);
        }
        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'SELECT') {
        const t = GAME.stateTimer;
        const frameX = 14, frameY = 22, frameW = 228, frameH = 180;

        // Background gradient
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.5, '#0a1525');
        grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated background particles
        for (let i = 0; i < 20; i++) {
            const x = (i * 31 + t * 0.2) % canvas.width;
            const y = (i * 47 + t * 0.1) % canvas.height;
            ctx.fillStyle = `rgba(251, 191, 36, ${0.1 + Math.sin(t * 0.05 + i) * 0.1})`;
            ctx.fillRect(x, y, 2, 2);
        }

        // Main frame with glow
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(frameX, frameY, frameW, frameH);
        ctx.shadowBlur = 0;

        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.strokeRect(frameX, frameY, frameW, frameH);
        ctx.strokeStyle = '#92400e';
        ctx.strokeRect(frameX + 2, frameY + 2, frameW - 4, frameH - 4);

        // Inner panel
        ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
        ctx.fillRect(frameX + 6, frameY + 35, frameW - 12, frameH - 50);

        ctx.textAlign = 'center';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#fbbf24';
        ctx.font = '11px "Press Start 2P"';
        ctx.fillText("SELECT COORDINATOR", frameX + frameW / 2, frameY + 18);
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#64748b';
        ctx.font = '7px monospace';
        ctx.fillText("< ARROWS TO BROWSE > | SPACE TO START", frameX + frameW / 2, frameY + 30);

        let name = GAME.charList[GAME.charIndex]; let data = CHAR_DATA[name];
        const portraitX = frameX + 18, portraitY = frameY + 46;
        ctx.fillStyle = '#000'; ctx.fillRect(portraitX - 2, portraitY - 2, 56, 56);
        ctx.strokeStyle = '#333'; ctx.strokeRect(portraitX - 4, portraitY - 4, 60, 60);
        ctx.save(); ctx.imageSmoothingEnabled = false; ctx.drawImage(GFX.chars[name], portraitX, portraitY, 52, 52); ctx.restore();

        ctx.fillStyle='#eab308'; ctx.font='12px monospace';
        ctx.fillText("< " + name + " >", frameX + frameW / 2, frameY + 54);

        ctx.textAlign = 'left';
        ctx.font='8px monospace'; ctx.fillStyle='#00ffff';
        const textStartX = portraitX + 70; const textStartY = frameY + 70;
        ctx.fillText("ROLE: " + data.role, textStartX, textStartY);

        const wrapText = (text, maxChars = 30) => {
            const words = text.split(' '); const lines = []; let line = '';
            words.forEach(word => { const candidate = line.length ? line + ' ' + word : word; if (candidate.length > maxChars) { lines.push(line); line = word; } else { line = candidate; } });
            if (line) lines.push(line); return lines;
        };
        const backstoryLines = wrapText(data.backstory, 30).slice(0, 3);
        ctx.fillStyle='#fff'; backstoryLines.forEach((l, idx) => ctx.fillText(l, textStartX, textStartY + 14 + idx * 12));

        ctx.fillStyle='#ff00ff';
        ctx.fillText("ATTACK: " + data.attack, frameX + 18, frameY + frameH - 30);

        ctx.textAlign = 'center';
        ctx.fillStyle='#888'; ctx.font='10px monospace';
        ctx.fillText("PRESS SPACE", frameX + frameW / 2, frameY + frameH - 12);
        ctx.restore(); return;
    }
    if (GAME.state === 'YARD_INTRO') {
        // Dark gradient background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a0a14');
        grad.addColorStop(0.5, '#1a1a2e');
        grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Warning stripes
        ctx.fillStyle = '#facc15';
        for (let i = 0; i < canvas.width; i += 24) {
            ctx.fillRect(i, 0, 12, 6);
            ctx.fillRect(i + 12, canvas.height - 6, 12, 6);
        }

        // Title
        ctx.fillStyle = '#ff9900';
        ctx.font = '16px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('THE YARD', canvas.width / 2, 50);

        // Subtitle
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px "Press Start 2P"';
        ctx.fillText('DANGER ZONE', canvas.width / 2, 70);

        // Instructions
        ctx.fillStyle = '#f0f0ff';
        ctx.font = '9px monospace';
        ctx.fillText('You sneak through the fire exit', canvas.width / 2, 100);
        ctx.fillText('into the Amazon logistics yard.', canvas.width / 2, 115);

        ctx.fillStyle = '#facc15';
        ctx.fillText('Dodge DSP vans and semis!', canvas.width / 2, 140);
        ctx.fillText('Reach the top without getting hit!', canvas.width / 2, 155);

        ctx.fillStyle = '#ef4444';
        ctx.font = '8px monospace';
        ctx.fillText('WARNING: Vehicles WILL reset you!', canvas.width / 2, 175);

        // Prompt
        ctx.fillStyle = '#00ffff';
        ctx.font = '9px "Press Start 2P"';
        const blink = Math.sin(GAME.stateTimer * 0.1) > 0;
        if (blink) ctx.fillText('[PRESS SPACE TO RUN]', canvas.width / 2, 205);

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'YARD_LEVEL') { drawYardLevel(); ctx.restore(); return; }
    if (GAME.state === 'VISITOR_SPLASH') {
        const t = GAME.stateTimer;
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a0f2e');
        gradient.addColorStop(1, '#2a1b44');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let y = -20; y < canvas.height + 20; y += 12) {
            const offset = (t * 2) % 24;
            ctx.fillStyle = y % 24 === 0 ? 'rgba(255,215,0,0.08)' : 'rgba(255,255,255,0.05)';
            ctx.fillRect(((t * 3) + y * 2) % canvas.width, y + offset, canvas.width, 6);
        }

        ctx.save();
        ctx.translate(canvas.width / 2, 90);
        ctx.textAlign = 'center';
        const wobble = 1 + Math.sin(t / 10) * 0.05;
        ctx.scale(wobble, wobble);
        ctx.fillStyle = '#000';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.fillText("SURPRISE VISITOR!", 0, 0);
        ctx.fillStyle = '#eab308';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 8;
        ctx.fillText("SURPRISE VISITOR!", -2, -2);
        ctx.restore();

        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd166';
        ctx.font = '8px monospace';
        ctx.fillText("An unannounced Visitor is stepping onto the floor...", canvas.width / 2, 148);
        ctx.fillStyle = '#fff';
        ctx.fillText("Simon braces: tighten PPE, breathe, and stand tall.", canvas.width / 2, 166);

        ctx.fillStyle = '#ff00ff';
        ctx.font = '10px monospace';
        ctx.fillText("[PRESS SPACE TO CONTINUE]", canvas.width / 2, 204);
        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'MECHA_BOSS_INTRO' && GAME.mecha) {
        ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#eab308'; ctx.font = '16px monospace'; ctx.fillText('MECHA JEFF RISES', 30, 40);
        ctx.drawImage(GFX.mechaJeff, 92, 60, 72, 72);
        ctx.fillStyle = '#fff'; ctx.font = '9px monospace';
        ctx.fillText('Prime Drone Swarm', 20, 150);
        ctx.fillText('2-Day Shipping Storm', 20, 166);
        ctx.fillText('Orbital Beam Audit', 20, 182);
        ctx.fillStyle = '#9ca3af'; ctx.fillText('[PRESS SPACE TO DEFY]', 60, 206);
        ctx.restore(); return;
    }
    if (GAME.state === 'MECHA_BOSS') { drawMechaBattle(); ctx.restore(); return; }
    if (GAME.state === 'THRONE_CONFRONTATION') { drawThroneConfrontation(); ctx.restore(); return; }
    if (GAME.state === 'MECHA_TRANSFORM') { drawMechaTransform(); ctx.restore(); return; }
    if (GAME.state === 'CREDITS') { drawCredits(); ctx.restore(); return; }
    if (GAME.state === 'BOSS_INTRO' && GAME.boss) {
        ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#eab308'; ctx.font = '16px monospace'; ctx.fillText("WARNING", 80, 50);
        ctx.fillStyle = '#ff0000'; ctx.font = '12px monospace'; ctx.fillText(GAME.boss.name.toUpperCase(), 20, 90);
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace'; ctx.fillText(GAME.boss.title, 20, 110);
        ctx.fillStyle = '#888'; ctx.fillText(GAME.boss.desc, 20, 130);
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        const portraitFrameX = 170, portraitFrameY = 70, portraitSize = 88;
        ctx.fillStyle = '#000';
        ctx.fillRect(portraitFrameX - 4, portraitFrameY - 4, portraitSize + 8, portraitSize + 8);
        ctx.strokeStyle = '#444';
        ctx.strokeRect(portraitFrameX - 6, portraitFrameY - 6, portraitSize + 12, portraitSize + 12);
        const bossSprite = (GAME.boss.sprite && GFX[GAME.boss.sprite]) ? GFX[GAME.boss.sprite] : GFX.boss_manager;
        ctx.drawImage(bossSprite, portraitFrameX, portraitFrameY, portraitSize, portraitSize);
        ctx.restore();
        ctx.fillStyle = '#eab308'; ctx.fillText("ATTACK: " + GAME.boss.attackName, 20, 160);
        ctx.fillStyle = '#fff'; ctx.fillText("[PRESS SPACE TO FIGHT]", 50, 200); ctx.restore(); return;
    }

    // Bezos intro screen
    if (GAME.state === 'BEZOS_INTRO' && GAME.boss) {
        ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Dramatic lines
        for (let i = 0; i < 10; i++) {
            ctx.strokeStyle = `rgba(255, 153, 0, ${0.3 - i * 0.03})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(128, 112);
            const angle = (GAME.stateTimer * 0.05 + i * 0.3) % (Math.PI * 2);
            ctx.lineTo(128 + Math.cos(angle) * 200, 112 + Math.sin(angle) * 200);
            ctx.stroke();
        }

        ctx.fillStyle = '#ff9900'; ctx.font = '16px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText("FINAL BOSS", 128, 40);
        ctx.fillStyle = '#ff0000'; ctx.font = '14px "Press Start 2P"';
        ctx.fillText("MECHA JEFF BEZOS", 128, 70);
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace';
        ctx.fillText("AUTOMATION PROTOCOL ACTIVATED", 128, 90);

        // Boss sprite
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(GFX.mechaBezos, 104, 100, 48, 48);
        ctx.restore();

        ctx.fillStyle = '#eab308'; ctx.font = '8px monospace';
        ctx.fillText("PRIME MISSILES READY", 128, 170);
        ctx.fillStyle = '#fff';
        ctx.fillText("[PRESS SPACE]", 128, 200);
        ctx.textAlign = 'left';
        ctx.restore();
        return;
    }

    // Bezos boss fight rendering
    if (GAME.state === 'BEZOS_BOSS') {
        // Space background - changes color when enraged
        const bgColor = GAME.boss && GAME.boss.enraged ? '#140a0a' : '#0a0a14';
        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 256, 224);

        // Stars
        for (let i = 0; i < 50; i++) {
            const x = (i * 37) % 256;
            const y = (i * 61) % 224;
            ctx.fillStyle = GAME.boss && GAME.boss.enraged ? '#ff6666' : '#fff';
            ctx.fillRect(x, y, 1, 1);
        }

        // === FALLING PACKAGES ===
        if (GAME.boss && GAME.boss.fallingPackages) {
            GAME.boss.fallingPackages.forEach(pkg => {
                // Package shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(pkg.x + 2, 210, 10, 4);
                // Package
                ctx.fillStyle = '#a16207';
                ctx.fillRect(pkg.x, pkg.y, pkg.w, pkg.h);
                ctx.fillStyle = '#78350f';
                ctx.fillRect(pkg.x + 2, pkg.y + 2, pkg.w - 4, pkg.h - 4);
                // Amazon smile
                ctx.fillStyle = '#ff9900';
                ctx.fillRect(pkg.x + 3, pkg.y + 6, 6, 2);
                ctx.fillRect(pkg.x + 8, pkg.y + 6, 2, 4);
            });
        }

        // === SHOCKWAVE EFFECT ===
        if (GAME.boss && GAME.boss.shockwaveTimer > 0) {
            const progress = 1 - (GAME.boss.shockwaveTimer / 30);
            const radius = progress * 80;
            const alpha = 1 - progress;
            ctx.strokeStyle = `rgba(255, 153, 0, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(GAME.boss.x + 24, GAME.boss.y + 24, radius, 0, Math.PI * 2);
            ctx.stroke();
            GAME.boss.shockwaveTimer--;
        }

        // Boss
        if (GAME.boss) {
            // Enrage glow effect
            if (GAME.boss.enraged) {
                const glowPulse = Math.sin(GAME.ticks * 0.15) * 10 + 30;
                const glowGrad = ctx.createRadialGradient(
                    GAME.boss.x + 24, GAME.boss.y + 24, 10,
                    GAME.boss.x + 24, GAME.boss.y + 24, glowPulse
                );
                glowGrad.addColorStop(0, 'rgba(255, 0, 0, 0.4)');
                glowGrad.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
                glowGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(GAME.boss.x + 24, GAME.boss.y + 24, glowPulse, 0, Math.PI * 2);
                ctx.fill();
            }

            // Dash trail effect
            if (GAME.boss.dashTarget) {
                ctx.fillStyle = 'rgba(255, 153, 0, 0.3)';
                for (let i = 0; i < 3; i++) {
                    const trailX = GAME.boss.x - (GAME.boss.dashTarget.x - GAME.boss.x) * 0.1 * i;
                    const trailY = GAME.boss.y - (GAME.boss.dashTarget.y - GAME.boss.y) * 0.1 * i;
                    ctx.globalAlpha = 0.3 - i * 0.1;
                    ctx.drawImage(GFX.mechaBezos, trailX, trailY);
                }
                ctx.globalAlpha = 1;
            }

            ctx.drawImage(GFX.mechaBezos, GAME.boss.x, GAME.boss.y);

            // Boss attack indicator
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'center';
            if (GAME.boss.attackPhase === 0) {
                ctx.fillStyle = '#ff9900';
                ctx.fillText('MISSILES', GAME.boss.x + 24, GAME.boss.y - 8);
            } else if (GAME.boss.attackPhase === 1) {
                ctx.fillStyle = '#00ffff';
                ctx.fillText('LASER SWEEP', GAME.boss.x + 24, GAME.boss.y - 8);
            } else if (GAME.boss.attackPhase === 2) {
                ctx.fillStyle = '#ff00ff';
                ctx.fillText('DRONE SWARM', GAME.boss.x + 24, GAME.boss.y - 8);
            }
        }

        // Drones
        GAME.entities.forEach(e => {
            if (e.type === 'drone') {
                ctx.drawImage(GFX.drone, e.x, e.y);
            }
        });

        // Player
        const p = GAME.player;
        if (p.iframe % 4 < 2) {
            ctx.drawImage(GFX.chars[GAME.selectedChar], p.x, p.y);
        }

        // Projectiles
        GAME.projectiles.forEach(proj => {
            if (proj.type === 'bezos_missile') {
                ctx.drawImage(GFX.bezosProj, proj.x, proj.y);
            } else if (proj.type === 'bezos_laser') {
                // Render laser beam
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillRect(proj.x - 2, proj.y - 2, 6, 6);
                ctx.shadowBlur = 0;
            } else if (proj.type === 'attack') {
                const sprite = (GFX.attacks && GFX.attacks[proj.owner]) ? GFX.attacks[proj.owner] : GFX.book;
                ctx.drawImage(sprite, proj.x, proj.y);
            }
        });

        ctx.restore();
        return;
    }

    // Bezos victory screen
    if (GAME.state === 'BEZOS_WIN') {
        // Victory gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a4d1a');
        gradient.addColorStop(1, '#0a1a0a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Fireworks effect
        for (let i = 0; i < 20; i++) {
            const x = (i * 31 + GAME.stateTimer * 2) % 256;
            const y = (i * 47 + GAME.stateTimer * 3) % 224;
            const colors = ['#ff9900', '#ffd700', '#ff6b6b', '#4ecdc4'];
            ctx.fillStyle = colors[i % colors.length];
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.textAlign = 'center';
        ctx.font = '16px "Press Start 2P"';
        ctx.fillStyle = '#ffd700';
        ctx.fillText("CONGRATULATIONS!", 128, 40);

        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = '#fff';
        ctx.fillText("YOU DEFEATED", 128, 70);
        ctx.fillText("MECHA JEFF BEZOS!", 128, 90);

        // Digitized face (using character sprite as placeholder)
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        const faceSize = 64;
        ctx.fillStyle = '#000';
        ctx.fillRect(96, 100, faceSize, faceSize);
        ctx.drawImage(GFX.chars[GAME.selectedChar], 96, 100, faceSize, faceSize);
        ctx.restore();

        ctx.font = '10px "Press Start 2P"';
        ctx.fillStyle = '#00ff00';
        ctx.fillText("TRUE HERO OF WHS!", 128, 175);

        // Credits
        ctx.font = '8px monospace';
        ctx.fillStyle = '#888';
        const creditsY = 190;
        ctx.fillText("CREDITS:", 128, creditsY);
        const credits = ["Director: Erwin Esener", "Producer: Erwin Esener", "Lead Dev: Erwin Esener", "Art: Erwin Esener", "Music: Erwin Esener"];
        credits.forEach((credit, i) => {
            ctx.fillText(credit, 128, creditsY + 12 + i * 10);
        });

        ctx.textAlign = 'left';
        ctx.restore();
        return;
    }

    const cx = Math.floor(GAME.camera.x); const cy = Math.floor(GAME.camera.y);
    let sx = Math.floor(cx/TILE_SIZE); let ex = sx + 17; let sy = Math.floor(cy/TILE_SIZE); let ey = sy + 15;
    for(let y=sy; y<=ey; y++) {
        for(let x=sx; x<=ex; x++) {
            if(x>=0 && x<MAP_W && y>=0 && y<MAP_H) {
                let t = GAME.map[y][x]; let dx = x*TILE_SIZE - cx; let dy = y*TILE_SIZE - cy;
                if (t===0) ctx.drawImage(GFX.floor, dx, dy); if (t===1) ctx.drawImage(GFX.wall, dx, dy);
                if (t===2) { ctx.drawImage(GFX.floor, dx, dy); ctx.drawImage(GFX.shelf, dx, dy); }
                if (t===3) {
                    ctx.drawImage(GFX.wall, dx, dy);
                    ctx.drawImage(GFX.door, dx, dy);
                    // Glow effect when door is accessible (4+ hazards cleared)
                    if (GAME.issuesFixed >= 4 && GAME.fireExitDoor) {
                        const pulse = Math.sin(GAME.ticks * 0.1) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(255, 215, 0, ${pulse * 0.4})`;
                        ctx.fillRect(dx - 2, dy - 2, 20, 20);
                    }
                }
            }
        }
    }

    GAME.clutter.forEach(c => { let img = GFX.clutter[c.type]; if(img) ctx.drawImage(img, c.x-cx, c.y-cy); });
    GAME.activeIssues.forEach(h => { if(!h.fixed) { let img = GFX.hazards[h.data.type] || GFX.hazards.box; ctx.drawImage(img, h.x-cx, h.y-cy); } });

    // === WAREHOUSE ATMOSPHERE RENDERING ===
    if (GAME.state === 'PLAY' || GAME.state === 'BOSS') {
        // Draw conveyor belts with animated texture
        const conveyorOffset = (GAME.ticks * 0.5) % 8;
        GAME.conveyorBelts.forEach(belt => {
            const dx = belt.x - cx;
            const dy = belt.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.conveyorBelt, dx, dy);
                // Animated belt line
                ctx.fillStyle = '#555';
                const lineOffset = belt.dir > 0 ? conveyorOffset : -conveyorOffset;
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(dx + ((lineOffset + i * 8) % 16), dy + 7, 3, 2);
                }
            }
        });

        // Draw packages on conveyors
        GAME.packages.forEach(pkg => {
            const dx = pkg.x - cx;
            const dy = pkg.y - cy;
            if (dx > -20 && dx < 272 && dy > -20 && dy < 240) {
                const sprite = pkg.type === 'small' ? GFX.packageSmall : GFX.packageLarge;
                ctx.drawImage(sprite, dx, dy);
            }
        });

        // Draw pallet stacks (static)
        GAME.palletStacks.forEach(pallet => {
            const dx = pallet.x - cx;
            const dy = pallet.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.palletStack, dx, dy);
            }
        });

        // Draw sorting stations
        GAME.sortStations.forEach(station => {
            const dx = station.x - cx;
            const dy = station.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.sortStation, dx, dy);
            }
        });

        // Draw warehouse zone signs
        GAME.warehouseSigns.forEach(sign => {
            const dx = sign.x - cx;
            const dy = sign.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                if (sign.type === 'pick') ctx.drawImage(GFX.signPick, dx, dy);
                else if (sign.type === 'pack') ctx.drawImage(GFX.signPack, dx, dy);
                else if (sign.type === 'ship') ctx.drawImage(GFX.signShip, dx, dy);
            }
        });

        // Draw cart workers
        GAME.cartWorkers.forEach(worker => {
            const dx = worker.x - cx;
            const dy = worker.y - cy;
            if (dx > -24 && dx < 272 && dy > -20 && dy < 240) {
                ctx.save();
                if (worker.dir < 0) {
                    // Flip horizontally when going left
                    ctx.translate(dx + 10, dy);
                    ctx.scale(-1, 1);
                    ctx.drawImage(GFX.cartWorker, -10, 0);
                } else {
                    ctx.drawImage(GFX.cartWorker, dx, dy);
                }
                ctx.restore();
            }
        });
    }

    let renderList = [GAME.player, ...GAME.entities, ...GAME.projectiles];
    if (GAME.state === 'BOSS' && GAME.boss) renderList.push(GAME.boss);
    renderList.sort((a,b) => a.y - b.y);

    renderList.forEach(e => {
        let dx = Math.floor(e.x - cx); let dy = Math.floor(e.y - cy);
        if (e.maxHp) {
            let img = (e.sprite && GFX[e.sprite]) ? GFX[e.sprite] : GFX.boss_manager;
            if (e.name === "SIMON UNGLAUBE") img = GFX.simonBoss;
            ctx.drawImage(img, dx, dy, 32, 32);
        } else {
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(dx+8, dy+14, 6, 3, 0, 0, Math.PI*2); ctx.fill();
            if (e.type === 'simon') ctx.drawImage(GFX.simon, dx, dy);
            else if (e.type === 'ops') ctx.drawImage(GFX.ops, dx, dy);
            else if (e.type === 'assoc') ctx.drawImage(GFX.assoc, dx, dy);
            else if (e.type === 'runner') ctx.drawImage(GFX.runner, dx, dy);
            else if (e === GAME.player) {
                if (e.iframe%4 < 2) ctx.drawImage(GFX.chars[GAME.selectedChar], dx, dy);
                if (e.cooldown > 0) { ctx.fillStyle = '#555'; ctx.fillRect(dx, dy-4, 16, 2); ctx.fillStyle = '#00ffff'; ctx.fillRect(dx, dy-4, 16 * (1 - e.cooldown/Math.max(1, e.cooldownMax || 120)), 2); }
                else { ctx.fillStyle = '#00ff00'; ctx.fillRect(dx+6, dy-6, 4, 4); }
            }
            else if (e.type === 'attack') {
                const sprite = (GFX.attacks && GFX.attacks[e.owner]) ? GFX.attacks[e.owner] : GFX.book;
                ctx.drawImage(sprite, dx+2, dy+4);
            }
            else if (e.type === 'book') ctx.drawImage(GFX.book, dx, dy);
            else if (e.type === 'req') { if (e.boss) ctx.drawImage(GFX.bossProj, dx, dy); else ctx.drawImage(GFX.req, dx, dy); }
        }
    });

    GAME.particles.forEach(p => {
        const alpha = p.alpha || (p.life / 50);
        ctx.globalAlpha = Math.min(1, alpha);
        if (p.sparkle) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(p.x - cx - 1, p.y - cy, 3, 1);
            ctx.fillRect(p.x - cx, p.y - cy - 1, 1, 3);
        }
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - cx, p.y - cy, p.size || 2, p.size || 2);
        ctx.globalAlpha = 1;
    });

    // Render Floating Text
    ctx.font = '8px "Press Start 2P"'; ctx.textAlign = 'center';
    GAME.floatingTexts.forEach(t => {
        let dx = Math.floor(t.x - cx); let dy = Math.floor(t.y - cy);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.strokeText(t.text, dx, dy);
        ctx.fillStyle = t.color; ctx.fillText(t.text, dx, dy);
    });
    ctx.textAlign = 'left'; // Reset

    if (GAME.flash > 0) { ctx.globalAlpha = GAME.flash / 10; ctx.fillStyle = 'white'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.globalAlpha = 1.0; }
    ctx.restore();
}

function updateCamera() {
    GAME.camera.x = Math.max(0, Math.min(GAME.player.x - 120, MAP_W*TILE_SIZE - 256));
    GAME.camera.y = Math.max(0, Math.min(GAME.player.y - 100, MAP_H*TILE_SIZE - 224));
}

// Frame rate independence - target 60 FPS
let lastFrameTime = performance.now();
const TARGET_FPS = 60;
const TARGET_FRAME_TIME = 1000 / TARGET_FPS;

function loop() {
    const now = performance.now();
    const elapsed = now - lastFrameTime;

    // Only update game logic when enough time has passed (targeting 60 FPS)
    if (elapsed >= TARGET_FRAME_TIME) {
        // Handle multiple frames if we're running behind (but cap at 3 to prevent spiral)
        const framesToRun = Math.min(Math.floor(elapsed / TARGET_FRAME_TIME), 3);
        for (let i = 0; i < framesToRun; i++) {
            update();
        }
        lastFrameTime = now - (elapsed % TARGET_FRAME_TIME);
    }

    draw();
    requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
