<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMZL WHS Coordinator Quest</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #0a0a12;
            --accent-gold: #ffd700;
            --accent-cyan: #00ffff;
            --accent-orange: #ff9900;
        }

        body {
            margin: 0; padding: 0;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a12 50%, #000 100%);
            display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden;
            font-family: 'Press Start 2P', monospace; color: white; user-select: none;
        }

        #game-wrapper {
            position: relative; width: 768px; height: 672px;
            background: linear-gradient(135deg, #0f0f1a 0%, #000 100%);
            border: 4px solid #333;
            border-radius: 24px;
            box-shadow:
                0 0 60px rgba(255, 153, 0, 0.15),
                0 0 120px rgba(0, 255, 255, 0.08),
                inset 0 0 60px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #game-wrapper::before {
            content: '';
            position: absolute;
            top: -4px; left: -4px; right: -4px; bottom: -4px;
            background: linear-gradient(45deg, #ff9900, #00ffff, #ff00ff, #ff9900);
            background-size: 400% 400%;
            animation: borderGlow 8s ease infinite;
            border-radius: 28px;
            z-index: -1;
            opacity: 0.5;
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        #crt-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background:
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%),
                linear-gradient(90deg, rgba(255, 100, 0, 0.03), rgba(0, 255, 100, 0.02), rgba(100, 0, 255, 0.03));
            background-size: 100% 3px, 4px 100%; pointer-events: none; z-index: 900;
            animation: flicker 0.08s infinite, scanline 10s linear infinite;
        }

        @keyframes scanline {
            0% { background-position: 0 0, 0 0; }
            100% { background-position: 0 100%, 0 0; }
        }

        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(0,0,0,0.5) 80%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 901; border-radius: 20px;
        }

        @keyframes flicker {
            0%, 100% { opacity: 0.97; }
            50% { opacity: 1; }
        }

        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: flex-end; padding: 20px; box-sizing: border-box; z-index: 1000;
        }

        #dialog-box {
            width: 100%; min-height: 140px;
            background: linear-gradient(180deg, #0a1628 0%, #061020 100%);
            border: 3px solid #3b82f6;
            border-radius: 12px; display: none;
            flex-direction: row; padding: 16px; box-sizing: border-box;
            box-shadow:
                0 0 20px rgba(59, 130, 246, 0.4),
                6px 6px 0px rgba(0,0,0,0.6),
                inset 0 0 30px rgba(59, 130, 246, 0.1);
            pointer-events: auto;
        }

        #portrait {
            width: 64px; height: 64px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a14 100%);
            border: 3px solid #ffd700;
            border-radius: 8px;
            margin-right: 20px; flex-shrink: 0; image-rendering: pixelated;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        #text-content {
            flex-grow: 1; font-size: 13px; line-height: 1.7; color: #f0f0ff;
            text-shadow: 2px 2px 4px #000, 0 0 10px rgba(255, 255, 255, 0.1);
            white-space: pre-wrap;
        }

        #press-space-hint {
            font-size: 10px; color: #ffd700; margin-top: 10px;
            animation: blink 0.8s ease-in-out infinite; display: block;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }

        .gemini-badge {
            font-size: 9px; color: #00ffff; margin-bottom: 8px; display: none;
            text-transform: uppercase; text-shadow: 0 0 8px #00ffff;
            letter-spacing: 1px;
        }

        .loading-dots::after {
            content: ' .';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: ' .'; }
            40% { content: ' ..'; }
            60% { content: ' ...'; }
            80%, 100% { content: ''; }
        }

        /* INTRO CONVERSATION CENTERED PORTRAIT WINDOW */
        #intro-portrait-window {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #0a1628 0%, #061020 100%);
            border: 4px solid #ffd700;
            border-radius: 16px;
            padding: 24px;
            box-shadow:
                0 0 30px rgba(255, 215, 0, 0.6),
                8px 8px 0px rgba(0,0,0,0.8),
                inset 0 0 40px rgba(255, 215, 0, 0.15);
            z-index: 1000;
            max-width: 600px;
            pointer-events: auto;
            animation: intro-window-appear 0.3s ease-out;
        }

        @keyframes intro-window-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        #intro-portrait-frame {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        #intro-portrait {
            width: 128px;
            height: 128px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a14 100%);
            border: 4px solid #ffd700;
            border-radius: 12px;
            image-rendering: pixelated;
            box-shadow:
                0 0 20px rgba(255, 215, 0, 0.4),
                inset 0 0 20px rgba(255, 215, 0, 0.1);
            margin-bottom: 12px;
        }

        #intro-speaker-name {
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
            text-shadow:
                2px 2px 4px #000,
                0 0 15px rgba(255, 215, 0, 0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #intro-dialog-content {
            display: flex;
            flex-direction: column;
            min-height: 120px;
        }

        #intro-text-content {
            flex-grow: 1;
            font-size: 15px;
            line-height: 1.8;
            color: #f0f0ff;
            text-shadow: 2px 2px 4px #000, 0 0 10px rgba(255, 255, 255, 0.1);
            white-space: pre-wrap;
            text-align: center;
            padding: 0 20px;
        }

        #intro-press-space-hint {
            font-size: 12px;
            color: #ffd700;
            margin-top: 16px;
            animation: blink 0.8s ease-in-out infinite;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }

        #intro-gemini-badge {
            font-size: 10px;
            color: #00ffff;
            margin-bottom: 12px;
            text-transform: uppercase;
            text-shadow: 0 0 10px #00ffff;
            letter-spacing: 1px;
            text-align: center;
        }

        /* Banner hidden as requested */
        #slogan-display {
            display: none; 
        }
        
        @keyframes blink { 50% { opacity: 0; } }

        .hud-text {
            position: absolute; top: 12px; right: 12px; color: white;
            text-align: right; text-shadow: 0 0 8px rgba(0,0,0,0.8), 2px 2px 4px black; font-size: 11px;
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(135deg, rgba(10, 15, 30, 0.95) 0%, rgba(5, 8, 20, 0.98) 100%);
            padding: 10px 14px; border: 2px solid #fbbf24; border-radius: 6px;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4), inset 0 0 15px rgba(0, 0, 0, 0.6), 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        .hud-text div:first-child { color: #ef4444; margin-bottom: 6px; letter-spacing: 1px; }
        .hud-text div:last-child { color: #22c55e; letter-spacing: 1px; }

        #boss-hud {
            position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
            width: 65%; display: none;
            background: linear-gradient(180deg, rgba(40, 10, 10, 0.9) 0%, rgba(20, 5, 5, 0.95) 100%);
            padding: 10px 16px; border-radius: 10px;
            border: 2px solid #dc2626;
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.4);
        }

        .boss-bar-bg {
            width: 100%; height: 14px;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #444; border-radius: 4px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
        }
        .boss-bar-fill {
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #ff4444 0%, #cc0000 50%, #aa0000 100%);
            transition: width 0.3s ease-out;
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5), inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }
        .boss-name {
            color: #ff4444; text-align: center; font-size: 11px; margin-bottom: 6px;
            text-shadow: 2px 2px 4px black, 0 0 10px rgba(255, 0, 0, 0.5);
            letter-spacing: 2px;
        }
        
        #ai-status {
            display: none !important; 
            position: absolute; top: 10px; left: 10px; font-size: 10px; color: #00ffff;
            background: rgba(0,0,0,0.8); padding: 4px; border: 1px solid #00ffff; pointer-events: none;
            z-index: 2000; 
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="ai-status">AI Status: Init</div>
        <canvas id="gameCanvas" width="256" height="224"></canvas>
        <div id="crt-overlay"></div>
        <div id="vignette"></div>

        <div id="ui-overlay">
            <div id="slogan-display"></div>

            <div class="hud-text" id="hud-layer" style="display:none;">
                <div style="color:#ff4444; margin-bottom:5px;">LIFE <span id="life-val">❤️❤️❤️❤️❤️</span></div>
                <div style="color:#44ff44;">HAZARDS: <span id="score-val">0/5</span></div>
            </div>
        
            <div id="boss-hud">
                <div class="boss-name" id="boss-name-el">BOSS NAME</div>
                <div class="boss-bar-bg"><div class="boss-bar-fill" id="boss-health-el"></div></div>
            </div>

            <div id="dialog-box">
                <canvas id="portrait" width="48" height="48"></canvas>
                <div style="display:flex; flex-direction:column; width:100%;">
                    <div id="gemini-badge" class="gemini-badge">✨ SIMON IS ANALYZING...</div>
                    <div id="text-content"></div>
                    <div id="press-space-hint">▼ PRESS SPACE</div>
                </div>
            </div>

            <!-- INTRO CONVERSATION CENTERED PORTRAIT WINDOW -->
            <div id="intro-portrait-window">
                <div id="intro-portrait-frame">
                    <canvas id="intro-portrait" width="96" height="96"></canvas>
                    <div id="intro-speaker-name"></div>
                </div>
                <div id="intro-dialog-content">
                    <div id="intro-gemini-badge" class="gemini-badge">✨ UPLINK ESTABLISHED...</div>
                    <div id="intro-text-content"></div>
                    <div id="intro-press-space-hint">▼ PRESS SPACE</div>
                </div>
            </div>
        </div>
    </div>


<script type="module">
// --- CONFIG ---
let apiKey = null;
let apiKeyPromise = null;
const MODEL_NAME = "gemini-2.5-flash-lite";

// --- GAME CONSTANTS (Performance: Avoid magic numbers) ---
const GAME_CONSTANTS = {
    // Timing
    PARTICLE_LIFE_BASE: 50,
    PARTICLE_LIFE_VARIANCE: 20,
    FLOATING_TEXT_LIFE: 210,
    IFRAME_DURATION: 60,
    CASTLE_IFRAME_DURATION: 120,
    BANTER_COOLDOWN: 5000,
    AI_BANTER_COOLDOWN: 15000,

    // Physics
    PARTICLE_GRAVITY: 0.2,
    PARTICLE_BOUNCE: -0.6,
    DIAGONAL_FACTOR: 0.707,

    // Pool sizes
    MAX_PARTICLES: 200,
    MAX_FLOATING_TEXTS: 30,
    MAX_PROJECTILES: 50,

    // Rendering
    VIEWPORT_PADDING: 16,
    SCREEN_WIDTH: 256,
    SCREEN_HEIGHT: 224
};

// --- OBJECT POOL SYSTEM (Performance: Reduce GC pressure) ---
const ObjectPool = {
    particles: [],
    floatingTexts: [],

    // Get a particle from pool or create new one
    getParticle() {
        const pool = this.particles;
        for (let i = 0; i < pool.length; i++) {
            if (!pool[i].active) {
                pool[i].active = true;
                return pool[i];
            }
        }
        // Create new if pool is empty or all active
        if (pool.length < GAME_CONSTANTS.MAX_PARTICLES) {
            const p = { active: true, x: 0, y: 0, vx: 0, vy: 0, life: 0, color: '', size: 2, alpha: 1, groundY: 0, sparkle: false };
            pool.push(p);
            return p;
        }
        // Reuse oldest if at max capacity
        pool[0].active = true;
        return pool[0];
    },

    releaseParticle(p) {
        p.active = false;
    },

    // Get a floating text from pool or create new one
    getFloatingText() {
        const pool = this.floatingTexts;
        for (let i = 0; i < pool.length; i++) {
            if (!pool[i].active) {
                pool[i].active = true;
                return pool[i];
            }
        }
        if (pool.length < GAME_CONSTANTS.MAX_FLOATING_TEXTS) {
            const t = { active: true, x: 0, y: 0, text: '', color: '#fff', life: 0, vy: 0 };
            pool.push(t);
            return t;
        }
        pool[0].active = true;
        return pool[0];
    },

    releaseFloatingText(t) {
        t.active = false;
    },

    // Reset all pools (call on game restart)
    reset() {
        this.particles.forEach(p => p.active = false);
        this.floatingTexts.forEach(t => t.active = false);
    }
};

// --- CACHED VALUES (Performance: Avoid repeated calculations) ---
const CachedValues = {
    // Will be populated at runtime
    canvasWidth: 0,
    canvasHeight: 0,
    halfCanvasWidth: 0,
    halfCanvasHeight: 0,

    init(canvas) {
        this.canvasWidth = canvas.width;
        this.canvasHeight = canvas.height;
        this.halfCanvasWidth = canvas.width / 2;
        this.halfCanvasHeight = canvas.height / 2;
    }
};

// --- BANTER DATA ---
const BANTER_DB = {
    ops: [
        "TPH is down!", "Walk faster!", "No talking!", "VTO?",
        "Scan scan scan!", "Where's your vest?", "Audit panic!",
        "My bonus!", "TOT!", "Bad rate!", "Let's go!",
        "Chase blue line!", "Less chatter!", "Time is rate!", "Trim that idle!",
        "Metrics don't nap!", "Pick it up!", "Stay in lanes!"
    ],
    assoc: [
        "My feet...", "Break time?", "Box heavy...", "Ugh...",
        "Safety shoes hurt", "Where's HR?", "Need coffee...",
        "Too early...", "Night shift...", "Pizza party?",
        "Belt keeps eating me", "Where's my badge?", "Snacks when?",
        "Scanner dying...", "Stuck in pack?", "Shift never ends"
    ]
};

// --- CHARACTER DATA ---
const CHAR_DATA = {
    "Carrie": {
        role: "The 5S Monk",
        backstory: "Precision hawk who spots crooked tape from 50 meters and breathes calm into chaotic clusters.",
        attack: "Label Maker Burst",
        speed: 1.5,
        lives: 5,
        ability: "PRECISION FOCUS",
        abilityDesc: "Attacks deal 2x damage to bosses"
    },
    "Nevena": {
        role: "The Oracle",
        backstory: "Safety oracle who predicts mishaps, carries emergency Palatschinken, and documents everything twice.",
        attack: "Clipboard Shockwave",
        speed: 1.5,
        lives: 5,
        ability: "FORESIGHT",
        abilityDesc: "Longer invincibility after taking damage"
    },
    "Joao": {
        role: "The Siren",
        backstory: "Espresso cannon whose warnings ring louder than the fire alarm and kick energy through the floor.",
        attack: "Sonic Shout",
        speed: 1.5,
        lives: 5,
        ability: "CAFFEINE RUSH",
        abilityDesc: "Attacks have faster cooldown"
    },
    "Roman": {
        role: "The Ghost",
        backstory: "Bald audit phantom. Appears, fixes, vanishes. Hazards straighten themselves when he is near.",
        attack: "Stealth Audit",
        speed: 1.5,
        lives: 5,
        ability: "PHANTOM STEP",
        abilityDesc: "Hazards have smaller collision radius"
    },
    "Erwin": {
        role: "The Manager",
        backstory: "Rolls in with a kid-sized Tesla and slides into briefings faster than gossip spreads.",
        attack: "Tesla Energy Pulse",
        speed: 1.95,
        lives: 1,
        ability: "TESLA RUSH",
        abilityDesc: "1 life but 30% faster movement"
    }
};

const ATTACKS = {
    "Carrie": { name: "Label Maker Burst", sprite: "attack_carrie", speed: 4.2, cooldown: 110, color: "#a855f7", text: "Aligned!" },
    "Nevena": { name: "Clipboard Shockwave", sprite: "attack_nevena", speed: 4.0, cooldown: 120, color: "#0ea5e9", text: "Documented!" },
    "Joao": { name: "Sonic Shout", sprite: "attack_joao", speed: 4.6, cooldown: 105, color: "#f97316", text: "Heard!" },
    "Roman": { name: "Stealth Audit Pulse", sprite: "attack_roman", speed: 4.0, cooldown: 115, color: "#94a3b8", text: "Noted." },
    "Erwin": { name: "Tesla Drift", sprite: "attack_erwin", speed: 5.0, cooldown: 140, color: "#22d3ee", text: "Zapped!" },
    default: { name: "Rule Book", sprite: "book", speed: 4.0, cooldown: 120, color: "#00ffff", text: "Hit!" }
};

function getAttackData(name) {
    return ATTACKS[name] || ATTACKS.default;
}

function getCharStats(name) {
    const data = CHAR_DATA[name] || {};
    return {
        speed: data.speed ?? 1.5,
        lives: data.lives ?? 5
    };
}

// --- SIMULATED AI DATABASE (FALLBACKS) ---
const SIMULATED_AI = {
    tips: [
        "Blocked exit? That box is your tombstone. Move it.",
        "Chemical spill? Entropy leaking. Contain it before you dissolve.",
        "Debris? Chaos on the floor leads to chaos in the soul. Clean it.",
        "Trip hazard? Gravity does not care about your excuses.",
        "Unstable stack? Newton is rolling in his grave. Fix it.",
        "Fire equipment blocked? Do you plan to fight fire with optimism?"
    ],
    runners: [
        "Halt! Kinetic energy is not your friend. Slow down.",
        "You are not a photon. You have mass. Walk.",
        "Running? I've seen glaciers move with more purpose.",
        "We fight entropy, not the clock. Walk."
    ],
    taunts: [
        "My spreadsheet predicts your failure!",
        "You cannot audit the inevitable!",
        "I am the final regulation!",
        "Compliance dropping... Termination imminent!",
        "Resistance is a safety violation!"
    ],
    simon_taunts: [
        "I AM THE SAFETY STANDARD!",
        "YOU CANNOT ESCAPE THE AUDIT!",
        "ENTROPY COMES FOR US ALL!",
        "YOUR PPE IS INSUFFICIENT!"
    ],
    simon_warnings: [
        "First warning: Stop flinging manuals. Compliance is not a contact sport.",
        "Final warning: Holster the rule books or I escalate this audit into a boss fight."
    ],
    reviews_win: [
        "Performance: IMPROBABLE. You survived. I am... adequately pleased.",
        "You fought chaos and won. For today.",
        "Adequate. Nothing to write up. Feels strange."
    ],
    reviews_loss: [
        "Performance: CATASTROPHIC. Entropy won.",
        "You failed. Gravity and stupidity destroyed us.",
        "Safety is binary. You are a zero."
    ]
};

// --- SIMON'S YARD SAFETY TIPS ---
const SIMON_YARD_TIPS = [
    "YARD SAFETY ALERT: Always use designated crosswalks. DSP vans have blind spots bigger than their ambition.",
    "CAUTION: The yard is NOT a shortcut. One associate versus a Prime van equals paperwork I don't want to file.",
    "REMINDER: Look both ways. Then look again. Those DSP drivers run on caffeine and impossible deadlines.",
    "YARD PROTOCOL: High-vis vests exist for a reason. Be seen or be statistics.",
    "CRITICAL: Vehicles have right of way. Your skeleton does not outweigh a delivery quota.",
    "SAFETY FIRST: If you hear a horn, MOVE. Don't stand there contemplating the meaning of life.",
    "PRO TIP: Headphones off in the yard. Music won't cushion the blow of a reversing semi.",
    "AUDIT NOTE: The yard claims more near-misses than I have patience. Stay alert, stay alive."
];

// --- JEFF YARD TAUNTS ---
const JEFF_YARD_TAUNTS = [
    "Come on then! I haven't got all day!",
    "You call that speed? My grandmother moves faster!",
    "The yard separates the workers from the WIMPS!",
    "Every second you waste costs the company money!",
    "I built this empire from NOTHING!",
    "You want a raise? EARN IT!",
    "Keep dodging! It's good entertainment!",
    "I've seen better coordination from interns!",
    "Tick tock! Your shift is almost OVER!",
    "Almost there... just kidding, you'll never make it!",
    "This is YOUR performance review!",
    "The trucks don't stop for ANYONE!",
    "MY DELIVERY FLEET IS UNSTOPPABLE!",
    "SAFETY? THAT'S NOT IN THE METRICS!",
    "PRODUCTIVITY OR TERMINATION!",
    "I CAN SEE YOUR TOT FROM HERE!",
    "YOUR RATE IS UNACCEPTABLE!",
    "CUSTOMER OBSESSION DEMANDS SACRIFICE!",
    "THINK BIG, DIE TRYING!",
    "NO BATHROOM BREAKS IN MY YARD!",
    "BIAS FOR ACTION MEANS RUN FASTER!",
    "I OWN THE CLOUDS AND THE GROUND!"
];

// --- JEFF CASTLE TAUNTS ---
const JEFF_CASTLE_TAUNTS = [
    "WELCOME TO MY FORTRESS OF EFFICIENCY!",
    "THIS CASTLE WAS BUILT ON PRIME SUBSCRIPTIONS!",
    "EVERY BRICK IS A WORKER'S DREAM... CRUSHED!",
    "YOU DARE ENTER THE BEZOS DOMAIN?!",
    "MY TOWERS REACH HIGHER THAN YOUR AMBITIONS!",
    "I WATCH EVERYTHING FROM UP HERE!",
    "THE ALGORITHMS DESIGNED THIS MAZE!",
    "PRODUCTIVITY FLOWS THROUGH THESE HALLS!",
    "NO UNION CAN SIEGE THESE WALLS!",
    "MY THRONE AWAITS... BUT YOU WON'T REACH IT!",
    "THIS IS WHERE WORKERS BECOME... OPTIMIZED!",
    "EACH STEP YOU TAKE, I GROW STRONGER!",
    "THE CASTLE IS MY FINAL WAREHOUSE!",
    "CUSTOMER OBSESSION BUILT THESE STONES!",
    "FEEL THE WEIGHT OF A TRILLION DOLLARS!",
    "MY DRONES PATROL THESE CORRIDORS!",
    "THE EXIT INTERVIEW IS AT THE TOP!",
    "ONLY THE WORTHY MEET MECHA JEFF!",
];

// --- BEZOS TAUNTS FOR BOSS FIGHT ---
const BEZOS_TAUNTS = [
    "Work harder, not smarter!",
    "Day One? Try Day DONE!",
    "No bathroom breaks in space!",
    "Prime delivery: FAILURE!",
    "Your metrics are TERRIBLE!",
    "Automate or ELIMINATE!",
    "I'm watching your IDLE TIME!",
    "Customer obsession DEMANDS speed!",
    "Move faster! Time is MONEY!",
    "Safety? I have insurance!",
    "Be peculiar! Like a PANCAKE!",
    "Invent and SIMPLIFY your exit!",
    "Ownership? I own EVERYTHING!",
    "Bias for ACTION not survival!",
    "Think BIG or go HOME!",
    "Frugality means NO raises!",
    "Deliver RESULTS or get REPLACED!",
    "Your TOT is UNACCEPTABLE!",
    "The yard IS the final exam!",
    "Automation never complains!"
];

// --- SNARKY CORPORATE GAME OVER MESSAGES ---
const CORPORATE_GAME_OVER = [
    "Your employment has been optimized out of existence.",
    "Thank you for your contribution to our quarterly injury statistics.",
    "Your position has been automated. Have a nice day.",
    "Performance review: Below expectations. Way below.",
    "Security will escort your badge to recycling.",
    "Your final paycheck will be mailed... eventually.",
    "Customer obsession doesn't include your safety, apparently.",
    "Think of this as a permanent growth opportunity elsewhere.",
    "Your metrics suggest a career in literally anything else.",
    "Day One mentality? More like Final Day reality.",
    "HR has prepared your exit interview. It's just a door.",
    "Your TOT just became permanent. Time Off: Total.",
    "Ownership principle achieved: You now own nothing.",
    "Congratulations! You've been promoted to customer.",
    "Your bias for action led to this inaction. Forever.",
    "Frugality win: We saved money on your benefits.",
    "Deliver results? You delivered... disappointment.",
    "Invent and simplify: Inventing a new career, simplified exit."
];

// --- CHARACTER DEFEAT VOICE LINES ---
const CHARACTER_DEFEAT_LINES = {
    "Carrie": [
        "My labels... all crooked now...",
        "The 5S system... failed me... or I failed it...",
        "Even my precision couldn't save me from this mess.",
        "Sort, Set, Shine, Standardize... Surrender."
    ],
    "Nevena": [
        "The Oracle did not foresee this outcome...",
        "My clipboard... it predicted everything except my defeat.",
        "Documentation complete: Status - Terminated.",
        "Even my emergency Palatschinken couldn't save me."
    ],
    "Joao": [
        "My warnings... nobody heard them in time...",
        "The Siren goes silent... forever...",
        "All that espresso... wasted...",
        "I couldn't shout loud enough to stop this."
    ],
    "Roman": [
        "Even ghosts can be eliminated...",
        "I vanished one too many times...",
        "The audit trail... ends here...",
        "Should have stayed invisible longer."
    ],
    "Erwin": [
        "My Tesla... my beautiful Tesla...",
        "One life wasn't enough...",
        "Drifted right into disaster...",
        "The Manager has been managed... out."
    ]
};

// --- AI STATUS HELPERS ---
const aiStatusEl = document.getElementById('ai-status');
let aiStatus = "init";

function setAIStatus(message, level = 'info') {
    aiStatus = level;
    console.log(`[AI STATUS ${level}]: ${message}`);
}

function personalizeAIText(text) {
    if (!text) return text;
    const name = (typeof GAME !== 'undefined' && GAME.selectedChar) ? GAME.selectedChar : 'Coordinator';
    const patterns = [
        /\[\s*player\s*name\s*\]/gi,
        /\{\s*player\s*name\s*\}/gi,
        /<\s*player\s*name\s*>/gi,
        /player name/gi,
        /\[\s*player\s*\]/gi,
        /\{\s*player\s*\}/gi,
        /<\s*player\s*>/gi
    ];
    let cleaned = text;
    patterns.forEach(p => { cleaned = cleaned.replace(p, name); });
    return cleaned;
}

async function fetchApiKeyFromNetlify() {
    try {
        const res = await fetch('/.netlify/functions/get-gemini-key', { cache: 'no-store' });
        if (!res.ok) throw new Error(`Netlify key endpoint returned ${res.status}`);
        const data = await res.json();
        const key = (data && data.apiKey ? String(data.apiKey) : '').trim();
        if (!key) throw new Error('No apiKey field in Netlify response');
        apiKey = key;
        return apiKey;
    } catch (err) {
        return null;
    }
}

async function ensureApiKey() {
    if (apiKey) return apiKey;
    if (!apiKeyPromise) apiKeyPromise = fetchApiKeyFromNetlify();
    return apiKeyPromise;
}

// --- GEMINI API ---
async function callGemini(prompt, category = 'generic', context = {}) {
    const activeKey = await ensureApiKey();
    if (!activeKey) {
        return personalizeAIText(getRandomFallback(prompt, category, context));
    }

    const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${activeKey}`;
    const payload = { 
        contents: [{ 
            parts: [{ text: prompt }] 
        }] 
    };
    const timeout = new Promise((r) => setTimeout(() => r("TIMEOUT"), 10000));

    try {
        const fetchPromise = fetch(url, { 
            method: 'POST', 
            headers: { 'Content-Type': 'application/json' }, 
            body: JSON.stringify(payload) 
        });
        const response = await Promise.race([fetchPromise, timeout]);
        
        if (response === "TIMEOUT") return personalizeAIText(getRandomFallback(prompt, category, context));
        if (!response.ok) return personalizeAIText(getRandomFallback(prompt, category, context));
        
        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (text) return personalizeAIText(text.trim());
        return personalizeAIText(getRandomFallback(prompt, category, context));

    } catch (e) {
        return personalizeAIText(getRandomFallback(prompt, category, context));
    }
}

function getRandomFallback(prompt, category = 'generic', context = {}) {
    const hazardName = context.hazardName;
    const stats = context.stats;
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const is = (key) => category === key || prompt.includes(key);

    if (is("runners")) return pick(SIMULATED_AI.runners);
    if (is("simon_warning")) {
        const warnings = SIMULATED_AI.simon_warnings || [];
        const idx = Math.min(context.warningIndex || 0, warnings.length - 1);
        return warnings.length ? warnings[Math.max(0, idx)] : pick(SIMULATED_AI.taunts);
    }
    if (is("bezos_taunt") || is("bezos_confrontation")) {
        return pick(BEZOS_TAUNTS);
    }
    if (is("bezos_transform")) {
        return pick([
            "WITNESS MY TRUE FORM! MECHA JEFF RISES!",
            "You forced this! BEHOLD MY ULTIMATE POWER!",
            "NOW YOU DIE! TRANSFORMATION SEQUENCE INITIATED!",
            "FOOLISH WORKER! FACE MY MECHANICAL MIGHT!",
            "PRIME TIME IS OVER! EXTINCTION MODE ACTIVATED!"
        ]);
    }
    if (is("player_response")) {
        return pick([
            "Your reign of terror ends here, Bezos!",
            "The workers will NOT be silenced!",
            "Time to break your prime directive!",
            "This delivery is YOUR termination notice!",
            "No more exploiting workers! Today you fall!"
        ]);
    }
    if (is("taunt")) {
         if(prompt.includes("Simon")) return pick(SIMULATED_AI.simon_taunts);
         return pick(SIMULATED_AI.taunts);
    }
    if ((is("reviews_loss") || is("reviews_win")) && stats) {
        const time = stats.time ?? "?";
        const hazards = stats.hazards ?? "?";
        const books = stats.books ?? "?";
        const ops = stats.ops ?? "?";
        if (is("reviews_loss")) {
            return `Audit recap: ${hazards}/5 hazards, ${books} rule books thrown, ${ops} ops nudged in ${time}s. Safety tip: hydrate, then try again.`;
        }
        return `Victory recap: ${hazards}/5 hazards cleared in ${time}s, ${books} rule books launched, ${ops} ops redirected. Celebrate, then keep exits clear.`;
    }
    if (is("reviews_loss")) return pick(SIMULATED_AI.reviews_loss);
    if (is("reviews_win")) return pick(SIMULATED_AI.reviews_win);
    if (is("hazard") || is("tips")) {
        if(hazardName) return `Hazard "${hazardName}" cleared. Paperwork avoided.`;
        return pick(SIMULATED_AI.tips);
    }
    if (is("banter_ops")) return pick(BANTER_DB.ops);
    if (is("banter_assoc")) return pick(BANTER_DB.assoc);

    return pick(SIMULATED_AI.tips);
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16;
const MAP_W = 60;
const MAP_H = 40;

// --- TTS SYSTEM WITH CHARACTER VOICES ---
const TTSSys = {
    synth: window.speechSynthesis,
    voice: null,
    maleVoice: null,
    femaleVoice: null,
    voices: [],
    // Character voice configurations: pitch (0.1-2), rate (0.1-10), volume (0-1), gender preference
    characterVoices: {
        // Main characters - varied voices
        "Simon": { pitch: 0.8, rate: 0.88, volume: 1.0, gender: "male", desc: "Authoritative manager" },
        "Simon Unglaube": { pitch: 0.8, rate: 0.88, volume: 1.0, gender: "male", desc: "Authoritative manager" },
        "Carrie": { pitch: 1.3, rate: 1.05, volume: 0.95, gender: "female", desc: "Energetic, precise" },
        "Nevena": { pitch: 1.15, rate: 0.95, volume: 0.9, gender: "female", desc: "Calm, oracle-like" },
        "Joao": { pitch: 0.85, rate: 1.2, volume: 1.0, gender: "male", desc: "Loud, siren-like" },
        "Roman": { pitch: 0.7, rate: 0.9, volume: 0.75, gender: "male", desc: "Ghost-like, quiet" },
        "Erwin": { pitch: 0.95, rate: 1.1, volume: 1.0, gender: "male", desc: "Manager, confident" },
        // Bosses & antagonists - gender-appropriate voices
        "Jeff Bezos": { pitch: 0.6, rate: 0.8, volume: 1.0, gender: "male", desc: "Megalomaniac" },
        "Mecha Jeff": { pitch: 0.3, rate: 0.6, volume: 1.0, gender: "male", desc: "Robotic, terrifying" },
        "MECHA MEGA SIMON": { pitch: 0.25, rate: 1.1, volume: 1.0, gender: "male", desc: "Mechanical overlord" },
        "MEGA SIMON": { pitch: 0.7, rate: 0.82, volume: 1.0, gender: "male", desc: "Final boss authority" },
        "Labour Inspector": { pitch: 1.1, rate: 1.0, volume: 1.0, gender: "female", desc: "Stern female enforcer" },
        "Compliance Auditor": { pitch: 1.05, rate: 0.85, volume: 0.9, gender: "female", desc: "Meticulous female watcher" },
        "Sebastian Sprigade": { pitch: 0.75, rate: 1.15, volume: 1.0, gender: "male", desc: "Fast, TPH obsessed male" },
        "Regional OPS MGR": { pitch: 0.85, rate: 0.9, volume: 1.0, gender: "male", desc: "Male executive" },
        "Avetta Platform": { pitch: 0.3, rate: 0.7, volume: 0.85, gender: "neutral", desc: "AI, robotic" },
        "Jelena": { pitch: 1.15, rate: 0.95, volume: 0.95, gender: "female", desc: "HR guardian female" },
        "Jelly": { pitch: 1.15, rate: 0.95, volume: 0.95, gender: "female", desc: "HR guardian female" },
        // System voices
        "System": { pitch: 1.2, rate: 1.0, volume: 0.9, gender: "female", desc: "Female announcer" },
        "Corporate": { pitch: 0.55, rate: 0.9, volume: 1.0, gender: "male", desc: "Snarky corporate" },
        "Narrator": { pitch: 0.7, rate: 0.85, volume: 1.0, gender: "male", desc: "Dramatic narrator" }
    },
    init: function() {
        const loadVoices = () => {
            this.voices = this.synth.getVoices();
            // Prioritize English voices - force English language
            const englishVoices = this.voices.filter(v =>
                v.lang.startsWith('en') || v.name.includes('English')
            );
            // Default voice - prefer Google US English, then any US English, then any English
            this.voice = englishVoices.find(v => v.name.includes("Google US English"))
                || englishVoices.find(v => v.lang === 'en-US')
                || englishVoices.find(v => v.lang.startsWith('en'))
                || this.voices[0];

            // Try to find distinct male and female voices
            // Male voice: look for male, David, or lower-numbered voices
            this.maleVoice = englishVoices.find(v => v.name.toLowerCase().includes('male') && !v.name.toLowerCase().includes('female'))
                || englishVoices.find(v => v.name.includes('David'))
                || englishVoices.find(v => v.name.includes('Daniel'))
                || englishVoices.find(v => v.name.includes('Fred'))
                || englishVoices.find(v => v.name.includes('Alex'))
                || this.voice;

            // Female voice: look for female, Samantha, or higher-pitched voices
            this.femaleVoice = englishVoices.find(v => v.name.toLowerCase().includes('female'))
                || englishVoices.find(v => v.name.includes('Samantha'))
                || englishVoices.find(v => v.name.includes('Victoria'))
                || englishVoices.find(v => v.name.includes('Karen'))
                || englishVoices.find(v => v.name.includes('Moira'))
                || this.voice;
        };
        if (this.synth.onvoiceschanged !== undefined) this.synth.onvoiceschanged = loadVoices;
        loadVoices();
    },
    getVoiceConfig: function(speakerName) {
        // Find matching voice config by checking if speaker name contains any key
        for (const [name, config] of Object.entries(this.characterVoices)) {
            if (speakerName && speakerName.includes(name)) return config;
        }
        return { pitch: 0.9, rate: 1.0, volume: 0.9, gender: "neutral" }; // Default
    },
    speak: function(text, speakerName = "System", callback = null) {
        if (!this.synth || !text) {
            if (callback) callback();
            return;
        }
        this.synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);

        // Force English language
        utterance.lang = 'en-US';

        // Apply character-specific voice settings
        const config = this.getVoiceConfig(speakerName);

        // Select appropriate voice based on gender
        if (config.gender === "male" && this.maleVoice) {
            utterance.voice = this.maleVoice;
        } else if (config.gender === "female" && this.femaleVoice) {
            utterance.voice = this.femaleVoice;
        } else if (this.voice) {
            utterance.voice = this.voice;
        }

        utterance.pitch = config.pitch;
        utterance.rate = config.rate;
        utterance.volume = config.volume;

        // Optional callback when speech ends
        if (callback) {
            utterance.onend = callback;
            utterance.onerror = callback;
        }

        this.synth.speak(utterance);
    },
    // Speak without canceling current speech (for queuing)
    queue: function(text, speakerName = "System") {
        if (!this.synth || !text) return;
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';

        // Apply character-specific voice settings
        const config = this.getVoiceConfig(speakerName);

        // Select appropriate voice based on gender
        if (config.gender === "male" && this.maleVoice) {
            utterance.voice = this.maleVoice;
        } else if (config.gender === "female" && this.femaleVoice) {
            utterance.voice = this.femaleVoice;
        } else if (this.voice) {
            utterance.voice = this.voice;
        }

        utterance.pitch = config.pitch;
        utterance.rate = config.rate;
        utterance.volume = config.volume;
        this.synth.speak(utterance);
    },
    cancel: function() { if (this.synth) this.synth.cancel(); }
};
TTSSys.init();

// --- TTS SETTINGS ---
const TTS_SETTINGS = {
    // TTS settings can be expanded here as needed
};


// TTS function using browser's native speech synthesis
function speakTTS(text, speakerName = "System", callback = null) {
    TTSSys.speak(text, speakerName, callback);
}

function cancelTTS() {
    TTSSys.cancel();
}

// --- AUDIO ---
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        if(!this.ctx) this.ctx = new AudioContext();
    },
    resume: function() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
    playTone: function(freq, type, duration, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol=0.1) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    sfx: {
        step: () => AudioSys.playNoise(0.05, 0.05),
        throw: () => AudioSys.playTone(400, 'square', 0.1, 0.1),
        hit: () => { AudioSys.playNoise(0.1, 0.2); AudioSys.playTone(100, 'sawtooth', 0.1, 0.2); },
        bossHit: () => { AudioSys.playNoise(0.2, 0.3); AudioSys.playTone(80, 'sawtooth', 0.2, 0.3); },
        alert: () => AudioSys.playTone(600, 'square', 0.2, 0.1),
        text: () => AudioSys.playTone(800, 'square', 0.03, 0.05),
        fix: () => { [440, 554, 659].forEach((f,i) => setTimeout(()=>AudioSys.playTone(f,'sine',0.2,0.1), i*100)); },
        hurt: () => AudioSys.playTone(150, 'sawtooth', 0.3, 0.2),
        start: () => { [440,440,440,660].forEach((f,i)=>setTimeout(()=>AudioSys.playTone(f,'square',0.2,0.2), i*150)); },
        angry: () => AudioSys.playTone(150, 'square', 0.5, 0.2),
        select: () => AudioSys.playTone(550, 'square', 0.1, 0.1),
        bossIntro: () => { 
            AudioSys.playTone(100, 'sawtooth', 1.0, 0.3);
            setTimeout(() => AudioSys.playTone(80, 'sawtooth', 1.0, 0.3), 200);
        },
        pop: () => AudioSys.playTone(1200, 'sine', 0.05, 0.1) // New pop sound for banter
    }
};

const MusicSys = {
    tracks: {
        title: new Audio('music/title-screen.mp3'),
        intro: new Audio('music/title-eeproductions.mp3'),
        menu: new Audio('music/game-over.mp3'),
        ingame: new Audio('music/level-gameplay.mp3'),
        yard: new Audio('music/level-yard.mp3'),
        boss: new Audio('music/boss-battle.mp3'),
        victory: new Audio('music/victory.mp3'),
        mechaJeff: new Audio('music/boss-mecha-jeff.mp3'),
        megaSimon: new Audio('music/boss-mega-simon.mp3'),
        credits: new Audio('music/credits.mp3'),
        snesBoss: new Audio('music/boss-snes-theme.mp3'),
        enraged: new Audio('music/boss-snes-theme.mp3') // Using boss-snes-theme as fallback for enraged
    },
    currentName: null,
    currentRate: 1,
    init() {
        Object.values(this.tracks).forEach(a => {
            a.loop = true; a.volume = 0.35; a.preload = 'auto';
        });
        // Don't loop the intro track - it's timed to match the logo animation
        this.tracks.intro.loop = false;
    },
    play(name, rate = 1) {
        const track = this.tracks[name];
        if (!track) return;
        if (this.currentName === name) {
            this.currentRate = rate;
            track.playbackRate = rate;
            if (track.paused) track.play().catch(() => {});
            return;
        }
        if (this.currentName && this.currentName !== name) this.stop();
        this.currentName = name;
        this.currentRate = rate;
        track.playbackRate = rate;
        track.currentTime = 0;
        track.play().catch(() => {});
    },
    stop() {
        if (this.currentName && this.tracks[this.currentName]) {
            const current = this.tracks[this.currentName];
            current.pause(); current.currentTime = 0;
        }
        this.currentName = null;
    },
    resume() {
        if (this.currentName && this.tracks[this.currentName]?.paused) {
            this.tracks[this.currentName].playbackRate = this.currentRate || 1;
            this.tracks[this.currentName].play().catch(() => {});
        }
    }
};

// --- ASSETS ---
const GFX = {};
function generateAssets() {
    const c = (w,h,f) => { const c=document.createElement('canvas');c.width=w;c.height=h;f(c.getContext('2d'));return c;};

    // Enhanced logo with gradient and glow
    GFX.logo = c(48, 48, ctx => {
        // Gradient background
        const grad = ctx.createLinearGradient(0, 0, 48, 48);
        grad.addColorStop(0, '#ffd700');
        grad.addColorStop(0.5, '#f59e0b');
        grad.addColorStop(1, '#d97706');
        ctx.fillStyle = grad;
        ctx.fillRect(2, 2, 44, 44);
        // Border
        ctx.strokeStyle = '#92400e';
        ctx.lineWidth = 2;
        ctx.strokeRect(2, 2, 44, 44);
        // Inner shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(4, 4, 40, 40);
        // Text with shadow
        ctx.fillStyle = '#000';
        ctx.font = 'bold 28px monospace';
        ctx.fillText("EE", 9, 35);
        ctx.fillStyle = '#fff';
        ctx.fillText("EE", 7, 33);
    });

    // PREMIUM CHARACTER SPRITES - 16x16 with full detail
    GFX.chars = {
        "Carrie": c(16,16, ctx => {
            // Shadow base
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Hair with highlight
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,0,12,6);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(3,1,10,3);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(4,1,3,2); // Hair shine
            // Face with contour
            ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
            ctx.fillStyle = '#f5d0a0'; ctx.fillRect(6,6,4,3); // Highlight
            // Eyes with detail
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
            // Eyebrows
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(5,6,2,1); ctx.fillRect(9,6,2,1);
            // Mouth
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(7,9,2,1);
            // Headset
            ctx.fillStyle = '#22c55e'; ctx.fillRect(4,10,8,1);
            ctx.fillStyle = '#16a34a'; ctx.fillRect(3,8,1,3); ctx.fillRect(12,8,1,3);
            // Purple robe with shading
            ctx.fillStyle = '#7c3aed'; ctx.fillRect(2,11,12,5);
            ctx.fillStyle = '#8b5cf6'; ctx.fillRect(3,11,10,3);
            ctx.fillStyle = '#a78bfa'; ctx.fillRect(5,12,6,2); // Highlight
            // Sash
            ctx.fillStyle = '#c4b5fd'; ctx.fillRect(7,11,2,4);
            // Boots
            ctx.fillStyle = '#1e3a8a'; ctx.fillRect(3,15,4,1); ctx.fillRect(9,15,4,1);
            ctx.fillStyle = '#3b82f6'; ctx.fillRect(4,15,2,1); ctx.fillRect(10,15,2,1);
        }),
        "Nevena": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Brown hair with wave
            ctx.fillStyle = '#5c2d12'; ctx.fillRect(2,1,12,5);
            ctx.fillStyle = '#7c3d1a'; ctx.fillRect(3,2,10,3);
            ctx.fillStyle = '#9a5a32'; ctx.fillRect(2,2,3,4); // Side wave
            ctx.fillStyle = '#b8784a'; ctx.fillRect(3,2,2,2); // Highlight
            // Headband
            ctx.fillStyle = '#0284c7'; ctx.fillRect(3,2,10,2);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,2,8,1);
            // Face
            ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
            ctx.fillStyle = '#f5c89a'; ctx.fillRect(6,6,4,3);
            // Eyes
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
            // Glasses frame
            ctx.strokeStyle = '#475569'; ctx.lineWidth = 0.5;
            ctx.strokeRect(5,7,2,2); ctx.strokeRect(9,7,2,2);
            ctx.fillStyle = '#475569'; ctx.fillRect(7,8,2,0.5);
            // Mouth
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(7,9,2,1);
            // Red jacket with detail
            ctx.fillStyle = '#991b1b'; ctx.fillRect(2,11,12,5);
            ctx.fillStyle = '#b91c1c'; ctx.fillRect(3,11,10,3);
            ctx.fillStyle = '#dc2626'; ctx.fillRect(4,12,8,2);
            // Clipboard
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(12,12,3,3);
            ctx.fillStyle = '#fcd34d'; ctx.fillRect(12,12,2,2);
            ctx.fillStyle = '#92400e'; ctx.fillRect(13,13,1,1);
            // Boots
            ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
            ctx.fillStyle = '#374151'; ctx.fillRect(5,15,1,1); ctx.fillRect(10,15,1,1);
        }),
        "Joao": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Spiky black hair
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(4,0,8,4);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(5,1,6,2);
            ctx.fillRect(5,-1,2,2); ctx.fillRect(9,-1,2,2); // Spikes
            // Face
            ctx.fillStyle = '#c4956a'; ctx.fillRect(4,4,8,6);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,5,6,4);
            ctx.fillStyle = '#e8b888'; ctx.fillRect(6,5,4,3);
            // Eyes with energy
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
            // Eyebrows (expressive)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(5,5,2,1); ctx.fillRect(9,5,2,1);
            // Open mouth (shouting)
            ctx.fillStyle = '#8b4513'; ctx.fillRect(6,8,4,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(7,8,2,1);
            // Mic headset
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(3,8,1,3);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(2,10,2,2);
            // Orange hi-vis vest
            ctx.fillStyle = '#c2410c'; ctx.fillRect(2,10,12,6);
            ctx.fillStyle = '#ea580c'; ctx.fillRect(3,10,10,4);
            ctx.fillStyle = '#f97316'; ctx.fillRect(4,11,8,2);
            // Reflective strips
            ctx.fillStyle = '#fef08a'; ctx.fillRect(3,11,10,1);
            ctx.fillStyle = '#fef08a'; ctx.fillRect(3,13,10,1);
            // Shoes
            ctx.fillStyle = '#0369a1'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(5,15,1,1); ctx.fillRect(10,15,1,1);
        }),
        "Roman": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Bald head with shine
            ctx.fillStyle = '#c4956a'; ctx.fillRect(4,2,8,8);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,3,6,6);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,3,4,4);
            ctx.fillStyle = '#f5deb3'; ctx.fillRect(6,2,3,2); // Shine
            // Eyes (narrow, mysterious)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,5,2,1); ctx.fillRect(9,5,2,1);
            ctx.fillStyle = '#64748b'; ctx.fillRect(5,5,1,1); ctx.fillRect(9,5,1,1);
            // Stern mouth
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(6,7,4,1);
            // Dark stealth coat
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,10,12,6);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(3,10,10,4);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(4,11,8,2);
            // Collar
            ctx.fillStyle = '#374151'; ctx.fillRect(5,10,6,1);
            // Silver cuffs
            ctx.fillStyle = '#6b7280'; ctx.fillRect(2,13,3,2); ctx.fillRect(11,13,3,2);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(3,13,1,1); ctx.fillRect(12,13,1,1);
            // Dark boots
            ctx.fillStyle = '#0b1224'; ctx.fillRect(3,15,4,1); ctx.fillRect(9,15,4,1);
        }),
        "Erwin": c(16,16, ctx => {
            // Shadow under Tesla
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fillRect(1,14,14,2);
            // Tesla body - sleek design
            ctx.fillStyle = '#3f3f46'; ctx.fillRect(1,8,14,6);
            ctx.fillStyle = '#52525b'; ctx.fillRect(2,9,12,4);
            ctx.fillStyle = '#71717a'; ctx.fillRect(3,9,10,2);
            // Hood with reflection
            ctx.fillStyle = '#4b5563'; ctx.fillRect(2,7,12,3);
            ctx.fillStyle = '#6b7280'; ctx.fillRect(4,7,8,2);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(5,7,3,1);
            // Windshield glow
            ctx.fillStyle = '#0891b2'; ctx.fillRect(3,9,10,2);
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(4,9,8,1);
            ctx.fillStyle = '#67e8f9'; ctx.fillRect(6,9,4,1);
            // Wheels with detail
            ctx.fillStyle = '#000'; ctx.fillRect(1,12,4,3); ctx.fillRect(11,12,4,3);
            ctx.fillStyle = '#27272a'; ctx.fillRect(2,12,2,2); ctx.fillRect(12,12,2,2);
            ctx.fillStyle = '#71717a'; ctx.fillRect(2,13,1,1); ctx.fillRect(13,13,1,1);
            // Headlights
            ctx.fillStyle = '#fef08a'; ctx.fillRect(1,10,1,2); ctx.fillRect(14,10,1,2);
            // Erwin face above
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,3,6,5);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,4,4,3);
            // Hair
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,2,6,3);
            ctx.fillStyle = '#2d2d2d'; ctx.fillRect(6,2,4,2);
            // Beard
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(6,6,4,2);
            // Eyes with smirk
            ctx.fillStyle = '#000'; ctx.fillRect(6,4,1,1); ctx.fillRect(9,4,1,1);
            ctx.fillStyle = '#fff'; ctx.fillRect(6,4,1,1);
            // Smirk
            ctx.fillStyle = '#f59e0b'; ctx.fillRect(7,5,2,1);
        })
    };

    // ENHANCED ATTACK PROJECTILES
    GFX.attacks = {
        "Carrie": c(14,14, ctx => {
            // Label maker projectile with glow
            const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
            grad.addColorStop(0, '#e879f9');
            grad.addColorStop(0.5, '#a855f7');
            grad.addColorStop(1, '#7c3aed');
            ctx.fillStyle = grad;
            ctx.fillRect(1,4,12,6);
            ctx.fillStyle = '#c4b5fd';
            ctx.fillRect(2,5,10,4);
            ctx.fillStyle = '#10b981';
            ctx.fillRect(6,2,2,10);
            // Label detail
            ctx.fillStyle = '#fff';
            ctx.fillRect(4,6,6,2);
        }),
        "Nevena": c(14,14, ctx => {
            // Clipboard shockwave
            ctx.fillStyle = '#0369a1';
            ctx.fillRect(2,2,10,10);
            const grad = ctx.createLinearGradient(0, 0, 14, 14);
            grad.addColorStop(0, '#f8fafc');
            grad.addColorStop(1, '#e2e8f0');
            ctx.fillStyle = grad;
            ctx.fillRect(3,3,8,8);
            // Paper lines
            ctx.fillStyle = '#334155';
            ctx.fillRect(4,4,6,1);
            ctx.fillRect(4,6,5,1);
            ctx.fillRect(4,8,4,1);
            // Checkmark
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(8,7,2,3);
            ctx.fillRect(6,9,2,1);
        }),
        "Joao": c(14,14, ctx => {
            // Sonic shout waves
            const grad = ctx.createLinearGradient(0, 0, 14, 0);
            grad.addColorStop(0, '#ea580c');
            grad.addColorStop(0.5, '#f97316');
            grad.addColorStop(1, '#fb923c');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.moveTo(0,7); ctx.lineTo(6,2); ctx.lineTo(6,12); ctx.fill();
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath(); ctx.moveTo(4,7); ctx.lineTo(10,1); ctx.lineTo(10,13); ctx.fill();
            ctx.fillStyle = '#22d3ee';
            ctx.beginPath(); ctx.moveTo(8,7); ctx.lineTo(14,3); ctx.lineTo(14,11); ctx.fill();
            // Inner ring
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(7,7,2,0,Math.PI*2); ctx.stroke();
        }),
        "Roman": c(14,14, ctx => {
            // Stealth audit pulse
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(7,7,6,0,Math.PI*2); ctx.stroke();
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(7,7,4,0,Math.PI*2); ctx.stroke();
            ctx.fillStyle = '#1e293b';
            ctx.beginPath(); ctx.arc(7,7,2,0,Math.PI*2); ctx.fill();
            // Crosshair
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(6,0,2,3); ctx.fillRect(6,11,2,3);
            ctx.fillRect(0,6,3,2); ctx.fillRect(11,6,3,2);
        }),
        "Erwin": c(14,14, ctx => {
            // Tesla energy pulse
            const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
            grad.addColorStop(0, '#67e8f9');
            grad.addColorStop(0.5, '#22d3ee');
            grad.addColorStop(1, '#0891b2');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(7, 7, 6, 0, Math.PI*2); ctx.fill();
            // Electric arcs
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(7, 1); ctx.lineTo(5, 4); ctx.lineTo(9, 6); ctx.lineTo(7, 9);
            ctx.stroke();
            // Center core
            ctx.fillStyle = '#f0f9ff';
            ctx.beginPath(); ctx.arc(7, 7, 2, 0, Math.PI*2); ctx.fill();
        })
    };
    // IMPROVED SIMON SPRITE - Short brown hair, glasses, brown beard
    GFX.simon = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Short brown hair
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(3,0,10,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(4,1,8,2);
        ctx.fillStyle = '#7a5030'; ctx.fillRect(5,1,3,1); // Highlight
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,4,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,5,6,4);
        // Glasses
        ctx.fillStyle = '#000'; ctx.fillRect(4,5,3,2); ctx.fillRect(9,5,3,2);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(5,5,1,1); ctx.fillRect(10,5,1,1);
        ctx.fillStyle = '#475569'; ctx.fillRect(7,6,2,1);
        // Brown beard
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(4,8,8,2);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(5,8,6,2);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(6,9,4,1);
        // Gold WHS jacket
        ctx.fillStyle = '#b45309'; ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#d97706'; ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(4,11,8,2);
        // WHS badge
        ctx.fillStyle = '#fff'; ctx.fillRect(5,12,6,2);
        ctx.fillStyle = '#000'; ctx.font = '3px monospace';
        // Boots
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });
    GFX.simonFace = c(32,32, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simon,0,0,16,16,0,0,32,32); });

    // Create ENHANCED FUNNY character portraits for SNES-style dialogues (48x48)
    GFX.charFaces = {
        "Carrie": c(48,48, ctx => {
            // CARRIE - The 5S Monk - Zen precision hawk portrait
            // Background gradient (purple zen aura)
            const grad = ctx.createRadialGradient(24,24,8,24,24,24);
            grad.addColorStop(0, '#8b5cf6'); grad.addColorStop(1, '#4c1d95');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Dark hair with meditation headband
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(10,6,28,12);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(12,8,24,8);
            // Meditation headband (green)
            ctx.fillStyle = '#22c55e'; ctx.fillRect(12,10,24,4);
            ctx.fillStyle = '#16a34a'; ctx.fillRect(14,11,20,2);
            // Face (serious zen expression)
            ctx.fillStyle = '#d4a574'; ctx.fillRect(14,16,20,14);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,18,16,10);
            // Closed meditation eyes (peaceful)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(18,22,4,2); ctx.fillRect(26,22,4,2);
            // Eyebrows (focused)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(18,20,5,1); ctx.fillRect(25,20,5,1);
            // Small smile (enlightened)
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(22,26,4,1);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(20,27,8,1); // Slight smile curve
            // Purple monk robe with sash
            ctx.fillStyle = '#7c3aed'; ctx.fillRect(10,30,28,18);
            ctx.fillStyle = '#8b5cf6'; ctx.fillRect(12,32,24,14);
            ctx.fillStyle = '#a78bfa'; ctx.fillRect(16,34,16,10); // Highlight
            // Golden sash (5S master)
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(22,32,4,14);
            // Hands in prayer position
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,38,8,6);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(21,39,6,4);
        }),
        "Nevena": c(48,48, ctx => {
            // NEVENA - The Oracle - Skeptical documentation expert
            // Background (red warning gradient)
            const grad = ctx.createRadialGradient(24,24,8,24,24,24);
            grad.addColorStop(0, '#dc2626'); grad.addColorStop(1, '#7f1d1d');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Brown wavy hair
            ctx.fillStyle = '#5c2d12'; ctx.fillRect(8,8,32,12);
            ctx.fillStyle = '#7c3d1a'; ctx.fillRect(10,10,28,8);
            // Hair waves on sides
            ctx.fillStyle = '#9a5a32'; ctx.fillRect(8,12,6,8); ctx.fillRect(34,12,6,8);
            // Blue headband
            ctx.fillStyle = '#0284c7'; ctx.fillRect(12,10,24,4);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(14,11,20,2);
            // Face (skeptical expression)
            ctx.fillStyle = '#d4a574'; ctx.fillRect(14,18,20,16);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,20,16,12);
            // Large glasses (oracle vision)
            ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
            ctx.strokeRect(16,24,6,5); ctx.strokeRect(26,24,6,5);
            // Eyes (one raised eyebrow, skeptical)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,26,2,2); ctx.fillRect(28,26,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(18,26,1,1); ctx.fillRect(28,26,1,1);
            // Raised eyebrow (skeptical)
            ctx.fillStyle = '#5c2d12'; ctx.fillRect(16,22,6,2); ctx.fillRect(26,23,6,1);
            // Smirk (knowing smile)
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(22,30,4,2);
            ctx.fillRect(20,31,2,1); ctx.fillRect(26,31,2,1);
            // Red safety jacket
            ctx.fillStyle = '#991b1b'; ctx.fillRect(10,34,28,14);
            ctx.fillStyle = '#dc2626'; ctx.fillRect(12,36,24,10);
            // GIANT clipboard (obsessive documentation)
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(32,30,12,16);
            ctx.fillStyle = '#fcd34d'; ctx.fillRect(33,31,10,14);
            // Checkmarks everywhere!
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(35,33,2,2); ctx.fillRect(38,36,2,2); ctx.fillRect(35,40,2,2);
        }),
        "Joao": c(48,48, ctx => {
            // JOAO - The Siren - Caffeinated chaos energy
            // Background (orange energy explosion)
            const grad = ctx.createRadialGradient(24,24,10,24,24,24);
            grad.addColorStop(0, '#fb923c'); grad.addColorStop(1, '#c2410c');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Energy lines radiating (SCREAMING ENERGY)
            ctx.strokeStyle = '#fef08a'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(24,10); ctx.lineTo(24,0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(10,24); ctx.lineTo(0,24); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(38,24); ctx.lineTo(48,24); ctx.stroke();
            // Super spiky black hair (ENERGIZED)
            ctx.fillStyle = '#0a0f1f';
            ctx.fillRect(14,4,20,10); // Base
            ctx.fillRect(16,2,4,4); ctx.fillRect(22,0,4,6); ctx.fillRect(28,2,4,4); // Spikes!
            ctx.fillStyle = '#1a2744'; ctx.fillRect(18,6,12,6);
            // Face (INTENSE SHOUTING)
            ctx.fillStyle = '#c4956a'; ctx.fillRect(14,16,20,18);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(16,18,16,14);
            // WIDE OPEN EYES (caffeinated)
            ctx.fillStyle = '#fff'; ctx.fillRect(18,22,5,6); ctx.fillRect(25,22,5,6);
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(20,24,3,4); ctx.fillRect(27,24,3,4);
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(20,25,2,2); ctx.fillRect(27,25,2,2); // Glint
            // Eyebrows (INTENSE)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(17,20,6,2); ctx.fillRect(25,20,6,2);
            // HUGE SHOUTING MOUTH (WARNING SIREN)
            ctx.fillStyle = '#8b4513'; ctx.fillRect(20,28,8,6);
            ctx.fillStyle = '#fff'; ctx.fillRect(22,28,4,2); // Teeth
            // Headset mic (always ON)
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(12,24,2,8);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(10,28,4,4);
            // Orange hi-vis vest (MAXIMUM VISIBILITY)
            ctx.fillStyle = '#ea580c'; ctx.fillRect(10,34,28,14);
            ctx.fillStyle = '#f97316'; ctx.fillRect(12,36,24,10);
            // Reflective strips
            ctx.fillStyle = '#fef08a'; ctx.fillRect(12,36,24,2); ctx.fillRect(12,42,24,2);
            // COFFEE CUP (essential fuel)
            ctx.fillStyle = '#78350f'; ctx.fillRect(34,36,10,10);
            ctx.fillStyle = '#92400e'; ctx.fillRect(35,37,8,8);
            // Steam (HOT COFFEE)
            ctx.strokeStyle = '#e0e7ff'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(36,34); ctx.lineTo(38,30); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(40,34); ctx.lineTo(42,30); ctx.stroke();
        }),
        "Roman": c(48,48, ctx => {
            // ROMAN - The Ghost - Mysterious audit phantom
            // Background (dark stealth gradient)
            const grad = ctx.createRadialGradient(24,24,8,24,24,24);
            grad.addColorStop(0, '#2a3755'); grad.addColorStop(1, '#0a0f1f');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Ghostly wisps around edges
            ctx.fillStyle = 'rgba(148,163,184,0.2)';
            ctx.fillRect(0,20,8,8); ctx.fillRect(40,20,8,8);
            // BALD HEAD with epic shine
            ctx.fillStyle = '#c4956a'; ctx.fillRect(14,10,20,16);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(16,12,16,12);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,12,12,8);
            // LEGENDARY HEAD SHINE
            ctx.fillStyle = '#fff'; ctx.fillRect(20,10,8,4);
            ctx.fillStyle = '#f5deb3'; ctx.fillRect(22,12,6,3);
            // Narrow mysterious eyes (seen it all)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,20,4,2); ctx.fillRect(26,20,4,2);
            ctx.fillStyle = '#64748b'; ctx.fillRect(19,20,2,1); ctx.fillRect(27,20,2,1);
            // Stern eyebrows
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(17,18,5,1); ctx.fillRect(26,18,5,1);
            // Serious mouth (disapproving)
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(22,24,4,1);
            // Dark stealth coat (mysterious)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(8,26,32,22);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(10,28,28,18);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(14,30,20,14);
            // High collar (dramatic)
            ctx.fillStyle = '#374151'; ctx.fillRect(16,26,16,4);
            // Silver audit badge (ghost credentials)
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(20,34,8,6);
            ctx.fillStyle = '#e5e7eb'; ctx.fillRect(21,35,6,4);
            // Mysterious silver cuffs
            ctx.fillStyle = '#6b7280'; ctx.fillRect(8,38,6,6); ctx.fillRect(34,38,6,6);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(9,39,4,4); ctx.fillRect(35,39,4,4);
            // Phantom shadowy hands (spooky)
            ctx.fillStyle = 'rgba(100,116,139,0.5)';
            ctx.fillRect(6,42,8,6); ctx.fillRect(34,42,8,6);
        }),
        "Erwin": c(48,48, ctx => {
            // ERWIN - The Manager - Smug kid in Tesla
            // Background (corporate gray gradient)
            const grad = ctx.createRadialGradient(24,24,10,24,24,24);
            grad.addColorStop(0, '#71717a'); grad.addColorStop(1, '#3f3f46');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Money signs floating ($$)
            ctx.fillStyle = '#22c55e'; ctx.font = 'bold 8px monospace';
            ctx.fillText('$', 6, 12); ctx.fillText('$', 38, 12);
            // Kid-sized Erwin's smug face
            ctx.fillStyle = '#d4a574'; ctx.fillRect(16,8,16,12);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,10,12,8);
            // Slicked-back hair (manager style)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(16,6,16,6);
            ctx.fillStyle = '#2d2d2d'; ctx.fillRect(18,7,12,4);
            ctx.fillStyle = '#4a4a4a'; ctx.fillRect(20,7,8,2); // Shine
            // Small beard (trying to look older)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(20,18,8,3);
            // SMUG EYES (superiority complex)
            ctx.fillStyle = '#000'; ctx.fillRect(20,12,2,2); ctx.fillRect(26,12,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(20,12,1,1); ctx.fillRect(26,12,1,1);
            // HUGE SMIRK (so pleased with himself)
            ctx.fillStyle = '#f59e0b'; ctx.fillRect(22,15,4,2);
            ctx.fillRect(20,16,2,1); ctx.fillRect(26,16,2,1);
            // Briefcase (important business)
            ctx.fillStyle = '#78350f'; ctx.fillRect(4,16,8,10);
            ctx.fillStyle = '#92400e'; ctx.fillRect(5,17,6,8);
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(7,20,2,2); // Lock
            // TESLA CAR (below his face)
            // Sleek body
            ctx.fillStyle = '#3f3f46'; ctx.fillRect(6,24,36,20);
            ctx.fillStyle = '#52525b'; ctx.fillRect(8,26,32,16);
            ctx.fillStyle = '#71717a'; ctx.fillRect(10,28,28,12);
            // Hood reflection
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(12,28,20,4);
            ctx.fillStyle = '#e5e7eb'; ctx.fillRect(16,28,12,2);
            // Windshield (glowing cyan)
            ctx.fillStyle = '#0891b2'; ctx.fillRect(10,30,28,6);
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(12,31,24,4);
            ctx.fillStyle = '#67e8f9'; ctx.fillRect(16,31,16,2);
            // Wheels
            ctx.fillStyle = '#000'; ctx.fillRect(8,40,8,6); ctx.fillRect(32,40,8,6);
            ctx.fillStyle = '#27272a'; ctx.fillRect(10,41,4,4); ctx.fillRect(34,41,4,4);
            ctx.fillStyle = '#71717a'; ctx.fillRect(11,42,2,2); ctx.fillRect(35,42,2,2);
            // LED headlights (expensive)
            ctx.fillStyle = '#fef08a'; ctx.fillRect(6,34,2,4); ctx.fillRect(40,34,2,4);
            // Tesla logo on hood
            ctx.fillStyle = '#ef4444'; ctx.fillRect(22,33,4,2);
        })
    };
    GFX.simonFaceLarge = c(48,48, ctx => {
        // SIMON - Friendly WHS Manager Portrait (Professional but Approachable)
        // Background (warm professional gradient)
        const grad = ctx.createRadialGradient(24,24,10,24,24,24);
        grad.addColorStop(0, '#fbbf24'); grad.addColorStop(1, '#d97706');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Clipboard in background (professional but not threatening)
        ctx.fillStyle = '#78350f'; ctx.fillRect(4,20,12,20);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(5,21,10,18);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(7,24,6,2); ctx.fillRect(7,28,6,2); // Green checkmarks
        // Short brown hair
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,6,24,10);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(14,8,20,6);
        ctx.fillStyle = '#7a5030'; ctx.fillRect(16,8,8,3); // Highlight
        // Face (professional, friendly)
        ctx.fillStyle = '#c4956a'; ctx.fillRect(12,14,24,18);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,16,20,14);
        // Friendly eyebrows (slightly raised, welcoming)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(16,19,6,2); ctx.fillRect(26,19,6,2);
        // Glasses with normal eyes (professional but kind)
        ctx.fillStyle = '#1e293b'; ctx.fillRect(16,22,7,6); ctx.fillRect(25,22,7,6);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(17,23,5,4); ctx.fillRect(26,23,5,4); // Blue calm eyes
        ctx.fillStyle = '#1e293b'; ctx.fillRect(18,24,3,2); ctx.fillRect(27,24,3,2); // Pupils
        ctx.fillStyle = '#fff'; ctx.fillRect(19,24,1,1); ctx.fillRect(28,24,1,1); // Eye glint
        // Bridge
        ctx.fillStyle = '#475569'; ctx.fillRect(23,24,2,1);
        // Slight SMILE (friendly professional)
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(21,29,6,1);
        ctx.fillRect(20,30,2,1); ctx.fillRect(26,30,2,1); // Smile curves up
        // Brown beard (well-groomed)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(14,30,20,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(16,30,16,3);
        // Gold WHS uniform
        ctx.fillStyle = '#92400e'; ctx.fillRect(10,34,28,14);
        ctx.fillStyle = '#b45309'; ctx.fillRect(12,36,24,10);
        ctx.fillStyle = '#d97706'; ctx.fillRect(14,38,20,6);
        // Large WHS badge
        ctx.fillStyle = '#fff'; ctx.fillRect(18,40,12,4);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(20,41,8,2); // Green badge (friendly)
        // Thumbs up gesture (encouraging)
        ctx.fillStyle = '#d4a574'; ctx.fillRect(34,30,6,10);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(35,31,4,8);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(35,28,4,4); // Thumb up
    });

    // TALKING ANIMATION VARIANTS - Open mouths for dialogue
    GFX.charFacesTalking = {
        "Carrie": c(48,48, ctx => {
            // Draw base portrait first (copy from above)
            ctx.drawImage(GFX.charFaces["Carrie"], 0, 0);
            // Now modify the mouth area to be OPEN (talking)
            // Clear mouth area
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,26,8,4);
            // Open mouth (serene chanting)
            ctx.fillStyle = '#8b4513'; ctx.fillRect(22,27,4,2);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(21,27,1,2); ctx.fillRect(26,27,1,2); // Sides
        }),
        "Nevena": c(48,48, ctx => {
            ctx.drawImage(GFX.charFaces["Nevena"], 0, 0);
            // Open mouth (explaining something skeptically)
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,30,8,4);
            ctx.fillStyle = '#8b4513'; ctx.fillRect(21,31,6,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(23,31,2,1); // Teeth visible
        }),
        "Joao": c(48,48, ctx => {
            ctx.drawImage(GFX.charFaces["Joao"], 0, 0);
            // EVEN BIGGER mouth (SCREAMING LOUDER)
            ctx.fillStyle = '#d4a574'; ctx.fillRect(18,28,12,8);
            ctx.fillStyle = '#8b4513'; ctx.fillRect(19,29,10,6);
            ctx.fillStyle = '#fff'; ctx.fillRect(21,29,6,2); // More teeth!
            // Sound waves!
            ctx.strokeStyle = '#fef08a'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(24,32,8,0,Math.PI*2); ctx.stroke();
        }),
        "Roman": c(48,48, ctx => {
            ctx.drawImage(GFX.charFaces["Roman"], 0, 0);
            // Slightly open mouth (mysterious whisper)
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,24,8,3);
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(22,25,4,1);
            ctx.fillStyle = '#64748b'; ctx.fillRect(23,25,2,1); // Shadow
        }),
        "Erwin": c(48,48, ctx => {
            ctx.drawImage(GFX.charFaces["Erwin"], 0, 0);
            // Bigger smirk talking (bragging)
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,15,8,4);
            ctx.fillStyle = '#f59e0b'; ctx.fillRect(21,16,6,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(23,16,2,1); // Teeth showing
            ctx.fillRect(19,17,2,1); ctx.fillRect(27,17,2,1); // Wide smile
        })
    };

    GFX.simonFaceTalking = c(48,48, ctx => {
        ctx.drawImage(GFX.simonFaceLarge, 0, 0);
        // Open mouth (friendly talking, not yelling)
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,29,8,4);
        ctx.fillStyle = '#8b4513'; ctx.fillRect(21,30,6,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(23,30,2,1); // Friendly teeth
        // Beard moves with mouth (slightly)
        ctx.fillStyle = '#6b4423'; ctx.fillRect(16,32,16,2);
    });

    // INTRO CONVERSATION PORTRAITS - 96x96 (2x size for centered window)
    GFX.introPortraits = {
        "Carrie": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Carrie"],0,0,48,48,0,0,96,96); }),
        "Nevena": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Nevena"],0,0,48,48,0,0,96,96); }),
        "Joao": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Joao"],0,0,48,48,0,0,96,96); }),
        "Roman": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Roman"],0,0,48,48,0,0,96,96); }),
        "Erwin": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Erwin"],0,0,48,48,0,0,96,96); }),
        "Simon Unglaube": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simonFaceLarge,0,0,48,48,0,0,96,96); })
    };

    GFX.introPortraitsTalking = {
        "Carrie": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Carrie"],0,0,48,48,0,0,96,96); }),
        "Nevena": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Nevena"],0,0,48,48,0,0,96,96); }),
        "Joao": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Joao"],0,0,48,48,0,0,96,96); }),
        "Roman": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Roman"],0,0,48,48,0,0,96,96); }),
        "Erwin": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Erwin"],0,0,48,48,0,0,96,96); }),
        "Simon Unglaube": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simonFaceTalking,0,0,48,48,0,0,96,96); })
    };

    // ENHANCED SIMON BOSS - 32x32 detailed sprite - Short brown hair, glasses, brown beard
    GFX.simonBoss = c(32,32, ctx => {
        // Dark background aura
        const aura = ctx.createRadialGradient(16, 16, 4, 16, 16, 16);
        aura.addColorStop(0, 'rgba(234, 179, 8, 0.3)');
        aura.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = aura;
        ctx.fillRect(0, 0, 32, 32);
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath(); ctx.ellipse(16, 30, 10, 3, 0, 0, Math.PI*2); ctx.fill();
        // Short brown hair
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(8,2,16,6);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(10,3,12,4);
        ctx.fillStyle = '#7a5030'; ctx.fillRect(12,3,4,2); // Highlight
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(8,7,16,11);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(10,9,12,7);
        // Angry brown eyebrows
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(10,9,4,2); ctx.fillRect(18,9,4,2);
        // Glasses (glowing red)
        ctx.fillStyle = '#1e293b'; ctx.fillRect(10,11,5,4); ctx.fillRect(17,11,5,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,12,3,2); ctx.fillRect(18,12,3,2);
        ctx.fillStyle = '#475569'; ctx.fillRect(15,13,2,1);
        // Brown beard
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(8,16,16,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(10,16,12,3);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,18,8,2);
        // Gold WHS uniform
        ctx.fillStyle = '#92400e'; ctx.fillRect(6,19,20,13);
        ctx.fillStyle = '#b45309'; ctx.fillRect(8,19,16,10);
        ctx.fillStyle = '#d97706'; ctx.fillRect(10,21,12,6);
        // Large badge
        ctx.fillStyle = '#fff'; ctx.fillRect(11,23,10,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(13,24,6,2);
    });

    // MECHA MEGA SIMON - Transformed final boss
    GFX.mechaMegaSimon = c(48,48, ctx => {
        // Dark energy aura
        const aura = ctx.createRadialGradient(24, 24, 8, 24, 24, 24);
        aura.addColorStop(0, 'rgba(220, 38, 38, 0.4)');
        aura.addColorStop(0.5, 'rgba(234, 179, 8, 0.2)');
        aura.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = aura; ctx.fillRect(0, 0, 48, 48);
        // Mecha body frame
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(8,26,32,18);
        ctx.fillStyle = '#252b3d'; ctx.fillRect(10,28,28,14);
        // Body armor plates
        ctx.fillStyle = '#3d4556'; ctx.fillRect(12,30,24,10);
        ctx.fillStyle = '#4a5568'; ctx.fillRect(14,32,20,6);
        // WHS logo on chest (glowing gold)
        ctx.fillStyle = '#eab308'; ctx.fillRect(18,33,12,6);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(20,34,8,4);
        ctx.fillText('WHS', 24, 38);
        // Shoulder cannons
        ctx.fillStyle = '#374151'; ctx.fillRect(2,22,10,20);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(4,24,6,16);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(5,28,4,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(6,29,2,2);
        ctx.fillStyle = '#374151'; ctx.fillRect(36,22,10,20);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(38,24,6,16);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(39,28,4,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(40,29,2,2);
        // Neck/collar chrome
        ctx.fillStyle = '#6b7280'; ctx.fillRect(14,22,20,5);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(16,23,16,3);
        // Short brown hair with mecha headgear
        ctx.fillStyle = '#374151'; ctx.fillRect(10,2,28,8);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,4,24,5);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(14,5,20,3);
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(12,9,24,12);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,11,20,8);
        // Angry brown eyebrows with mecha enhancement
        ctx.fillStyle = '#374151'; ctx.fillRect(14,10,8,3); ctx.fillRect(26,10,8,3);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(15,11,6,2); ctx.fillRect(27,11,6,2);
        // Glowing red cyber-glasses
        ctx.fillStyle = '#1e293b'; ctx.fillRect(14,13,8,5); ctx.fillRect(26,13,8,5);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(15,14,6,3); ctx.fillRect(27,14,6,3);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(16,15,4,2); ctx.fillRect(28,15,4,2);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(17,15,2,1); ctx.fillRect(29,15,2,1);
        ctx.fillStyle = '#475569'; ctx.fillRect(22,15,4,1);
        // Brown beard with mecha jaw
        ctx.fillStyle = '#374151'; ctx.fillRect(10,18,28,6);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,19,24,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(14,19,20,3);
        // Ear comm devices
        ctx.fillStyle = '#4b5563'; ctx.fillRect(8,12,4,8); ctx.fillRect(36,12,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(9,14,2,4); ctx.fillRect(37,14,2,4);
        // Legs/thrusters
        ctx.fillStyle = '#374151'; ctx.fillRect(14,42,8,6); ctx.fillRect(26,42,8,6);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(16,44,4,4); ctx.fillRect(28,44,4,4);
        ctx.fillStyle = '#f97316'; ctx.fillRect(17,46,2,2); ctx.fillRect(29,46,2,2);
    });

    // IMPROVED OPS MANAGER NPC
    GFX.ops = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Slicked hair
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#2d2d2d'; ctx.fillRect(5,2,6,2);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,3);
        // Beady eyes
        ctx.fillStyle = '#000'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
        // Frown
        ctx.fillStyle = '#8b6b5a'; ctx.fillRect(6,8,4,1);
        // Red manager polo
        ctx.fillStyle = '#991b1b'; ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#b91c1c'; ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,11,8,2);
        // Collar
        ctx.fillStyle = '#fff'; ctx.fillRect(6,10,4,1);
        // Boots
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    // ENHANCED BOSS SPRITES
    GFX.boss_manager = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,0,12,6);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(3,1,10,4);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
        ctx.fillStyle = '#000'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,11,12,5);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(3,11,10,3);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,11,2,4);
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_inspector = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Grey hair
        ctx.fillStyle = '#6b7280'; ctx.fillRect(3,0,10,5);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(4,1,8,3);
        ctx.fillStyle = '#d4d4d4'; ctx.fillRect(5,1,3,2);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,3);
        // Stern eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
        // Yellow inspector jacket
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#eab308'; ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(4,11,8,2);
        // Badge
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(6,12,4,2);
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_compliance = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Dark hair
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(3,0,10,5);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(4,1,8,3);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(5,4,6,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,5,4,4);
        // Calculating eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(6,6,1,2); ctx.fillRect(9,6,1,2);
        // Cyan suit
        ctx.fillStyle = '#0891b2'; ctx.fillRect(3,10,10,6);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,10,8,4);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(5,11,6,2);
        // Tie
        ctx.fillStyle = '#14b8a6'; ctx.fillRect(7,10,2,5);
        ctx.fillStyle = '#a855f7'; ctx.fillRect(5,15,2,1); ctx.fillRect(9,15,2,1);
    });

    GFX.boss_regional = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Styled hair
        ctx.fillStyle = '#1e1b4b'; ctx.fillRect(2,0,12,6);
        ctx.fillStyle = '#312e81'; ctx.fillRect(3,1,10,4);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
        // Eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
        // Purple exec suit
        ctx.fillStyle = '#4c1d95'; ctx.fillRect(3,10,10,6);
        ctx.fillStyle = '#6d28d9'; ctx.fillRect(4,10,8,4);
        ctx.fillStyle = '#8b5cf6'; ctx.fillRect(5,11,6,2);
        // Gold tie
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(7,10,2,5);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_sebastian = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Bald head (no hair)
        ctx.fillStyle = '#f5d0a0'; ctx.fillRect(4,1,8,7);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,2,6,5);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(5,1,5,2); // Shine on bald head
        ctx.fillStyle = '#fce8d0'; ctx.fillRect(6,0,4,1); // Top shine
        // Eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,4,1,1); ctx.fillRect(9,4,1,1);
        // Slight beard (stubble/light beard)
        ctx.fillStyle = '#8b7355'; ctx.fillRect(5,6,6,2); // Beard area
        ctx.fillStyle = '#7a6248'; ctx.fillRect(6,7,4,1); // Chin beard
        ctx.fillStyle = '#6b5340'; ctx.fillRect(7,6,2,1); // Mustache hint
        // Blue Amazon polo
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(2,8,12,8);
        ctx.fillStyle = '#2563eb'; ctx.fillRect(3,8,10,6);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(4,9,8,4);
        // Orange smile logo
        ctx.fillStyle = '#f97316'; ctx.fillRect(6,11,4,2);
        ctx.fillStyle = '#fb923c'; ctx.fillRect(9,10,2,3);
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_jelly = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Brown hair
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(3,0,10,6);
        ctx.fillStyle = '#7a5142'; ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#8b6352'; ctx.fillRect(5,1,3,2);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,3);
        // Friendly eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
        // Smile
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(6,8,4,1);
        // Green HR jacket
        ctx.fillStyle = '#166534'; ctx.fillRect(3,10,10,6);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(4,10,8,4);
        ctx.fillStyle = '#4ade80'; ctx.fillRect(5,11,6,2);
        // Badge
        ctx.fillStyle = '#fff'; ctx.fillRect(5,12,6,2);
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_avetta = c(16,16, ctx => {
        // AI platform - robotic look
        ctx.fillStyle = 'rgba(34, 211, 238, 0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 6, 2, 0, 0, Math.PI*2); ctx.fill();
        // Main body
        ctx.fillStyle = '#0f172a'; ctx.fillRect(2,2,12,12);
        ctx.fillStyle = '#1e293b'; ctx.fillRect(3,3,10,10);
        // Glowing screen
        const screenGrad = ctx.createLinearGradient(4, 4, 12, 12);
        screenGrad.addColorStop(0, '#0ea5e9');
        screenGrad.addColorStop(1, '#22d3ee');
        ctx.fillStyle = screenGrad;
        ctx.fillRect(4,4,8,8);
        // Data lines
        ctx.fillStyle = '#67e8f9';
        ctx.fillRect(5,5,6,1);
        ctx.fillRect(5,7,5,1);
        ctx.fillRect(5,9,4,1);
        // Center indicator
        ctx.fillStyle = '#34d399';
        ctx.fillRect(9,7,2,3);
        // Warning light
        ctx.fillStyle = '#fcd34d';
        ctx.fillRect(7,10,2,1);
    });

    GFX.boss_bot = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Robot body
        ctx.fillStyle = '#374151'; ctx.fillRect(2,2,12,12);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(3,3,10,10);
        ctx.fillStyle = '#6b7280'; ctx.fillRect(4,4,8,8);
        // Visor
        ctx.fillStyle = '#1e293b'; ctx.fillRect(3,5,10,3);
        // Glowing eyes
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,6,3,2);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(5,6,1,1);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(9,6,3,2);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(10,6,1,1);
        // Mouth grille
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(5,10,6,2);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(6,10,1,2); ctx.fillRect(8,10,1,2); ctx.fillRect(10,10,1,2);
        // Antenna
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(7,0,2,3);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,0,2,1);
    });

    GFX.mechaJeff = c(64,64, ctx => {
        // Transparent background - no fill needed
        // Mecha body frame with gradient effect
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(8,32,48,28);
        ctx.fillStyle = '#252b3d'; ctx.fillRect(12,34,40,24);
        // Body armor plates
        ctx.fillStyle = '#3d4556'; ctx.fillRect(14,36,36,20);
        ctx.fillStyle = '#4a5568'; ctx.fillRect(16,38,32,16);
        // Amazon logo on chest (glowing)
        ctx.fillStyle = '#ff9900'; ctx.fillRect(24,42,16,8);
        ctx.fillStyle = '#ffb347'; ctx.fillRect(26,44,12,4);
        // Glowing arc smile
        ctx.fillStyle = '#ff6600'; ctx.fillRect(32,46,8,4);
        ctx.fillStyle = '#ff9900'; ctx.fillRect(38,44,4,8);
        // Shoulder cannons
        ctx.fillStyle = '#374151'; ctx.fillRect(2,28,12,24);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(4,30,8,20);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(5,34,6,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(6,35,4,4);
        ctx.fillStyle = '#374151'; ctx.fillRect(50,28,12,24);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(52,30,8,20);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(53,34,6,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(54,35,4,4);
        // Neck/collar chrome
        ctx.fillStyle = '#6b7280'; ctx.fillRect(18,28,28,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(20,29,24,4);
        // Bald dome with shine
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(20,8,24,22);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(22,6,20,8);
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(26,4,12,6);
        // Head shine highlight
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(24,6,8,4);
        // Evil eyebrows
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(22,14,8,3); ctx.fillRect(34,14,8,3);
        // Glowing red eyes
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(24,18,6,6); ctx.fillRect(34,18,6,6);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(25,19,4,4); ctx.fillRect(35,19,4,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(26,20,2,2); ctx.fillRect(36,20,2,2);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(26,26,12,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(28,27,8,1);
        // Ear pieces
        ctx.fillStyle = '#4b5563'; ctx.fillRect(16,14,4,10); ctx.fillRect(44,14,4,10);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(17,16,2,6); ctx.fillRect(45,16,2,6);
        // Legs
        ctx.fillStyle = '#374151'; ctx.fillRect(18,56,10,8); ctx.fillRect(36,56,10,8);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(20,58,6,6); ctx.fillRect(38,58,6,6);
    });
    // IMPROVED ASSOCIATE NPC
    GFX.assoc = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Hair
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#52525b';
        ctx.fillRect(5,2,6,2);
        // Face
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a';
        ctx.fillRect(5,6,6,3);
        // Eyes
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(5,6,2,2);
        ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,6,1,1);
        ctx.fillRect(9,6,1,1);
        // Yellow safety vest
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(4,11,8,2);
        // Reflective strips
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(3,11,10,1);
        ctx.fillRect(3,13,10,1);
        // Boots
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(4,15,3,1);
        ctx.fillRect(9,15,3,1);
    });

    // IMPROVED RUNNER NPC (with motion blur effect)
    GFX.runner = c(16,16, ctx => {
        // Motion blur shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(0, 14, 16, 2);
        // Motion lines
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillRect(0, 8, 3, 1);
        ctx.fillRect(0, 11, 2, 1);
        ctx.fillRect(13, 6, 3, 1);
        ctx.fillRect(14, 9, 2, 1);
        // Hair (windswept)
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(3,1,10,4);
        ctx.fillStyle = '#52525b';
        ctx.fillRect(4,2,8,2);
        // Face (leaning forward)
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(5,5,8,5);
        ctx.fillStyle = '#e8c49a';
        ctx.fillRect(6,6,6,3);
        // Wide eyes
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(6,6,2,2);
        ctx.fillRect(10,6,2,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(7,6,1,1);
        ctx.fillRect(11,6,1,1);
        // Yellow vest
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(3,10,11,6);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(4,10,9,4);
        // Reflective strips
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(4,11,9,1);
        ctx.fillRect(4,13,9,1);
        // Running legs
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,14,3,2);
        ctx.fillRect(11,14,3,2);
    });

    GFX.van = c(34,18, ctx => {
        ctx.fillStyle = '#020617'; ctx.fillRect(0,12,34,6);
        ctx.fillStyle = '#0b1224'; ctx.fillRect(1,10,32,8);
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(2,4,30,10);
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(2,10,30,2);
        ctx.fillStyle = '#2563eb'; ctx.fillRect(4,6,26,8);
        ctx.fillStyle = '#60a5fa'; ctx.fillRect(6,7,14,5);
        ctx.fillStyle = '#c7d2fe'; ctx.fillRect(20,6,8,6);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(22,9,6,2);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(6,14,8,4); ctx.fillRect(22,14,8,4);
        ctx.fillStyle = '#eab308'; ctx.fillRect(4,12,2,2); ctx.fillRect(28,12,2,2);
        ctx.fillStyle = '#f8fafc'; ctx.fillRect(14,5,2,2);
        ctx.fillStyle = '#0f172a'; ctx.font = '6px monospace'; ctx.fillText('DSP', 6, 11);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(0,15,4,3); ctx.fillRect(30,15,4,3);
    });

    GFX.truck = c(52,20, ctx => {
        ctx.fillStyle = '#020617'; ctx.fillRect(0,14,52,6);
        ctx.fillStyle = '#0b1224'; ctx.fillRect(1,12,50,8);
        ctx.fillStyle = '#cbd5e1'; ctx.fillRect(4,4,44,12);
        ctx.fillStyle = '#e5e7eb'; ctx.fillRect(6,6,40,10);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(6,8,18,8);
        ctx.fillStyle = '#f8fafc'; ctx.fillRect(24,8,24,8);
        ctx.fillStyle = '#dbeafe'; ctx.fillRect(6,6,14,3);
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(8,6,20,2);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(8,12,34,2);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(10,15,10,4); ctx.fillRect(34,15,10,4);
        ctx.fillStyle = '#facc15'; ctx.fillRect(4,4,4,10);
        ctx.fillStyle = '#0f172a'; ctx.font = '7px monospace'; ctx.fillText('PRIME', 22, 13);
        ctx.fillStyle = '#64748b'; ctx.fillRect(2,10,6,6);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(40,6,6,2);
        ctx.fillStyle = '#c2410c'; ctx.fillRect(0,16,52,1);
    });

    GFX.flyingBox = c(14,14, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,3,12,10);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,2,10,10);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(2,6,10,2);
        ctx.fillStyle = '#111827'; ctx.fillRect(4,4,2,2); ctx.fillRect(8,4,2,2);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(6,1,2,2);
    });

    // Bezos escape rocket - MASSIVE space rocket (Blue Origin style)
    GFX.escapeRocket = c(64,128, ctx => {
        // Main body (metallic silver/white)
        ctx.fillStyle = '#e5e7eb';
        ctx.fillRect(20, 16, 24, 96);
        ctx.fillStyle = '#f3f4f6';
        ctx.fillRect(24, 20, 16, 88);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(28, 24, 8, 80);

        // Nose cone (pointed, blue)
        ctx.fillStyle = '#1e40af';
        ctx.beginPath();
        ctx.moveTo(32, 0);
        ctx.lineTo(18, 24);
        ctx.lineTo(46, 24);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.moveTo(32, 4);
        ctx.lineTo(22, 20);
        ctx.lineTo(42, 20);
        ctx.closePath();
        ctx.fill();

        // Blue Origin stripe
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(20, 40, 24, 8);
        ctx.fillRect(20, 70, 24, 8);

        // Amazon arrow logo (orange)
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(24, 50, 16, 12);
        ctx.fillStyle = '#ffb347';
        ctx.beginPath();
        ctx.moveTo(24, 56);
        ctx.lineTo(40, 56);
        ctx.lineTo(40, 58);
        ctx.lineTo(32, 62);
        ctx.lineTo(24, 58);
        ctx.closePath();
        ctx.fill();

        // Windows (multiple)
        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = '#0ea5e9';
            ctx.beginPath();
            ctx.arc(32, 28 + i * 16, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#67e8f9';
            ctx.beginPath();
            ctx.arc(30, 26 + i * 16, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Landing legs / Fins (4 of them, blue)
        ctx.fillStyle = '#1e40af';
        // Left fin
        ctx.beginPath();
        ctx.moveTo(20, 96);
        ctx.lineTo(4, 124);
        ctx.lineTo(12, 124);
        ctx.lineTo(20, 108);
        ctx.closePath();
        ctx.fill();
        // Right fin
        ctx.beginPath();
        ctx.moveTo(44, 96);
        ctx.lineTo(60, 124);
        ctx.lineTo(52, 124);
        ctx.lineTo(44, 108);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.moveTo(22, 98);
        ctx.lineTo(10, 120);
        ctx.lineTo(16, 120);
        ctx.lineTo(22, 106);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(42, 98);
        ctx.lineTo(54, 120);
        ctx.lineTo(48, 120);
        ctx.lineTo(42, 106);
        ctx.closePath();
        ctx.fill();

        // Engine section (darker)
        ctx.fillStyle = '#374151';
        ctx.fillRect(18, 108, 28, 16);
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(22, 110, 20, 12);

        // Engine nozzles (3)
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(22, 120, 6, 8);
        ctx.fillRect(29, 120, 6, 8);
        ctx.fillRect(36, 120, 6, 8);
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(23, 121, 4, 6);
        ctx.fillRect(30, 121, 4, 6);
        ctx.fillRect(37, 121, 4, 6);
    });

    GFX.clutter = { cart: c(16,16, ctx => { ctx.fillStyle = '#444'; ctx.fillRect(2,6,12,8); ctx.fillStyle = '#8b4513'; ctx.fillRect(4,4,8,6); }), coffee: c(8,8, ctx => { ctx.fillStyle='#fff'; ctx.fillRect(2,2,4,5); }), paper: c(8,8, ctx => { ctx.fillStyle='#eee'; ctx.fillRect(1,3,6,4); }), tape: c(8,8, ctx => { ctx.fillStyle='#d97706'; ctx.beginPath(); ctx.arc(4,4,3,0,Math.PI*2); ctx.fill(); }) };
   GFX.hazards = {
    // --- Liquids / Spills (Amazon yellow warning) ---
    spill: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.ellipse(8,11,7,4,0,0,Math.PI*2); ctx.fill();
        // Dark base
        ctx.fillStyle = '#b91c1c';
        ctx.beginPath(); ctx.ellipse(8,10,6,4,0,0,Math.PI*2); ctx.fill();
        // Main puddle (red hazmat)
        ctx.fillStyle = '#dc2626';
        ctx.beginPath(); ctx.ellipse(8,9,5,3,0,0,Math.PI*2); ctx.fill();
        // Highlight
        ctx.fillStyle = '#ef4444';
        ctx.beginPath(); ctx.ellipse(6,8,2,1.5,0,0,Math.PI*2); ctx.fill();
        // Warning reflection
        ctx.fillStyle = '#fecaca';
        ctx.fillRect(9,9,2,1);
    }),

    // --- Amazon Box ---
    box: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(2,6,13,10);
        // Main box (Amazon brown)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(1,4,13,10);
        // Front face
        ctx.fillStyle = '#a16207';
        ctx.fillRect(2,5,11,8);
        // Top flaps
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,3,11,2);
        // Amazon tape (Prime blue)
        ctx.fillStyle = '#0284c7';
        ctx.fillRect(4,7,6,2);
        // Smile arrow
        ctx.fillStyle = '#f97316';
        ctx.fillRect(5,10,4,1);
        ctx.fillRect(8,9,1,1);
        // Barcode label
        ctx.fillStyle = '#fff';
        ctx.fillRect(9,5,3,3);
        ctx.fillStyle = '#111';
        ctx.fillRect(10,6,1,1);
    }),

    // --- Chemical drum / hazmat ---
    drum: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8,14,5,2,0,0,Math.PI*2); ctx.fill();
        // Body (safety blue)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(4,3,8,10);
        // Top
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath(); ctx.ellipse(8,3,4,2,0,0,Math.PI*2); ctx.fill();
        // Bands
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(4,5,8,1);
        ctx.fillRect(4,10,8,1);
        // Hazard diamond
        ctx.fillStyle = '#facc15';
        ctx.fillRect(6,6,4,3);
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(7,7,2,1);
    }),

    // --- Tall pallet stacks ---
    tall_pallet: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(4,14,10,2);
        // Main stack (Amazon orange)
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(3,1,10,13);
        // Box layers
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(4,2,8,3);
        ctx.fillRect(4,6,8,3);
        ctx.fillRect(4,10,8,3);
        // Tape highlights
        ctx.fillStyle = '#0284c7';
        ctx.fillRect(5,3,2,1); ctx.fillRect(9,3,2,1);
        ctx.fillRect(5,7,2,1); ctx.fillRect(9,7,2,1);
        // Pallet base (wood)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(2,13,12,2);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(3,13,2,2); ctx.fillRect(7,13,2,2); ctx.fillRect(11,13,2,2);
    }),

    // --- Debris / broken pallets ---
    debris: c(16,16, ctx => {
        // Scattered packing material
        ctx.fillStyle = '#d6d3d1';
        ctx.fillRect(2,8,4,2); ctx.fillRect(10,10,3,2);
        // Main broken plank
        ctx.save();
        ctx.translate(8,8);
        ctx.rotate(0.35);
        ctx.fillStyle = '#78350f';
        ctx.fillRect(-6,-2,12,4);
        ctx.fillStyle = '#92400e';
        ctx.fillRect(-5,-1,10,2);
        ctx.restore();
        // Scattered nails/screws
        ctx.fillStyle = '#71717a';
        ctx.fillRect(4,12,1,2); ctx.fillRect(11,11,2,1);
        // Cardboard chunk
        ctx.fillStyle = '#a16207';
        ctx.fillRect(1,4,3,3);
    }),

    // --- Conveyor / chute (Amazon FC style) ---
    conveyor: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(2,12,13,3);
        // Frame (industrial gray)
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(1,5,14,8);
        // Belt surface
        ctx.fillStyle = '#374151';
        ctx.fillRect(2,6,12,6);
        // Belt segments
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(3,7,2,4); ctx.fillRect(7,7,2,4); ctx.fillRect(11,7,2,4);
        // Rollers
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(2,5,3,1); ctx.fillRect(11,5,3,1);
        // Jammed package (Amazon brown)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(5,3,6,4);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(6,4,4,2);
        // Warning light
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(1,4,2,2);
    }),

    // --- Scanner Battery / charging station ---
    battery: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(4,13,9,3);
        // Battery body
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,5,10,8);
        ctx.fillStyle = '#374151';
        ctx.fillRect(4,6,8,6);
        // Terminals (yellow)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(5,3,2,3); ctx.fillRect(9,3,2,3);
        // Lightning symbol
        ctx.fillStyle = '#facc15';
        ctx.fillRect(7,6,2,1); ctx.fillRect(6,7,1,2); ctx.fillRect(7,8,2,1); ctx.fillRect(9,9,1,2);
        // Warning label
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,10,6,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(7,11,2,1);
    }),

    // --- Extension Cord / scanner cord ---
    cord: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.ellipse(8,13,6,2,0,0,Math.PI*2); ctx.fill();
        // Coiled yellow cable
        ctx.strokeStyle = '#eab308';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(2,4);
        ctx.bezierCurveTo(5,10,8,2,11,8);
        ctx.bezierCurveTo(13,12,15,6,14,10);
        ctx.stroke();
        // Cable highlight
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(3,3); ctx.bezierCurveTo(6,8,9,2,12,6);
        ctx.stroke();
        // Plug
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(12,8,3,4);
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(13,12,1,2);
    }),

    // --- Amazon Tote / bin ---
    tote: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(3,13,11,3);
        // Main body (Amazon yellow)
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,5,12,9);
        // Front face
        ctx.fillStyle = '#eab308';
        ctx.fillRect(3,6,10,7);
        // Rim
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,4,12,2);
        // Handle cutouts
        ctx.fillStyle = '#92400e';
        ctx.fillRect(4,5,3,1); ctx.fillRect(9,5,3,1);
        // Label area
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,8,6,3);
        // Barcode
        ctx.fillStyle = '#111';
        ctx.fillRect(6,9,4,1);
    }),

    // --- Stretch wrap / shrink wrap ---
    wrap: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(3,12,10,3);
        // Crumpled wrap
        ctx.fillStyle = '#e2e8f0';
        ctx.beginPath();
        ctx.moveTo(2,5); ctx.lineTo(14,4); ctx.lineTo(13,12); ctx.lineTo(3,13);
        ctx.closePath(); ctx.fill();
        // Texture lines
        ctx.fillStyle = '#cbd5e1';
        ctx.fillRect(4,6,8,1); ctx.fillRect(5,9,6,1);
        // Stretched tension
        ctx.fillStyle = '#f1f5f9';
        ctx.fillRect(6,7,4,2);
        // Torn edge
        ctx.fillStyle = '#94a3b8';
        ctx.fillRect(10,10,3,2);
    }),

    // --- Roller cage / Gaylord cage ---
    cage: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(4,14,9,2);
        // Frame (blue warehouse cage)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(2,2,12,12);
        // Wire mesh pattern
        ctx.fillStyle = '#3b82f6';
        for (let x = 3; x <= 12; x += 2) { ctx.fillRect(x,3,1,10); }
        for (let y = 4; y <= 11; y += 2) { ctx.fillRect(3,y,10,1); }
        // Contents visible
        ctx.fillStyle = '#92400e';
        ctx.fillRect(5,6,3,4); ctx.fillRect(9,7,3,3);
        // Caster wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(3,13,2,2); ctx.fillRect(11,13,2,2);
    }),

    // --- Flat cart / Amazon blue cart ---
    cart: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(3,13,11,3);
        // Platform (Amazon blue)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(2,9,12,4);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(2,8,12,2);
        // Handle frame
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,3,2,6);
        ctx.fillRect(3,3,9,2);
        ctx.fillRect(11,3,2,3);
        // Grip
        ctx.fillStyle = '#f97316';
        ctx.fillRect(4,3,7,1);
        // Wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(3,12,3,3); ctx.fillRect(10,12,3,3);
        ctx.fillStyle = '#374151';
        ctx.fillRect(4,13,1,1); ctx.fillRect(11,13,1,1);
    }),

    // --- Fire door / emergency exit ---
    door: c(16,16, ctx => {
        // Frame
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(3,1,10,14);
        // Door panel (safety green)
        ctx.fillStyle = '#15803d';
        ctx.fillRect(4,2,8,12);
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(5,3,6,10);
        // Window
        ctx.fillStyle = '#0c4a6e';
        ctx.fillRect(6,3,4,3);
        ctx.fillStyle = '#0ea5e9';
        ctx.fillRect(7,4,2,1);
        // Push bar
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,8,6,2);
        // EXIT sign
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(6,11,4,2);
        // Wedge blocking (hazard!)
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(4,14); ctx.lineTo(8,14); ctx.lineTo(8,12); ctx.closePath();
        ctx.fill();
    }),

    // --- Loading dock ---
    dock: c(16,16, ctx => {
        // Shadow/pit
        ctx.fillStyle = '#020617';
        ctx.fillRect(1,8,14,7);
        // Dock plate
        ctx.fillStyle = '#374151';
        ctx.fillRect(2,9,12,5);
        // Diamond plate texture
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(3,10,2,1); ctx.fillRect(6,10,2,1); ctx.fillRect(9,10,2,1); ctx.fillRect(12,10,2,1);
        ctx.fillRect(4,12,2,1); ctx.fillRect(7,12,2,1); ctx.fillRect(10,12,2,1);
        // Yellow safety edge
        ctx.fillStyle = '#eab308';
        ctx.fillRect(2,8,12,2);
        // Warning stripes
        ctx.fillStyle = '#111';
        ctx.fillRect(4,8,2,2); ctx.fillRect(8,8,2,2); ctx.fillRect(12,8,2,2);
        // Edge bumper
        ctx.fillStyle = '#f97316';
        ctx.fillRect(1,6,3,2); ctx.fillRect(12,6,3,2);
    }),

    // --- Facility hazard / bollard ---
    facility: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8,15,4,2,0,0,Math.PI*2); ctx.fill();
        // Column base
        ctx.fillStyle = '#374151';
        ctx.fillRect(5,12,6,3);
        // Main column (safety yellow)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(5,2,6,11);
        // Warning stripes
        ctx.fillStyle = '#111';
        ctx.fillRect(5,4,6,2); ctx.fillRect(5,8,6,2); ctx.fillRect(5,12,6,1);
        // Top cap
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(5,1,6,2);
        // Reflector
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(6,5,4,1);
    }),

    // --- Unsafe worker behavior ---
    npc: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath(); ctx.ellipse(8,15,5,2,0,0,Math.PI*2); ctx.fill();
        // Head
        ctx.fillStyle = '#facc15';
        ctx.beginPath();
        ctx.arc(8,4,3,0,Math.PI*2);
        ctx.fill();
        // Body (Amazon hi-vis vest)
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(5,7,6,7);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(6,8,4,5);
        // Hi-vis reflective stripes
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(5,8,6,1); ctx.fillRect(5,11,6,1);
        // Phone in hand (distracted!)
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(11,6,3,5);
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(12,7,1,3);
        // Legs
        ctx.fillStyle = '#1e3a8a';
        ctx.fillRect(6,13,2,2); ctx.fillRect(8,13,2,2);
    }),

    // --- PIT Forklift ---
    forklift: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(5,13,10,3);
        // Main body (Amazon orange)
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(3,7,8,6);
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(4,8,6,4);
        // Cabin/cage
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,4,7,4);
        ctx.fillStyle = '#374151';
        ctx.fillRect(4,5,5,2);
        // Windshield
        ctx.fillStyle = '#0c4a6e';
        ctx.fillRect(5,5,3,2);
        // Mast
        ctx.fillStyle = '#374151';
        ctx.fillRect(10,2,2,11);
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(11,3,1,9);
        // Forks
        ctx.fillStyle = '#eab308';
        ctx.fillRect(11,11,4,1); ctx.fillRect(11,13,4,1);
        // Wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(3,12,3,3); ctx.fillRect(7,12,3,3);
        // Warning light
        ctx.fillStyle = '#f97316';
        ctx.fillRect(5,4,2,1);
    }),

    // --- DSP Van / yard hazard ---
    yard: c(16,16, ctx => {
        // Asphalt
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(0,6,16,10);
        // Lane markings
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,10,3,1); ctx.fillRect(7,10,3,1); ctx.fillRect(12,10,3,1);
        // Prime van body
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(3,3,10,7);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(4,4,8,5);
        // Windshield
        ctx.fillStyle = '#0c4a6e';
        ctx.fillRect(10,4,3,3);
        // Prime smile logo
        ctx.fillStyle = '#f97316';
        ctx.fillRect(5,6,4,1); ctx.fillRect(8,5,1,1);
        // Wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(4,9,2,3); ctx.fillRect(10,9,2,3);
        // Headlights
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(11,8,2,1);
    }),

    // --- Compliance / audit clipboard ---
    compliance: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(4,13,9,3);
        // Clipboard board
        ctx.fillStyle = '#92400e';
        ctx.fillRect(3,2,10,13);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(4,3,8,11);
        // Metal clip
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(6,1,4,3);
        ctx.fillStyle = '#d4d4d8';
        ctx.fillRect(7,2,2,1);
        // Paper
        ctx.fillStyle = '#f5f5f4';
        ctx.fillRect(5,4,6,9);
        // Checklist lines
        ctx.fillStyle = '#71717a';
        ctx.fillRect(6,5,4,1); ctx.fillRect(6,7,4,1); ctx.fillRect(6,9,3,1);
        // Red X marks (violations!)
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(10,5,1,1); ctx.fillRect(10,7,1,1);
        // Warning stamp
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(6,10,4,2);
    }),

    // --- Box cutter / safety blade ---
    blade: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(4,12,10,3);
        // Handle (safety orange)
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(2,7,9,4);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(3,8,7,2);
        // Grip ridges
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(4,8,1,2); ctx.fillRect(6,8,1,2); ctx.fillRect(8,8,1,2);
        // Blade (exposed!)
        ctx.fillStyle = '#d4d4d8';
        ctx.fillRect(10,8,4,2);
        ctx.fillStyle = '#a1a1aa';
        ctx.fillRect(11,8,3,1);
        // Blade edge (sharp!)
        ctx.fillStyle = '#e4e4e7';
        ctx.fillRect(13,8,1,2);
        // Guard tab
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(10,7,1,4);
    }),

    // --- Pallet Jack / Manual Pump Truck ---
    jack: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 14, 6, 2, 0, 0, Math.PI*2); ctx.fill();
        // Fork base (yellow safety color)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(2,10,12,3);
        // Fork tines
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,12,3,2);
        ctx.fillRect(11,12,3,2);
        // Main body/pump
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(6,5,4,6);
        // Handle
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(7,2,2,4);
        ctx.fillRect(6,2,4,1);
        // Wheels
        ctx.fillStyle = '#111827';
        ctx.fillRect(3,13,2,2);
        ctx.fillRect(11,13,2,2);
        // Small steering wheel
        ctx.fillStyle = '#374151';
        ctx.fillRect(7,8,2,1);
    })
};
    // ENHANCED FIRE EXIT DOOR
    GFX.door = c(16,16, ctx => {
        // Door frame shadow
        ctx.fillStyle = '#064e3b';
        ctx.fillRect(1,0,14,16);
        // Door frame
        ctx.fillStyle = '#065f46';
        ctx.fillRect(2,1,12,14);
        // Main door panel
        const doorGrad = ctx.createLinearGradient(3, 0, 13, 0);
        doorGrad.addColorStop(0, '#10b981');
        doorGrad.addColorStop(0.5, '#34d399');
        doorGrad.addColorStop(1, '#10b981');
        ctx.fillStyle = doorGrad;
        ctx.fillRect(3,2,10,12);
        // Window with glow
        ctx.fillStyle = '#0d9488';
        ctx.fillRect(4,3,8,4);
        ctx.fillStyle = '#5eead4';
        ctx.fillRect(5,4,6,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,4,3,1);
        // Handle
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(10,8,3,2);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(11,8,1,2);
        // EXIT text indicator
        ctx.fillStyle = '#ecfdf5';
        ctx.fillRect(5,10,6,2);
    });

    // ENHANCED WAREHOUSE FLOOR - industrial concrete look
    GFX.floor = c(16,16, ctx => {
        // Base concrete
        const floorGrad = ctx.createLinearGradient(0, 0, 16, 16);
        floorGrad.addColorStop(0, '#44444f');
        floorGrad.addColorStop(0.5, '#3c3c47');
        floorGrad.addColorStop(1, '#38383f');
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0,0,16,16);
        // Tile pattern
        ctx.fillStyle = '#3a3a42';
        ctx.fillRect(0,0,8,8);
        ctx.fillRect(8,8,8,8);
        // Subtle texture
        ctx.fillStyle = '#4a4a55';
        ctx.fillRect(2,2,4,4);
        ctx.fillRect(10,10,4,4);
        // Grout lines
        ctx.fillStyle = '#2d2d35';
        ctx.fillRect(7,0,2,16);
        ctx.fillRect(0,7,16,2);
        // Wear marks
        ctx.fillStyle = '#35353d';
        ctx.fillRect(4,4,2,2);
        ctx.fillRect(11,3,1,1);
        ctx.fillRect(3,12,2,1);
        // Edge shadow
        ctx.fillStyle = '#28282e';
        ctx.fillRect(0,15,16,1);
        ctx.fillRect(15,0,1,16);
    });

    // ENHANCED WAREHOUSE WALL - industrial cinder block
    GFX.wall = c(16,16, ctx => {
        // Base wall color
        const wallGrad = ctx.createLinearGradient(0, 0, 0, 16);
        wallGrad.addColorStop(0, '#3d3530');
        wallGrad.addColorStop(0.5, '#4a4138');
        wallGrad.addColorStop(1, '#3a322c');
        ctx.fillStyle = wallGrad;
        ctx.fillRect(0,0,16,16);
        // Cinder block pattern
        ctx.fillStyle = '#4e443c';
        ctx.fillRect(1,1,6,6);
        ctx.fillRect(9,1,6,6);
        ctx.fillRect(1,9,6,6);
        ctx.fillRect(9,9,6,6);
        // Block highlights
        ctx.fillStyle = '#5d5248';
        ctx.fillRect(2,2,4,4);
        ctx.fillRect(10,2,4,4);
        ctx.fillRect(2,10,4,4);
        ctx.fillRect(10,10,4,4);
        // Block texture
        ctx.fillStyle = '#6d6258';
        ctx.fillRect(3,3,2,2);
        ctx.fillRect(11,3,2,2);
        ctx.fillRect(3,11,2,2);
        ctx.fillRect(11,11,2,2);
        // Mortar lines
        ctx.fillStyle = '#2a241f';
        ctx.fillRect(0,0,16,1);
        ctx.fillRect(0,8,16,1);
        ctx.fillRect(7,0,2,16);
        // Shadow effects
        ctx.fillStyle = '#1a1612';
        ctx.fillRect(0,7,16,1);
        ctx.fillRect(0,15,16,1);
    });
    // ENHANCED WAREHOUSE SHELF - industrial racking
    GFX.shelf = c(16,16, ctx => {
        // Vertical posts with shading
        ctx.fillStyle = '#92400e';
        ctx.fillRect(0,0,4,16);
        ctx.fillRect(12,0,4,16);
        ctx.fillStyle = '#b45309';
        ctx.fillRect(1,0,3,16);
        ctx.fillRect(13,0,3,16);
        ctx.fillStyle = '#d97706';
        ctx.fillRect(2,0,1,16);
        ctx.fillRect(13,0,1,16);
        // Horizontal shelves with depth
        ctx.fillStyle = '#a16207';
        ctx.fillRect(0,4,16,4);
        ctx.fillRect(0,11,16,4);
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(1,5,14,2);
        ctx.fillRect(1,12,14,2);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(2,5,12,1);
        ctx.fillRect(2,12,12,1);
        // Shelf items
        ctx.fillStyle = '#78350f';
        ctx.fillRect(4,2,3,2);
        ctx.fillRect(9,2,3,2);
        ctx.fillRect(5,9,4,2);
        // Safety labels
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(6,6,4,1);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(2,5,12,1); ctx.fillRect(2,11,12,1);
    });
    // ENHANCED RULE BOOK projectile
    GFX.book = c(10,10, ctx => {
        // Book shadow
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(2,2,8,8);
        // Book cover
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(0,0,8,8);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(1,1,6,6);
        // Book spine
        ctx.fillStyle = '#15803d';
        ctx.fillRect(0,0,2,8);
        // Pages
        ctx.fillStyle = '#f8fafc';
        ctx.fillRect(2,1,5,6);
        // Text lines
        ctx.fillStyle = '#64748b';
        ctx.fillRect(3,2,3,1);
        ctx.fillRect(3,4,2,1);
        // WHS badge
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(3,5,2,2);
    });

    // ENHANCED REQUEST projectile (from ops managers)
    GFX.req = c(12,12, ctx => {
        // Glow effect
        ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
        ctx.beginPath();
        ctx.arc(6, 6, 6, 0, Math.PI * 2);
        ctx.fill();
        // Diamond shape
        ctx.fillStyle = '#fef2f2';
        ctx.beginPath();
        ctx.moveTo(6,0);
        ctx.lineTo(12,6);
        ctx.lineTo(6,12);
        ctx.lineTo(0,6);
        ctx.closePath();
        ctx.fill();
        // Inner diamond
        ctx.fillStyle = '#fecaca';
        ctx.beginPath();
        ctx.moveTo(6,2);
        ctx.lineTo(10,6);
        ctx.lineTo(6,10);
        ctx.lineTo(2,6);
        ctx.closePath();
        ctx.fill();
        // Exclamation mark
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,3,2,4);
        ctx.fillRect(5,8,2,2);
    });
    // ENHANCED BOSS PROJECTILE
    GFX.bossProj = c(14,14, ctx => {
        // Outer glow
        const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
        grad.addColorStop(0, '#f5d0fe');
        grad.addColorStop(0.3, '#e879f9');
        grad.addColorStop(0.6, '#c026d3');
        grad.addColorStop(1, '#86198f');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(7, 7, 6, 0, Math.PI * 2);
        ctx.fill();
        // Core
        ctx.fillStyle = '#fdf4ff';
        ctx.beginPath();
        ctx.arc(7, 7, 2, 0, Math.PI * 2);
        ctx.fill();
        // Sparkle effect
        ctx.fillStyle = '#fff';
        ctx.fillRect(6, 1, 2, 2);
        ctx.fillRect(6, 11, 2, 2);
        ctx.fillRect(1, 6, 2, 2);
        ctx.fillRect(11, 6, 2, 2);
    });

    // Hidden level assets - HIGH QUALITY SNES style
    GFX.van = c(32,22, ctx => {
        // Main body outline
        ctx.fillStyle = '#0a3d5c'; ctx.fillRect(0,1,32,19);
        // Main body - Amazon blue with gradient effect
        ctx.fillStyle = '#146eb4'; ctx.fillRect(1,2,30,17);
        ctx.fillStyle = '#1e7fc4'; ctx.fillRect(1,2,30,2); // Top highlight
        ctx.fillStyle = '#0a4d7c'; ctx.fillRect(1,17,30,2); // Bottom shadow
        // Windshield (angled)
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(2,4,11,8);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(3,5,9,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(4,6,7,4);
        // Side windows
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(14,5,7,7);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(15,6,5,5);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(15,6,4,4);
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(22,5,7,7);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(23,6,5,5);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(23,6,4,4);
        // Amazon smile arrow
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(15,13,10,2);
        ctx.fillRect(23,13,2,3);
        // Front grille
        ctx.fillStyle = '#222'; ctx.fillRect(2,11,4,3);
        // Wheels (detailed)
        ctx.fillStyle = '#000'; ctx.fillRect(5,19,6,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(6,19,4,3);
        ctx.fillStyle = '#444'; ctx.fillRect(7,20,2,1);
        ctx.fillStyle = '#000'; ctx.fillRect(21,19,6,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(22,19,4,3);
        ctx.fillStyle = '#444'; ctx.fillRect(23,20,2,1);
        // Highlights
        ctx.fillStyle = '#fff'; ctx.fillRect(2,3,2,1); ctx.fillRect(5,5,1,2);
    });
    GFX.truck = c(42,26, ctx => {
        // Outline
        ctx.fillStyle = '#4a2511'; ctx.fillRect(0,1,42,23);
        // Main body - brown with shading
        ctx.fillStyle = '#8b4513'; ctx.fillRect(1,2,40,21);
        ctx.fillStyle = '#a0522d'; ctx.fillRect(1,2,40,3); // Top highlight
        ctx.fillStyle = '#5d2a0a'; ctx.fillRect(1,20,40,3); // Bottom shadow
        // Cab section
        ctx.fillStyle = '#654321'; ctx.fillRect(1,3,14,15);
        // Windshield
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(2,5,13,9);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(3,6,11,7);
        ctx.fillStyle = '#6a9fbe'; ctx.fillRect(4,7,9,5);
        // Cargo section windows
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(17,6,9,8);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(18,7,7,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(19,8,5,4);
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(28,6,9,8);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(29,7,7,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(30,8,5,4);
        // Amazon logo (large on side)
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(18,15,18,4);
        ctx.fillRect(32,15,4,5);
        ctx.fillStyle = '#000';
        ctx.font = '6px monospace';
        ctx.fillText('PRIME', 20, 18);
        // Front grille
        ctx.fillStyle = '#222'; ctx.fillRect(2,13,6,4);
        // Wheels (detailed)
        ctx.fillStyle = '#000'; ctx.fillRect(7,23,7,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,23,5,3);
        ctx.fillStyle = '#555'; ctx.fillRect(9,24,3,1);
        ctx.fillStyle = '#000'; ctx.fillRect(29,23,7,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(30,23,5,3);
        ctx.fillStyle = '#555'; ctx.fillRect(31,24,3,1);
        // Highlights
        ctx.fillStyle = '#fff'; ctx.fillRect(2,3,3,1); ctx.fillRect(5,6,1,3);
    });
    GFX.bezosHead = c(24,24, ctx => {
        // Shadow base
        ctx.fillStyle = '#0a0a14'; ctx.fillRect(2,2,20,20);
        // Bald head with shading
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,3,16,17);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,4,14,14);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(6,5,12,12);
        // Head shine highlight
        ctx.fillStyle = '#faebd7'; ctx.fillRect(7,4,8,4);
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(8,5,5,2);
        // Evil eyebrows (angled)
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(7,9,5,2); ctx.fillRect(12,9,5,2);
        ctx.fillRect(6,10,1,1); ctx.fillRect(17,10,1,1);
        // Eyes with glint
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,12,4,3); ctx.fillRect(12,12,4,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(9,13,1,1); ctx.fillRect(13,13,1,1);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,17,8,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(9,17,6,1);
        // Ears
        ctx.fillStyle = '#d4a574'; ctx.fillRect(2,11,3,5); ctx.fillRect(19,11,3,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(3,12,2,3); ctx.fillRect(19,12,2,3);
    });
    // Jeff character for yard level - full body standing with arms crossed
    GFX.jeffYard = c(48,48, ctx => {
        // Transparent background - no fill needed
        // Legs (dark pants)
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(16,38,6,10); ctx.fillRect(26,38,6,10);
        ctx.fillStyle = '#2d3748'; ctx.fillRect(17,39,4,9); ctx.fillRect(27,39,4,9);
        // Shoes
        ctx.fillStyle = '#0f0f0f'; ctx.fillRect(15,46,8,2); ctx.fillRect(25,46,8,2);
        // Body (expensive suit jacket)
        ctx.fillStyle = '#1a2744'; ctx.fillRect(12,22,24,18);
        ctx.fillStyle = '#223050'; ctx.fillRect(14,24,20,14);
        // Suit lapels
        ctx.fillStyle = '#0f1a2e'; ctx.fillRect(20,24,2,12); ctx.fillRect(26,24,2,12);
        // White shirt underneath
        ctx.fillStyle = '#e8e8e8'; ctx.fillRect(21,24,6,10);
        ctx.fillStyle = '#ffffff'; ctx.fillRect(22,25,4,8);
        // Tie
        ctx.fillStyle = '#dc2626'; ctx.fillRect(23,25,2,8);
        ctx.fillStyle = '#b91c1c'; ctx.fillRect(23,33,2,3);
        // Arms crossed (in front of body)
        ctx.fillStyle = '#1a2744'; ctx.fillRect(10,26,28,8);
        ctx.fillStyle = '#223050'; ctx.fillRect(11,27,26,6);
        // Hands (flesh tone)
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(10,28,4,4); ctx.fillRect(34,28,4,4);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(11,29,2,2); ctx.fillRect(35,29,2,2);
        // Neck
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,18,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(21,19,6,4);
        // Head (bald)
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,2,20,18);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,3,16,15);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(18,4,12,12);
        // Dome shine
        ctx.fillStyle = '#faebd7'; ctx.fillRect(20,3,8,4);
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(22,3,4,2);
        // Eyebrows (arrogant raised)
        ctx.fillStyle = '#3f3f46'; ctx.fillRect(18,8,5,2); ctx.fillRect(25,8,5,2);
        // Eyes (looking down smugly)
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(19,11,4,3); ctx.fillRect(25,11,4,3);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(20,12,2,2); ctx.fillRect(26,12,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(20,12,1,1); ctx.fillRect(26,12,1,1);
        // Smug smirk
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(20,16,8,2);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(21,16,6,1);
        // One corner raised (smirk)
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(26,15,3,1);
        // Ears
        ctx.fillStyle = '#d4a574'; ctx.fillRect(12,10,3,6); ctx.fillRect(33,10,3,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(13,11,2,4); ctx.fillRect(33,11,2,4);
    });
    GFX.mechaBezos = c(48,48, ctx => {
        // Base plate
        ctx.fillStyle = '#0a0f18'; ctx.fillRect(0,0,48,48);
        // Mecha body with armor
        ctx.fillStyle = '#2d3748'; ctx.fillRect(8,22,32,20);
        ctx.fillStyle = '#3d4a5c'; ctx.fillRect(10,24,28,16);
        ctx.fillStyle = '#4a5568'; ctx.fillRect(12,26,24,12);
        // Amazon logo chest (glowing)
        ctx.fillStyle = '#ff9900'; ctx.fillRect(18,28,12,8);
        ctx.fillStyle = '#ffb347'; ctx.fillRect(20,30,8,4);
        ctx.fillStyle = '#ff6600'; ctx.fillRect(26,32,4,4);
        // Shoulder cannons with glow
        ctx.fillStyle = '#374151'; ctx.fillRect(0,22,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,24,6,14);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(3,28,4,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,29,2,2);
        ctx.fillStyle = '#374151'; ctx.fillRect(38,22,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(40,24,6,14);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(41,28,4,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(42,29,2,2);
        // Neck chrome
        ctx.fillStyle = '#6b7280'; ctx.fillRect(14,18,20,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(16,19,16,4);
        // Bald dome with highlight
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(14,2,20,18);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(16,1,16,8);
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(20,0,8,4);
        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(18,2,6,3);
        // Evil eyebrows
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(16,8,6,2); ctx.fillRect(26,8,6,2);
        // Glowing red eyes
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(17,11,5,5); ctx.fillRect(26,11,5,5);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(18,12,3,3); ctx.fillRect(27,12,3,3);
        ctx.fillStyle = '#ff4444'; ctx.fillRect(19,13,1,1); ctx.fillRect(28,13,1,1);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(19,17,10,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(21,17,6,1);
        // Ear sensors
        ctx.fillStyle = '#4b5563'; ctx.fillRect(10,8,4,8); ctx.fillRect(34,8,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,10,2,4); ctx.fillRect(35,10,2,4);
        // Legs
        ctx.fillStyle = '#374151'; ctx.fillRect(14,42,8,6); ctx.fillRect(26,42,8,6);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(16,44,4,4); ctx.fillRect(28,44,4,4);
    });
    GFX.bezosProj = c(12,12, ctx => { ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(6,6,5,0,Math.PI*2); ctx.fill(); ctx.fillStyle = '#ff9900'; ctx.beginPath(); ctx.arc(6,6,3,0,Math.PI*2); ctx.fill(); });
    GFX.drone = c(16,16, ctx => {
        // Drone body
        ctx.fillStyle = '#2a2a2a'; ctx.fillRect(4,6,8,4);
        // Propellers
        ctx.fillStyle = '#444'; ctx.fillRect(2,4,3,8); ctx.fillRect(11,4,3,8);
        // Eye/camera
        ctx.fillStyle = '#ff0000'; ctx.fillRect(7,7,2,2);
        // Amazon logo
        ctx.fillStyle = '#ff9900'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
    });

    // === NEW WAREHOUSE ATMOSPHERE SPRITES ===

    // Animated Conveyor Belt (horizontal)
    GFX.conveyorBelt = c(16,16, ctx => {
        // Belt frame
        ctx.fillStyle = '#374151'; ctx.fillRect(0,4,16,8);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(1,5,14,6);
        // Belt surface with ridges
        ctx.fillStyle = '#1f2937';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect(i * 2, 6, 1, 4);
        }
        // Rollers at ends
        ctx.fillStyle = '#6b7280'; ctx.fillRect(0,4,2,8); ctx.fillRect(14,4,2,8);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(0,6,2,4); ctx.fillRect(14,6,2,4);
        // Safety stripe
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(0,3,16,1); ctx.fillRect(0,12,16,1);
    });

    // Package on conveyor (small)
    GFX.packageSmall = c(12,12, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,2,10,9);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,3,8,7);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,5,4,2); // tape
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(3,3,6,1); // label
    });

    // Package on conveyor (large)
    GFX.packageLarge = c(16,14, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,2,14,11);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,3,12,9);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(2,2,12,2); // flap
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(5,6,6,2); // tape
        ctx.fillStyle = '#111'; ctx.fillRect(7,8,2,2); // barcode
    });

    // Manual Pallet Jack
    GFX.palletJack = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 14, 6, 2, 0, 0, Math.PI*2); ctx.fill();
        // Fork tines (yellow safety)
        ctx.fillStyle = '#eab308'; ctx.fillRect(2,10,12,3);
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,12,3,2); ctx.fillRect(11,12,3,2);
        // Main pump body (red)
        ctx.fillStyle = '#dc2626'; ctx.fillRect(6,5,4,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,6,2,4);
        // Handle
        ctx.fillStyle = '#1f2937'; ctx.fillRect(7,2,2,4);
        ctx.fillStyle = '#374151'; ctx.fillRect(6,2,4,1);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(3,13,2,2); ctx.fillRect(11,13,2,2);
    });

    // Pallet Jack with Load
    GFX.palletJackLoaded = c(16,20, ctx => {
        // Pallet on top
        ctx.fillStyle = '#92400e'; ctx.fillRect(1,0,14,3);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,1,12,2);
        // Boxes on pallet
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,3,6,6);
        ctx.fillStyle = '#a16207'; ctx.fillRect(3,4,4,4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(3,3,4,1); // tape
        ctx.fillStyle = '#78350f'; ctx.fillRect(8,4,6,5);
        ctx.fillStyle = '#a16207'; ctx.fillRect(9,5,4,3);
        // Fork tines
        ctx.fillStyle = '#eab308'; ctx.fillRect(2,10,12,3);
        // Pump body
        ctx.fillStyle = '#dc2626'; ctx.fillRect(6,13,4,4);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(3,16,2,2); ctx.fillRect(11,16,2,2);
    });

    // Worker pushing cart
    GFX.cartWorker = c(20,16, ctx => {
        // Cart first (behind worker)
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(10,8,9,6);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(11,7,7,5);
        // Packages on cart
        ctx.fillStyle = '#a16207'; ctx.fillRect(11,4,3,4);
        ctx.fillStyle = '#78350f'; ctx.fillRect(14,5,4,3);
        // Cart wheels
        ctx.fillStyle = '#111'; ctx.fillRect(11,13,2,2); ctx.fillRect(17,13,2,2);
        // Worker shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(5, 15, 4, 2, 0, 0, Math.PI*2); ctx.fill();
        // Worker body (hi-vis)
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,7,6,8);
        ctx.fillStyle = '#eab308'; ctx.fillRect(3,8,4,6);
        // Reflective strips
        ctx.fillStyle = '#fef08a'; ctx.fillRect(3,9,4,1); ctx.fillRect(3,12,4,1);
        // Head
        ctx.fillStyle = '#d4a574'; ctx.fillRect(3,3,4,4);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(3,2,4,2); // hair
        // Arms pushing
        ctx.fillStyle = '#d4a574'; ctx.fillRect(7,8,3,1);
    });

    // Package handler scanning
    GFX.packageHandler = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(6, 15, 4, 2, 0, 0, Math.PI*2); ctx.fill();
        // Body (hi-vis)
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,7,8,8);
        ctx.fillStyle = '#eab308'; ctx.fillRect(3,8,6,6);
        ctx.fillStyle = '#fef08a'; ctx.fillRect(3,9,6,1); ctx.fillRect(3,12,6,1);
        // Head
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,3,4,4);
        ctx.fillStyle = '#3f3f46'; ctx.fillRect(4,2,4,2); // cap
        // Scanner in hand
        ctx.fillStyle = '#111'; ctx.fillRect(10,6,4,6);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(11,7,2,1); // screen
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,11,2,1); // laser
        // Package being scanned
        ctx.fillStyle = '#a16207'; ctx.fillRect(10,12,5,3);
    });

    // Pallet stack (multiple boxes)
    GFX.palletStack = c(16,16, ctx => {
        // Pallet base
        ctx.fillStyle = '#92400e'; ctx.fillRect(1,13,14,3);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,14,12,1);
        // Bottom layer boxes
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,9,5,4); ctx.fillRect(8,9,6,4);
        ctx.fillStyle = '#a16207'; ctx.fillRect(3,10,3,2); ctx.fillRect(9,10,4,2);
        // Top layer boxes
        ctx.fillStyle = '#b45309'; ctx.fillRect(3,5,4,4); ctx.fillRect(8,6,5,3);
        ctx.fillStyle = '#d97706'; ctx.fillRect(4,6,2,2); ctx.fillRect(9,7,3,1);
        // Labels
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,7,2,1); ctx.fillRect(10,7,2,1);
    });

    // Sorting station
    GFX.sortStation = c(16,16, ctx => {
        // Main station body
        ctx.fillStyle = '#374151'; ctx.fillRect(1,6,14,9);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,7,12,7);
        // Chute openings
        ctx.fillStyle = '#1f2937'; ctx.fillRect(3,8,3,5); ctx.fillRect(7,8,3,5); ctx.fillRect(11,8,3,5);
        // Labels above chutes
        ctx.fillStyle = '#22c55e'; ctx.fillRect(3,6,3,2);
        ctx.fillStyle = '#eab308'; ctx.fillRect(7,6,3,2);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,6,3,2);
        // Top scanner bar
        ctx.fillStyle = '#111'; ctx.fillRect(2,3,12,3);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,4,8,1);
    });

    // Conveyor junction
    GFX.conveyorJunction = c(16,16, ctx => {
        // Cross pattern
        ctx.fillStyle = '#374151'; ctx.fillRect(0,5,16,6); ctx.fillRect(5,0,6,16);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(1,6,14,4); ctx.fillRect(6,1,4,14);
        // Center platform
        ctx.fillStyle = '#6b7280'; ctx.fillRect(5,5,6,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(6,6,4,4);
        // Direction arrows
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,7,2,2); ctx.fillRect(12,7,2,2);
        ctx.fillRect(7,2,2,2); ctx.fillRect(7,12,2,2);
    });

    // Warehouse signage
    GFX.signPick = c(16,10, ctx => {
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('PICK', 2, 7);
    });

    GFX.signPack = c(16,10, ctx => {
        ctx.fillStyle = '#16a34a'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('PACK', 2, 7);
    });

    GFX.signShip = c(16,10, ctx => {
        ctx.fillStyle = '#dc2626'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('SHIP', 2, 7);
    });

    // Floor arrow markings
    GFX.floorArrow = c(16,16, ctx => {
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(8, 2); ctx.lineTo(14, 8); ctx.lineTo(10, 8);
        ctx.lineTo(10, 14); ctx.lineTo(6, 14); ctx.lineTo(6, 8);
        ctx.lineTo(2, 8);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#92400e'; ctx.lineWidth = 1; ctx.stroke();
    });

    // === YARD LEVEL NEW SPRITES ===

    // Forklift (moving obstacle)
    GFX.forkliftMoving = c(24,20, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(2,17,20,3);
        // Main body
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(6,8,12,9);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(7,9,10,7);
        // Cabin
        ctx.fillStyle = '#1f2937'; ctx.fillRect(7,4,10,5);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(8,5,8,3);
        // Mast
        ctx.fillStyle = '#374151'; ctx.fillRect(2,2,4,15);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(3,3,2,13);
        // Forks
        ctx.fillStyle = '#1f2937'; ctx.fillRect(0,15,6,2); ctx.fillRect(0,13,6,2);
        // Pallet on forks
        ctx.fillStyle = '#92400e'; ctx.fillRect(0,8,6,5);
        ctx.fillStyle = '#a16207'; ctx.fillRect(1,9,4,3);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(8,16,4,3); ctx.fillRect(14,16,4,3);
        // Warning light
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(10,3,4,2);
    });

    // Power-up: Speed Boost
    GFX.powerSpeed = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#22d3ee');
        grad.addColorStop(0.5, '#0891b2');
        grad.addColorStop(1, 'rgba(8, 145, 178, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Lightning bolt
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(9, 2); ctx.lineTo(5, 8); ctx.lineTo(8, 8);
        ctx.lineTo(6, 14); ctx.lineTo(12, 7); ctx.lineTo(9, 7);
        ctx.closePath();
        ctx.fill();
    });

    // Power-up: Shield
    GFX.powerShield = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#a855f7');
        grad.addColorStop(0.5, '#7c3aed');
        grad.addColorStop(1, 'rgba(124, 58, 237, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Shield shape
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(8, 2); ctx.lineTo(13, 5); ctx.lineTo(13, 9);
        ctx.lineTo(8, 14); ctx.lineTo(3, 9); ctx.lineTo(3, 5);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#7c3aed'; ctx.fillRect(7, 6, 2, 4);
    });

    // Power-up: Extra Life
    GFX.powerLife = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#f87171');
        grad.addColorStop(0.5, '#dc2626');
        grad.addColorStop(1, 'rgba(220, 38, 38, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Heart
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(8, 13);
        ctx.bezierCurveTo(2, 8, 2, 3, 8, 6);
        ctx.bezierCurveTo(14, 3, 14, 8, 8, 13);
        ctx.fill();
    });

    // Collectible package (bonus points)
    GFX.collectPackage = c(14,14, ctx => {
        // Sparkle glow
        ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
        ctx.beginPath(); ctx.arc(7, 7, 7, 0, Math.PI*2); ctx.fill();
        // Box
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(2,3,10,9);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(3,4,8,7);
        // Smile logo
        ctx.fillStyle = '#ff9900'; ctx.fillRect(4,7,6,2);
        ctx.fillRect(8,7,2,3);
        // Sparkles
        ctx.fillStyle = '#fff';
        ctx.fillRect(1, 1, 2, 1); ctx.fillRect(11, 2, 2, 1);
        ctx.fillRect(0, 10, 1, 2); ctx.fillRect(12, 11, 2, 1);
    });

    // Safety barrier
    GFX.safetyBarrier = c(16,12, ctx => {
        // Posts
        ctx.fillStyle = '#1f2937'; ctx.fillRect(1,0,3,12); ctx.fillRect(12,0,3,12);
        // Warning stripes
        for (let i = 0; i < 4; i++) {
            ctx.fillStyle = i % 2 === 0 ? '#fbbf24' : '#111';
            ctx.fillRect(4, i * 3, 8, 3);
        }
    });

    // Loading dock door
    GFX.dockDoor = c(32,24, ctx => {
        // Door frame
        ctx.fillStyle = '#374151'; ctx.fillRect(0,0,32,24);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,2,28,20);
        // Segmented door
        for (let i = 0; i < 4; i++) {
            ctx.fillStyle = i % 2 === 0 ? '#6b7280' : '#9ca3af';
            ctx.fillRect(3, 3 + i * 4, 26, 4);
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(3, 3 + i * 4 + 3, 26, 1);
        }
        // Door number
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace';
        ctx.fillText('D1', 12, 14);
    });

    // Yard pedestrian
    GFX.yardPedestrian = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Legs
        ctx.fillStyle = '#1f2937'; ctx.fillRect(5,12,2,3); ctx.fillRect(9,12,2,3);
        // Body (hi-vis)
        ctx.fillStyle = '#16a34a'; ctx.fillRect(3,6,10,7);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(4,7,8,5);
        // Reflective X
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(4,7,1,5); ctx.fillRect(11,7,1,5);
        ctx.fillRect(4,9,8,1);
        // Head with hard hat
        ctx.fillStyle = '#d4a574'; ctx.fillRect(5,3,6,4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(4,1,8,3);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(5,2,6,1);
    });
}
// --- GAME STATE ---
const GAME = {
    state: 'PRESS_START',
    stateTimer: 0,
    nextState: 'PLAY',
    ticks: 0,
    player: null,
    selectedChar: "Carrie",
    charList: ["Carrie", "Nevena", "Joao", "Roman", "Erwin"],
    charIndex: 0,
    camera: { x: 0, y: 0 },
    map: [], clutter: [], entities: [], projectiles: [], particles: [], floatingTexts: [],
    activeIssues: [],
    issuesFixed: 0, lives: 5, genId: 0, gameOverTriggered: false, simonHits: 0, boss: null, pendingBossIntro: false,
    shake: 0, flash: 0,
    dialogText: "", dialogVisible: "", dialogTimer: 0,
    introDialogueStep: 0, // Track intro conversation sequence
    // Portrait animation state
    portraitAnimInterval: null,
    currentPortraitBase: null,
    currentPortraitTalking: null,
    portraitTalkPhase: false,
    splashTimer: 0, aiResultText: null,
    // Game Over screen state
    gameOverPhase: 0, corporateMessage: "", characterDefeatLine: "", gameOverReason: "",
    creditsType: 'normal', // 'normal' for surprise visitor, 'mecha' for Mecha Jeff
    startTime: 0, booksFired: 0, opsPushed: 0,
    lastAIBanterTime: 0, // Throttle AI requests
    fireExitDoor: null, // Hidden level door position
    froggerVehicles: [], // Vehicles array (deprecated, kept for compatibility)
    jeffTaunt: "", // Current Jeff taunt
    jeffTauntTimer: 0, // Timer for taunt display

    // === NEW WAREHOUSE ATMOSPHERE ===
    conveyorBelts: [], // Animated conveyor belt positions
    packages: [], // Moving packages on conveyors
    palletJacks: [], // Moving pallet jacks
    cartWorkers: [], // Workers pushing carts
    palletStacks: [], // Static pallet stacks
    sortStations: [], // Sorting station positions
    warehouseSigns: [], // Zone signage

    // === YARD LEVEL ENHANCEMENTS ===
    powerUps: [], // Power-ups in yard level
    collectibles: [], // Collectible packages
    forklifts: [], // Moving forklift obstacles
    playerPowerUp: null, // Current active power-up
    powerUpTimer: 0, // Power-up duration timer
    score: 0, // Bonus score from collectibles
    yardPedestrians: [], // NPC pedestrians in yard

    bossTypes: [
        { name: "Labour Inspector", sprite: "boss_inspector", hp: 25, speed: 1.2, attackDelay: 50, title: "The Enforcer", desc: "Checks every corner.", attackName: "Violation Notice", attackPattern: "sweep" },
        { name: "Compliance Auditor", sprite: "boss_compliance", hp: 30, speed: 0.8, attackDelay: 70, title: "The Watcher", desc: "Nothing escapes.", attackName: "Audit Cascade", attackPattern: "tracking" },
        { name: "Sebastian Sprigade", sprite: "boss_sebastian", hp: 35, speed: 1.0, attackDelay: 60, title: "Delivery Station Mgr", desc: "Obsessed with TPH.", attackName: "TPH Overload", attackPattern: "burst" },
        { name: "Regional OPS MGR", sprite: "boss_regional", hp: 32, speed: 0.6, attackDelay: 90, title: "The Executive", desc: "Metrics first.", attackName: "KPI Crusher", attackPattern: "orbital" },
        { name: "Avetta Platform", sprite: "boss_avetta", hp: 40, speed: 0.4, attackDelay: 100, title: "Risk Manager", desc: "Judges all.", attackName: "Risk Assessment Beam", attackPattern: "laser" },
        { name: "Jelena \"Jelly\"", sprite: "boss_jelly", hp: 28, speed: 0.9, attackDelay: 65, title: "HR Guardian", desc: "HR legend who never forgets a policy.", attackName: "Write-Up Wave", attackPattern: "wave" }
    ]
};

const HAZARD_POOL = [
    // === POWERED INDUSTRIAL TRUCKS (PITs) ===
    { name: "Speeding PIT Operator", type: "forklift" },
    { name: "Forklift With Blocked View", type: "forklift" },
    { name: "Reach Truck Cutting Corner", type: "forklift" },
    { name: "Order Picker Too High", type: "forklift" },
    { name: "Turret Truck Near Pedestrians", type: "forklift" },
    { name: "Clamp Truck Overloaded", type: "forklift" },
    { name: "PIT Operator Without Seatbelt", type: "forklift" },

    // === PACK & SHIP HAZARDS ===
    { name: "Overflowing SLAM Line", type: "conveyor" },
    { name: "Jammed AFE Chute", type: "conveyor" },
    { name: "SIOC Avalanche", type: "box" },
    { name: "Crushed Jiffy Mailer Pile", type: "debris" },
    { name: "Tape Gun Left Running", type: "blade" },
    { name: "Poly Bag Explosion", type: "wrap" },
    { name: "Gift Wrap Station Chaos", type: "debris" },
    { name: "Dunnage Bag Mountain", type: "debris" },

    // === INBOUND & RECEIVE ===
    { name: "Unbroken-Down Gaylord", type: "tall_pallet" },
    { name: "Vendor Pallet Leaning", type: "tall_pallet" },
    { name: "Receive Dock Gap", type: "dock" },
    { name: "Trailer Without Wheel Chocks", type: "dock" },
    { name: "Dock Plate Not Secured", type: "dock" },
    { name: "Mixed SKU Nightmare Pallet", type: "tall_pallet" },
    { name: "Shrink Wrap Tornado", type: "wrap" },

    // === PROBLEM SOLVE CHAOS ===
    { name: "Problem Solve Cart Avalanche", type: "cart" },
    { name: "ASIN Research Black Hole", type: "tote" },
    { name: "Damaged Out Pile Growing", type: "box" },
    { name: "Research Bin Overflow", type: "tote" },
    { name: "Missing Label Saga", type: "compliance" },

    // === FLOOR HAZARDS ===
    { name: "Ice Pack Leak Trail", type: "spill" },
    { name: "Crushed Fragile Item Spill", type: "spill" },
    { name: "Leaking Liquid Hazmat", type: "spill" },
    { name: "Sweeper Missed This Spot", type: "spill" },
    { name: "Energy Drink Explosion", type: "spill" },
    { name: "Smoothie Shrapnel Zone", type: "spill" },
    { name: "Coffee Ring of Standup Past", type: "spill" },
    { name: "Wet Floor No Sign", type: "spill" },

    // === STOW & STORAGE ===
    { name: "Overstuffed Prime Bin", type: "tote" },
    { name: "Top Stock About to Fall", type: "tall_pallet" },
    { name: "Heavy Item Stowed High", type: "tall_pallet" },
    { name: "Bin Capacity Ignored", type: "box" },
    { name: "Unstable Rack Section", type: "tall_pallet" },
    { name: "Random Cage Contents", type: "cage" },

    // === PICK & COUNT ===
    { name: "Scanner Cord Trip Wire", type: "cord" },
    { name: "Pick Cart Wheel Failure", type: "cart" },
    { name: "Tote Stack Too Tall", type: "tote" },
    { name: "Mystery SKU in Wrong Bin", type: "box" },
    { name: "Cycle Count Chaos", type: "compliance" },

    // === EQUIPMENT & TOOLS ===
    { name: "Box Cutter Without Guard", type: "blade" },
    { name: "Frayed Scanner Holster", type: "cord" },
    { name: "Broken Safety Ladder", type: "facility" },
    { name: "Missing Step Stool", type: "facility" },
    { name: "Unsecured Extension Cord", type: "cord" },
    { name: "Charging Station Overload", type: "battery" },
    { name: "Dead Battery Pile", type: "battery" },

    // === FIRE & EMERGENCY ===
    { name: "Blocked Fire Exit", type: "door" },
    { name: "Fire Extinguisher Hidden", type: "door" },
    { name: "Emergency Shower Blocked", type: "facility" },
    { name: "First Aid Kit Empty", type: "compliance" },
    { name: "AED Signage Covered", type: "facility" },

    // === ERGONOMIC HAZARDS ===
    { name: "Overreaching Associate", type: "npc" },
    { name: "Improper Lifting Technique", type: "npc" },
    { name: "Continuous Repetitive Motion", type: "npc" },
    { name: "Standing Mat Missing", type: "facility" },
    { name: "Keyboard at Wrong Height", type: "facility" },

    // === PEOPLE & BEHAVIOR ===
    { name: "Phone Walker on Floor", type: "npc" },
    { name: "Manager Speed Walk Mode", type: "npc" },
    { name: "New Hire Wrong Way Traffic", type: "npc" },
    { name: "Peak Season Burnout Zone", type: "npc" },
    { name: "Ambassador Training Cluster", type: "npc" },
    { name: "VTO Line Blocking Path", type: "npc" },

    // === OUTBOUND & SHIPPING ===
    { name: "Trailer Loaded Unevenly", type: "dock" },
    { name: "Smalls Bag Landslide", type: "debris" },
    { name: "Rollers Not Locked", type: "cage" },
    { name: "Cart Wall Collapse Risk", type: "cart" },
    { name: "CPT Rush Hour Chaos", type: "conveyor" },
    { name: "Sortation System Jam", type: "conveyor" },

    // === COMPLIANCE & DOCUMENTATION ===
    { name: "Safety Audit Due Tomorrow", type: "compliance" },
    { name: "Training Expired Badge", type: "compliance" },
    { name: "PPE Checklist Skipped", type: "compliance" },
    { name: "Incident Near-Miss Unreported", type: "compliance" },
    { name: "OSHA Log Update Pending", type: "compliance" },
    { name: "Lockout Tagout Forgotten", type: "compliance" },
];

function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function pickRandomHazards(count) {
    const picks = shuffleArray([...HAZARD_POOL]);
    return picks.slice(0, Math.min(count, picks.length));
}

function randomDoorPlacement() {
    const side = ['top', 'bottom', 'left', 'right'][Math.floor(Math.random() * 4)];
    const buffer = 2;
    let doorX = 0, doorY = 0, hazardX = 0, hazardY = 0;

    if (side === 'top') {
        doorY = 0; doorX = Math.floor(Math.random() * (MAP_W - buffer * 2)) + buffer;
        hazardX = doorX; hazardY = 1;
    } else if (side === 'bottom') {
        doorY = MAP_H - 1; doorX = Math.floor(Math.random() * (MAP_W - buffer * 2)) + buffer;
        hazardX = doorX; hazardY = MAP_H - 2;
    } else if (side === 'left') {
        doorX = 0; doorY = Math.floor(Math.random() * (MAP_H - buffer * 2)) + buffer;
        hazardX = 1; hazardY = doorY;
    } else {
        doorX = MAP_W - 1; doorY = Math.floor(Math.random() * (MAP_H - buffer * 2)) + buffer;
        hazardX = MAP_W - 2; hazardY = doorY;
    }

    return { doorX, doorY, hazardX, hazardY };
}

function isTileFree(tx, ty) {
    if (GAME.map[ty][tx] !== 0) return false;
    return !GAME.activeIssues.some(h => Math.round(h.x / TILE_SIZE) === tx && Math.round(h.y / TILE_SIZE) === ty);
}

function pickRandomFloorTile() {
    let attempts = 0;
    while (attempts < 500) {
        const tx = Math.floor(Math.random() * (MAP_W - 2)) + 1;
        const ty = Math.floor(Math.random() * (MAP_H - 2)) + 1;
        if (isTileFree(tx, ty)) return { tx, ty };
        attempts++;
    }
    return { tx: 1, ty: 1 };
}

// --- INPUT ---
const KEYS = { up: false, down: false, left: false, right: false, action: false };
window.addEventListener('keydown', e => {
    if(e.key==='w'||e.key==='ArrowUp') KEYS.up=true;
    if(e.key==='s'||e.key==='ArrowDown') KEYS.down=true;
    if(e.key==='a'||e.key==='ArrowLeft') KEYS.left=true;
    if(e.key==='d'||e.key==='ArrowRight') KEYS.right=true;
    if(e.code==='Space') { if(!KEYS.action) handleAction(); KEYS.action=true; }
});
window.addEventListener('keyup', e => {
    if(e.key==='w'||e.key==='ArrowUp') KEYS.up=false;
    if(e.key==='s'||e.key==='ArrowDown') KEYS.down=false;
    if(e.key==='a'||e.key==='ArrowLeft') KEYS.left=false;
    if(e.key==='d'||e.key==='ArrowRight') KEYS.right=false;
    if(e.code==='Space') KEYS.action=false;
});

function handleAction() {
    // Initialize audio systems (safely handle any errors)
    try {
        AudioSys.init();
        AudioSys.resume();
        MusicSys.init();
        MusicSys.resume();
    } catch(e) {
        console.error("Audio init error:", e);
    }

    // Force intro music to start on first user interaction (bypass autoplay restrictions)
    if (GAME.state === 'PRESS_START') {
        // First interaction - allows audio to play
        advanceState(); // Move to LOGO state and start intro music
        return;
    }
    // Let intro music play - ignore input and auto-advance after timer
    if (GAME.state === 'LOGO') { return; }
    // Handle other states that should not process input
    if (GAME.state === 'LOSE_SPLASH' || GAME.state === 'WIN_SPLASH') return;

    updateMusicForState();
    if (['INTRO', 'STORY'].includes(GAME.state)) { AudioSys.sfx.start(); advanceState(); }
    else if (['TITLE', 'HOWTO'].includes(GAME.state)) {
        GAME.state = (GAME.state==='TITLE')?'HOWTO':'SELECT'; AudioSys.sfx.select(); updateMusicForState();
    }
    else if (GAME.state === 'SELECT') { AudioSys.sfx.select(); GAME.selectedChar = GAME.charList[GAME.charIndex]; resetGame(); }
    else if (GAME.state === 'DIALOG') {
        if (GAME.dialogVisible.length < GAME.dialogText.length) {
            GAME.dialogVisible = GAME.dialogText;
            // Update whichever window is visible
            if (document.getElementById('intro-portrait-window').style.display === 'block') {
                document.getElementById('intro-text-content').innerText = GAME.dialogVisible;
            } else {
                document.getElementById('text-content').innerText = GAME.dialogVisible;
            }
        } else {
            // Close whichever window is visible
            if (document.getElementById('intro-portrait-window').style.display === 'block') {
                closeIntroDialog();
            } else {
                closeDialog();
            }
            // Check if transitioning to yard level
            if (GAME.nextState === 'YARD_INTRO') {
                GAME.state = 'YARD_INTRO';
                GAME.stateTimer = 0;
                startYardLevel();
            }
        }
    }
    else if (GAME.state === 'VISITOR_SPLASH') { initBossEncounter(); }
    else if (GAME.state === 'BOSS_INTRO') { GAME.state = 'BOSS'; GAME.nextState = 'BOSS'; updateMusicForState(); }
    else if (GAME.state === 'BEZOS_INTRO') { GAME.state = 'BEZOS_BOSS'; GAME.nextState = 'BEZOS_BOSS'; updateMusicForState(); }
    else if (GAME.state === 'MECHA_BOSS_INTRO') { GAME.state = 'MECHA_BOSS'; GAME.nextState = 'MECHA_BOSS'; updateMusicForState(); }
    else if (GAME.state === 'MECHA_SIMON_SPLASH') { GAME.state = 'BOSS'; GAME.nextState = 'BOSS'; updateMusicForState(); }
    else if (GAME.state === 'THRONE_CONFRONTATION') {
        // Throne confrontation cutscene using AI-powered showDialog system
        const scene = GAME.throneScene;
        if (!scene) return;

        // Phase 0: Quick zoom in animation (frames 0-20)
        if (scene.phase === 0 && GAME.stateTimer >= 20) {
            scene.phase = 1;
            // Start the AI dialogue sequence
            startBezosConfrontationDialogue();
        }
    }
    else if (GAME.state === 'MECHA_TRANSFORM') {
        // Only allow skip after animation has played for a bit
        if (GAME.stateTimer > 200) {
            beginMechaEncounter(); // Proceed to Mecha boss fight
        }
    }
    else if (GAME.state === 'SIMON_MECHA_TRANSFORM') {
        // Only allow proceeding after health bar animation completes (120 frames = 2 seconds)
        if (GAME.stateTimer > 120) {
            completeSimonMechaTransformation(); // Proceed to Phase 4: Transformation
        }
    }
    else if (GAME.state === 'BEZOS_ESCAPE') {
        // Handle escape scene dialogue advances
        const scene = GAME.escapeScene;
        if (scene && scene.phase === 7) {
            // During dialogue phase (phase 7), advance to next dialogue
            advanceBezosEscapeDialogue();
        }
    }
    else if (GAME.state === 'YARD_INTRO') { startYardLevel(); }
    else if (GAME.state === 'GAMEOVER_SPLASH') {
        // After viewing game over screen, go back to title
        if (GAME.stateTimer > 60) { // Short delay before allowing skip
            GAME.state = 'TITLE'; updateMusicForState();
        }
    }
    else if (GAME.state === 'GAMEOVER' || GAME.state === 'WIN') {
        document.getElementById('boss-hud').style.display = 'none'; GAME.state = 'TITLE'; updateMusicForState();
    }
    else if (GAME.state === 'BEZOS_WIN') {
        GAME.state = 'TITLE'; updateMusicForState();
    }
    else if (GAME.state === 'CREDITS') {
        // Allow skip after credits have been rolling for a while
        if (GAME.stateTimer > 600) {
            GAME.state = 'TITLE'; updateMusicForState();
        }
    }
    else if (GAME.state === 'PLAY' || GAME.state === 'BOSS' || GAME.state === 'BEZOS_BOSS' || GAME.state === 'MECHA_BOSS') {
        if (GAME.state === 'PLAY' && tryInteract()) return;
        throwBook();
    }
}

function init() {
    // Initialize cached values for performance
    CachedValues.init(canvas);

    generateAssets();
    GAME.state = 'PRESS_START';
    // DON'T call updateMusicForState() here - it will fail due to autoplay policy
    // Music will start on first user interaction in handleAction()
    requestAnimationFrame(loop);
}

function advanceState() {
    GAME.stateTimer = 0;
    if (GAME.state === 'PRESS_START') GAME.state = 'LOGO';
    else if (GAME.state === 'LOGO') GAME.state = 'INTRO';
    else if (GAME.state === 'INTRO') GAME.state = 'STORY';
    else if (GAME.state === 'STORY') GAME.state = 'TITLE';
    else if (GAME.state === 'TITLE') GAME.state = 'HOWTO';
    updateMusicForState();
}

function resetGame() {
    GAME.state = 'PLAY';
    GAME.genId++;
    GAME.gameOverTriggered = false;
    GAME.mechaSimonDefeat = false; // Reset Mecha Mega Simon defeat flag
    const stats = getCharStats(GAME.selectedChar);
    GAME.player = { x: 100, y: 100, dir: 0, speed: stats.speed, iframe: 0, cooldown: 0, cooldownMax: 120 };
    GAME.entities = []; GAME.projectiles = []; GAME.particles = []; GAME.floatingTexts = [];
    // Performance: Reset object pools on game restart
    ObjectPool.reset();
    GAME.activeIssues = []; GAME.clutter = [];
    GAME.issuesFixed = 0; GAME.lives = stats.lives; GAME.simonHits = 0; GAME.boss = null; GAME.pendingBossIntro = false;
    GAME.hiddenDoor = null; GAME.yard = null; GAME.mecha = null;
    GAME.nextState = 'PLAY'; GAME.aiResultText = null;
    GAME.startTime = Date.now(); GAME.booksFired = 0; GAME.opsPushed = 0;
    
    generateMap();
    GAME.entities.push({ type: 'simon', x: 100, y: 80, w: 16, h: 16 });
    document.getElementById('hud-layer').style.display = 'block'; updateHud();
    document.getElementById('boss-hud').style.display = 'none';
    
    // --- INTRO DIALOGUE SEQUENCE ---
    GAME.introDialogueStep = 0;
    const currentGen = GAME.genId;

    // Show Simon's thinking state in INTRO WINDOW while AI generates greeting
    showIntroThinking("Simon Unglaube");
    GAME.nextState = 'INTRO_DIALOGUE_CONTINUE'; // Custom state for dialogue sequence

    // Generate Simon's greeting with objective overview
    callGemini(`You are Simon Unglaube, WHS Senior Regional Manager for Amazon MEU. Give ${GAME.selectedChar} a brief welcome with your signature dry wit, then explain their shift objective: find and fix 5 safety hazards while dodging ops manager interruptions. Keep it concise and witty. Max 45 words.`, "intro").then(text => {
        if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
             let finalText = text.replace(/\[.*?\]/g, GAME.selectedChar);
             showIntroDialog(finalText, "Simon Unglaube", true);
        }
    });
    updateMusicForState();
}

function generateMap() {
    GAME.map = [];
    // Reset warehouse atmosphere arrays
    GAME.conveyorBelts = [];
    GAME.packages = [];
    GAME.palletJacks = [];
    GAME.cartWorkers = [];
    GAME.palletStacks = [];
    GAME.sortStations = [];
    GAME.warehouseSigns = [];

    for(let y=0; y<MAP_H; y++) {
        GAME.map[y] = [];
        for(let x=0; x<MAP_W; x++) {
            if (x===0 || x===MAP_W-1 || y===0 || y===MAP_H-1) GAME.map[y][x] = 1;
            else if (x > 5 && x < 55 && y % 5 === 0 && x % 3 !== 0) GAME.map[y][x] = 2;
            else {
                GAME.map[y][x] = 0;
                if (Math.random() < 0.05) {
                    const type = ['coffee','paper','tape'][Math.floor(Math.random()*3)];
                    GAME.clutter.push({x: x*TILE_SIZE + 4, y: y*TILE_SIZE + 4, type: type});
                }
            }
        }
    }
    for(let y=15; y<25; y++) for(let x=25; x<35; x++) GAME.map[y][x] = 0;

    // === ADD CONVEYOR BELT LANES ===
    // Horizontal conveyor lanes through the warehouse
    const conveyorLanes = [8, 18, 28]; // Y positions for conveyor lanes
    conveyorLanes.forEach(laneY => {
        for (let x = 6; x < 54; x++) {
            if (x % 3 !== 0) { // Gap for crossing
                GAME.conveyorBelts.push({
                    x: x * TILE_SIZE,
                    y: laneY * TILE_SIZE,
                    dir: laneY === 18 ? -1 : 1 // Alternate directions
                });
            }
        }
    });

    // === SPAWN MOVING PACKAGES ON CONVEYORS ===
    for (let i = 0; i < 12; i++) {
        const laneY = conveyorLanes[Math.floor(Math.random() * conveyorLanes.length)];
        GAME.packages.push({
            x: Math.random() * (48 * TILE_SIZE) + 6 * TILE_SIZE,
            y: laneY * TILE_SIZE - 4,
            speed: (laneY === 18 ? -0.5 : 0.5) + Math.random() * 0.2,
            type: Math.random() < 0.5 ? 'small' : 'large'
        });
    }


    // === SPAWN CART WORKERS ===
    for (let i = 0; i < 4; i++) {
        const startY = 10 + i * 8;
        GAME.cartWorkers.push({
            x: 8 * TILE_SIZE,
            y: startY * TILE_SIZE,
            targetX: 50 * TILE_SIZE,
            dir: 1, // 1 = right, -1 = left
            speed: 0.6 + Math.random() * 0.2,
            pauseTimer: 0
        });
    }

    // === ADD PALLET STACKS (static decoration) ===
    const palletPositions = [
        {x: 4, y: 4}, {x: 4, y: 12}, {x: 4, y: 22}, {x: 4, y: 32},
        {x: 55, y: 4}, {x: 55, y: 12}, {x: 55, y: 22}, {x: 55, y: 32},
        {x: 12, y: 35}, {x: 22, y: 35}, {x: 38, y: 35}, {x: 48, y: 35}
    ];
    palletPositions.forEach(pos => {
        if (pos.x < MAP_W - 1 && pos.y < MAP_H - 1) {
            GAME.palletStacks.push({
                x: pos.x * TILE_SIZE,
                y: pos.y * TILE_SIZE
            });
        }
    });

    // === ADD SORTING STATIONS ===
    GAME.sortStations.push(
        { x: 15 * TILE_SIZE, y: 3 * TILE_SIZE },
        { x: 35 * TILE_SIZE, y: 3 * TILE_SIZE },
        { x: 25 * TILE_SIZE, y: 36 * TILE_SIZE }
    );

    // === ADD WAREHOUSE ZONE SIGNS ===
    GAME.warehouseSigns.push(
        { x: 10 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'pick' },
        { x: 30 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'pack' },
        { x: 50 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'ship' }
    );

    const door = randomDoorPlacement();
    GAME.map[door.doorY][door.doorX] = 3;
    GAME.map[door.hazardY][door.hazardX] = 0;
    GAME.fireExitDoor = { x: door.doorX * TILE_SIZE, y: door.doorY * TILE_SIZE }; // Store door position for hidden level
    GAME.activeIssues.push({ x: door.hazardX*TILE_SIZE, y: door.hazardY*TILE_SIZE, data: {name: "Blocked Exit", type: "box"}, fixed: false });

    spawnEntity('runner'); spawnEntity('runner');

    const hazardList = pickRandomHazards(5);
    hazardList.forEach(rHazard => {
        const { tx, ty } = pickRandomFloorTile();
        GAME.activeIssues.push({ x: tx*TILE_SIZE, y: ty*TILE_SIZE, data: rHazard, fixed: false });
    });
    for(let i=0; i<8; i++) spawnEntity('ops');
    for(let i=0; i<10; i++) spawnEntity('assoc');
}

function spawnEntity(type) {
    let tx, ty;
    do { tx = Math.floor(Math.random()*(MAP_W-2))+1; ty = Math.floor(Math.random()*(MAP_H-2))+1; } while(GAME.map[ty][tx]!==0);
    GAME.entities.push({ type:type, x:tx*TILE_SIZE, y:ty*TILE_SIZE, dir:0, timer:0 });
}

function initSimonBoss() {
    GAME.state = 'BOSS_INTRO';
    AudioSys.sfx.bossIntro();
    GAME.boss = {
        name: "MEGA SIMON", sprite: "simonBoss", hp: 50, speed: 1.3, attackDelay: 30,
        title: "THE WHS FINAL BOSS", desc: "He is not impressed.", attackName: "SAFETY VIOLATION STORM", attackPattern: "storm",
        tauntsTriggered: [], tauntThresholds: [0.75, 0.5, 0.25], maxHp: 50,
        x: MAP_W * TILE_SIZE / 2, y: MAP_H * TILE_SIZE / 2, timer: 0,
        transformTriggered: false, isMecha: false, lowHealthAttackTriggered: false
    };
    GAME.entities = []; GAME.projectiles = [];
    updateMusicForState();
}

// Fake victory dialogue - player thinks they won at 0 HP, but Simon transforms
function triggerFakeVictoryDialogue() {
    // Phase 1: Player Surprise
    // Stop the action
    GAME.projectiles = [];
    GAME.shake = 15;
    GAME.flash = 10;
    AudioSys.sfx.fix(); // Victory sound

    // Initialize fake victory dialogue state
    GAME.fakeVictoryPhase = 0;
    GAME.fakeVictoryTimer = 0;
    GAME.state = 'SIMON_FAKE_VICTORY';
    GAME.stateTimer = 0;

    // Hide boss HUD temporarily to sell the "victory"
    document.getElementById('boss-hud').style.display = 'none';

    // Start the dialogue sequence after a short delay
    setTimeout(() => {
        if (GAME.state !== 'SIMON_FAKE_VICTORY') return;

        // Phase 1: Player expresses surprise (~2 seconds)
        showDialog("That was... surprisingly easy?", GAME.selectedChar, GFX.chars[GAME.selectedChar], false);
        GAME.fakeVictoryPhase = 1;
        GAME.nextState = 'SIMON_FAKE_VICTORY_CONTINUE';
    }, 500);
}

// Continue fake victory dialogue after player's line
function continueFakeVictoryDialogue() {
    GAME.fakeVictoryPhase++;

    if (GAME.fakeVictoryPhase === 2) {
        // Phase 2: Simon's Reveal
        GAME.shake = 20;
        AudioSys.sfx.angry();

        // Show boss HUD again with HP at 0 to start the animation
        document.getElementById('boss-hud').style.display = 'block';
        GAME.boss.hp = 0;
        GAME.boss.maxHp = 999;
        updateBossHud();

        showDialog("You fool... That wasn't even my final form!\n\nBEHOLD MY TRUE POWER!", "MEGA SIMON", GFX.simonBoss, false);
        GAME.nextState = 'SIMON_FAKE_VICTORY_TRANSFORM';
    }
}

// Handle closing dialog during fake victory sequence
function handleFakeVictoryDialogClose() {
    if (GAME.nextState === 'SIMON_FAKE_VICTORY_CONTINUE') {
        continueFakeVictoryDialogue();
    }
    else if (GAME.nextState === 'SIMON_FAKE_VICTORY_TRANSFORM') {
        // Now trigger the actual transformation
        triggerMechaSimonTransformation();
    }
}

// Mecha Mega Simon transformation - triggered after fake victory dialogue
function triggerMechaSimonTransformation() {
    // Phase 3: Health Bar Animation
    GAME.shake = 30;
    GAME.flash = 20;
    AudioSys.sfx.bossIntro();

    // Clear existing projectiles
    GAME.projectiles = [];

    // Start the transformation animation state
    GAME.state = 'SIMON_MECHA_TRANSFORM';
    GAME.stateTimer = 0;

    // Initialize health bar animation from 0% to 100%
    GAME.boss.hp = 0;
    GAME.boss.maxHp = 999;
    GAME.healthBarAnimProgress = 0; // Track animation progress (0 to 1)

    // Set flag to indicate transformation is in progress
    GAME.simonTransformTextFetched = true; // Skip AI text for simplified version
    GAME.simonTransformText = null;
}

// Complete Simon's mecha transformation after animation
function completeSimonMechaTransformation() {
    // Phase 4: Transformation Complete
    // Transform the boss
    GAME.boss.name = "MECHA MEGA SIMON";
    GAME.boss.title = "MECHANIZED AUDIT ENFORCER";
    GAME.boss.sprite = "mechaMegaSimon";
    GAME.boss.isMecha = true;
    GAME.boss.hp = 999;
    GAME.boss.maxHp = 999;
    GAME.boss.speed = 1.2; // Faster than before (was 1.0)
    GAME.boss.attackDelay = 40; // Faster attacks (was 55)
    GAME.boss.attackName = "COMPLIANCE ANNIHILATION";
    GAME.boss.mechaTimer = 0; // Timer to trigger game over
    document.getElementById('boss-name-el').innerText = GAME.boss.name;
    updateBossHud();

    // Return to boss fight immediately with massive visual effects
    GAME.state = 'BOSS';
    GAME.nextState = 'BOSS';
    GAME.shake = 50; // Massive screen shake
    GAME.flash = 30; // Massive flash

    // Spawn massive particle burst
    spawnParticleBurst(GAME.boss.x + 24, GAME.boss.y + 24, ['#eab308', '#dc2626', '#ff9900', '#ff4444'], 50);
}

// Show Mecha Mega Simon splash screen before boss fight
function showMechaSimonSplash() {
    GAME.state = 'MECHA_SIMON_SPLASH';
    GAME.stateTimer = 0;
    AudioSys.sfx.bossIntro();
}

function initBossEncounter() {
    GAME.state = 'BOSS_INTRO';
    GAME.stateTimer = 0;
    GAME.pendingBossIntro = false;
    GAME.nextState = 'BOSS';
    AudioSys.sfx.bossIntro();
    const bossData = GAME.bossTypes[Math.floor(Math.random() * GAME.bossTypes.length)];
    GAME.boss = { ...bossData, x: MAP_W * TILE_SIZE / 2, y: MAP_H * TILE_SIZE / 2, w: 32, h: 32, maxHp: bossData.hp, timer: 0, tauntsTriggered: [], tauntThresholds: [0.75, 0.5, 0.25], lowHealthAttackTriggered: false };
    GAME.entities = []; GAME.projectiles = [];
    document.getElementById('boss-name-el').innerText = GAME.boss.name;
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function startYardLevel() {
    GAME.state = 'YARD_LEVEL';
    GAME.stateTimer = 0;
    const yardHeight = 650; // Yard section height
    const hallwayHeight = 450; // Long hallway with lasers and drones
    const throneRoomHeight = 250; // Safe throne room at top
    const h = yardHeight + hallwayHeight + throneRoomHeight; // Total level height
    const castleStart = yardHeight; // Where castle/hallway begins
    const hallwayStart = throneRoomHeight; // Where the dangerous hallway starts (Y < this is safe throne room)
    GAME.yard = {
        height: h,
        yardHeight: yardHeight,
        castleStart: castleStart,
        hallwayStart: hallwayStart, // Y boundary for safe throne room
        throneRoomHeight: throneRoomHeight,
        cameraY: 0,
        playerX: canvas.width / 2 - 8,
        playerY: h - 32,
        startY: h - 32, // Remember starting position for reset
        speed: getCharStats(GAME.selectedChar).speed * 0.95,
        vehicles: [],
        forklifts: [], // Forklift hazards
        hazardZones: [], // Environmental hazard zones
        transformationTriggered: false, // Track if Mecha transformation cutscene started
        inCastle: false, // Track if player entered castle
        castleEntered: false, // Track if castle entry message shown
        inHallway: false, // Track if player entered the hallway
        hallwayEntered: false, // Track if hallway entry message shown
        throneRoomGreeted: false, // Track if throne room AI greeting was shown
        jeffAnimFrame: 0, // Animation frame for Jeff
        // Extended vehicle lanes - more challenging gauntlet with varied patterns (in yard section only)
        lanes: [
            { y: h - 70, dir: 1, speed: 0.85, timer: 75, type: 'truck' },
            { y: h - 120, dir: -1, speed: 1.0, timer: 65, type: 'van' },
            { y: h - 170, dir: 1, speed: 1.1, timer: 55, type: 'mixed' },
            { y: h - 230, dir: -1, speed: 0.9, timer: 80, type: 'truck' },
            { y: h - 290, dir: 1, speed: 1.2, timer: 50, type: 'van' },
            { y: h - 350, dir: -1, speed: 1.0, timer: 60, type: 'mixed' },
            { y: h - 410, dir: 1, speed: 1.15, timer: 55, type: 'van' },
            { y: h - 470, dir: -1, speed: 0.95, timer: 70, type: 'truck' },
            { y: h - 530, dir: 1, speed: 1.25, timer: 45, type: 'van' },
            { y: h - 590, dir: -1, speed: 1.1, timer: 50, type: 'mixed' }
        ],
        // Forklift crossing zones
        forkliftZones: [
            { y: h - 200, timer: 180, active: false },
            { y: h - 380, timer: 240, active: false },
            { y: h - 520, timer: 200, active: false }
        ],
        // Static hazard areas (puddles, debris) - in yard section
        staticHazards: [
            { x: 30, y: h - 150, type: 'puddle' },
            { x: 180, y: h - 260, type: 'debris' },
            { x: 80, y: h - 440, type: 'puddle' },
            { x: 150, y: h - 550, type: 'debris' }
        ],
        // Hallway section hazards (all within hallway zone, NOT in throne room)
        castleDrones: [], // Patrol drones in hallway
        castleLasers: [], // Laser barriers
        castleGuards: [], // Stationary guard turrets
        // Moving platforms only in hallway section (Y > hallwayStart)
        castlePlatforms: [
            { x: 20, y: hallwayStart + 50, w: 40, dir: 1, speed: 0.8 },
            { x: 150, y: hallwayStart + 120, w: 50, dir: -1, speed: 1.0 },
            { x: 80, y: hallwayStart + 200, w: 45, dir: 1, speed: 0.9 },
            { x: 30, y: hallwayStart + 280, w: 55, dir: -1, speed: 1.1 },
            { x: 120, y: hallwayStart + 360, w: 40, dir: 1, speed: 1.2 }
        ],
        // Laser barriers in hallway section (Y > hallwayStart)
        castleLaserBarriers: [
            { y: hallwayStart + 80, onTime: 60, offTime: 90, timer: 0, active: true },
            { y: hallwayStart + 160, onTime: 50, offTime: 80, timer: 30, active: false },
            { y: hallwayStart + 260, onTime: 70, offTime: 70, timer: 50, active: true },
            { y: hallwayStart + 350, onTime: 40, offTime: 100, timer: 20, active: false },
            { y: hallwayStart + 420, onTime: 55, offTime: 75, timer: 40, active: true }
        ],
        // Patrol drones initialization
        droneSpawnTimer: 0
    };

    // Initialize hallway guard turrets (all in hallway section, NOT in throne room)
    const y = GAME.yard;
    y.castleGuards = [
        { x: 10, y: hallwayStart + 60, fireTimer: 60, fireRate: 80 },
        { x: canvas.width - 26, y: hallwayStart + 130, fireTimer: 40, fireRate: 90 },
        { x: 10, y: hallwayStart + 200, fireTimer: 20, fireRate: 70 },
        { x: canvas.width - 26, y: hallwayStart + 290, fireTimer: 0, fireRate: 85 },
        { x: 10, y: hallwayStart + 380, fireTimer: 50, fireRate: 75 },
        { x: canvas.width - 26, y: hallwayStart + 440, fireTimer: 30, fireRate: 80 }
    ];

    GAME.player.speed = GAME.yard.speed;
    GAME.projectiles = [];
    GAME.particles = [];
    GAME.floatingTexts = [];
    updateMusicForState();

    // Show Simon's yard safety tip
    const safetyTip = SIMON_YARD_TIPS[Math.floor(Math.random() * SIMON_YARD_TIPS.length)];
    showDialog(safetyTip, "Simon Unglaube", GFX.simonFaceLarge, true);
    GAME.nextState = 'YARD_LEVEL';
}

function beginMechaEncounter() {
    GAME.state = 'MECHA_BOSS_INTRO';
    GAME.stateTimer = 0;
    // Completely redesigned Mecha Boss with multiple phases
    GAME.mecha = {
        hp: 48,
        maxHp: 48,
        x: canvas.width / 2 - 32,
        y: 18,
        baseY: 18,
        timer: 0,
        // Phase system: 0=Prime Missiles, 1=Drone Swarm, 2=Package Rain, 3=Laser Grid, 4=Ground Slam
        currentPhase: 0,
        phaseTimer: 0,
        phaseDuration: 280,
        phaseTransition: false,
        transitionTimer: 0,
        // Attack state
        attackCooldown: 0,
        projectiles: [],
        shadows: [],
        beam: null,
        beams: [], // Multiple beams for laser grid
        // Movement pattern
        moveDir: 1,
        moveTimer: 0,
        bobOffset: 0,
        // Enrage at low HP
        enraged: false,
        enrageFlash: 0,
        // Dash attack
        dashing: false,
        dashTarget: null,
        dashSpeed: 0,
        // Ground slam
        slamming: false,
        slamTimer: 0,
        slamY: 18,
        // Phase names for announcements
        phaseNames: ['PRIME STRIKE', 'DRONE SWARM', 'PACKAGE STORM', 'LASER GRID', 'GROUND SLAM'],
        phaseTaunts: [
            "PRIME DELIVERY INCOMING!",
            "RELEASE THE DRONES!",
            "BOXES FROM THE SKY!",
            "LASER PRECISION!",
            "FEEL THE EARTH SHAKE!"
        ]
    };
    GAME.player.x = canvas.width / 2 - 8;
    GAME.player.y = canvas.height - 28;
    GAME.boss = { name: 'MECHA JEFF', hp: 48, maxHp: 48 };
    document.getElementById('boss-name-el').innerText = 'MECHA JEFF';
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function startCredits() {
    GAME.state = 'CREDITS';
    GAME.stateTimer = 0;
    GAME.boss = null;
    stopPortraitAnimation();
    document.getElementById('boss-hud').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';
    document.getElementById('dialog-box').style.display = 'none';
    GAME.projectiles = [];
    GAME.particles = [];
    GAME.floatingTexts = [];
    updateMusicForState();
}

function queueVisitorSplash() {
    if (GAME.pendingBossIntro || GAME.boss) return;
    GAME.pendingBossIntro = true;
    GAME.nextState = 'VISITOR_SPLASH';
}

function showVisitorSplash() {
    GAME.state = 'VISITOR_SPLASH';
    GAME.stateTimer = 0;
    GAME.nextState = 'BOSS_INTRO';
    AudioSys.sfx.bossIntro();
    updateMusicForState();
}

function initMechaBezos() {
    GAME.state = 'BEZOS_INTRO';
    GAME.stateTimer = 0;
    AudioSys.sfx.bossIntro();

    GAME.boss = {
        name: "MECHA JEFF BEZOS",
        sprite: "mechaBezos",
        hp: 40,
        maxHp: 40,
        speed: 1.2,
        attackDelay: 50,
        title: "THE ULTIMATE BOSS",
        desc: "Automation has gone too far!",
        attackName: "AUTOMATION PROTOCOL",
        x: 104,
        y: 60,
        w: 48,
        h: 48,
        timer: 0,
        attackPhase: 0, // Tracks which attack pattern (0-2)
        laserAngle: 0, // For laser sweep attack
        droneSpawnTimer: 0,
        tauntsTriggered: [],
        tauntThresholds: [0.75, 0.5, 0.25]
    };

    GAME.player.x = 120;
    GAME.player.y = 180;
    GAME.entities = [];
    GAME.projectiles = [];
    GAME.froggerVehicles = [];

    document.getElementById('boss-name-el').innerText = "MECHA JEFF BEZOS";
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function updateMechaBezos() {
    const b = GAME.boss;
    if (!b) return;

    b.timer++;

    // Initialize new boss properties if not set
    if (!b.enraged) b.enraged = false;
    if (!b.tauntTimer) b.tauntTimer = 0;
    if (!b.fallingPackages) b.fallingPackages = [];
    if (!b.shockwaveTimer) b.shockwaveTimer = 0;
    if (!b.dashTarget) b.dashTarget = null;
    if (!b.dashCooldown) b.dashCooldown = 0;

    // === ENRAGE MODE when HP < 10 ===
    if (b.hp <= 10 && !b.enraged) {
        b.enraged = true;
        b.speed *= 1.5;
        GAME.flash = 15;
        GAME.shake = 20;
        spawnFloatingText(b.x + 24, b.y - 10, "ENRAGED!", "#ff0000");
        AudioSys.sfx.bossIntro();
    }

    // === FALLING PACKAGE HAZARDS ===
    if (b.timer % 90 === 0 && b.attackPhase >= 1) {
        // Spawn falling packages from top of screen
        for (let i = 0; i < (b.enraged ? 3 : 2); i++) {
            b.fallingPackages.push({
                x: Math.random() * 220 + 18,
                y: -20,
                vy: 2 + Math.random() * 1,
                w: 14,
                h: 14
            });
        }
    }

    // Update falling packages
    for (let i = b.fallingPackages.length - 1; i >= 0; i--) {
        const pkg = b.fallingPackages[i];
        pkg.y += pkg.vy;

        // Remove if off screen
        if (pkg.y > 240) {
            b.fallingPackages.splice(i, 1);
            continue;
        }

        // Check collision with player
        if (GAME.player.iframe === 0 &&
            GAME.player.x < pkg.x + pkg.w && GAME.player.x + 16 > pkg.x &&
            GAME.player.y < pkg.y + pkg.h && GAME.player.y + 16 > pkg.y) {
            GAME.lives--;
            GAME.player.iframe = 60;
            updateHud();
            AudioSys.sfx.hurt();
            GAME.shake = 6;
            b.fallingPackages.splice(i, 1);
            spawnFloatingText(GAME.player.x, GAME.player.y - 16, "PRIME DELIVERY!", "#ff9900");
            if (GAME.lives <= 0) {
                triggerGameOver("PRIME DELIVERED!");
            }
        }
    }

    // === BOSS DASH ATTACK (new mechanic) ===
    if (b.dashCooldown > 0) b.dashCooldown--;
    if (b.enraged && b.dashCooldown === 0 && b.timer % 180 === 0) {
        // Start dash attack
        b.dashTarget = { x: GAME.player.x, y: GAME.player.y };
        b.dashCooldown = 200;
        spawnFloatingText(b.x + 24, b.y - 16, "PRIME NOW!", "#ff4444");
        AudioSys.sfx.alert();
    }

    // Execute dash
    if (b.dashTarget) {
        const dx = b.dashTarget.x - b.x;
        const dy = b.dashTarget.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 10) {
            b.x += (dx / dist) * 5; // Fast dash speed
            b.y += (dy / dist) * 5;
        } else {
            b.dashTarget = null;
            // Shockwave on landing
            b.shockwaveTimer = 30;
            GAME.shake = 10;
            // Spawn ring of projectiles
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                GAME.projectiles.push({
                    type: 'bezos_missile',
                    x: b.x + 24,
                    y: b.y + 24,
                    vx: Math.cos(angle) * 2.5,
                    vy: Math.sin(angle) * 2.5,
                    life: 80,
                    boss: true
                });
            }
        }
    } else {
        // Normal movement toward player
        const dx = GAME.player.x - b.x;
        const dy = GAME.player.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 60) {
            b.x += (dx / dist) * b.speed;
            b.y += (dy / dist) * b.speed;
        }
    }

    // === TAUNT MECHANIC ===
    b.tauntTimer++;
    if (b.tauntTimer > 300 && !b.taunting) {
        b.taunting = true;
        const taunts = [
            "YOUR METRICS ARE UNACCEPTABLE!",
            "TWO-DAY SHIPPING... FOR YOUR DOOM!",
            "PRIME DIRECTIVE: ELIMINATE!",
            "CUSTOMER OBSESSION... WITH DESTRUCTION!",
            "BEZOS PROTOCOL ENGAGED!"
        ];
        const taunt = taunts[Math.floor(Math.random() * taunts.length)];
        spawnFloatingText(b.x + 24, b.y - 20, taunt.substring(0, 20), "#ff9900");
        b.tauntTimer = 0;
        setTimeout(() => { if (b) b.taunting = false; }, 1000);
    }

    // Switch attack phases based on HP
    if (b.hp > 26) b.attackPhase = 0; // Phase 1: Missile Spread
    else if (b.hp > 13) b.attackPhase = 1; // Phase 2: Laser Sweep
    else b.attackPhase = 2; // Phase 3: Drone Swarm

    // === ATTACK PHASE 1: PRIME MISSILE SPREAD ===
    const attackDelay = b.enraged ? Math.floor(b.attackDelay * 0.7) : b.attackDelay;
    if (b.attackPhase === 0 && b.timer % attackDelay === 0) {
        // Fire missiles in a spread pattern
        const missileCount = b.enraged ? 12 : 8;
        for (let i = 0; i < missileCount; i++) {
            const angle = (i / missileCount) * Math.PI * 2;
            const vx = Math.cos(angle) * 3;
            const vy = Math.sin(angle) * 3;
            GAME.projectiles.push({
                type: 'bezos_missile',
                x: b.x + 24,
                y: b.y + 24,
                vx: vx,
                vy: vy,
                life: 120,
                boss: true
            });
        }
        AudioSys.sfx.throw();
    }

    // === ATTACK PHASE 2: LASER SWEEP ===
    if (b.attackPhase === 1) {
        const laserSpeed = b.enraged ? 0.08 : 0.05;
        b.laserAngle += laserSpeed;
        // Fire laser beam every few frames
        const laserRate = b.enraged ? 5 : 8;
        if (b.timer % laserRate === 0) {
            const vx = Math.cos(b.laserAngle) * 4;
            const vy = Math.sin(b.laserAngle) * 4;
            GAME.projectiles.push({
                type: 'bezos_laser',
                x: b.x + 24,
                y: b.y + 24,
                vx: vx,
                vy: vy,
                life: 40,
                boss: true
            });
            if (b.timer % 16 === 0) AudioSys.sfx.alert();
        }
    }

    // === ATTACK PHASE 3: DRONE SWARM ===
    if (b.attackPhase === 2) {
        b.droneSpawnTimer++;
        const droneRate = b.enraged ? 35 : 50;
        if (b.droneSpawnTimer > droneRate) {
            b.droneSpawnTimer = 0;
            // Spawn a drone that homes in on player
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 100;
            GAME.entities.push({
                type: 'drone',
                x: b.x + 24 + Math.cos(angle) * spawnDist,
                y: b.y + 24 + Math.sin(angle) * spawnDist,
                w: 16,
                h: 16,
                speed: b.enraged ? 2.0 : 1.5,
                hp: 2
            });
            AudioSys.sfx.pop();
        }

        // Update drones - they home in on player
        GAME.entities.forEach(drone => {
            if (drone.type === 'drone') {
                const dx = GAME.player.x - drone.x;
                const dy = GAME.player.y - drone.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    drone.x += (dx / dist) * drone.speed;
                    drone.y += (dy / dist) * drone.speed;
                }

                // Drone collision with player
                if (GAME.player.iframe === 0 && Math.hypot(drone.x - GAME.player.x, drone.y - GAME.player.y) < 14) {
                    GAME.lives--;
                    GAME.player.iframe = 60;
                    updateHud();
                    AudioSys.sfx.hurt();
                    GAME.shake = 8;
                    drone.hp = 0; // Destroy drone on impact

                    if (GAME.lives <= 0) {
                        triggerGameOver("AUTOMATED OUT OF EXISTENCE!");
                    }
                }
            }
        });

        // Player can destroy drones
        for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
            const proj = GAME.projectiles[i];
            if (proj.type === 'attack') {
                for (let j = GAME.entities.length - 1; j >= 0; j--) {
                    const drone = GAME.entities[j];
                    if (drone.type === 'drone' && Math.hypot(proj.x - drone.x, proj.y - drone.y) < 12) {
                        drone.hp--;
                        if (drone.hp <= 0) {
                            GAME.entities.splice(j, 1);
                            AudioSys.sfx.hit();
                        }
                        GAME.projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }
    }

    // Check player projectiles hitting boss
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const proj = GAME.projectiles[i];
        if (proj.type === 'attack' &&
            proj.x >= b.x && proj.x <= b.x + b.w &&
            proj.y >= b.y && proj.y <= b.y + b.h) {
            b.hp--;
            updateBossHud();
            AudioSys.sfx.bossHit();
            GAME.shake = 5;
            GAME.projectiles.splice(i, 1);
            spawnParticle(proj.x, proj.y, '#ff9900', 5);
            // Damage number above boss head
            spawnFloatingText(b.x + 24, b.y - 10, '-1', '#ffffff');

            if (b.hp <= 0) {
                winBezosLevel();
            }
        }
    }

    // Check boss projectiles hitting player
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const proj = GAME.projectiles[i];
        if ((proj.type === 'bezos_missile' || proj.type === 'bezos_laser') && GAME.player.iframe === 0) {
            if (Math.hypot(proj.x - GAME.player.x, proj.y - GAME.player.y) < 16) {
                GAME.lives--;
                GAME.player.iframe = 60;
                updateHud();
                AudioSys.sfx.hurt();
                GAME.shake = 8;
                GAME.projectiles.splice(i, 1);

                if (GAME.lives <= 0) {
                    triggerGameOver("AUTOMATED OUT OF EXISTENCE!");
                }
            }
        }
    }
}

function winBezosLevel() {
    GAME.state = 'BEZOS_WIN';
    GAME.stateTimer = 0;
    GAME.boss = null;
    document.getElementById('boss-hud').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';
    AudioSys.sfx.start();
    MusicSys.play('victory');
}

// === WAREHOUSE ATMOSPHERE UPDATE ===
function updateWarehouseAtmosphere() {
    // Update moving packages on conveyors
    GAME.packages.forEach(pkg => {
        pkg.x += pkg.speed;
        // Wrap around when off screen
        if (pkg.speed > 0 && pkg.x > 54 * TILE_SIZE) {
            pkg.x = 6 * TILE_SIZE;
        } else if (pkg.speed < 0 && pkg.x < 6 * TILE_SIZE) {
            pkg.x = 54 * TILE_SIZE;
        }
    });

    // Update cart workers
    GAME.cartWorkers.forEach(worker => {
        if (worker.pauseTimer > 0) {
            worker.pauseTimer--;
            return;
        }

        worker.x += worker.dir * worker.speed;

        // Randomly pause to simulate work
        if (Math.random() < 0.002) {
            worker.pauseTimer = 60 + Math.random() * 60; // 1-2 second pause
        }

        // Turn around at edges
        if (worker.dir > 0 && worker.x > 50 * TILE_SIZE) {
            worker.dir = -1;
            worker.pauseTimer = 30; // Brief pause when turning
        } else if (worker.dir < 0 && worker.x < 8 * TILE_SIZE) {
            worker.dir = 1;
            worker.pauseTimer = 30;
        }
    });
}

// === YARD LEVEL POWER-UP AND COLLECTIBLE UPDATE ===
function updateYardPowerUps() {
    const p = GAME.player;

    // Update power-up timer
    if (GAME.playerPowerUp) {
        GAME.powerUpTimer--;
        if (GAME.powerUpTimer <= 0) {
            // Remove power-up effects
            if (GAME.playerPowerUp === 'speed') {
                p.speed = getCharStats(GAME.selectedChar).speed * 0.9;
            }
            GAME.playerPowerUp = null;
        }
    }

    // Check power-up collection
    for (let i = GAME.powerUps.length - 1; i >= 0; i--) {
        const pu = GAME.powerUps[i];
        if (Math.hypot(pu.x - p.x, pu.y - p.y) < 16) {
            AudioSys.sfx.fix();
            GAME.powerUps.splice(i, 1);

            if (pu.type === 'speed') {
                GAME.playerPowerUp = 'speed';
                GAME.powerUpTimer = 300; // 5 seconds
                p.speed = getCharStats(GAME.selectedChar).speed * 1.5;
                spawnFloatingText(p.x, p.y - 16, "SPEED BOOST!", "#22d3ee");
            } else if (pu.type === 'shield') {
                GAME.playerPowerUp = 'shield';
                GAME.powerUpTimer = 180; // 3 seconds
                p.iframe = 180; // Temporary invincibility
                spawnFloatingText(p.x, p.y - 16, "SHIELD!", "#a855f7");
            } else if (pu.type === 'life') {
                GAME.lives = Math.min(GAME.lives + 1, 5);
                updateHud();
                spawnFloatingText(p.x, p.y - 16, "+1 LIFE!", "#f87171");
            }
        }
    }

    // Check collectible package collection
    for (let i = GAME.collectibles.length - 1; i >= 0; i--) {
        const col = GAME.collectibles[i];
        if (Math.hypot(col.x - p.x, col.y - p.y) < 16) {
            AudioSys.sfx.pop();
            GAME.collectibles.splice(i, 1);
            GAME.score += 100;
            spawnFloatingText(col.x, col.y - 10, "+100", "#ffd700");
        }
    }

    // Update forklifts
    GAME.forklifts.forEach(fl => {
        fl.x += fl.speed;
        if (fl.speed > 0 && fl.x > 256) fl.x = -fl.w;
        if (fl.speed < 0 && fl.x < -fl.w) fl.x = 256;

        // Check collision with player
        if (p.iframe === 0 &&
            p.x < fl.x + fl.w && p.x + 16 > fl.x &&
            p.y < fl.y + fl.h && p.y + 16 > fl.y) {
            p.iframe = 90;
            GAME.lives--;
            updateHud();
            AudioSys.sfx.hurt();
            GAME.shake = 15;
            GAME.flash = 12;
            p.x = 128;
            p.y = 200;
            spawnFloatingText(p.x, p.y - 20, "FORKLIFT!", "#fbbf24");
            if (GAME.lives <= 0) {
                triggerGameOver("RUN OVER BY FORKLIFT!");
            }
        }
    });
}

function update() {
    GAME.ticks++;
    GAME.stateTimer++;
    if (GAME.shake > 0) GAME.shake--;
    if (GAME.flash > 0) GAME.flash--;

    if (GAME.state === 'LOSE_SPLASH' || GAME.state === 'WIN_SPLASH') {
        GAME.splashTimer--;
        const isWin = GAME.state === 'WIN_SPLASH';
        const ready = GAME.aiResultText !== null;
        const waitedEnough = GAME.splashTimer <= 0;
        const fallbackTimer = -600;

        // No phase system needed anymore - go straight to dialog like WIN_SPLASH

        if (ready && waitedEnough) {
            const speaker = "Simon Unglaube";
            let finalText = GAME.aiResultText.replace(/\[.*?\]/g, GAME.selectedChar);
            let header, body;
            if (isWin) {
                header = `OUTSTANDING!\n"${finalText}"\n`;
                let stats = `\nStats:\nTime Spent: ${Math.floor((Date.now() - GAME.startTime)/1000)}s\nSafety Rules used: ${GAME.booksFired}\nOPS pushed back: ${GAME.opsPushed}\n(Press Space)`;
                showDialog(header + stats, speaker, GFX.simonFaceLarge, true);
                GAME.state = 'DIALOG'; GAME.nextState = 'CREDITS';
            } else {
                // Simon's analysis only - no corporate message or character defeat line
                header = `${finalText}`;
                let stats = `\n\nStats:\nTime Spent: ${Math.floor((Date.now() - GAME.startTime)/1000)}s\nSafety Rules used: ${GAME.booksFired}\nOPS pushed back: ${GAME.opsPushed}\n(Press Space)`;
                showDialog(header + stats, speaker, GFX.simonFaceLarge, true);
                GAME.state = 'DIALOG'; GAME.nextState = 'GAMEOVER_SPLASH';
            }
        } else if (!ready && GAME.splashTimer <= fallbackTimer) {
            GAME.aiResultText = 'System could not load live review. Using cached performance log.';
        }
        return;
    }

    if (GAME.state === 'LOGO' && GAME.stateTimer > 420) advanceState();

    if (GAME.state === 'TITLE') {
        return;
    }

    if (GAME.state === 'HOWTO') {
        return;
    }

    if (GAME.state === 'SELECT') {
        let changed = false;
        if (KEYS.left && GAME.ticks % 10 === 0) { GAME.charIndex--; AudioSys.sfx.step(); changed = true; }
        if (KEYS.right && GAME.ticks % 10 === 0) { GAME.charIndex++; AudioSys.sfx.step(); changed = true; }
        if (changed) {
            if (GAME.charIndex < 0) GAME.charIndex = GAME.charList.length - 1;
            if (GAME.charIndex >= GAME.charList.length) GAME.charIndex = 0;
            speakTTS(GAME.charList[GAME.charIndex], "System");
        }
        return;
    }

    if (GAME.state === 'DIALOG') {
        // Update press-space-hint
        const hintEl = document.getElementById('press-space-hint');
        hintEl.innerText = '▼ PRESS SPACE';
        hintEl.style.color = '#ffd700';
        hintEl.style.animation = 'blink 0.8s ease-in-out infinite';

        if (GAME.dialogVisible.length < GAME.dialogText.length) {
            if (GAME.ticks % 2 === 0) {
                GAME.dialogVisible += GAME.dialogText[GAME.dialogVisible.length];
                // Update whichever window is visible
                const regularContent = document.getElementById('text-content');
                const introContent = document.getElementById('intro-text-content');
                if (document.getElementById('intro-portrait-window').style.display === 'block') {
                    introContent.innerText = GAME.dialogVisible;
                } else {
                    regularContent.innerText = GAME.dialogVisible;
                }
                AudioSys.sfx.text();
            }
        }
        return;
    }

    // Phase 3: Health Bar Animation during Simon transformation
    if (GAME.state === 'SIMON_MECHA_TRANSFORM') {
        // Animate health bar from 0% to 100% over 120 frames (~2 seconds at 60fps)
        const animDuration = 120;
        if (GAME.stateTimer <= animDuration) {
            // Smooth easing animation (ease-in-out)
            const t = GAME.stateTimer / animDuration;
            const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            GAME.healthBarAnimProgress = eased;
            GAME.boss.hp = Math.floor(eased * 999);
            updateBossHud();

            // Continuous particle effects during animation
            if (GAME.ticks % 3 === 0) {
                spawnParticle(
                    GAME.boss.x + 16 + (Math.random() - 0.5) * 20,
                    GAME.boss.y + 16 + (Math.random() - 0.5) * 20,
                    Math.random() > 0.5 ? '#eab308' : '#dc2626',
                    -1 - Math.random() * 2
                );
            }

            // Continuous screen shake
            if (GAME.shake < 5) GAME.shake = 5;
        }
        return;
    }

    if (['LOGO', 'INTRO', 'STORY', 'TITLE', 'HOWTO', 'BOSS_INTRO', 'VISITOR_SPLASH', 'BEZOS_INTRO', 'MECHA_TRANSFORM', 'MECHA_SIMON_SPLASH', 'BEZOS_ESCAPE', 'BEZOS_ESCAPE_MECHA_LINE', 'BEZOS_ESCAPE_JEFF_LINE', 'BEZOS_ESCAPE_DIALOGUE', 'SIMON_FAKE_VICTORY'].includes(GAME.state)) return;

    // Bezos victory screen
    if (GAME.state === 'BEZOS_WIN') {
        // Auto-advance after delay
        if (GAME.stateTimer > 300) {
            GAME.state = 'TITLE';
            updateMusicForState();
        }
        return;
    }

    if (GAME.state === 'PLAY' || GAME.state === 'BOSS' || GAME.state === 'BEZOS_BOSS') {
        updatePlayer(); updateProjectiles(); updateParticles(); updateFloatingTexts();
        updateCamera();
    }

    if (GAME.state === 'PLAY') {
        updateEntities();
        updateWarehouseAtmosphere(); // Update warehouse atmosphere (packages, kivas, cart workers)
    }
    if (GAME.state === 'BOSS') updateBoss();
    if (GAME.state === 'BEZOS_BOSS') updateMechaBezos();

    // Yard level and Mecha boss updates
    if (GAME.state === 'YARD_LEVEL') updateYardLevel();
    if (GAME.state === 'MECHA_BOSS') updateMechaBattle();
}

function updatePlayer() {
    const p = GAME.player;
    // Guard against undefined player state
    if (!p) return;
    if (p.iframe>0) p.iframe--; if (p.cooldown>0) p.cooldown--;
    let dx=0, dy=0;
    if (KEYS.up) dy = -p.speed; if (KEYS.down) dy = p.speed; if (KEYS.left) dx = -p.speed; if (KEYS.right) dx = p.speed;
    if (dx!==0 && dy!==0) { dx *= GAME_CONSTANTS.DIAGONAL_FACTOR; dy *= GAME_CONSTANTS.DIAGONAL_FACTOR; }
    if (dx!==0 || dy!==0) {
        // In Bezos boss mode, no collision detection with walls
        if (GAME.state === 'BEZOS_BOSS') {
            p.x = Math.max(0, Math.min(240, p.x + dx));
            p.y = Math.max(0, Math.min(208, p.y + dy));
        } else {
            if (!checkCol(p.x+dx, p.y)) p.x+=dx;
            if (!checkCol(p.x, p.y+dy)) p.y+=dy;
        }
        if (GAME.ticks % 20 === 0) { AudioSys.sfx.step(); spawnParticle(p.x+8, p.y+16, '#555', 0); }
    }
}

function updateYardLevel() {
    if (!GAME.yard) return;
    const y = GAME.yard;
    GAME.player.x = y.playerX; GAME.player.y = y.playerY;

    // Decrement invincibility frames (fixes permanent invincibility bug)
    if (GAME.player.iframe > 0) GAME.player.iframe--;

    // Check if player is in castle section
    const inCastle = y.playerY < y.castleStart;
    if (inCastle && !y.inCastle) {
        y.inCastle = true;
        if (!y.castleEntered) {
            y.castleEntered = true;
            spawnFloatingText(y.playerX, y.playerY - 30, "ENTERING BEZOS CASTLE!", "#ff9900");
            AudioSys.sfx.bossIntro();
        }
    }

    // Update Jeff animation frame
    y.jeffAnimFrame++;

    // Show message when entering the dangerous hallway section
    if (y.playerY < y.castleStart && !y.hallwayEntered) {
        y.hallwayEntered = true;
        y.inHallway = true;
        spawnFloatingText(canvas.width / 2 - 50, 100, "DANGER: SECURITY HALLWAY!", "#ff4444");
        AudioSys.sfx.bossIntro();
    }

    let dx = 0, dy = 0;
    if (KEYS.up) dy = -y.speed; if (KEYS.down) dy = y.speed; if (KEYS.left) dx = -y.speed; if (KEYS.right) dx = y.speed;
    if (dx!==0 && dy!==0) { dx *= GAME_CONSTANTS.DIAGONAL_FACTOR; dy *= GAME_CONSTANTS.DIAGONAL_FACTOR; }

    // Check for static hazard slowdown (puddles slow you down) - only in yard section
    let inHazard = false;
    if (y.staticHazards && !y.inCastle) {
        y.staticHazards.forEach(h => {
            if (Math.abs(y.playerX - h.x) < 20 && Math.abs(y.playerY - h.y) < 20) {
                if (h.type === 'puddle') {
                    dx *= 0.5; dy *= 0.5; // Slow down in puddles
                    inHazard = true;
                }
            }
        });
    }

    y.playerX = Math.max(0, Math.min(canvas.width - 16, y.playerX + dx));
    y.playerY = Math.max(10, Math.min(y.height - 22, y.playerY + dy));
    GAME.player.x = y.playerX; GAME.player.y = y.playerY;

    const viewAnchor = y.playerY - canvas.height * 0.55;
    y.cameraY = Math.max(0, Math.min(y.height - canvas.height, viewAnchor));

    // === YARD SECTION UPDATES (only when in yard) ===
    if (!y.inCastle) {
        // Spawn vehicles in lanes with varied types
        y.lanes.forEach(lane => {
            lane.timer--;
            if (lane.timer <= 0) {
                let type;
                if (lane.type === 'truck') type = 'truck';
                else if (lane.type === 'van') type = 'van';
                else type = Math.random() < 0.55 ? 'van' : 'truck';

                const w = type === 'van' ? 34 : 52;
                const h = type === 'van' ? 16 : 20;
                const x = lane.dir === 1 ? -w : canvas.width + w;
                y.vehicles.push({ type, x, y: lane.y - h/2, w, h, dir: lane.dir, speed: lane.speed + Math.random()*0.25 });
                lane.timer = 50 + Math.random() * 60;
            }
        });

        // Update forklift zones
        if (y.forkliftZones) {
            y.forkliftZones.forEach(zone => {
                zone.timer--;
                if (zone.timer <= 0) {
                    zone.active = !zone.active;
                    zone.timer = zone.active ? 60 : (150 + Math.random() * 100);
                    if (zone.active && Math.abs(y.playerY - zone.y) < 100) {
                        // Spawn a forklift
                        const dir = Math.random() < 0.5 ? 1 : -1;
                        y.forklifts.push({
                            x: dir === 1 ? -30 : canvas.width + 30,
                            y: zone.y - 10,
                            dir: dir,
                            speed: 1.5 + Math.random() * 0.5,
                            w: 28, h: 20
                        });
                        AudioSys.sfx.alert();
                    }
                }
            });
        }
    }

    // Update forklifts (can still be on screen when transitioning)
    for (let i = y.forklifts.length - 1; i >= 0; i--) {
        const f = y.forklifts[i];
        f.x += f.dir * f.speed;
        if (f.x < -60 || f.x > canvas.width + 60) { y.forklifts.splice(i, 1); continue; }
        // Forklift collision - Roman's PHANTOM STEP reduces collision hitbox
        const romanMod = GAME.selectedChar === 'Roman' ? 0.6 : 1.0;
        if (Math.abs((f.x + f.w/2) - (y.playerX + 8)) < (f.w/2 + 4) * romanMod && Math.abs((f.y + f.h/2) - (y.playerY + 8)) < (f.h/2 + 4) * romanMod) {
            if (GAME.player.iframe <= 0) {
                GAME.lives--; GAME.flash = 15; GAME.shake = 20; AudioSys.sfx.hurt(); updateHud();
                // Teleport to start - no iframe needed since player is repositioned
                y.playerX = canvas.width / 2 - 8;
                y.playerY = y.startY;
                y.inCastle = false;
                y.cameraY = Math.max(0, y.height - canvas.height);
                spawnFloatingText(y.playerX, y.playerY - 20, "FORKLIFT! NO PEDESTRIANS!", "#ff4444");
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('FORKLIFT INCIDENT!'); return; }
            }
        }
    }

    // Vehicle collision - FULL RESET to starting position
    for (let i = y.vehicles.length - 1; i >= 0; i--) {
        const v = y.vehicles[i];
        v.x += v.dir * v.speed;
        if (v.x < -80 || v.x > canvas.width + 80) { y.vehicles.splice(i,1); continue; }
        // Roman's PHANTOM STEP reduces collision hitbox
        const romanModV = GAME.selectedChar === 'Roman' ? 0.6 : 1.0;
        if (Math.abs((v.x + v.w/2) - (y.playerX + 8)) < (v.w/2 + 5) * romanModV && Math.abs((v.y + v.h/2) - (y.playerY + 8)) < (v.h/2 + 5) * romanModV) {
            if (GAME.player.iframe <= 0) {
                GAME.lives--; GAME.flash = 12; GAME.shake = 15; AudioSys.sfx.hurt(); updateHud();
                // FULL RESET - player goes back to starting position, no iframe since teleporting
                y.playerX = canvas.width / 2 - 8;
                y.playerY = y.startY;
                y.inCastle = false;
                y.cameraY = Math.max(0, y.height - canvas.height);
                spawnFloatingText(y.playerX, y.playerY - 20, "WATCH THE TRAFFIC!", "#ff4444");
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('FLATTENED BY LOGISTICS!'); return; }
            }
        }
    }

    // === CASTLE SECTION UPDATES ===
    if (y.inCastle) {
        // Update castle moving platforms
        if (y.castlePlatforms) {
            y.castlePlatforms.forEach(p => {
                p.x += p.dir * p.speed;
                if (p.x <= 0 || p.x + p.w >= canvas.width) {
                    p.dir *= -1;
                }
            });
        }

        // Update hallway laser barriers (only in hallway section, NOT in throne room)
        // Throne room is Y < hallwayStart - safe zone with no hazards
        const hallwayBoundary = y.hallwayStart;
        if (y.castleLaserBarriers && y.playerY >= hallwayBoundary) {
            y.castleLaserBarriers.forEach(barrier => {
                barrier.timer++;
                if (barrier.active && barrier.timer >= barrier.onTime) {
                    barrier.active = false;
                    barrier.timer = 0;
                } else if (!barrier.active && barrier.timer >= barrier.offTime) {
                    barrier.active = true;
                    barrier.timer = 0;
                    AudioSys.sfx.alert();
                }

                // Collision with active laser barrier
                if (barrier.active && Math.abs(y.playerY - barrier.y) < 8 && GAME.player.iframe <= 0) {
                    GAME.lives--; GAME.flash = 15; GAME.shake = 12; AudioSys.sfx.hurt(); updateHud();
                    GAME.player.iframe = 120; // 2 seconds of invincibility in castle
                    spawnFloatingText(y.playerX, y.playerY - 20, "LASER BARRIER!", "#ff4444");
                    if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('VAPORIZED BY SECURITY!'); return; }
                }
            });
        }

        // Update hallway guard turrets (only in hallway section)
        if (y.castleGuards && y.playerY >= hallwayBoundary) {
            y.castleGuards.forEach(guard => {
                guard.fireTimer++;
                // Fire if player is within vertical range and in hallway
                if (guard.fireTimer >= guard.fireRate && Math.abs(y.playerY - guard.y) < 150) {
                    guard.fireTimer = 0;
                    // Fire projectile toward player
                    const dirX = guard.x < canvas.width / 2 ? 1 : -1;
                    if (!y.castleProjectiles) y.castleProjectiles = [];
                    y.castleProjectiles.push({
                        x: guard.x + 8,
                        y: guard.y + 6,
                        vx: dirX * 2.5,
                        vy: 0,
                        life: 120
                    });
                    AudioSys.sfx.throw();
                }
            });
        }

        // Update hallway projectiles
        if (y.castleProjectiles) {
            for (let i = y.castleProjectiles.length - 1; i >= 0; i--) {
                const proj = y.castleProjectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.life--;

                if (proj.life <= 0 || proj.x < -20 || proj.x > canvas.width + 20) {
                    y.castleProjectiles.splice(i, 1);
                    continue;
                }

                // Collision with player (only in hallway)
                if (y.playerY >= hallwayBoundary && Math.abs(proj.x - (y.playerX + 8)) < 12 && Math.abs(proj.y - (y.playerY + 8)) < 12) {
                    if (GAME.player.iframe <= 0) {
                        GAME.lives--; GAME.flash = 10; GAME.shake = 8; AudioSys.sfx.hurt(); updateHud();
                        GAME.player.iframe = 120; // 2 seconds of invincibility in castle
                        y.castleProjectiles.splice(i, 1);
                        spawnFloatingText(y.playerX, y.playerY - 20, "GUARD TURRET!", "#ff4444");
                        if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('TERMINATED BY SECURITY!'); return; }
                    }
                }
            }
        }

        // Spawn patrol drones periodically (only in hallway section)
        y.droneSpawnTimer++;
        if (y.droneSpawnTimer > 180 && y.castleDrones.length < 4 && y.playerY >= hallwayBoundary) {
            y.droneSpawnTimer = 0;
            // Spawn drones within the hallway section only
            const droneY = hallwayBoundary + 50 + Math.random() * 350;
            y.castleDrones.push({
                x: Math.random() < 0.5 ? -20 : canvas.width + 20,
                y: droneY,
                dir: Math.random() < 0.5 ? 1 : -1,
                speed: 1.2 + Math.random() * 0.5,
                pulseTimer: 0
            });
        }

        // Clear all hazards when player enters throne room (peaceful confrontation zone)
        if (y.playerY < hallwayBoundary) {
            y.castleDrones = [];
            if (y.castleProjectiles) y.castleProjectiles = [];
        }

        // Update patrol drones (only when player is in hallway)
        if (y.playerY >= hallwayBoundary) {
            for (let i = y.castleDrones.length - 1; i >= 0; i--) {
                const drone = y.castleDrones[i];
                drone.x += drone.dir * drone.speed;
                drone.pulseTimer++;

                // Slight homing toward player Y (but stay in hallway)
                if (Math.abs(drone.y - y.playerY) > 30) {
                    const newY = drone.y + (y.playerY > drone.y ? 0.3 : -0.3);
                    if (newY >= hallwayBoundary) drone.y = newY;
                }

                // Remove if off screen
                if ((drone.dir === 1 && drone.x > canvas.width + 40) || (drone.dir === -1 && drone.x < -40)) {
                    y.castleDrones.splice(i, 1);
                    continue;
                }

                // Collision with player
                if (Math.abs(drone.x - (y.playerX + 8)) < 14 && Math.abs(drone.y - (y.playerY + 8)) < 14) {
                    if (GAME.player.iframe <= 0) {
                        GAME.lives--; GAME.flash = 12; GAME.shake = 10; AudioSys.sfx.hurt(); updateHud();
                        GAME.player.iframe = 120; // 2 seconds of invincibility in castle
                        y.castleDrones.splice(i, 1);
                        spawnFloatingText(y.playerX, y.playerY - 20, "PATROL DRONE!", "#22d3ee");
                        if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('DRONE STRIKE!'); return; }
                    }
                }
            }
        }

    }

    // Trigger THRONE CONFRONTATION CUTSCENE when player enters throne room (Y < hallwayStart)
    // Player approaches Jeff who is sitting on the throne - dialogue begins
    if (y.playerY <= y.hallwayStart && !y.transformationTriggered) {
        y.transformationTriggered = true;
        GAME.state = 'THRONE_CONFRONTATION';
        GAME.stateTimer = 0;
        GAME.throneScene = {
            phase: 0 // 0=zoom in visual, 1=AI dialogue via showDialog
        };
        AudioSys.sfx.bossIntro();
        return;
    }
}

function updateMechaBattle() {
    const m = GAME.mecha; if (!m) return;
    const p = GAME.player;
    if (p.iframe>0) p.iframe--; if (p.cooldown>0) p.cooldown--;

    // Player movement
    let dx = 0, dy = 0;
    if (KEYS.up) dy = -p.speed; if (KEYS.down) dy = p.speed; if (KEYS.left) dx = -p.speed; if (KEYS.right) dx = p.speed;
    if (dx!==0 && dy!==0) { dx *= GAME_CONSTANTS.DIAGONAL_FACTOR; dy *= GAME_CONSTANTS.DIAGONAL_FACTOR; }
    p.x = Math.max(4, Math.min(canvas.width - 20, p.x + dx));
    p.y = Math.max(40, Math.min(canvas.height - 20, p.y + dy));

    m.timer++;
    m.bobOffset = Math.sin(m.timer * 0.05) * 3;
    if (m.attackCooldown > 0) m.attackCooldown--;

    // Enrage mode at low HP
    if (m.hp <= 12 && !m.enraged) {
        m.enraged = true;
        m.phaseDuration = 200; // Faster phases
        GAME.shake = 20;
        spawnFloatingText(m.x + 32, m.y, "ENRAGED!", "#ff0000");
        AudioSys.sfx.bossIntro();
    }
    if (m.enraged) m.enrageFlash = (m.enrageFlash + 1) % 20;

    // Phase transition handling
    if (m.phaseTransition) {
        m.transitionTimer++;
        if (m.transitionTimer >= 60) {
            m.phaseTransition = false;
            m.transitionTimer = 0;
            m.phaseTimer = 0;
            // Announce new phase with attack warning
            const phaseWarnings = {
                0: { text: "MISSILES!", color: "#dc2626" },
                1: { text: "DRONES!", color: "#22d3ee" },
                2: { text: "PRIME DROP!", color: "#f59e0b" },
                3: { text: "LASER GRID!", color: "#38bdf8" },
                4: { text: "GROUND SLAM!", color: "#a855f7" }
            };
            const warning = phaseWarnings[m.currentPhase];
            spawnFloatingText(canvas.width / 2 - 40, 60, warning.text, warning.color);
        }
        return; // Pause attacks during transition
    }

    m.phaseTimer++;

    // Boss movement - sway side to side
    m.moveTimer++;
    if (m.moveTimer > 60) {
        m.moveTimer = 0;
        m.moveDir *= -1;
    }
    if (!m.slamming && !m.dashing) {
        const targetX = canvas.width / 2 - 32 + m.moveDir * 60;
        m.x += (targetX - m.x) * 0.02;
        m.y = m.baseY + m.bobOffset;
    }

    // Phase-specific attack patterns
    const attackRate = m.enraged ? 0.7 : 1.0;

    // Initialize attack announcement tracking
    if (!m.lastAnnounce) m.lastAnnounce = { phase: -1, timer: 0 };

    // PHASE 0: Prime Missiles - Homing missiles from shoulders
    if (m.currentPhase === 0) {
        if (m.timer % Math.floor(70 * attackRate) === 0 && m.attackCooldown <= 0) {
            const angle = Math.atan2(p.y - m.y, p.x - m.x);
            for (let i = -1; i <= 1; i += 2) {
                m.projectiles.push({
                    type: 'missile',
                    x: m.x + 32 + i * 24,
                    y: m.y + 20,
                    vx: Math.cos(angle + i * 0.3) * 1.5,
                    vy: Math.sin(angle + i * 0.3) * 1.5,
                    life: 180,
                    trail: []
                });
            }
            AudioSys.sfx.throw();
        }
    }

    // PHASE 1: Drone Swarm - Multiple homing drones
    if (m.currentPhase === 1) {
        const activeDrones = m.projectiles.filter(pr => pr.type === 'drone').length;
        if (m.timer % Math.floor(50 * attackRate) === 0 && activeDrones < (m.enraged ? 5 : 3)) {
            m.projectiles.push({
                type: 'drone',
                x: m.x + 32 + (Math.random() - 0.5) * 40,
                y: m.y + 24,
                vx: 0, vy: 0.3,
                life: 400,
                pulseTimer: 0
            });
            AudioSys.sfx.pop();
        }
    }

    // PHASE 2: Package Rain - Boxes rain from above with shadows
    if (m.currentPhase === 2) {
        if (m.timer % Math.floor(35 * attackRate) === 0) {
            const targetX = p.x + (Math.random() - 0.5) * 80;
            m.shadows.push({ x: Math.max(10, Math.min(canvas.width - 30, targetX)), timer: 45 });
        }
    }

    // PHASE 3: Laser Grid - Multiple sweeping beams
    if (m.currentPhase === 3) {
        if (m.timer % Math.floor(100 * attackRate) === 0 && m.beams.length < 3) {
            const beamCount = m.enraged ? 3 : 2;
            for (let i = 0; i < beamCount; i++) {
                m.beams.push({
                    x: (canvas.width / (beamCount + 1)) * (i + 1) - 7,
                    telegraph: 50,
                    active: 35,
                    sweepDir: i % 2 === 0 ? 1 : -1,
                    sweepSpeed: 0.8
                });
            }
            AudioSys.sfx.alert();
        }
    }

    // PHASE 4: Ground Slam - Boss slams down and creates shockwave
    if (m.currentPhase === 4) {
        if (!m.slamming && m.timer % Math.floor(120 * attackRate) === 0) {
            m.slamming = true;
            m.slamTimer = 0;
            m.slamY = m.y;
            AudioSys.sfx.alert();
        }

        if (m.slamming) {
            m.slamTimer++;
            if (m.slamTimer < 30) {
                // Wind up
                m.y = m.slamY - m.slamTimer * 0.5;
            } else if (m.slamTimer < 45) {
                // Slam down
                m.y = m.slamY - 15 + (m.slamTimer - 30) * 4;
                if (m.slamTimer === 44) {
                    GAME.shake = 25;
                    AudioSys.sfx.hurt();
                    // Create shockwave
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        m.projectiles.push({
                            type: 'shockwave',
                            x: m.x + 32,
                            y: canvas.height - 20,
                            vx: Math.cos(angle) * 2.5,
                            vy: Math.sin(angle) * 0.5 - 0.5,
                            life: 80
                        });
                    }
                }
            } else if (m.slamTimer < 80) {
                // Recovery
                m.y = m.baseY + 30 - (m.slamTimer - 45) * 0.85;
            } else {
                m.slamming = false;
                m.y = m.baseY;
            }
        }
    }

    // Phase cycling
    if (m.phaseTimer >= m.phaseDuration) {
        m.currentPhase = (m.currentPhase + 1) % 5;
        m.phaseTransition = true;
        m.shadows = [];
        m.beams = [];
        m.slamming = false;
    }

    // Update projectiles
    for (let i = m.projectiles.length - 1; i >= 0; i--) {
        const pr = m.projectiles[i];

        if (pr.type === 'missile') {
            // Slight homing
            const angle = Math.atan2(p.y - pr.y, p.x - pr.x);
            pr.vx = pr.vx * 0.95 + Math.cos(angle) * 0.08;
            pr.vy = pr.vy * 0.95 + Math.sin(angle) * 0.08;
            pr.trail.push({ x: pr.x, y: pr.y });
            if (pr.trail.length > 8) pr.trail.shift();
        } else if (pr.type === 'drone') {
            pr.pulseTimer = (pr.pulseTimer || 0) + 1;
            const angle = Math.atan2(p.y - pr.y, p.x - pr.x);
            const targetVx = Math.cos(angle) * 0.5;
            const targetVy = Math.sin(angle) * 0.5;
            pr.vx = pr.vx * 0.92 + targetVx * 0.08;
            pr.vy = pr.vy * 0.92 + targetVy * 0.08;
        } else if (pr.type === 'box') {
            pr.vy += 0.06;
            pr.rotation = (pr.rotation || 0) + 0.1;
        } else if (pr.type === 'shockwave') {
            pr.vy += 0.1; // Gravity
        }

        pr.x += pr.vx || 0;
        pr.y += pr.vy || 0;
        pr.life = (pr.life || 200) - 1;

        if (pr.y > canvas.height + 40 || pr.x < -40 || pr.x > canvas.width + 40 || pr.life <= 0) {
            m.projectiles.splice(i, 1);
            continue;
        }

        // Collision with player
        const hitW = pr.type === 'shockwave' ? 8 : 10;
        const hitH = pr.type === 'shockwave' ? 6 : 10;
        if (Math.abs((pr.x + hitW/2) - (p.x + 8)) < (hitW/2 + 6) && Math.abs((pr.y + hitH/2) - (p.y + 8)) < (hitH/2 + 6)) {
            if (p.iframe <= 0) {
                GAME.lives--;
                p.iframe = 90;
                GAME.flash = 10;
                GAME.shake = 8;
                AudioSys.sfx.hurt();
                updateHud();
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) {
                    triggerGameOver('OVERWHELMED BY MECHA JEFF!');
                    return;
                }
            }
            if (pr.type !== 'shockwave') m.projectiles.splice(i, 1);
        }
    }

    // Update shadows (package warning indicators)
    for (let i = m.shadows.length - 1; i >= 0; i--) {
        m.shadows[i].timer--;
        if (m.shadows[i].timer <= 0) {
            const x = m.shadows[i].x;
            m.projectiles.push({
                type: 'box',
                x, y: -16,
                vy: 1.8,
                vx: (Math.random() - 0.5) * 0.5,
                life: 200,
                rotation: 0
            });
            m.shadows.splice(i, 1);
            AudioSys.sfx.throw();
        }
    }

    // Update beams (laser grid)
    for (let i = m.beams.length - 1; i >= 0; i--) {
        const beam = m.beams[i];
        if (beam.telegraph > 0) {
            beam.telegraph--;
        } else if (beam.active > 0) {
            beam.active--;
            beam.x += beam.sweepDir * beam.sweepSpeed;
            // Collision
            if (p.x + 12 > beam.x && p.x < beam.x + 14 && p.iframe <= 0) {
                GAME.lives--;
                p.iframe = 90;
                GAME.flash = 12;
                AudioSys.sfx.hurt();
                updateHud();
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) {
                    triggerGameOver('VAPORIZED!');
                    return;
                }
            }
        } else {
            m.beams.splice(i, 1);
        }
    }

    // Player projectile hits on boss
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const a = GAME.projectiles[i];
        a.x += a.vx;
        a.y += a.vy;
        a.life--;
        if (a.x < -20 || a.x > canvas.width + 20 || a.y < -20 || a.y > canvas.height + 20 || a.life <= 0) {
            GAME.projectiles.splice(i, 1);
            continue;
        }
        // Hit detection on boss
        if (Math.abs((a.x + 6) - (m.x + 32)) < 36 && Math.abs((a.y + 6) - (m.y + 32)) < 36) {
            m.hp--;
            GAME.boss.hp = m.hp;
            updateBossHud();
            GAME.projectiles.splice(i, 1);
            AudioSys.sfx.bossHit();
            spawnFloatingText(m.x + 32, m.y + 12, 'HIT!', '#ff2e63');
            // Damage number above boss head
            spawnFloatingText(m.x + 32, m.y - 10, '-1', '#ffffff');

            // Spawn hit particles
            for (let j = 0; j < 4; j++) {
                spawnParticle(m.x + 32 + (Math.random() - 0.5) * 20, m.y + 32 + (Math.random() - 0.5) * 20, '#ff9900', 1);
            }

            if (m.hp <= 0) {
                // Trigger Bezos escape sequence - show Mecha Jeff's defeat one-liner first
                GAME.state = 'BEZOS_ESCAPE';
                GAME.stateTimer = 0;
                GAME.escapeScene = {
                    // New phases: 0=mecha sparks/shakes, 1=mecha one-liner, 2=mecha explodes,
                    // 3=slow transform, 4=jeff one-liner, 5=throne room + run to rocket,
                    // 6=rocket launch with camera follow, 7=escape dialogue, 8=simon joins
                    phase: 0,
                    jeffX: m.x + 32,
                    jeffY: m.y + 32,
                    startJeffX: m.x + 32,
                    startJeffY: m.y + 32,
                    rocketX: canvas.width / 2 - 32, // Center the bigger rocket
                    rocketY: canvas.height - 150,   // Adjust for bigger rocket
                    rocketVelocity: 0,              // For acceleration
                    rocketLaunched: false,
                    launchCountdown: 0,             // For countdown sequence
                    dialogueStep: 0,
                    simonJoined: false,
                    phaseTimer: 0,
                    transformProgress: 0,
                    explosionParticles: [],
                    // Camera zoom/follow system
                    cameraZoom: 1.0,
                    cameraY: 0,
                    cameraTargetY: 0,
                    followingRocket: false,
                    stars: [],                      // Stars for space background
                    inSpace: false
                };
                document.getElementById('boss-hud').style.display = 'none';
                MusicSys.stop();
                AudioSys.sfx.bossHit();
                return;
            }
        }
    }
}

// --- BANTER SYSTEM ---
function spawnFloatingText(x, y, text, color='#fff') {
    // Performance: Limit max floating texts to prevent buildup
    if (GAME.floatingTexts.length >= GAME_CONSTANTS.MAX_FLOATING_TEXTS) return;

    GAME.floatingTexts.push({
        x: x + 8, y: y,
        text: text, color: color,
        life: GAME_CONSTANTS.FLOATING_TEXT_LIFE, vy: -0.2 // Slower, longer life (3.5s)
    });
    AudioSys.sfx.pop();
}

function triggerBanter(entity) {
    if (!entity || Math.random() > 0.8) return; // Don't trigger every time
    
    const now = Date.now();
    const useAI = (now - GAME.lastAIBanterTime > 15000) && (Math.random() < 0.3); // 30% chance if cooldown over
    const category = (entity.type === 'ops') ? 'banter_ops' : 'banter_assoc';
    
    if (useAI && apiKey) {
        GAME.lastAIBanterTime = now;
        let prompt = "";
        if (entity.type === 'ops') prompt = "Short, funny bark (max 3 words) from an Amazon Warehouse Ops Manager yelling about productivity.";
        else prompt = "Short, funny thought (max 3 words) from a tired Amazon Warehouse Associate.";

        // ASYNC CALL - DOES NOT BLOCK GAME
        callGemini(prompt, category).then(text => {
            // Check if entity still alive/relevant, otherwise just spawn near player or drop
            if (GAME.entities.includes(entity)) {
                 spawnFloatingText(entity.x, entity.y, text, (entity.type==='ops'?'#ffcc00':'#ccc'));
            }
        });
    } else {
        // Hardcoded fallback
        const text = getRandomFallback(category, category);
        spawnFloatingText(entity.x, entity.y, text, (entity.type==='ops'?'#ffcc00':'#ccc'));
    }
}

function updateEntities() {
    GAME.entities.forEach(e => {
        if (e.type === 'simon') return;
        
        // Banter Trigger (Random Chance)
        if (Math.random() < 0.002) triggerBanter(e); // Low chance per tick

        if (e.type === 'ops') {
            let d = Math.hypot(GAME.player.x - e.x, GAME.player.y - e.y);
            if (d < 100) {
                if (GAME.player.x > e.x) e.x += 0.4; else e.x -= 0.4;
                if (GAME.player.y > e.y) e.y += 0.4; else e.y -= 0.4;
            }
            if (d < 80 && Math.random() < 0.01) {
                let angle = Math.atan2(GAME.player.y - e.y, GAME.player.x - e.x);
                GAME.projectiles.push({ type: 'req', x: e.x, y: e.y, vx: Math.cos(angle)*2, vy: Math.sin(angle)*2, life: 80 });
                AudioSys.sfx.alert();
            }
        }
        if (e.type === 'assoc') {
            if (Math.random() < 0.02) e.dir = Math.floor(Math.random()*4);
            let s = 0.3;
            if (e.dir===0) e.y-=s; else if(e.dir===1) e.y+=s; else if(e.dir===2) e.x-=s; else e.x+=s;
            // Slow OPS respawn - assocs slowly turn back into OPS managers (makes warehouse more challenging)
            if (Math.random() < 0.0008) {
                e.type = 'ops';
                spawnFloatingText(e.x, e.y - 10, "PROMOTED!", "#ff4444");
            }
        }
        if (e.type === 'runner') {
            if (Math.random() < 0.05) e.dir = Math.floor(Math.random()*4);
            let s = 0.8; 
            let nx = e.x, ny = e.y;
            if (e.dir===0) ny-=s; else if(e.dir===1) ny+=s; else if(e.dir===2) nx-=s; else nx+=s;
            if (!checkCol(nx, ny)) { e.x = nx; e.y = ny; } else e.dir = Math.floor(Math.random()*4); 
        }
    });
}

function updateBoss() {
    const b = GAME.boss; const p = GAME.player;
    // Guard against undefined boss or player state
    if (!b || !p) return;
    document.getElementById('boss-hud').style.display = 'block'; document.getElementById('boss-name-el').innerText = b.name; updateBossHud();

    // Mecha Mega Simon timer - triggers inevitable game over
    if (b.isMecha) {
        b.mechaTimer = (b.mechaTimer || 0) + 1;
        // After ~8 seconds (480 ticks at 60fps), trigger game over
        if (b.mechaTimer >= 480 && !GAME.gameOverTriggered) {
            GAME.mechaSimonDefeat = true; // Flag for special game over message
            triggerGameOver("COMPLIANCE ENFORCED!");
            return;
        }
        // Periodic warning messages during mecha phase
        if (b.mechaTimer === 120 || b.mechaTimer === 300) {
            spawnFloatingText(b.x + 24, b.y, "RESISTANCE IS FUTILE!", "#dc2626");
        }
    }

    let hpPct = b.hp / b.maxHp;
    if (b.tauntThresholds && b.tauntThresholds.length > 0 && hpPct < b.tauntThresholds[0]) {
         b.tauntThresholds.shift();
         const currentGen = GAME.genId;
         let prompt = b.name === "SIMON UNGLAUBE" ? "Simon Unglaube final warning. Max 25 words." : `Taunt from boss ${b.name}. Max 25 words.`;

         // Use appropriate portrait for Mecha Mega Simon
         let portrait = b.isMecha ? GFX.mechaMegaSimon : (b.name.includes("Simon") ? GFX.simonBoss : GFX.boss_manager);

         // --- CHANGED: IMMEDIATE PAUSE WITH LOADING DIALOG ---
         showThinking(b.name, portrait);

         callGemini(prompt, "taunt").then(text => {
            if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
                 showDialog(text, b.name, portrait, true);
            }
        });
    }

    // ⚠️ DESPERATION PHASE - SPECIAL LOW-HEALTH ATTACK (triggers once at 40% HP) ⚠️
    if (!b.lowHealthAttackTriggered && hpPct <= 0.4 && !b.isMecha) {
        b.lowHealthAttackTriggered = true;
        b.desperationMode = true; // 🔥 ENRAGED STATE - 30% faster, 30% dodge chance!

        // 🔥 RESTORE BOSS HEALTH TO 70% (excluding Simon)
        if (b.name !== "MEGA SIMON") {
            b.hp = Math.floor(b.maxHp * 0.7);
            updateBossHud();
            spawnFloatingText(b.x + 16, b.y - 40, "HEALTH RESTORED!", "#ffff00");
        }

        // 🔥 PLAY ENRAGED MUSIC
        MusicSys.play('enraged', 1.0);

        const baseAngle = Math.atan2(p.y - b.y, p.x - b.x);

        // MASSIVE visual feedback - boss is desperate!
        GAME.shake = 25;
        GAME.flash = 15;
        spawnFloatingText(b.x + 16, b.y - 25, "*** DESPERATION! ***", "#ff0000");
        spawnParticleBurst(b.x + 16, b.y + 16, ['#ff0000', '#ff4444', '#ff9900', '#ffff00'], 40);

        // Multiple alert sounds for emphasis
        AudioSys.sfx.alert();
        setTimeout(() => AudioSys.sfx.alert(), 100);
        setTimeout(() => AudioSys.sfx.alert(), 200);

        if (b.attackPattern === 'sweep') {
            // Labour Inspector - "EMERGENCY FULL INSPECTION" - MASSIVE 15-way sweep covering entire screen
            spawnFloatingText(b.x + 16, b.y - 10, "EMERGENCY INSPECTION!", "#ff0000");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#fbbf24', '#ff9900'], 30);
            for (let i = -7; i <= 7; i++) {
                let angle = baseAngle + (i * 0.22);
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*4.0, vy: Math.sin(angle)*4.0, life: 140, boss: true, grace: 18 });
                    }
                }, Math.abs(i) * 30);
            }
        }
        else if (b.attackPattern === 'tracking') {
            // Compliance Auditor - "TOTAL LOCKDOWN" - 12 homing projectiles in all directions
            spawnFloatingText(b.x + 16, b.y - 10, "TOTAL SURVEILLANCE!", "#ff0000");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#22d3ee', '#0ea5e9'], 35);
            for (let i = 0; i < 12; i++) {
                let angle = (i / 12) * Math.PI * 2;
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*2.5, vy: Math.sin(angle)*2.5, life: 200, boss: true, grace: 20, tracking: true });
                    }
                }, i * 40);
            }
        }
        else if (b.attackPattern === 'burst') {
            // Sebastian - "MAXIMUM TPH OVERLOAD" - insane 15-shot ultra-rapid burst!
            spawnFloatingText(b.x + 16, b.y - 10, "TPH MELTDOWN!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "MAXIMUM THROUGHPUT!", "#ff9900");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#ff4444', '#ff9900'], 40);
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        let angle = Math.atan2(GAME.player.y - b.y, GAME.player.x - b.x) + (Math.random() - 0.5) * 0.6;
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*5.0, vy: Math.sin(angle)*5.0, life: 100, boss: true, grace: 10 });
                        spawnParticle(b.x + 16, b.y + 16, '#ff0000', -2);
                        AudioSys.sfx.alert();
                    }
                }, i * 35);
            }
        }
        else if (b.attackPattern === 'orbital') {
            // Regional OPS MGR - "FULL AUDIT STORM" - TRIPLE orbital rings (30 total projectiles!)
            spawnFloatingText(b.x + 16, b.y - 10, "EXECUTIVE ORDER!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "TRIPLE AUDIT!", "#fbbf24");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#eab308', '#fbbf24', '#ff9900'], 50);
            for (let i = 0; i < 10; i++) {
                let angle = (i / 10) * Math.PI * 2;
                // Inner ring
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*12, y: b.y + 16 + Math.sin(angle)*12, vx: Math.cos(angle + 0.4)*2.8, vy: Math.sin(angle + 0.4)*2.8, life: 120, boss: true, grace: 15 });
                // Middle ring
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*24, y: b.y + 16 + Math.sin(angle)*24, vx: Math.cos(angle)*2.2, vy: Math.sin(angle)*2.2, life: 130, boss: true, grace: 15 });
                // Outer ring
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*36, y: b.y + 16 + Math.sin(angle)*36, vx: Math.cos(angle - 0.4)*1.8, vy: Math.sin(angle - 0.4)*1.8, life: 140, boss: true, grace: 15 });
            }
        }
        else if (b.attackPattern === 'laser') {
            // Avetta Platform - "CRITICAL RISK MATRIX" - asterisk pattern (8 directions × 2 waves)
            spawnFloatingText(b.x + 16, b.y - 10, "CRITICAL RISK!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "FULL SCAN ACTIVE!", "#dc2626");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#dc2626', '#ff0000', '#ff4444'], 45);
            for (let wave = 0; wave < 2; wave++) {
                for (let i = 0; i < 8; i++) {
                    let angle = (i / 8) * Math.PI * 2;
                    setTimeout(() => {
                        if (GAME.state === 'BOSS' && GAME.boss) {
                            GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*6.0, vy: Math.sin(angle)*6.0, life: 90, boss: true, grace: 6 });
                            AudioSys.sfx.alert();
                        }
                    }, (wave * 400) + (i * 40));
                }
            }
        }
        else if (b.attackPattern === 'wave') {
            // Jelena HR - "TERMINATION NOTICE" - massive 9-wave tsunami
            spawnFloatingText(b.x + 16, b.y - 10, "FINAL WARNING!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "POLICY TSUNAMI!", "#a855f7");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#a855f7', '#c084fc', '#e9d5ff'], 40);
            for (let i = -4; i <= 4; i++) {
                let angle = baseAngle + (i * 0.18);
                let proj = { type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*3.5, vy: Math.sin(angle)*3.5, life: 160, boss: true, grace: 18, wave: true, waveTime: i * 10, waveAmplitude: 1.5, baseAngle: angle };
                GAME.projectiles.push(proj);
            }
        }
        else if (b.attackPattern === 'storm') {
            // MEGA SIMON - "TOTAL COMPLIANCE FAILURE" - absolute chaos (20 projectiles!)
            spawnFloatingText(b.x + 16, b.y - 10, "AUDIT APOCALYPSE!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "COMPLIANCE FAILURE!", "#ff9900");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#ff0000', '#ff9900', '#ffff00', '#ff4444'], 60);
            for (let i = 0; i < 20; i++) {
                let angle = (Math.random() * Math.PI * 2);
                let speed = 2.0 + Math.random() * 3.0;
                let scatter = (Math.random() - 0.5) * 40;
                let delay = Math.random() * 150;
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16 + scatter, y: b.y + 16 + scatter, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 150, boss: true, grace: 15 });
                        spawnParticle(b.x + 16, b.y + 16, '#ff0000', -2);
                    }
                }, delay);
            }
        }
    }

    if (isNaN(b.x) || isNaN(b.y)) return;
    let dx = 0, dy = 0; let dist = Math.hypot(p.x - b.x, p.y - b.y);
    if (dist > 50) {
        let angle = Math.atan2(p.y - b.y, p.x - b.x);
        // 🔥 DESPERATION MODE: 30% speed boost!
        const speedMultiplier = b.desperationMode ? 1.3 : 1.0;
        dx = Math.cos(angle) * b.speed * speedMultiplier; dy = Math.sin(angle) * b.speed * speedMultiplier;
        if (!checkCol(b.x + dx, b.y)) b.x += dx; if (!checkCol(b.x, b.y + dy)) b.y += dy;
    }
    b.timer++;
    if (b.timer > b.attackDelay) {
        b.timer = 0;
        const baseAngle = Math.atan2(p.y - b.y, p.x - b.x);

        // Mecha Mega Simon - Ultimate spread attack
        if (b.isMecha) {
            for (let i = -2; i <= 2; i++) {
                let angle = baseAngle + (i * 0.5);
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*10, y: b.y + 16 + Math.sin(angle)*10, vx: Math.cos(angle)*3.5, vy: Math.sin(angle)*3.5, life: 100, boss: true, grace: 10 });
            }
        }
        // Unique attack patterns based on boss personality
        else if (b.attackPattern === 'sweep') {
            // Labour Inspector - "INSPECTION LINE" - horizontal sweeping line (11 projectiles in wide arc)
            // VISUAL: Wide horizontal sweep like checking every corner
            GAME.shake = 8; // More visual feedback
            spawnParticleBurst(b.x + 16, b.y + 16, ['#fbbf24', '#ff9900'], 12);
            for (let i = -5; i <= 5; i++) {
                let angle = baseAngle + (i * 0.25); // Wider spread
                let offset = Math.abs(i) * 3; // Slight stagger
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*offset, y: b.y + 16 + Math.sin(angle)*offset, vx: Math.cos(angle)*3.2, vy: Math.sin(angle)*3.2, life: 120, boss: true, grace: 10 });
                    }
                }, Math.abs(i) * 15); // Sweep from center out
            }
        }
        else if (b.attackPattern === 'tracking') {
            // Compliance Auditor - "AUDIT GRID" - 6 slow homing projectiles
            // VISUAL: Grid pattern that slowly homes in on player
            GAME.shake = 6;
            spawnParticleBurst(b.x + 16, b.y + 16, ['#22d3ee', '#0ea5e9'], 15);
            for (let row = -1; row <= 1; row++) {
                for (let col = -1; col <= 1; col += 2) {
                    if (row === 0 && col === -1) continue; // Skip center-left for pattern
                    let angle = baseAngle + (col * 0.3) + (row * 0.25);
                    GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*1.4, vy: Math.sin(angle)*1.4, life: 200, boss: true, grace: 15, tracking: true });
                }
            }
        }
        else if (b.attackPattern === 'burst') {
            // Sebastian - "TPH BARRAGE" - 10-shot rapid machine gun burst!
            // VISUAL: Relentless rapid-fire, overwhelming volume
            GAME.shake = 10;
            spawnFloatingText(b.x + 16, b.y - 15, "TPH RUSH!", "#ff4444");
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        let angle = Math.atan2(GAME.player.y - b.y, GAME.player.x - b.x) + (Math.random() - 0.5) * 0.5;
                        let speed = 3.5 + (i * 0.15); // Accelerates with each shot
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 90, boss: true, grace: 7 });
                        spawnParticle(b.x + 16, b.y + 16, '#ff9900', -1);
                        if (i % 2 === 0) AudioSys.sfx.alert();
                    }
                }, i * 50); // Faster burst
            }
        }
        else if (b.attackPattern === 'orbital') {
            // Regional OPS MGR - "METRIC RINGS" - dual counter-rotating orbital rings (16 total projectiles!)
            // VISUAL: Two rings rotating in opposite directions - impossible to dodge without precision
            GAME.shake = 12;
            spawnParticleBurst(b.x + 16, b.y + 16, ['#eab308', '#fbbf24'], 20);
            for (let i = 0; i < 8; i++) {
                let angle = (i / 8) * Math.PI * 2;
                // Inner ring - clockwise
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*18, y: b.y + 16 + Math.sin(angle)*18, vx: Math.cos(angle + 0.3)*2.2, vy: Math.sin(angle + 0.3)*2.2, life: 110, boss: true, grace: 10 });
                // Outer ring - counter-clockwise
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*30, y: b.y + 16 + Math.sin(angle)*30, vx: Math.cos(angle - 0.3)*1.8, vy: Math.sin(angle - 0.3)*1.8, life: 120, boss: true, grace: 10 });
            }
        }
        else if (b.attackPattern === 'laser') {
            // Avetta Platform - "RISK CROSS" - + shaped cross laser pattern (5 beams in cardinal + center)
            // VISUAL: Cross/plus pattern of fast laser beams
            GAME.shake = 14;
            spawnFloatingText(b.x + 16, b.y - 15, "RISK SCAN!", "#dc2626");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#dc2626', '#ff0000'], 25);
            // Fire cross pattern in sequence
            const crossAngles = [0, Math.PI/2, Math.PI, Math.PI*1.5, baseAngle]; // 4 cardinal + aimed center
            for (let i = 0; i < crossAngles.length; i++) {
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        let angle = crossAngles[i];
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*5.5, vy: Math.sin(angle)*5.5, life: 75, boss: true, grace: 5 });
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*6.5, vy: Math.sin(angle)*6.5, life: 65, boss: true, grace: 4 });
                        AudioSys.sfx.alert();
                    }
                }, i * 60);
            }
        }
        else if (b.attackPattern === 'wave') {
            // Jelena "Jelly" HR - "POLICY CASCADE" - 7-wave cascading sinusoidal attack
            // VISUAL: Multiple waves that undulate visibly
            GAME.shake = 7;
            spawnParticleBurst(b.x + 16, b.y + 16, ['#a855f7', '#c084fc'], 18);
            for (let i = -3; i <= 3; i++) {
                let angle = baseAngle + (i * 0.22);
                let proj = { type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*2.8, vy: Math.sin(angle)*2.8, life: 150, boss: true, grace: 12, wave: true, waveTime: i * 12, waveAmplitude: 1.2, baseAngle: angle };
                GAME.projectiles.push(proj);
            }
        }
        else if (b.attackPattern === 'storm') {
            // MEGA SIMON - "CHAOS VORTEX" - complete 360° chaotic storm (14 projectiles)
            // VISUAL: Absolute chaos, projectiles everywhere at varying speeds
            GAME.shake = 15;
            GAME.flash = 5;
            spawnFloatingText(b.x + 16, b.y - 15, "VIOLATION STORM!", "#ff0000");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#ff0000', '#ff9900', '#ffff00'], 30);
            for (let i = 0; i < 14; i++) {
                let angle = (Math.random() * Math.PI * 2); // Completely random directions
                let speed = 1.8 + Math.random() * 2.5; // Wildly varying speeds
                let scatter = (Math.random() - 0.5) * 35;
                let delay = Math.random() * 100;
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16 + scatter, y: b.y + 16 + scatter, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 130, boss: true, grace: 10 });
                    }
                }, delay);
            }
        }
        else {
            // Default spread attack
            for (let i = -1; i <= 1; i++) {
                let angle = baseAngle + (i * 0.3);
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*10, y: b.y + 16 + Math.sin(angle)*10, vx: Math.cos(angle)*2.5, vy: Math.sin(angle)*2.5, life: 100, boss: true, grace: 10 });
            }
        }
        AudioSys.sfx.alert(); GAME.shake = b.isMecha ? 8 : 5;
    }
}

function updateProjectiles() {
    for(let i=GAME.projectiles.length-1; i>=0; i--) {
        let p = GAME.projectiles[i];
        // Guard against undefined projectiles (can happen during state transitions)
        if (!p) { GAME.projectiles.splice(i, 1); continue; }
        p.x += p.vx; p.y += p.vy; p.life--; if(p.grace > 0) p.grace--;
        // Skip wall collision check in Bezos boss level
        if (GAME.state !== 'BEZOS_BOSS') {
            if (p.grace <= 0 && checkCol(p.x, p.y)) { GAME.projectiles.splice(i,1); continue; }
        }
        if (p.life <= 0) { GAME.projectiles.splice(i,1); continue; }
        // Roman's PHANTOM STEP - smaller collision radius for projectiles
        const projectileRadius = GAME.selectedChar === 'Roman' ? 6 : 10;
        if ((p.type === 'req') && Math.hypot(p.x-GAME.player.x, p.y-GAME.player.y) < projectileRadius) {
            if (GAME.player.iframe<=0) {
                // Nevena's FORESIGHT ability - longer invincibility frames
                const iframeBonus = GAME.selectedChar === 'Nevena' ? 180 : 120;
                GAME.lives--; GAME.player.iframe = iframeBonus; GAME.shake = 10; GAME.flash = 10; AudioSys.sfx.hurt(); updateHud();
                if (GAME.lives<=0 && !GAME.gameOverTriggered) triggerGameOver("OVERWHELMED!");
            }
            GAME.projectiles.splice(i,1);
        }
        if (p.type === 'attack') {
            const attackMeta = getAttackData(p.owner);
            if (GAME.state === 'BOSS' && GAME.boss) {
                if (Math.hypot(p.x - (GAME.boss.x+16), p.y - (GAME.boss.y+16)) < 24) {
                    // If Mecha Mega Simon, attacks are ineffective
                    if (GAME.boss.isMecha) {
                        GAME.projectiles.splice(i,1);
                        spawnFloatingText(GAME.boss.x+16, GAME.boss.y+8, "INEFFECTIVE!", "#666");
                        AudioSys.sfx.alert();
                        continue;
                    }
                    // 🔥 DESPERATION MODE: 30% dodge chance!
                    if (GAME.boss.desperationMode && Math.random() < 0.3) {
                        GAME.projectiles.splice(i,1);
                        spawnFloatingText(GAME.boss.x+16, GAME.boss.y+8, "DODGED!", "#ff9900");
                        spawnParticleBurst(GAME.boss.x+16, GAME.boss.y+16, ['#ff9900', '#ffff00'], 8);
                        AudioSys.sfx.alert();
                        continue;
                    }
                    // Character ability damage multipliers
                    let dmg = 1;
                    if (GAME.selectedChar === 'Carrie') dmg = 2; // PRECISION FOCUS
                    GAME.boss.hp -= dmg; updateBossHud(); AudioSys.sfx.bossHit(); GAME.shake = 5; spawnParticle(p.x, p.y, attackMeta.color || '#ff0000', -2); GAME.projectiles.splice(i,1);
                    const dmgText = dmg > 1 ? `${attackMeta.text || 'Hit!'} x${dmg}` : (attackMeta.text || 'Hit!');
                    spawnFloatingText(GAME.boss.x+16, GAME.boss.y+8, dmgText, attackMeta.color || '#ff0000');
                    // Damage number above boss head
                    spawnFloatingText(GAME.boss.x+16, GAME.boss.y-8, `-${dmg}`, '#ffffff');
                    // Check for Mecha Mega Simon transformation at 0 HP with fake victory sequence
                    if (GAME.boss.hp <= 0 && GAME.boss.name === "MEGA SIMON" && !GAME.boss.transformTriggered) {
                        GAME.boss.transformTriggered = true;
                        GAME.boss.hp = 1; // Keep boss alive during dialogue
                        triggerFakeVictoryDialogue(); // Start the fake victory sequence
                        continue;
                    }
                    // For non-Simon bosses, normal win condition
                    if (GAME.boss.hp <= 0 && GAME.boss.name !== "MEGA SIMON") { winGame(); continue; }
                }
            }
            if (GAME.state === 'PLAY') {
                let simon = GAME.entities.find(e => e.type === 'simon');
                if (simon && Math.hypot(p.x-simon.x, p.y-simon.y) < 12) {
                     GAME.simonHits++; AudioSys.sfx.angry(); GAME.projectiles.splice(i,1);
                     if (GAME.simonHits <= 2) {
                         const warningIndex = GAME.simonHits - 1;
                         const currentGen = GAME.genId;
                         GAME.nextState = 'PLAY';

                         // --- CHANGED: REMOVED HARDCODED FALLBACK DISPLAY. SHOW LOADING. ---
                         showThinking("Simon Unglaube", GFX.simonFaceLarge);

                         callGemini(`You are Simon Unglaube. Deliver a ${warningIndex === 0 ? "first" : "final"} warning to the coordinator who keeps throwing rule books at you. Keep it sharp, under 24 words.`, "simon_warning", { warningIndex }).then(text => {
                             if (GAME.genId === currentGen && GAME.state === 'DIALOG') {
                                  showDialog(text, "Simon Unglaube", GFX.simonFaceLarge, true);
                             }
                         });
                     }
                     else if (GAME.simonHits >= 3) initSimonBoss();
                     continue;
                }
                let hit = false;
                GAME.entities.forEach(e => {
                    if (e.type === 'ops' && Math.hypot(p.x-e.x, p.y-e.y) < 12) {
                        const rng = Math.random();
                        // 🔥 10% DEFLECT CHANCE FOR OPS ENEMIES - throws projectile back at player
                        if (rng < 0.1) {
                            spawnFloatingText(e.x, e.y, "DEFLECTED!", "#ff4444");
                            spawnParticleBurst(e.x, e.y, ['#ff4444', '#ff0000'], 8);
                            AudioSys.sfx.alert();
                            // Reverse projectile direction toward player
                            const angle = Math.atan2(GAME.player.y - e.y, GAME.player.x - e.x);
                            p.vx = Math.cos(angle) * 3.0;
                            p.vy = Math.sin(angle) * 3.0;
                            p.type = 'req'; // Change to boss projectile type so it damages player
                            p.boss = true;
                            p.grace = 15; // Give player a moment to react
                            hit = false; // Don't remove projectile
                        }
                        // 🔥 30% DODGE CHANCE FOR OPS ENEMIES
                        else if (rng < 0.4) { // 0.1 to 0.4 = 30% chance
                            spawnFloatingText(e.x, e.y, "DODGED!", "#ff9900");
                            spawnParticleBurst(e.x, e.y, ['#ff9900', '#ffff00'], 6);
                            AudioSys.sfx.alert();
                            hit = true;
                        } else {
                            e.type = 'assoc'; AudioSys.sfx.hit(); spawnParticle(e.x, e.y, attackMeta.color || '#fff', -2); GAME.opsPushed++;
                            spawnFloatingText(e.x, e.y, attackMeta.text || "My Rates!", attackMeta.color || "#ff0000");
                            hit = true;
                        }
                    }
                });
                if (hit) GAME.projectiles.splice(i,1);
            }
        }
    }
}

function updateParticles() {
    // Performance: Use constants and avoid splice in hot loop
    const gravity = GAME_CONSTANTS.PARTICLE_GRAVITY;
    const bounce = GAME_CONSTANTS.PARTICLE_BOUNCE;
    const particles = GAME.particles;
    let writeIdx = 0;

    for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.life--;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += gravity;

        if (p.y > p.groundY) {
            p.y = p.groundY;
            p.vy *= bounce;
        }

        if (p.life > 0) {
            // Keep this particle - swap to write position if needed
            if (writeIdx !== i) particles[writeIdx] = p;
            writeIdx++;
        }
    }
    // Truncate array to remove dead particles
    particles.length = writeIdx;
}

function updateFloatingTexts() {
    // Performance: Avoid splice in hot loop
    const texts = GAME.floatingTexts;
    let writeIdx = 0;

    for (let i = 0; i < texts.length; i++) {
        const t = texts[i];
        t.y += t.vy;
        t.life--;

        if (t.life > 0) {
            if (writeIdx !== i) texts[writeIdx] = t;
            writeIdx++;
        }
    }
    texts.length = writeIdx;
}

function spawnParticle(x, y, color, forceY = 0) {
    // Performance: Reuse objects where possible, limit max particles
    if (GAME.particles.length >= GAME_CONSTANTS.MAX_PARTICLES) return;

    GAME.particles.push({
        x: x,
        y: y,
        color: color,
        life: GAME_CONSTANTS.PARTICLE_LIFE_BASE + Math.random() * GAME_CONSTANTS.PARTICLE_LIFE_VARIANCE,
        vx: (Math.random() - 0.5) * 3,
        vy: forceY || (Math.random() * -3 - 1),
        groundY: y + 5,
        size: 1 + Math.random() * 2,
        alpha: 1,
        sparkle: false
    });
}

// Enhanced particle burst for special effects
function spawnParticleBurst(x, y, colors, count) {
    const maxToAdd = Math.min(count, GAME_CONSTANTS.MAX_PARTICLES - GAME.particles.length);
    const colorsLen = colors.length;

    for (let i = 0; i < maxToAdd; i++) {
        const angle = (i / count) * Math.PI * 2;
        const speed = 1 + Math.random() * 2;
        const color = colors[Math.floor(Math.random() * colorsLen)];
        GAME.particles.push({
            x: x,
            y: y,
            color: color,
            life: 30 + Math.random() * 30,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1,
            groundY: y + 20,
            size: 1 + Math.random() * 2,
            alpha: 1,
            sparkle: false
        });
    }
}

// Sparkle effect for special moments
function spawnSparkles(x, y, color) {
    const maxToAdd = Math.min(8, GAME_CONSTANTS.MAX_PARTICLES - GAME.particles.length);

    for (let i = 0; i < maxToAdd; i++) {
        GAME.particles.push({
            x: x + (Math.random() - 0.5) * 10,
            y: y + (Math.random() - 0.5) * 10,
            color: color,
            life: 20 + Math.random() * 20,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 3,
            groundY: y + 30,
            size: 1 + Math.random(),
            alpha: 1,
            sparkle: true
        });
    }
}

function throwBook() {
    const p = GAME.player; if (p.cooldown > 0) return; const attackMeta = getAttackData(GAME.selectedChar);
    // Joao's CAFFEINE RUSH ability - faster cooldown
    const cooldownMod = GAME.selectedChar === 'Joao' ? 0.65 : 1.0;
    const finalCooldown = Math.floor((attackMeta.cooldown || 120) * cooldownMod);
    p.cooldown = finalCooldown; p.cooldownMax = finalCooldown; GAME.booksFired++;
    const speed = attackMeta.speed || 4;
    let vx=0, vy=0;
    if (GAME.state === 'BOSS' && GAME.boss) {
        let angle = Math.atan2((GAME.boss.y+16) - p.y, (GAME.boss.x+16) - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed;
    } else if (GAME.state === 'MECHA_BOSS' && GAME.mecha) {
        let angle = Math.atan2((GAME.mecha.y+32) - p.y, (GAME.mecha.x+32) - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed;
    } else {
        let target = null; let minDist = 200;
        GAME.entities.forEach(e => { if (e.type === 'ops') { let d = Math.hypot(e.x - p.x, e.y - p.y); if (d < minDist) { minDist = d; target = e; } } });
        if (target) { let angle = Math.atan2(target.y - p.y, target.x - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed; }
        else { if (KEYS.up) vy=-speed; else if (KEYS.down) vy=speed; else if (KEYS.left) vx=-speed; else vx=speed; }
    }
    GAME.projectiles.push({ type:'attack', owner: GAME.selectedChar, sprite: attackMeta.sprite, color: attackMeta.color, x:p.x+8, y:p.y+8, vx, vy, life:attackMeta.life || 40, text: attackMeta.text }); AudioSys.sfx.throw();
}

function tryInteract() {
    const p = GAME.player;

    // Check if player is near fire exit door after exactly 4 hazards cleared
    if (GAME.issuesFixed >= 4 && GAME.fireExitDoor && Math.hypot(p.x - GAME.fireExitDoor.x, p.y - GAME.fireExitDoor.y) < 20) {
        AudioSys.sfx.alert();
        showDialog("You found the hidden exit!\n\nYou step through the fire door into the Amazon yard...", "System", null, false);
        GAME.nextState = 'YARD_INTRO';
        return true;
    }

    for (let i=0; i<GAME.entities.length; i++) {
        let e = GAME.entities[i];
        if (e.type === 'runner' && Math.hypot(p.x-e.x, p.y-e.y) < 20) {
             e.type = 'assoc'; GAME.issuesFixed++; updateHud(); AudioSys.sfx.fix();
             spawnFloatingText(e.x, e.y, "Safe!", "#00ff00");

             if (GAME.issuesFixed >= 5) { queueVisitorSplash(); }

             // SIMON COMMENTARY
             const currentGen = GAME.genId;

             // --- CHANGED: Show thinking state immediately for responsiveness ---
             showThinking("Simon Unglaube", GFX.simonFaceLarge);

             callGemini(
                 "You are Simon Unglaube, WHS Senior Regional Manager. The player stopped a runner. Praise the player with dry, professional humor and add a witty safety reminder about slowing down. Max 22 words.",
                 "runners"
             ).then(tip => {
                if (GAME.genId === currentGen) showDialog(`Fixed: Runner!\n${tip}`, "Simon Unglaube", GFX.simonFaceLarge, true);
             });
             return true;
        }
    }
    for(let h of GAME.activeIssues) {
        if (!h.fixed && Math.hypot(p.x-h.x, p.y-h.y) < 20) {
            h.fixed = true; GAME.issuesFixed++; updateHud(); AudioSys.sfx.fix();
            if (h.hiddenDoor && GAME.hiddenDoor) GAME.hiddenDoor.unlocked = true;
            spawnFloatingText(h.x, h.y, "Fixed!", "#00ff00");

            if (GAME.issuesFixed >= 5) { queueVisitorSplash(); }

            // SIMON COMMENTARY
            const currentGen = GAME.genId;

            // --- CHANGED: Show thinking state immediately ---
            showThinking("Simon Unglaube", GFX.simonFaceLarge);

            callGemini(
                `You are Simon Unglaube, WHS Senior Regional Manager. A hazard "${h.data.name}" was fixed. Praise the player with dry, professional humor and share one specific safety tip tied to that hazard. Max 32 words.`,
                "hazard",
                { hazardName: h.data.name }
            ).then(tip => {
                if (GAME.genId === currentGen) showDialog(`Fixed: ${h.data.name}!\n${tip}`, "Simon Unglaube", GFX.simonFaceLarge, true);
            });
            return true;
        }
    }
    if (GAME.hiddenDoor && GAME.hiddenDoor.unlocked) {
        const dx = GAME.player.x - GAME.hiddenDoor.doorX * TILE_SIZE;
        const dy = GAME.player.y - GAME.hiddenDoor.doorY * TILE_SIZE;
        if (Math.hypot(dx, dy) < 18) {
            GAME.state = 'YARD_INTRO';
            GAME.stateTimer = 0;
            GAME.nextState = 'YARD_LEVEL';
            GAME.projectiles = [];
            updateMusicForState();
            return true;
        }
    }
    return false;
}

// Helper to get random item from array
function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function triggerGameOver(reason) {
    GAME.gameOverTriggered = true; GAME.nextState = 'TITLE'; GAME.state = 'LOSE_SPLASH'; GAME.splashTimer = 320; GAME.aiResultText = null; GAME.stateTimer = 0;
    GAME.gameOverPhase = 0; // Track voice phases: 0=corporate, 1=character, 2=simon
    stopPortraitAnimation();
    document.getElementById('boss-hud').style.display = 'none'; document.getElementById('dialog-box').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';

    // Get snarky corporate message and character defeat line
    GAME.corporateMessage = pickRandom(CORPORATE_GAME_OVER);
    const charLines = CHARACTER_DEFEAT_LINES[GAME.selectedChar] || CHARACTER_DEFEAT_LINES["Carrie"];
    GAME.characterDefeatLine = pickRandom(charLines);
    GAME.gameOverReason = reason;

    // Special message for Mecha Mega Simon defeat
    if (GAME.mechaSimonDefeat) {
        GAME.corporateMessage = "MECHA MEGA SIMON has achieved ultimate safety compliance. All resistance has been optimized.";
        GAME.characterDefeatLine = "No one could have survived that transformation...";
    }

    // Stop current music and play game over music
    MusicSys.stop();
    MusicSys.currentName = null;
    MusicSys.play('menu'); // Game Over But Not Really track

    const time = Math.floor((Date.now() - GAME.startTime)/1000); const currentGen = GAME.genId;
    if (reason === "FIRED!") { GAME.aiResultText = "Terminated for unsafe behavior."; }
    else if (GAME.mechaSimonDefeat) {
        // Special Mecha Mega Simon performance review
        const stats = { time, hazards: GAME.issuesFixed, books: GAME.booksFired, ops: GAME.opsPushed };
        callGemini(`You are MECHA MEGA SIMON, the ultimate WHS authority. You just transformed into your unstoppable mecha form and defeated the coordinator. Deliver a terrifying mechanical performance review explaining how your transformation made you invincible and how no human could ever hope to defeat pure safety compliance given form. Mention that this defeat will be permanently recorded on their performance review that will be delivered to your ultimate form - MECHA MEGA SIMON. Remind them that Mega Simon's transformation was triggered by their futile resistance. Max 70 words.`, "reviews_loss", { stats }).then(review => {
             if (GAME.genId === currentGen) { GAME.aiResultText = review; }
        });
    }
    else {
        const stats = { time, hazards: GAME.issuesFixed, books: GAME.booksFired, ops: GAME.opsPushed };
        callGemini(`You are Simon Unglaube, WHS Senior Regional Manager. Coordinator failed after ${time}s with ${GAME.issuesFixed}/5 hazards fixed, ${GAME.booksFired} rule books thrown, ${GAME.opsPushed} ops pushed. Deliver a scathing yet funny performance review that weaves those stats into a safety lesson. Threaten that their failure will be documented and sent to MEGA SIMON or worse - MECHA MEGA SIMON for ultimate judgment. Max 55 words.`, "reviews_loss", { stats }).then(review => {
             if (GAME.genId === currentGen) { GAME.aiResultText = review; }
        });
    }
}

function winGame() {
    AudioSys.sfx.start(); MusicSys.play('victory'); GAME.nextState = 'CREDITS'; GAME.creditsType = 'normal'; GAME.state = 'WIN_SPLASH'; GAME.splashTimer = 260; GAME.aiResultText = null; GAME.stateTimer = 0;
    stopPortraitAnimation();
    document.getElementById('boss-hud').style.display = 'none'; document.getElementById('dialog-box').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';
    const currentGen = GAME.genId; const time = Math.floor((Date.now() - GAME.startTime)/1000);
    const stats = { time, hazards: GAME.issuesFixed, books: GAME.booksFired, ops: GAME.opsPushed };
    callGemini(`You are Simon Unglaube, WHS Senior Regional Manager. Coordinator won in ${time}s clearing ${GAME.issuesFixed}/5 hazards, tossing ${GAME.booksFired} rule books, redirecting ${GAME.opsPushed} ops. Give warm but witty praise plus one practical safety takeaway using those stats. Max 55 words.`, "reviews_win", { stats }).then(praise => {
        if (GAME.genId === currentGen) GAME.aiResultText = praise;
    });
}

function updateBossHud() { if(GAME.boss) document.getElementById('boss-health-el').style.width = Math.max(0, (GAME.boss.hp / GAME.boss.maxHp) * 100) + '%'; }

function checkCol(x, y) {
    let tx = Math.floor((x+8)/TILE_SIZE); let ty = Math.floor((y+8)/TILE_SIZE);
    if (tx<0||tx>=MAP_W||ty<0||ty>=MAP_H) return true;
    return GAME.map[ty][tx] !== 0;
}

function updateHud() { document.getElementById('life-val').innerText = "❤️".repeat(Math.max(0, GAME.lives)); document.getElementById('score-val').innerText = GAME.issuesFixed + "/5"; }

// Helper function to start portrait talking animation
function startPortraitAnimation(basePortrait, talkingPortrait) {
    // Stop any existing animation
    if (GAME.portraitAnimInterval) {
        clearInterval(GAME.portraitAnimInterval);
    }

    GAME.currentPortraitBase = basePortrait;
    GAME.currentPortraitTalking = talkingPortrait;
    GAME.portraitTalkPhase = false;

    const port = document.getElementById('portrait');
    const pCtx = port.getContext('2d');

    // Animate between normal and talking at 6 FPS (every ~166ms)
    GAME.portraitAnimInterval = setInterval(() => {
        GAME.portraitTalkPhase = !GAME.portraitTalkPhase;
        pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,48,48);
        if (GAME.portraitTalkPhase && talkingPortrait) {
            pCtx.drawImage(talkingPortrait, 0, 0);
        } else {
            pCtx.drawImage(basePortrait, 0, 0);
        }
    }, 166);
}

// Helper function to stop portrait animation
function stopPortraitAnimation() {
    if (GAME.portraitAnimInterval) {
        clearInterval(GAME.portraitAnimInterval);
        GAME.portraitAnimInterval = null;
    }
}

// Helper function to start INTRO portrait talking animation (larger, centered)
function startIntroPortraitAnimation(speaker) {
    // Stop any existing animation
    if (GAME.portraitAnimInterval) {
        clearInterval(GAME.portraitAnimInterval);
    }

    const basePortrait = GFX.introPortraits[speaker];
    const talkingPortrait = GFX.introPortraitsTalking[speaker];

    if (!basePortrait || !talkingPortrait) return;

    GAME.currentPortraitBase = basePortrait;
    GAME.currentPortraitTalking = talkingPortrait;
    GAME.portraitTalkPhase = false;

    const port = document.getElementById('intro-portrait');
    const pCtx = port.getContext('2d');

    // Animate between normal and talking at 6 FPS (every ~166ms)
    GAME.portraitAnimInterval = setInterval(() => {
        GAME.portraitTalkPhase = !GAME.portraitTalkPhase;
        pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,96,96);
        if (GAME.portraitTalkPhase && talkingPortrait) {
            pCtx.drawImage(talkingPortrait, 0, 0);
        } else {
            pCtx.drawImage(basePortrait, 0, 0);
        }
    }, 166);
}

// Show intro portrait window (for intro conversation only)
function showIntroDialog(text, speaker, isAI = false) {
    // Hide regular dialog box
    document.getElementById('dialog-box').style.display = 'none';

    // Show intro window
    const window = document.getElementById('intro-portrait-window');
    const nameEl = document.getElementById('intro-speaker-name');
    const badge = document.getElementById('intro-gemini-badge');
    const textContent = document.getElementById('intro-text-content');
    const port = document.getElementById('intro-portrait');
    const pCtx = port.getContext('2d');

    window.style.display = 'block';
    nameEl.innerText = speaker;
    textContent.innerText = "";

    badge.style.display = isAI ? 'block' : 'none';
    badge.innerHTML = isAI ? "✨ SIMON IS ANALYZING..." : "";

    // Store dialog text for typewriter effect
    GAME.state = 'DIALOG';
    GAME.dialogText = text;
    GAME.dialogVisible = "";

    // Draw portrait
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,96,96);
    const portrait = GFX.introPortraits[speaker];
    if (portrait) {
        pCtx.drawImage(portrait, 0, 0);
        // Start animation
        startIntroPortraitAnimation(speaker);
    }

    AudioSys.sfx.text();
    if (speaker) speakTTS(text, speaker);
}

// Show thinking state in intro window
function showIntroThinking(speaker) {
    // Stop any talking animation while thinking
    stopPortraitAnimation();

    // Hide regular dialog box
    document.getElementById('dialog-box').style.display = 'none';

    // Show intro window
    const window = document.getElementById('intro-portrait-window');
    const nameEl = document.getElementById('intro-speaker-name');
    const badge = document.getElementById('intro-gemini-badge');
    const textContent = document.getElementById('intro-text-content');
    const port = document.getElementById('intro-portrait');
    const pCtx = port.getContext('2d');

    window.style.display = 'block';
    nameEl.innerText = speaker;
    textContent.innerHTML = "<span class='loading-dots'>PROCESSING</span>";

    badge.style.display = 'block';
    badge.innerText = "✨ UPLINK ESTABLISHED...";

    GAME.state = 'DIALOG';
    GAME.dialogText = "";
    GAME.dialogVisible = "";

    // Draw portrait
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,96,96);
    const portrait = GFX.introPortraits[speaker];
    if (portrait) pCtx.drawImage(portrait, 0, 0);

    AudioSys.sfx.text();
}

// Close intro window
function closeIntroDialog() {
    stopPortraitAnimation();
    document.getElementById('intro-portrait-window').style.display = 'none';
    GAME.state = GAME.nextState;
}

function showDialog(text, speaker, portrait, isAI = false) {
    // Store previous state for background rendering during dialog
    // Don't overwrite if we're in the Bezos dialogue sequence (keep THRONE_CONFRONTATION)
    if (GAME.state !== 'DIALOG' && GAME.state !== 'BEZOS_DIALOGUE_NEXT') {
        GAME.dialogBackgroundState = GAME.state;
    }
    GAME.state = 'DIALOG'; GAME.dialogText = (speaker ? speaker + ":\n" : "") + text; GAME.dialogVisible = "";
    const box = document.getElementById('dialog-box'); const badge = document.getElementById('gemini-badge'); const port = document.getElementById('portrait'); const pCtx = port.getContext('2d');
    box.style.display = 'flex'; document.getElementById('text-content').innerText = "";
    badge.style.display = isAI ? 'block' : 'none';
    badge.innerHTML = isAI ? "✨ SIMON IS ANALYZING..." : ""; // Reset badge text
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,48,48);
    if (portrait) {
        pCtx.drawImage(portrait, 0, 0);

        // Start talking animation if we have a talking variant
        let talkingPortrait = null;
        if (speaker === "Simon Unglaube") {
            talkingPortrait = GFX.simonFaceTalking;
        } else if (GFX.charFacesTalking[speaker]) {
            talkingPortrait = GFX.charFacesTalking[speaker];
        }

        if (talkingPortrait) {
            startPortraitAnimation(portrait, talkingPortrait);
        }
    } else {
        pCtx.fillStyle='#fff'; pCtx.fillText("!", 10, 20);
    }
    AudioSys.sfx.text();
    if (speaker) speakTTS(text.replace(speaker + ":\n", "").replace(/\n/g, ' '), speaker);
}

// --- NEW FUNCTION: Show "Thinking" state ---
function showThinking(speaker, portrait) {
    // Store previous state for background rendering during dialog
    // Don't overwrite if we're in the Bezos dialogue sequence (keep THRONE_CONFRONTATION)
    if (GAME.state !== 'DIALOG' && GAME.state !== 'BEZOS_DIALOGUE_NEXT') {
        GAME.dialogBackgroundState = GAME.state;
    }

    // Stop any talking animation while thinking
    stopPortraitAnimation();

    GAME.state = 'DIALOG';
    GAME.dialogText = ""; // No typed text yet
    GAME.dialogVisible = "";
    const box = document.getElementById('dialog-box');
    const badge = document.getElementById('gemini-badge');
    const port = document.getElementById('portrait');
    const pCtx = port.getContext('2d');

    box.style.display = 'flex';
    document.getElementById('text-content').innerHTML = "<span class='loading-dots'>PROCESSING</span>"; // Loading animation

    badge.style.display = 'block';
    badge.innerText = "✨ UPLINK ESTABLISHED...";

    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,48,48);
    if (portrait) pCtx.drawImage(portrait, 0, 0);

    AudioSys.sfx.text();
}

// === BEZOS CONFRONTATION DIALOGUE SYSTEM ===
// Uses AI-powered showDialog for the throne room confrontation
let bezosDialogueStep = 0;

function startBezosConfrontationDialogue() {
    bezosDialogueStep = 0;
    showNextBezosDialogue();
}

function showNextBezosDialogue() {
    const currentGen = GAME.genId;
    const scene = GAME.throneScene;

    // Dialogue steps: Bezos taunts, player responds, Bezos transforms
    const dialoguePrompts = [
        {
            speaker: "Jeff Bezos",
            portrait: GFX.jeffYard,
            prompt: `You are Jeff Bezos, megalomaniac CEO sitting on your golden Amazon throne. A ${GAME.selectedChar} warehouse worker just survived your gauntlet. Deliver an arrogant opening taunt about how pathetic their attempt is. Reference Prime delivery or ownership principles. Max 25 words.`,
            category: "bezos_confrontation"
        },
        {
            speaker: GAME.selectedChar,
            portrait: GFX.chars[GAME.selectedChar],
            prompt: `You are ${GAME.selectedChar}, a brave warehouse worker confronting evil Jeff Bezos. Deliver a defiant one-liner about ending his reign of terror over workers. Be heroic and determined. Max 20 words.`,
            category: "player_response"
        },
        {
            speaker: "Jeff Bezos",
            portrait: GFX.jeffYard,
            prompt: `You are Jeff Bezos, enraged that a worker dares challenge you. Announce your transformation into your TRUE FORM - Mecha Jeff. Be dramatic, megalomaniacal, and terrifying. Reference your ultimate power. Max 25 words.`,
            category: "bezos_transform"
        }
    ];

    if (bezosDialogueStep >= dialoguePrompts.length) {
        // All dialogues done, proceed to transformation
        GAME.state = 'MECHA_TRANSFORM';
        GAME.stateTimer = 0;
        return;
    }

    const step = dialoguePrompts[bezosDialogueStep];
    showThinking(step.speaker, step.portrait);

    callGemini(step.prompt, step.category).then(text => {
        if (GAME.genId === currentGen) {
            showDialog(text, step.speaker, step.portrait, true);
            // Set up the next dialogue to trigger when this one closes
            GAME.nextState = 'BEZOS_DIALOGUE_NEXT';
        }
    });
}

function closeDialog() {
    stopPortraitAnimation(); // Stop talking animation
    cancelTTS(); AudioSys.sfx.step(); document.getElementById('dialog-box').style.display = 'none';

    GAME.state = GAME.nextState;

    // Handle intro dialogue sequence - player responds to Simon in INTRO WINDOW
    if (GAME.state === 'INTRO_DIALOGUE_CONTINUE') {
        const currentGen = GAME.genId;

        showIntroThinking(GAME.selectedChar);
        GAME.nextState = 'PLAY'; // After player response, start the game

        // Get character personality for response
        const charData = CHAR_DATA[GAME.selectedChar] || {};
        const personality = charData.backstory || "a dedicated WHS coordinator";

        // Generate player's enthusiastic response
        callGemini(`You are ${GAME.selectedChar}, ${personality}. Simon just explained your mission: find 5 safety hazards and dodge ops interruptions. Respond enthusiastically that you'll do your best not to disappoint him. Keep it short, in-character, and determined. Max 25 words.`, "player_response").then(text => {
            if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
                let finalText = text.replace(/\[.*?\]/g, GAME.selectedChar);
                showIntroDialog(finalText, GAME.selectedChar, true);
            }
        });
        return;
    }

    // Handle Simon fake victory dialogue sequence
    if (GAME.state === 'SIMON_FAKE_VICTORY_CONTINUE' || GAME.state === 'SIMON_FAKE_VICTORY_TRANSFORM') {
        handleFakeVictoryDialogClose();
        return;
    }

    // Handle Bezos dialogue sequence
    if (GAME.state === 'BEZOS_DIALOGUE_NEXT') {
        bezosDialogueStep++;
        showNextBezosDialogue();
        return;
    }

    // Handle BEZOS_ESCAPE dialogue sequence (snarky exchange)
    if (GAME.state === 'BEZOS_ESCAPE_DIALOGUE' && GAME.escapeScene) {
        // Advance to next escape dialogue
        const nextIndex = GAME.escapeScene.dialogueStep + 1;
        showBezosEscapeDialogue(nextIndex);
        return;
    }

    // Handle Mecha Jeff's defeat one-liner (after phase 0)
    if (GAME.state === 'BEZOS_ESCAPE_MECHA_LINE' && GAME.escapeScene) {
        // After Mecha Jeff's one-liner, proceed to explosion (phase 2)
        GAME.state = 'BEZOS_ESCAPE';
        GAME.escapeScene.phase = 2;
        GAME.escapeScene.phaseTimer = 0;
        GAME.escapeScene.explosionParticles = [];
        return;
    }

    // Handle Jeff's one-liner after transformation (after phase 3)
    if (GAME.state === 'BEZOS_ESCAPE_JEFF_LINE' && GAME.escapeScene) {
        // After Jeff's one-liner, proceed to running to rocket (phase 5)
        GAME.state = 'BEZOS_ESCAPE';
        GAME.escapeScene.phase = 5;
        GAME.escapeScene.phaseTimer = 0;
        // Reset Jeff position for the run
        GAME.escapeScene.jeffX = GAME.escapeScene.startJeffX || canvas.width / 2;
        GAME.escapeScene.jeffY = canvas.height - 70;
        return;
    }

    // Handle BEZOS_ESCAPE dialogue continuation (Simon's congratulations)
    if (GAME.state === 'BEZOS_ESCAPE' && GAME.escapeScene && GAME.escapeScene.phase === 8) {
        // Continue phase 8 animation after Simon's dialog
        GAME.stateTimer = GAME.escapeScene.phaseTimer || 0;
        return;
    }

    if (GAME.state === 'VISITOR_SPLASH') { showVisitorSplash(); return; }

    // Handle GAMEOVER_SPLASH - reset stateTimer for animation
    if (GAME.state === 'GAMEOVER_SPLASH') {
        GAME.stateTimer = 0;
        return;
    }

    // Only start yard level if not already initialized (prevents infinite loop)
    if (GAME.state === 'YARD_LEVEL' && !GAME.yard) { startYardLevel(); return; }
    if (GAME.state === 'MECHA_BOSS_INTRO') { beginMechaEncounter(); return; }
    if (GAME.state === 'CREDITS') { startCredits(); return; }

    if (GAME.state === 'PLAY' && GAME.pendingBossIntro && !GAME.boss) {
        showVisitorSplash();
        return;
    }
    if (GAME.state === 'PLAY' && GAME.issuesFixed >= 5 && !GAME.boss && !GAME.pendingBossIntro) {
        queueVisitorSplash();
        showVisitorSplash();
        return;
    }

    updateMusicForState();
}

function updateMusicForState() {
    // Don't change music during dialogues - let current track continue
    if (GAME.state === 'DIALOG') return;

    let rate = 1;
    let track = 'title';

    // Title EE Productions - for LOGO intro screen (7 seconds, non-looping)
    if (GAME.state === 'LOGO') track = 'intro';
    // Pixel Reverie - for Menus (intro, story, title, how to play)
    else if (['INTRO', 'STORY', 'TITLE', 'HOWTO'].includes(GAME.state)) track = 'title';
    // Game Over But Not Really - for character select screen
    else if (GAME.state === 'SELECT') track = 'menu';
    // Pixel Warehouse Crawl - for warehouse gameplay
    else if (GAME.state === 'PLAY') track = 'ingame';
    // Level-Yard - for yard/outdoor level
    else if (['YARD_INTRO', 'YARD_LEVEL'].includes(GAME.state)) track = 'yard';
    // Pixel Panic - for boss reveals (regular bosses only)
    else if (GAME.state === 'VISITOR_SPLASH') track = 'boss';
    // MEGA SIMON's theme - for Simon boss intro, fight, and transformation
    else if (['BOSS_INTRO', 'SIMON_MECHA_TRANSFORM', 'MECHA_SIMON_SPLASH'].includes(GAME.state) &&
             GAME.boss && (GAME.boss.name === 'MEGA SIMON' || GAME.boss.name === 'MECHA MEGA SIMON')) {
        track = 'megaSimon';
    }
    // Pixel Panic - for regular boss intros
    else if (GAME.state === 'BOSS_INTRO') track = 'boss';
    // MEGA SIMON's theme - for Simon fight and fake victory sequence
    else if ((GAME.state === 'BOSS' || GAME.state === 'SIMON_FAKE_VICTORY') &&
             GAME.boss && (GAME.boss.name === 'MEGA SIMON' || GAME.boss.name === 'MECHA MEGA SIMON')) {
        track = 'megaSimon';
    }
    // SNES BOSS FIGHT MUSIC - for regular boss fights (5 random bosses)
    else if (GAME.state === 'BOSS') track = 'snesBoss';
    // SNES BOSS FIGHT MUSIC - for Mecha Jeff fight
    else if (['MECHA_BOSS', 'MECHA_BOSS_INTRO', 'MECHA_TRANSFORM', 'THRONE_CONFRONTATION'].includes(GAME.state)) track = 'snesBoss';
    // Pixel Victory - for beating the game
    else if (GAME.state === 'BEZOS_ESCAPE') track = 'victory';
    // Game Over Symphony - for both Credits Scenes
    else if (GAME.state === 'CREDITS') track = 'credits';
    // WIN_SPLASH - don't change music (handled in winGame function)
    else if (GAME.state === 'WIN_SPLASH') return;
    // LOSE_SPLASH and GAMEOVER_SPLASH - play game over music (Game Over But Not Really track)
    else if (GAME.state === 'LOSE_SPLASH' || GAME.state === 'GAMEOVER_SPLASH') {
        track = 'menu';
        // Force music change even if currently playing
        if (MusicSys.currentName !== 'menu') {
            MusicSys.stop();
            MusicSys.currentName = null;
        }
    }

    MusicSys.play(track, rate);
}

function drawSnesSplash(isWin) {
    const t = GAME.stateTimer;
    const primary = isWin ? '#0d1b4c' : '#2d0a0f';
    const accent = isWin ? '#7dd3fc' : '#f87171';
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, isWin ? '#0a102a' : '#1a0408');
    gradient.addColorStop(0.5, primary);
    gradient.addColorStop(1, '#000');
    ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Moving scanlines
    for (let y = 0; y < canvas.height; y += 8) {
        const offset = Math.sin((t / 8) + y * 0.12) * 3;
        ctx.fillStyle = `rgba(255,255,255,${isWin ? 0.05 : 0.04})`;
        ctx.fillRect(offset, y, canvas.width, 2);
    }

    // Mode-7 style horizon lines
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height * 0.65);
    for (let i = 0; i < 18; i++) {
        const scale = (i + 1) / 18;
        const wave = Math.sin((t / 10) + i * 0.6) * 4;
        const w = canvas.width * (1.1 - scale * 0.6);
        const y = i * 12 + wave;
        ctx.strokeStyle = `${accent}80`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-w / 2, y);
        ctx.lineTo(w / 2, y);
        ctx.stroke();
    }
    ctx.restore();

    // Star glints
    for (let i = 0; i < 14; i++) {
        const x = (Math.sin((t + i * 13) / 6) * 0.5 + 0.5) * canvas.width;
        const y = (i * 37 + t * 2) % canvas.height;
        const alpha = 0.25 + ((i % 3) * 0.1);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillRect(x, y, 2, 2);
        ctx.fillRect(x - 2, y, 6, 1);
        ctx.fillRect(x, y - 2, 1, 6);
    }

    ctx.textAlign = 'center';
    ctx.fillStyle = '#000';
    ctx.font = '22px monospace';
    const text = isWin ? 'COMPLIANT!' : 'TERMINATED';
    const shadowOffsets = [[2,2],[-2,2],[2,-2],[-2,-2]];
    shadowOffsets.forEach(([dx, dy]) => ctx.fillText(text, canvas.width/2 + dx, canvas.height/2 - 50 + dy));

    ctx.fillStyle = accent;
    ctx.fillText(text, canvas.width/2, canvas.height/2 - 50);

    // Game Over: Just show loading message like WIN_SPLASH - full content shows in Simon's dialog

    ctx.font = '11px monospace';
    ctx.fillStyle = '#fef9c3';
    const sub = isWin ? 'CALCULATING SAFETY SCORE...' : 'PREPARING EXIT INTERVIEW...';
    ctx.fillText(sub, canvas.width/2, canvas.height/2 + 55);
    ctx.textAlign = 'start';
}

// Game Over splash screen - shown after Simon's review dialog
function drawGameOverSplash() {
    const t = GAME.stateTimer;

    // Dark red gradient background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#1a0408');
    gradient.addColorStop(0.5, '#2d0a0f');
    gradient.addColorStop(1, '#000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Moving scanlines
    for (let y = 0; y < canvas.height; y += 8) {
        const offset = Math.sin((t / 8) + y * 0.12) * 3;
        ctx.fillStyle = `rgba(255,255,255,0.04)`;
        ctx.fillRect(offset, y, canvas.width, 2);
    }

    // Flickering vignette effect
    const vignetteAlpha = 0.4 + Math.sin(t / 20) * 0.1;
    const vignette = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width * 0.8);
    vignette.addColorStop(0, 'rgba(0,0,0,0)');
    vignette.addColorStop(1, `rgba(0,0,0,${vignetteAlpha})`);
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.textAlign = 'center';

    // "GAME OVER" text with dramatic shadow
    ctx.font = 'bold 28px monospace';
    const shadowOffsets = [[3,3],[-3,3],[3,-3],[-3,-3],[0,4],[0,-4],[4,0],[-4,0]];
    shadowOffsets.forEach(([dx, dy]) => {
        ctx.fillStyle = '#000';
        ctx.fillText('GAME OVER', canvas.width/2 + dx, canvas.height/2 - 30 + dy);
    });

    // Pulsing red text
    const pulse = 0.7 + Math.sin(t / 10) * 0.3;
    ctx.fillStyle = `rgba(248, 113, 113, ${pulse})`;
    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 30);

    // Corporate message
    ctx.font = '10px monospace';
    ctx.fillStyle = '#fef9c3';
    const corporateMsg = GAME.corporateMessage || 'Employment optimized.';
    wrapText(ctx, `"${corporateMsg}"`, canvas.width/2, canvas.height/2 + 20, canvas.width - 40, 14);

    // Character defeat line
    if (GAME.characterDefeatLine) {
        ctx.fillStyle = '#94a3b8';
        ctx.font = '9px monospace';
        const charLine = `${GAME.selectedChar}: "${GAME.characterDefeatLine}"`;
        wrapText(ctx, charLine, canvas.width/2, canvas.height/2 + 60, canvas.width - 40, 12);
    }

    // Press space prompt (after short delay)
    if (t > 120) {
        const blink = Math.floor(t / 30) % 2 === 0;
        if (blink) {
            ctx.font = '10px monospace';
            ctx.fillStyle = '#666';
            ctx.fillText('[PRESS SPACE]', canvas.width/2, canvas.height - 20);
        }
    }

    ctx.textAlign = 'start';
}

// Helper function for word wrapping text
function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    let currentY = y;
    ctx.textAlign = 'center';

    for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line.trim(), x, currentY);
            line = words[n] + ' ';
            currentY += lineHeight;
        } else {
            line = testLine;
        }
    }
    ctx.fillText(line.trim(), x, currentY);
}

function drawYardLevel() {
    const y = GAME.yard;
    const camY = y ? y.cameraY || 0 : 0;
    const totalHeight = y ? y.height : canvas.height;
    const hallwayStart = y ? y.hallwayStart : 250;
    const hallwayEnd = y ? y.castleStart : 650;

    ctx.save();
    ctx.translate(0, -camY);

    // === MASSIVE THRONE ROOM AT TOP (safe zone - no weapons) ===
    const throneRoomHeight = hallwayStart;

    // Dark throne room background with gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, throneRoomHeight);
    skyGrad.addColorStop(0, '#020206');
    skyGrad.addColorStop(0.3, '#050510');
    skyGrad.addColorStop(0.6, '#0a0a18');
    skyGrad.addColorStop(1, '#0f0f22');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, canvas.width, throneRoomHeight);

    // === THRONE ROOM FLOOR TILES ===
    const floorStart = Math.floor(throneRoomHeight * 0.5);
    for (let ty = floorStart; ty < throneRoomHeight; ty += 16) {
        for (let tx = 0; tx < canvas.width; tx += 16) {
            const isEven = ((tx / 16) + (ty / 16)) % 2 === 0;
            ctx.fillStyle = isEven ? '#1a1a28' : '#252535';
            ctx.fillRect(tx, ty, 16, 16);
            ctx.fillStyle = isEven ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.01)';
            ctx.fillRect(tx + 1, ty + 1, 6, 6);
        }
    }

    // === RED CARPET LEADING TO THRONE ===
    const carpetWidth = 70;
    const carpetX = canvas.width / 2 - carpetWidth / 2;
    ctx.fillStyle = '#7f1d1d';
    ctx.fillRect(carpetX, 0, carpetWidth, throneRoomHeight);
    ctx.fillStyle = '#991b1b';
    ctx.fillRect(carpetX + 8, 0, carpetWidth - 16, throneRoomHeight);
    ctx.fillStyle = '#b45309';
    ctx.fillRect(carpetX, 0, 4, throneRoomHeight);
    ctx.fillRect(carpetX + carpetWidth - 4, 0, 4, throneRoomHeight);
    ctx.fillStyle = '#fbbf24';
    for (let py = 20; py < throneRoomHeight; py += 40) {
        ctx.fillRect(carpetX + 22, py, 26, 3);
        ctx.fillRect(carpetX + 27, py + 6, 16, 3);
    }

    if (y) {
        const animFrame = y.jeffAnimFrame || 0;

        // === AMAZON WALL BANNERS ===
        const bannerY = 20;
        // Left banner with Amazon logo
        ctx.fillStyle = '#4a1010';
        ctx.fillRect(40, bannerY, 35, 70);
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(44, bannerY + 5, 27, 60);
        ctx.fillStyle = '#4a1010';
        ctx.beginPath();
        ctx.moveTo(44, bannerY + 40); ctx.quadraticCurveTo(57, bannerY + 55, 71, bannerY + 37);
        ctx.lineTo(71, bannerY + 42); ctx.quadraticCurveTo(57, bannerY + 60, 44, bannerY + 47); ctx.fill();

        // Right banner
        ctx.fillStyle = '#4a1010';
        ctx.fillRect(canvas.width - 75, bannerY, 35, 70);
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(canvas.width - 71, bannerY + 5, 27, 60);
        ctx.fillStyle = '#4a1010';
        ctx.beginPath();
        ctx.moveTo(canvas.width - 71, bannerY + 40); ctx.quadraticCurveTo(canvas.width - 58, bannerY + 55, canvas.width - 44, bannerY + 37);
        ctx.lineTo(canvas.width - 44, bannerY + 42); ctx.quadraticCurveTo(canvas.width - 58, bannerY + 60, canvas.width - 71, bannerY + 47); ctx.fill();

        // === ELEVATED THRONE PLATFORM ===
        const throneX = canvas.width / 2;
        const throneY = 45;

        // Stepped platform
        ctx.fillStyle = '#1a1520';
        ctx.fillRect(throneX - 80, 118, 160, 12);
        ctx.fillStyle = '#201828';
        ctx.fillRect(throneX - 70, 106, 140, 14);
        ctx.fillStyle = '#281e30';
        ctx.fillRect(throneX - 60, 94, 120, 14);

        // === MASSIVE GOLDEN THRONE ===
        ctx.fillStyle = '#2d1810';
        ctx.fillRect(throneX - 55, throneY - 25, 110, 75);
        ctx.fillStyle = '#4a2818';
        ctx.fillRect(throneX - 50, throneY - 20, 100, 65);
        ctx.fillStyle = '#5a3520';
        ctx.fillRect(throneX - 45, throneY - 15, 90, 55);

        // Throne spires
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(throneX - 52, throneY - 50, 12, 40);
        ctx.fillRect(throneX + 40, throneY - 50, 12, 40);
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(throneX - 52, throneY - 50);
        ctx.lineTo(throneX - 46, throneY - 70);
        ctx.lineTo(throneX - 40, throneY - 50);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(throneX + 40, throneY - 50);
        ctx.lineTo(throneX + 46, throneY - 70);
        ctx.lineTo(throneX + 52, throneY - 50);
        ctx.fill();
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(throneX - 49, throneY - 45, 6, 6);
        ctx.fillRect(throneX + 43, throneY - 45, 6, 6);

        // Amazon logo on throne (glowing and pulsing)
        const logoPulse = Math.sin(animFrame * 0.08) * 0.2 + 0.8;
        ctx.fillStyle = `rgba(255, 153, 0, ${logoPulse})`;
        ctx.fillRect(throneX - 25, throneY, 50, 22);
        ctx.fillStyle = '#ffb347';
        ctx.fillRect(throneX - 20, throneY + 3, 40, 16);
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.moveTo(throneX - 15, throneY + 14);
        ctx.quadraticCurveTo(throneX, throneY + 24, throneX + 15, throneY + 11);
        ctx.lineTo(throneX + 20, throneY + 14);
        ctx.quadraticCurveTo(throneX, throneY + 30, throneX - 18, throneY + 17);
        ctx.fill();

        // Ornate throne armrests
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(throneX - 48, throneY + 30, 14, 25);
        ctx.fillRect(throneX + 34, throneY + 30, 14, 25);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(throneX - 45, throneY + 33, 8, 19);
        ctx.fillRect(throneX + 37, throneY + 33, 8, 19);

        // === MENACING GLOW BEHIND BEZOS ===
        const jeffX = canvas.width / 2 - 24;
        const jeffY = throneY + 5;
        const bobY = Math.sin(animFrame * 0.04) * 2;

        const glowSize = 60 + Math.sin(animFrame * 0.06) * 10;
        const glowGrad = ctx.createRadialGradient(jeffX + 24, jeffY + 24 + bobY, 8, jeffX + 24, jeffY + 24 + bobY, glowSize);
        glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.7)');
        glowGrad.addColorStop(0.3, 'rgba(220, 38, 38, 0.4)');
        glowGrad.addColorStop(0.6, 'rgba(139, 0, 0, 0.2)');
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(jeffX + 24, jeffY + 24 + bobY, glowSize, 0, Math.PI * 2);
        ctx.fill();

        // === DRAW BEZOS ON THRONE ===
        ctx.drawImage(GFX.jeffYard, jeffX, jeffY + bobY);

        // === AMBIENT PARTICLES ===
        for (let i = 0; i < 5; i++) {
            const px = (animFrame * 0.3 + i * 50) % canvas.width;
            const py = 30 + Math.sin(animFrame * 0.02 + i * 2) * 40;
            ctx.fillStyle = 'rgba(255, 200, 100, 0.3)';
            ctx.fillRect(px, py, 2, 2);
        }

        // === "SAFE ZONE" indicator at throne room boundary ===
        ctx.fillStyle = '#22c55e';
        ctx.font = '6px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('THRONE ROOM', canvas.width / 2, throneRoomHeight - 8);
        ctx.textAlign = 'left';
    }

    // === LONG SECURITY HALLWAY (dangerous zone with lasers/drones) ===
    const hallwayBgGrad = ctx.createLinearGradient(0, throneRoomHeight, 0, hallwayEnd);
    hallwayBgGrad.addColorStop(0, '#0a0a18');
    hallwayBgGrad.addColorStop(0.5, '#0f1020');
    hallwayBgGrad.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = hallwayBgGrad;
    ctx.fillRect(0, throneRoomHeight, canvas.width, hallwayEnd - throneRoomHeight);

    // Hallway floor - industrial metal grating
    for (let ty = throneRoomHeight; ty < hallwayEnd; ty += 12) {
        for (let tx = 0; tx < canvas.width; tx += 12) {
            ctx.fillStyle = (tx + ty) % 24 === 0 ? '#1a1a28' : '#151522';
            ctx.fillRect(tx, ty, 11, 11);
            // Grating details
            ctx.fillStyle = 'rgba(255,255,255,0.02)';
            ctx.fillRect(tx + 2, ty + 2, 3, 3);
        }
    }

    // Hallway walls (sides) with red alert lighting
    if (y) {
        const animFrame = y.jeffAnimFrame || 0;
        const alertPulse = Math.sin(animFrame * 0.1) * 0.3 + 0.5;

        // Left wall
        ctx.fillStyle = '#1f1f35';
        ctx.fillRect(0, throneRoomHeight, 25, hallwayEnd - throneRoomHeight);
        // Right wall
        ctx.fillRect(canvas.width - 25, throneRoomHeight, 25, hallwayEnd - throneRoomHeight);

        // Red alert strips on walls
        ctx.fillStyle = `rgba(220, 38, 38, ${alertPulse})`;
        for (let wy = throneRoomHeight + 20; wy < hallwayEnd - 20; wy += 60) {
            ctx.fillRect(2, wy, 4, 30);
            ctx.fillRect(canvas.width - 6, wy, 4, 30);
        }

        // "DANGER" signs along hallway
        ctx.fillStyle = '#dc2626';
        ctx.font = '5px "Press Start 2P"';
        ctx.textAlign = 'center';
        for (let signY = throneRoomHeight + 50; signY < hallwayEnd - 50; signY += 100) {
            ctx.fillText('⚠', 12, signY);
            ctx.fillText('⚠', canvas.width - 12, signY);
        }
        ctx.textAlign = 'left';
    }

    // Warning stripes at throne room / hallway boundary
    ctx.fillStyle = '#facc15';
    for (let x = 0; x < canvas.width; x += 16) {
        ctx.fillRect(x, throneRoomHeight, 8, 5);
    }
    ctx.fillStyle = '#0f0f0f';
    for (let x = 8; x < canvas.width; x += 16) {
        ctx.fillRect(x, throneRoomHeight, 8, 5);
    }

    // Warning stripes at hallway / yard boundary
    ctx.fillStyle = '#facc15';
    for (let x = 0; x < canvas.width; x += 16) {
        ctx.fillRect(x, hallwayEnd - 5, 8, 5);
    }
    ctx.fillStyle = '#0f0f0f';
    for (let x = 8; x < canvas.width; x += 16) {
        ctx.fillRect(x, hallwayEnd - 5, 8, 5);
    }

    // curbs and dock edges (at bottom of yard)
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0, totalHeight - 18, canvas.width, 18);
    ctx.fillStyle = '#334155'; ctx.fillRect(0, totalHeight - 22, canvas.width, 4);
    ctx.fillStyle = '#64748b'; for (let x=0; x<canvas.width; x+=14) ctx.fillRect(x, totalHeight - 16, 8, 3);

    // lane bands and markings
    if (y) {
        ctx.setLineDash([8, 10]);
        ctx.strokeStyle = '#facc15'; ctx.lineWidth = 2;
        y.lanes.forEach(lane => {
            ctx.fillStyle = '#0f172a'; ctx.fillRect(0, lane.y - 20, canvas.width, 40);
            ctx.fillStyle = '#111827'; ctx.fillRect(0, lane.y - 14, canvas.width, 28);
            ctx.beginPath(); ctx.moveTo(0, lane.y); ctx.lineTo(canvas.width, lane.y); ctx.stroke();
            ctx.fillStyle = '#1e293b'; ctx.fillRect(0, lane.y - 22, canvas.width, 2);
            ctx.fillStyle = '#1e293b'; ctx.fillRect(0, lane.y + 20, canvas.width, 2);
        });
        ctx.setLineDash([]);
    }

    // palettes at bottom of yard
    ctx.fillStyle = '#f97316'; for (let x=10; x<canvas.width; x+=60) ctx.fillRect(x, totalHeight - 36, 8, 16);
    ctx.fillStyle = '#9ca3af'; for (let x=6; x<canvas.width; x+=50) ctx.fillRect(x, totalHeight - 48, 14, 6);

    if (y) {
        // Draw static hazards (puddles, debris)
        if (y.staticHazards) {
            y.staticHazards.forEach(h => {
                if (h.type === 'puddle') {
                    // Oil/water puddle
                    ctx.fillStyle = 'rgba(30, 64, 175, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(h.x + 12, h.y + 8, 18, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(96, 165, 250, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(h.x + 10, h.y + 6, 8, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Warning icon
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = '6px "Press Start 2P"';
                    ctx.fillText('!', h.x + 10, h.y - 2);
                } else if (h.type === 'debris') {
                    // Debris pile
                    ctx.fillStyle = '#78716c';
                    ctx.fillRect(h.x, h.y + 8, 24, 8);
                    ctx.fillStyle = '#a8a29e';
                    ctx.fillRect(h.x + 2, h.y + 4, 8, 10);
                    ctx.fillRect(h.x + 12, h.y + 6, 10, 8);
                    ctx.fillStyle = '#d6d3d1';
                    ctx.fillRect(h.x + 4, h.y + 6, 4, 4);
                }
            });
        }

        // Draw forklift zone warnings
        if (y.forkliftZones) {
            y.forkliftZones.forEach(zone => {
                if (zone.active || zone.timer < 40) {
                    const pulse = Math.sin(GAME.ticks * 0.2) * 0.3 + 0.5;
                    ctx.fillStyle = `rgba(234, 179, 8, ${pulse * 0.3})`;
                    ctx.fillRect(0, zone.y - 15, canvas.width, 30);
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(0, zone.y);
                    ctx.lineTo(canvas.width, zone.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
        }

        // Draw vehicles
        y.vehicles.forEach(v => {
            const sprite = v.type === 'van' ? GFX.van : GFX.truck;
            ctx.drawImage(sprite, v.x, v.y);
        });

        // Draw forklifts
        if (y.forklifts) {
            y.forklifts.forEach(f => {
                // Forklift body
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(f.x, f.y, 28, 16);
                ctx.fillStyle = '#d97706';
                ctx.fillRect(f.x + 2, f.y + 2, 24, 12);
                // Cage
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(f.x + 4, f.y + 2, 8, 10);
                ctx.fillStyle = '#374151';
                ctx.fillRect(f.x + 5, f.y + 3, 6, 8);
                // Forks
                ctx.fillStyle = '#6b7280';
                const forkX = f.dir === 1 ? f.x + 24 : f.x - 8;
                ctx.fillRect(forkX, f.y + 12, 10, 3);
                ctx.fillRect(forkX, f.y + 8, 10, 3);
                // Wheels
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(f.x + 4, f.y + 14, 6, 4);
                ctx.fillRect(f.x + 18, f.y + 14, 6, 4);
                // Warning light
                const lightPulse = Math.sin(GAME.ticks * 0.3) > 0;
                ctx.fillStyle = lightPulse ? '#ef4444' : '#7f1d1d';
                ctx.fillRect(f.x + 12, f.y - 2, 4, 4);
            });
        }

        // === HALLWAY SECTION HAZARDS RENDERING ===
        // Entrance archway at the bottom of hallway leading to yard
        if (y.castleStart) {
            const castleY = y.castleStart;

            // Entrance archway from yard to hallway
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, castleY - 60, canvas.width, 60);
            ctx.fillStyle = '#2d2d44';
            ctx.fillRect(canvas.width / 2 - 40, castleY - 45, 80, 45);
            ctx.fillStyle = '#3d3d5c';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, castleY - 45, 40, Math.PI, 0);
            ctx.fill();
            // "SECURITY CHECKPOINT" text
            ctx.fillStyle = '#dc2626';
            ctx.font = '5px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('SECURITY', canvas.width / 2, castleY - 55);
            ctx.textAlign = 'left';

            // Draw hallway platforms
            if (y.castlePlatforms) {
                y.castlePlatforms.forEach(p => {
                    // Platform glow
                    ctx.fillStyle = 'rgba(14, 165, 233, 0.3)';
                    ctx.fillRect(p.x - 2, p.y - 2, p.w + 4, 12);
                    // Platform body
                    ctx.fillStyle = '#38bdf8';
                    ctx.fillRect(p.x, p.y, p.w, 8);
                    ctx.fillStyle = '#0ea5e9';
                    ctx.fillRect(p.x + 2, p.y + 2, p.w - 4, 4);
                    // Platform edges
                    ctx.fillStyle = '#7dd3fc';
                    ctx.fillRect(p.x, p.y, 4, 8);
                    ctx.fillRect(p.x + p.w - 4, p.y, 4, 8);
                });
            }

            // Draw laser barriers
            if (y.castleLaserBarriers) {
                y.castleLaserBarriers.forEach(barrier => {
                    if (barrier.active) {
                        // Active laser - dangerous
                        const pulse = Math.sin(GAME.ticks * 0.3) * 0.2 + 0.8;
                        ctx.fillStyle = `rgba(239, 68, 68, ${pulse * 0.3})`;
                        ctx.fillRect(30, barrier.y - 10, canvas.width - 60, 20);
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(30, barrier.y - 3, canvas.width - 60, 6);
                        ctx.fillStyle = '#fca5a5';
                        ctx.fillRect(30, barrier.y - 1, canvas.width - 60, 2);
                        // Emitter nodes
                        ctx.fillStyle = '#dc2626';
                        ctx.fillRect(26, barrier.y - 6, 8, 12);
                        ctx.fillRect(canvas.width - 34, barrier.y - 6, 8, 12);
                    } else {
                        // Inactive - safe to pass
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                        ctx.fillRect(30, barrier.y - 2, canvas.width - 60, 4);
                        ctx.fillStyle = '#166534';
                        ctx.fillRect(26, barrier.y - 6, 8, 12);
                        ctx.fillRect(canvas.width - 34, barrier.y - 6, 8, 12);
                    }
                });
            }

            // Draw guard turrets
            if (y.castleGuards) {
                y.castleGuards.forEach(guard => {
                    // Turret base
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(guard.x, guard.y, 16, 16);
                    ctx.fillStyle = '#4b5563';
                    ctx.fillRect(guard.x + 2, guard.y + 2, 12, 12);
                    // Turret barrel
                    const dirX = guard.x < canvas.width / 2 ? 1 : -1;
                    ctx.fillStyle = '#6b7280';
                    if (dirX === 1) {
                        ctx.fillRect(guard.x + 12, guard.y + 5, 10, 6);
                    } else {
                        ctx.fillRect(guard.x - 6, guard.y + 5, 10, 6);
                    }
                    // Warning light
                    const charging = guard.fireTimer > guard.fireRate - 20;
                    ctx.fillStyle = charging ? '#ef4444' : '#22c55e';
                    ctx.fillRect(guard.x + 6, guard.y - 2, 4, 4);
                });
            }

            // Draw castle projectiles
            if (y.castleProjectiles) {
                y.castleProjectiles.forEach(proj => {
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(proj.x - 4, proj.y - 3, 8, 6);
                    ctx.fillStyle = '#f59e0b';
                    ctx.fillRect(proj.x - 2, proj.y - 1, 4, 2);
                });
            }

            // Draw patrol drones
            if (y.castleDrones) {
                y.castleDrones.forEach(drone => {
                    const pulse = Math.sin(drone.pulseTimer * 0.15) * 2;
                    // Drone body
                    ctx.fillStyle = '#22d3ee';
                    ctx.fillRect(drone.x - 8 - pulse/2, drone.y - 8 - pulse/2, 16 + pulse, 16 + pulse);
                    ctx.fillStyle = '#0ea5e9';
                    ctx.fillRect(drone.x - 5, drone.y - 5, 10, 10);
                    // Eye
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(drone.x - 2, drone.y - 2, 4, 4);
                    // Propellers
                    const propPhase = Math.floor(drone.pulseTimer / 2) % 2;
                    ctx.fillStyle = '#94a3b8';
                    if (propPhase === 0) {
                        ctx.fillRect(drone.x - 14, drone.y - 2, 6, 4);
                        ctx.fillRect(drone.x + 8, drone.y - 2, 6, 4);
                    } else {
                        ctx.fillRect(drone.x - 2, drone.y - 14, 4, 6);
                        ctx.fillRect(drone.x - 2, drone.y + 8, 4, 6);
                    }
                });
            }

        }
    }

    // Draw player
    if (GAME.player.iframe > 0 && GAME.player.iframe % 6 < 3) {
        ctx.globalAlpha = 0.5;
    }
    ctx.drawImage(GFX.chars[GAME.selectedChar], GAME.player.x, GAME.player.y);
    ctx.globalAlpha = 1;

    // Goal text
    ctx.fillStyle = '#facc15';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('GOAL', 8, 8);

    ctx.restore();

    // Progress indicator (fixed position, not scrolling)
    if (y) {
        const progress = 1 - (y.playerY / y.height);
        const barWidth = 8;
        const barHeight = canvas.height - 40;
        const barX = canvas.width - 14;
        const barY = 20;

        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

        // Track
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // Progress fill
        const fillHeight = barHeight * progress;
        const gradient = ctx.createLinearGradient(0, barY + barHeight - fillHeight, 0, barY + barHeight);
        gradient.addColorStop(0, '#22c55e');
        gradient.addColorStop(1, '#16a34a');
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY + barHeight - fillHeight, barWidth, fillHeight);

        // Player marker
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(barX - 3, barY + barHeight - fillHeight - 2, barWidth + 6, 4);

        // Labels
        ctx.fillStyle = '#facc15';
        ctx.font = '4px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('JEFF', barX + barWidth / 2, barY - 4);
        ctx.fillStyle = '#22c55e';
        ctx.fillText('START', barX + barWidth / 2, barY + barHeight + 10);
        ctx.textAlign = 'left';
    }
}

function drawMechaBattle() {
    const m = GAME.mecha;

    // === CASTLE THRONE ROOM BACKGROUND ===
    // Base castle wall color - changes when enraged
    let wallColor = '#1a1a2e';
    let accentColor = '#2a2a40';
    if (m && m.enraged) {
        const pulse = Math.sin(GAME.ticks * 0.1) * 0.15;
        wallColor = `rgb(${Math.floor(40 + pulse * 30)}, ${Math.floor(15 + pulse * 10)}, ${Math.floor(25 + pulse * 15)})`;
        accentColor = `rgb(${Math.floor(60 + pulse * 20)}, ${Math.floor(25 + pulse * 10)}, ${Math.floor(35 + pulse * 10)})`;
    }

    // Castle wall background
    ctx.fillStyle = wallColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Stone brick pattern
    ctx.fillStyle = accentColor;
    for (let ty = 0; ty < canvas.height; ty += 16) {
        for (let tx = 0; tx < canvas.width; tx += 20) {
            const offset = (Math.floor(ty / 16) % 2) * 10;
            ctx.fillRect(tx + offset, ty, 18, 14);
        }
    }

    // Castle pillars on sides
    ctx.fillStyle = '#151525';
    ctx.fillRect(0, 0, 24, canvas.height);
    ctx.fillRect(canvas.width - 24, 0, 24, canvas.height);
    ctx.fillStyle = '#252538';
    ctx.fillRect(4, 0, 16, canvas.height);
    ctx.fillRect(canvas.width - 20, 0, 16, canvas.height);

    // Pillar decorations
    ctx.fillStyle = '#ff9900';
    for (let py = 20; py < canvas.height; py += 40) {
        ctx.fillRect(8, py, 8, 6);
        ctx.fillRect(canvas.width - 16, py, 8, 6);
    }

    // Throne room banners
    ctx.fillStyle = '#dc2626';
    ctx.fillRect(40, 0, 20, 50);
    ctx.fillRect(canvas.width - 60, 0, 20, 50);
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(44, 20, 12, 8);
    ctx.fillRect(canvas.width - 56, 20, 12, 8);
    // Banner tips
    ctx.beginPath();
    ctx.moveTo(40, 50); ctx.lineTo(50, 65); ctx.lineTo(60, 50); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(canvas.width - 60, 50); ctx.lineTo(canvas.width - 50, 65); ctx.lineTo(canvas.width - 40, 50); ctx.fill();

    // Castle window arches with ominous glow
    const windowGlow = m && m.enraged ? 'rgba(220, 38, 38, 0.4)' : 'rgba(14, 165, 233, 0.3)';
    ctx.fillStyle = windowGlow;
    ctx.fillRect(80, 10, 30, 25);
    ctx.fillRect(canvas.width - 110, 10, 30, 25);
    ctx.beginPath();
    ctx.arc(95, 10, 15, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(canvas.width - 95, 10, 15, Math.PI, 0);
    ctx.fill();

    // Throne room floor with perspective tiles
    const floorGradient = ctx.createLinearGradient(0, 35, 0, canvas.height);
    floorGradient.addColorStop(0, '#1f1f35');
    floorGradient.addColorStop(1, '#0f0f20');
    ctx.fillStyle = floorGradient;
    ctx.fillRect(0, 35, canvas.width, canvas.height - 35);

    // Floor tile grid with perspective effect
    ctx.strokeStyle = m && m.enraged ? '#4a1515' : '#2d2d48';
    ctx.lineWidth = 1;
    for (let x = 24; x < canvas.width - 24; x += 24) {
        ctx.beginPath();
        ctx.moveTo(x, 35);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 35; y < canvas.height; y += 18) {
        ctx.beginPath();
        ctx.moveTo(24, y);
        ctx.lineTo(canvas.width - 24, y);
        ctx.stroke();
    }

    // Golden carpet runner in center
    ctx.fillStyle = m && m.enraged ? '#7f1d1d' : '#92400e';
    ctx.fillRect(canvas.width / 2 - 30, 35, 60, canvas.height - 35);
    ctx.fillStyle = m && m.enraged ? '#dc2626' : '#f59e0b';
    ctx.fillRect(canvas.width / 2 - 26, 35, 52, canvas.height - 35);
    // Carpet pattern
    ctx.fillStyle = m && m.enraged ? '#7f1d1d' : '#b45309';
    for (let cy = 45; cy < canvas.height; cy += 30) {
        ctx.fillRect(canvas.width / 2 - 20, cy, 40, 8);
    }

    // Arena edge glow line
    ctx.fillStyle = m && m.enraged ? '#dc2626' : '#ff9900';
    ctx.fillRect(24, 33, canvas.width - 48, 3);

    // Phase transition overlay
    if (m && m.phaseTransition) {
        const alpha = Math.min(0.6, m.transitionTimer / 30);
        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Phase name announcement
        if (m.transitionTimer > 20) {
            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillStyle = '#ff9900';
            const shake = Math.sin(m.transitionTimer * 0.5) * 2;
            ctx.fillText(m.phaseNames[m.currentPhase], canvas.width / 2 + shake, canvas.height / 2 - 10);
            ctx.font = '6px "Press Start 2P"';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(m.phaseTaunts[m.currentPhase], canvas.width / 2, canvas.height / 2 + 10);
            ctx.restore();
        }
    }

    // Draw boss with enrage glow
    if (m) {
        // Enrage aura
        if (m.enraged && m.enrageFlash < 10) {
            ctx.fillStyle = 'rgba(220, 38, 38, 0.3)';
            ctx.beginPath();
            ctx.arc(m.x + 32, m.y + 32, 45 + Math.sin(GAME.ticks * 0.1) * 5, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.drawImage(GFX.mechaJeff, m.x, m.y);
    }

    // Draw player
    if (GAME.player.iframe > 0 && GAME.player.iframe % 6 < 3) {
        ctx.globalAlpha = 0.5;
    }
    ctx.drawImage(GFX.chars[GAME.selectedChar], GAME.player.x, GAME.player.y);
    ctx.globalAlpha = 1;

    if (m) {
        // Draw shadows (package warning indicators)
        m.shadows.forEach(s => {
            const pulse = Math.sin(s.timer * 0.2) * 0.3 + 0.5;
            ctx.fillStyle = `rgba(239, 68, 68, ${pulse})`;
            ctx.beginPath();
            ctx.ellipse(s.x + 8, canvas.height - 16, 12 - s.timer * 0.15, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            // Warning X
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(s.x + 2, canvas.height - 22);
            ctx.lineTo(s.x + 14, canvas.height - 10);
            ctx.moveTo(s.x + 14, canvas.height - 22);
            ctx.lineTo(s.x + 2, canvas.height - 10);
            ctx.stroke();
        });

        // Draw projectiles
        m.projectiles.forEach(pr => {
            if (pr.type === 'missile') {
                // Draw trail
                if (pr.trail) {
                    for (let i = 0; i < pr.trail.length; i++) {
                        const t = pr.trail[i];
                        const alpha = i / pr.trail.length * 0.6;
                        ctx.fillStyle = `rgba(255, 100, 50, ${alpha})`;
                        ctx.fillRect(t.x + 3, t.y + 3, 4, 4);
                    }
                }
                // Missile body
                ctx.fillStyle = '#dc2626';
                ctx.fillRect(pr.x, pr.y, 10, 10);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(pr.x + 2, pr.y + 2, 6, 6);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(pr.x + 4, pr.y + 4, 2, 2);
            }
            if (pr.type === 'drone') {
                const pulse = Math.sin((pr.pulseTimer || 0) * 0.1) * 2;
                ctx.fillStyle = '#22d3ee';
                ctx.fillRect(pr.x - pulse/2, pr.y - pulse/2, 12 + pulse, 12 + pulse);
                ctx.fillStyle = '#0ea5e9';
                ctx.fillRect(pr.x + 2, pr.y + 2, 8, 8);
                // Propeller animation
                ctx.fillStyle = '#ffffff';
                const propAngle = (pr.pulseTimer || 0) % 4;
                if (propAngle < 2) {
                    ctx.fillRect(pr.x - 3, pr.y + 5, 4, 2);
                    ctx.fillRect(pr.x + 11, pr.y + 5, 4, 2);
                } else {
                    ctx.fillRect(pr.x + 4, pr.y - 3, 4, 2);
                    ctx.fillRect(pr.x + 4, pr.y + 13, 4, 2);
                }
            }
            if (pr.type === 'box') {
                ctx.save();
                ctx.translate(pr.x + 7, pr.y + 7);
                ctx.rotate(pr.rotation || 0);
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(-7, -7, 14, 14);
                ctx.fillStyle = '#92400e';
                ctx.fillRect(-5, 3, 10, 2);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(-5, -5, 10, 3);
                ctx.restore();
            }
            if (pr.type === 'shockwave') {
                ctx.fillStyle = '#a855f7';
                ctx.beginPath();
                ctx.arc(pr.x, pr.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#e879f9';
                ctx.beginPath();
                ctx.arc(pr.x, pr.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // Draw beams (laser grid)
        m.beams.forEach(beam => {
            if (beam.telegraph > 0) {
                // Telegraph warning line
                const pulse = Math.sin(beam.telegraph * 0.3) * 0.2 + 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.fillRect(beam.x, 35, 14, canvas.height - 35);
                // Warning text
                ctx.fillStyle = '#ff0000';
                ctx.font = '4px "Press Start 2P"';
                ctx.fillText('!', beam.x + 5, 50);
            } else {
                // Active beam
                ctx.fillStyle = 'rgba(14, 165, 233, 0.6)';
                ctx.fillRect(beam.x - 2, 35, 18, canvas.height - 35);
                ctx.fillStyle = '#38bdf8';
                ctx.fillRect(beam.x + 2, 35, 10, canvas.height - 35);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(beam.x + 5, 35, 4, canvas.height - 35);
            }
        });
    }

    // Draw player projectiles (attacks)
    GAME.projectiles.forEach(proj => {
        if (proj.type === 'attack') {
            const sprite = (GFX.attacks && GFX.attacks[proj.owner]) ? GFX.attacks[proj.owner] : GFX.book;
            // Glow effect behind projectile
            ctx.fillStyle = proj.color || '#00ffff';
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.arc(proj.x + 6, proj.y + 6, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            // Draw the projectile sprite
            ctx.drawImage(sprite, proj.x, proj.y);
        }
    });

    // Particles
    GAME.particles.forEach(p => {
        const alpha = p.alpha || (p.life / 50);
        ctx.globalAlpha = Math.min(1, alpha);
        if (p.sparkle) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(p.x - 1, p.y, 3, 1);
            ctx.fillRect(p.x, p.y - 1, 1, 3);
        }
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size || 2, p.size || 2);
        ctx.globalAlpha = 1;
    });

    // Floating texts with fade out and shrink effect
    GAME.floatingTexts.forEach(t => {
        const lifePercent = t.life / GAME_CONSTANTS.FLOATING_TEXT_LIFE;

        // Fade out slowly in the last 30% of life
        let alpha = 1.0;
        if (lifePercent < 0.3) {
            alpha = lifePercent / 0.3; // Smooth fade out
        }

        // Shrink gradually from 100% to 70% size over entire lifetime
        const scale = 0.7 + (lifePercent * 0.3);
        const baseFontSize = 6;
        const fontSize = Math.max(4, Math.floor(baseFontSize * scale));

        ctx.save();
        ctx.globalAlpha = Math.max(0.1, Math.min(1, alpha)); // Keep minimum visibility
        ctx.fillStyle = t.color;
        ctx.font = `${fontSize}px "Press Start 2P"`;
        ctx.textAlign = 'center';
        ctx.fillText(t.text, t.x, t.y);
        ctx.restore();
    });
}

// === THRONE CONFRONTATION CUTSCENE ===
function drawThroneConfrontation() {
    const t = GAME.stateTimer;
    const scene = GAME.throneScene;
    if (!scene) return;

    // Dark throne room background
    const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGrad.addColorStop(0, '#050510');
    bgGrad.addColorStop(0.3, '#0a0a18');
    bgGrad.addColorStop(0.7, '#1a1a2e');
    bgGrad.addColorStop(1, '#0b1224');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Dramatic torchlight flicker
    const flickerIntensity = 0.1 + Math.sin(t * 0.15) * 0.05;
    ctx.fillStyle = `rgba(255, 120, 40, ${flickerIntensity})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw the massive throne in the center-top
    const throneX = canvas.width / 2;
    const throneY = 40;

    // Throne backing - massive golden structure
    ctx.fillStyle = '#2d1810';
    ctx.fillRect(throneX - 60, throneY - 15, 120, 80);
    ctx.fillStyle = '#4a2818';
    ctx.fillRect(throneX - 55, throneY - 10, 110, 70);

    // Throne spires (taller, more imposing)
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(throneX - 58, throneY - 40, 10, 35);
    ctx.fillRect(throneX + 48, throneY - 40, 10, 35);
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.moveTo(throneX - 58, throneY - 40);
    ctx.lineTo(throneX - 53, throneY - 55);
    ctx.lineTo(throneX - 48, throneY - 40);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(throneX + 48, throneY - 40);
    ctx.lineTo(throneX + 53, throneY - 55);
    ctx.lineTo(throneX + 58, throneY - 40);
    ctx.fill();

    // Amazon logo on throne (glowing and pulsing)
    const logoPulse = Math.sin(t * 0.08) * 0.2 + 0.8;
    ctx.fillStyle = `rgba(255, 153, 0, ${logoPulse})`;
    ctx.fillRect(throneX - 25, throneY + 5, 50, 20);
    ctx.fillStyle = '#ffb347';
    ctx.fillRect(throneX - 20, throneY + 8, 40, 14);
    // Amazon arrow/smile
    ctx.fillStyle = '#ff6600';
    ctx.beginPath();
    ctx.moveTo(throneX - 15, throneY + 18);
    ctx.quadraticCurveTo(throneX, throneY + 28, throneX + 15, throneY + 15);
    ctx.lineTo(throneX + 20, throneY + 18);
    ctx.quadraticCurveTo(throneX, throneY + 32, throneX - 18, throneY + 20);
    ctx.fill();

    // Ornate throne armrests
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(throneX - 52, throneY + 40, 16, 25);
    ctx.fillRect(throneX + 36, throneY + 40, 16, 25);

    // Menacing glow behind Bezos
    const glowSize = 60 + Math.sin(t * 0.06) * 10;
    const glowGrad = ctx.createRadialGradient(throneX, throneY + 45, 10, throneX, throneY + 45, glowSize);
    glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.6)');
    glowGrad.addColorStop(0.4, 'rgba(220, 38, 38, 0.3)');
    glowGrad.addColorStop(0.7, 'rgba(139, 0, 0, 0.15)');
    glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(throneX, throneY + 45, glowSize, 0, Math.PI * 2);
    ctx.fill();

    // Draw Jeff Bezos on throne (larger, more imposing)
    const jeffBob = Math.sin(t * 0.04) * 2;
    ctx.save();
    ctx.translate(throneX, throneY + 35 + jeffBob);
    ctx.scale(1.5, 1.5);
    ctx.drawImage(GFX.jeffYard, -24, -24);
    ctx.restore();

    // Draw player character at bottom facing Bezos
    const playerY = canvas.height - 50;
    const playerX = canvas.width / 2;
    const playerBob = Math.sin(t * 0.06) * 1;
    ctx.save();
    ctx.translate(playerX, playerY + playerBob);
    ctx.scale(1.3, 1.3);
    ctx.drawImage(GFX.chars[GAME.selectedChar], -8, -8);
    ctx.restore();

    // VS text or confrontation indicator during phase 0 (quick zoom)
    if (scene.phase === 0) {
        ctx.fillStyle = '#dc2626';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        const vsFlash = Math.sin(t * 0.1) > 0 ? '#ff4444' : '#dc2626';
        ctx.fillStyle = vsFlash;
        ctx.fillText('VS', canvas.width / 2, canvas.height / 2 - 10);
    }

    // Note: Dialogue is now handled by showDialog system (no slow typewriter)

    ctx.textAlign = 'left';
}

// === MECHA TRANSFORMATION CUTSCENE ===
function drawMechaTransform() {
    const t = GAME.stateTimer;

    // Dark dramatic background
    ctx.fillStyle = '#050508';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Lightning flashes
    if (t % 30 < 5 || (t > 60 && t % 20 < 3) || (t > 120 && t % 15 < 4)) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Dramatic lines radiating from center
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
    for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2 + t * 0.02;
        const len = 50 + Math.sin(t * 0.1 + i) * 30;
        ctx.strokeStyle = i % 2 === 0 ? '#ff9900' : '#dc2626';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
        ctx.stroke();
    }
    ctx.restore();

    // Phase 1: Power surge (frames 0-80)
    if (t < 80) {
        const scale = 1 + Math.sin(t * 0.2) * 0.1;
        const shakeX = (Math.random() - 0.5) * (t / 20);
        const shakeY = (Math.random() - 0.5) * (t / 20);

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
        ctx.scale(scale, scale);
        ctx.drawImage(GFX.jeffYard, -24 + shakeX, -24 + shakeY);
        ctx.restore();

        // Warning text
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        const warningFlash = Math.sin(t * 0.15) > 0;
        if (warningFlash) {
            ctx.fillText('!! WARNING !!', canvas.width / 2, 180);
        }
        ctx.fillStyle = '#ff9900';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('TRANSFORMATION', canvas.width / 2, 195);
    }
    // Phase 2: Transformation (frames 80-160)
    else if (t < 160) {
        const progress = (t - 80) / 80;
        const shakeIntensity = 10 + progress * 20;

        // Intense shaking
        const shakeX = (Math.random() - 0.5) * shakeIntensity;
        const shakeY = (Math.random() - 0.5) * shakeIntensity;

        // Morphing between sprites
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);

        // Glowing energy effect
        const glowGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 80);
        glowGrad.addColorStop(0, `rgba(255, 153, 0, ${0.8 - progress * 0.3})`);
        glowGrad.addColorStop(0.5, `rgba(220, 38, 38, ${0.5})`);
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 80, 0, Math.PI * 2);
        ctx.fill();

        // Draw morphing sprites
        if (progress < 0.5) {
            ctx.globalAlpha = 1 - progress * 2;
            ctx.drawImage(GFX.jeffYard, -24 + shakeX, -24 + shakeY);
        }
        ctx.globalAlpha = Math.min(1, progress * 2);
        ctx.drawImage(GFX.mechaBezos, -24 + shakeX, -24 + shakeY);
        ctx.globalAlpha = 1;

        ctx.restore();

        // Text
        const texts = ['NOW WITNESS...', 'TRUE POWER...', 'FINAL FORM!'];
        const textIdx = Math.min(2, Math.floor(progress * 3));
        ctx.fillStyle = progress > 0.7 ? '#ff4444' : '#ff9900';
        ctx.font = '11px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(texts[textIdx], canvas.width / 2, 185);
    }
    // Phase 3: Mecha Reveal (frames 160+)
    else {
        const revealProgress = Math.min(1, (t - 160) / 60);

        // Epic glow
        const glowGrad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2 - 20, 20, canvas.width / 2, canvas.height / 2 - 20, 100);
        glowGrad.addColorStop(0, 'rgba(220, 38, 38, 0.6)');
        glowGrad.addColorStop(0.5, 'rgba(255, 153, 0, 0.3)');
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2 - 20, 100, 0, Math.PI * 2);
        ctx.fill();

        // Mecha Bezos revealed
        const scale = 1 + Math.sin(t * 0.1) * 0.05;
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
        ctx.scale(scale, scale);
        ctx.drawImage(GFX.mechaJeff, -32, -32);
        ctx.restore();

        // Title text
        ctx.fillStyle = '#ff4444';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('MECHA JEFF BEZOS', canvas.width / 2, 175);

        ctx.fillStyle = '#ff9900';
        ctx.font = '9px monospace';
        ctx.fillText('AUTOMATION PROTOCOL ACTIVATED', canvas.width / 2, 195);

        // Continue prompt after delay
        if (t > 200) {
            ctx.fillStyle = '#fff';
            ctx.font = '8px "Press Start 2P"';
            const blink = Math.sin(t * 0.15) > 0;
            if (blink) ctx.fillText('[PRESS SPACE]', canvas.width / 2, 215);
        }
    }

    ctx.textAlign = 'left';
}

// === SIMON MECHA TRANSFORMATION CUTSCENE ===
function drawSimonMechaTransform() {
    const t = GAME.stateTimer;

    // Dark dramatic background with WHS colors
    ctx.fillStyle = '#080808';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Red warning flashes
    if (t % 25 < 4 || (t > 50 && t % 18 < 3) || (t > 100 && t % 12 < 4)) {
        ctx.fillStyle = 'rgba(220, 38, 38, 0.25)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Dramatic lines radiating from center (WHS gold and red)
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2 - 15);
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 + t * 0.025;
        const len = 40 + Math.sin(t * 0.12 + i) * 25;
        ctx.strokeStyle = i % 2 === 0 ? '#eab308' : '#dc2626';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
        ctx.stroke();
    }
    ctx.restore();

    // Phase 1: Power surge (frames 0-70)
    if (t < 70) {
        const scale = 1 + Math.sin(t * 0.18) * 0.12;
        const shakeX = (Math.random() - 0.5) * (t / 15);
        const shakeY = (Math.random() - 0.5) * (t / 15);

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 15);
        ctx.scale(scale, scale);
        // Draw Mega Simon sprite (32x32)
        ctx.drawImage(GFX.simonBoss, -16 + shakeX, -16 + shakeY);
        ctx.restore();

        // Warning text
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        const warningFlash = Math.sin(t * 0.18) > 0;
        if (warningFlash) {
            ctx.fillText('!! DANGER !!', canvas.width / 2, 175);
        }
        ctx.fillStyle = '#eab308';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('SAFETY PROTOCOL', canvas.width / 2, 190);
        ctx.fillText('INITIATING', canvas.width / 2, 202);
    }
    // Phase 2: Transformation (frames 70-140)
    else if (t < 140) {
        const progress = (t - 70) / 70;
        const shakeIntensity = 8 + progress * 15;

        // Intense shaking
        const shakeX = (Math.random() - 0.5) * shakeIntensity;
        const shakeY = (Math.random() - 0.5) * shakeIntensity;

        // Morphing between sprites
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 15);

        // Glowing energy effect (WHS colors)
        const glowGrad = ctx.createRadialGradient(0, 0, 8, 0, 0, 70);
        glowGrad.addColorStop(0, `rgba(234, 179, 8, ${0.85 - progress * 0.25})`);
        glowGrad.addColorStop(0.5, `rgba(220, 38, 38, ${0.5})`);
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 70, 0, Math.PI * 2);
        ctx.fill();

        // Draw morphing sprites - fade from Simon to Mecha Simon
        if (progress < 0.5) {
            ctx.globalAlpha = 1 - progress * 2;
            ctx.drawImage(GFX.simonBoss, -16 + shakeX, -16 + shakeY);
        }
        ctx.globalAlpha = Math.min(1, progress * 2);
        // Mecha Simon is 48x48
        ctx.drawImage(GFX.mechaMegaSimon, -24 + shakeX, -24 + shakeY);
        ctx.globalAlpha = 1;

        ctx.restore();

        // Text
        const texts = ['INITIATING...', 'UPGRADE...', 'COMPLETE!'];
        const textIdx = Math.min(2, Math.floor(progress * 3));
        ctx.fillStyle = progress > 0.7 ? '#ff4444' : '#eab308';
        ctx.font = '11px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(texts[textIdx], canvas.width / 2, 185);
    }
    // Phase 3: Mecha Reveal (frames 140+)
    else {
        const revealProgress = Math.min(1, (t - 140) / 50);

        // Epic glow
        const glowGrad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2 - 15, 15, canvas.width / 2, canvas.height / 2 - 15, 90);
        glowGrad.addColorStop(0, 'rgba(220, 38, 38, 0.65)');
        glowGrad.addColorStop(0.5, 'rgba(234, 179, 8, 0.35)');
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2 - 15, 90, 0, Math.PI * 2);
        ctx.fill();

        // Mecha Mega Simon revealed with pulse
        const scale = 1 + Math.sin(t * 0.08) * 0.04;
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 15);
        ctx.scale(scale, scale);
        ctx.drawImage(GFX.mechaMegaSimon, -24, -24);
        ctx.restore();

        // Title text
        ctx.fillStyle = '#dc2626';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('MECHA MEGA', canvas.width / 2, 168);
        ctx.fillText('SIMON', canvas.width / 2, 183);

        ctx.fillStyle = '#eab308';
        ctx.font = '8px monospace';
        ctx.fillText('ULTIMATE WHS AUTHORITY', canvas.width / 2, 198);

        // Continue prompt after delay (or when text is ready)
        if (t > 180 && GAME.simonTransformTextFetched) {
            ctx.fillStyle = '#fff';
            ctx.font = '8px "Press Start 2P"';
            const blink = Math.sin(t * 0.15) > 0;
            if (blink) ctx.fillText('[PRESS SPACE]', canvas.width / 2, 215);
        } else if (t > 180) {
            // Show loading if text not ready yet
            ctx.fillStyle = '#888';
            ctx.font = '7px monospace';
            ctx.fillText('SYNCING PROTOCOL...', canvas.width / 2, 215);
        }
    }

    ctx.textAlign = 'left';
}

// === MECHA MEGA SIMON SPLASH SCREEN ===
function drawMechaSimonSplash() {
    const t = GAME.stateTimer;

    // Dark dramatic background with WHS/Amazon colors
    ctx.fillStyle = '#080008';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Red warning flashes
    if (t % 40 < 5) {
        ctx.fillStyle = 'rgba(220, 38, 38, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Dramatic radiating lines (gold and red - WHS colors)
    ctx.save();
    ctx.translate(canvas.width / 2, 100);
    for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2 + t * 0.02;
        const len = 80 + Math.sin(t * 0.1 + i) * 30;
        ctx.strokeStyle = i % 2 === 0 ? 'rgba(234, 179, 8, 0.6)' : 'rgba(220, 38, 38, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
        ctx.stroke();
    }
    ctx.restore();

    // Epic glow behind sprite
    const glowGrad = ctx.createRadialGradient(canvas.width / 2, 100, 10, canvas.width / 2, 100, 80);
    glowGrad.addColorStop(0, 'rgba(220, 38, 38, 0.7)');
    glowGrad.addColorStop(0.4, 'rgba(234, 179, 8, 0.4)');
    glowGrad.addColorStop(0.7, 'rgba(139, 0, 0, 0.2)');
    glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(canvas.width / 2, 100, 80, 0, Math.PI * 2);
    ctx.fill();

    // Mecha Mega Simon sprite (pulsing)
    const scale = 1.8 + Math.sin(t * 0.08) * 0.1;
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.translate(canvas.width / 2, 100);
    ctx.scale(scale, scale);
    ctx.drawImage(GFX.mechaMegaSimon, -24, -24);
    ctx.restore();

    // Title text with shadow effect
    ctx.textAlign = 'center';

    // "ULTIMATE THREAT" warning
    ctx.fillStyle = '#dc2626';
    ctx.font = '10px "Press Start 2P"';
    const flashWarning = Math.sin(t * 0.12) > 0;
    if (flashWarning) {
        ctx.fillText('!! ULTIMATE THREAT !!', canvas.width / 2, 28);
    }

    // Main title
    ctx.fillStyle = '#000';
    ctx.font = '14px "Press Start 2P"';
    ctx.fillText('MECHA MEGA', canvas.width / 2 + 1, 165);
    ctx.fillText('SIMON', canvas.width / 2 + 1, 182);
    ctx.fillStyle = '#dc2626';
    ctx.fillText('MECHA MEGA', canvas.width / 2, 164);
    ctx.fillText('SIMON', canvas.width / 2, 181);

    // Subtitle
    ctx.fillStyle = '#eab308';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('THE ULTIMATE WHS AUTHORITY', canvas.width / 2, 198);

    // Attack description
    ctx.fillStyle = '#ff9900';
    ctx.font = '7px monospace';
    ctx.fillText('ATTACK: COMPLIANCE ANNIHILATION', canvas.width / 2, 212);

    // Performance review warning
    ctx.fillStyle = '#ff4444';
    ctx.font = '6px monospace';
    const reviewFlash = Math.sin(t * 0.1) > 0;
    if (reviewFlash) {
        ctx.fillText('Your performance review awaits...', canvas.width / 2, 225);
    }

    // Continue prompt
    if (t > 60) {
        ctx.fillStyle = '#fff';
        ctx.font = '8px "Press Start 2P"';
        const blink = Math.sin(t * 0.15) > 0;
        if (blink) ctx.fillText('[PRESS SPACE]', canvas.width / 2, 240);
    }

    ctx.textAlign = 'left';
}

// === BEZOS ESCAPE SEQUENCE ===
// Mecha Jeff's defeat one-liner (shown right after defeat)
const MECHA_JEFF_DEFEAT_LINE = {
    speaker: "Mecha Jeff",
    portrait: "mechaJeff",
    text: "CRITICAL... SYSTEM... FAILURE! But you haven't won yet, worker ant! My TRUE form awaits..."
};

// Jeff Bezos one-liner after transforming back (shown after de-mecha transformation)
const JEFF_TRANSFORM_LINE = {
    speaker: "Jeff Bezos",
    portrait: "jeffYard",
    text: "Ugh! That mecha suit cost more than your entire BLOODLINE! No matter... I have a BACKUP plan!"
};

// Snarky dialogue exchange during/after rocket escape
const BEZOS_ESCAPE_DIALOGUES = [
    {
        speaker: "Jeff Bezos",
        portrait: "jeffYard",
        text: "Ha! You think this is over? I've got a rocket for EXACTLY this situation! Customer obsession includes ME escaping!"
    },
    {
        speaker: GAME?.selectedChar || "Player",
        portrait: "player",
        text: "Running away? That's NOT very 'Day One' of you, Bezos! What happened to 'bias for action'?"
    },
    {
        speaker: "Jeff Bezos",
        portrait: "jeffYard",
        text: "I'm not running, I'm PIVOTING! To space! Where there are no unions, no bathroom breaks, and NO SAFETY COORDINATORS!"
    },
    {
        speaker: GAME?.selectedChar || "Player",
        portrait: "player",
        text: "Go on then! We'll send the safety violations to orbit! Workers 1, Billionaire Bald Guy 0!"
    },
    {
        speaker: "Jeff Bezos",
        portrait: "jeffYard",
        text: "This isn't goodbye... it's 'See you in the next Prime Day'! BEZOS AWAAAAAY!",
        final: true
    }
];

function updateBezosEscape() {
    GAME.stateTimer++;
    const scene = GAME.escapeScene;
    if (!scene) return;

    scene.phaseTimer = (scene.phaseTimer || 0) + 1;
    const t = scene.phaseTimer;

    // Phase 0: Mecha sparks and shakes (90 frames), then show Mecha Jeff's one-liner
    if (scene.phase === 0) {
        if (t >= 90) {
            scene.phase = 1;
            scene.phaseTimer = 0;
            // Show Mecha Jeff's defeat one-liner
            GAME.dialogBackgroundState = 'BEZOS_ESCAPE';
            showDialog(MECHA_JEFF_DEFEAT_LINE.text, MECHA_JEFF_DEFEAT_LINE.speaker, GFX.mechaJeff, true);
            GAME.nextState = 'BEZOS_ESCAPE_MECHA_LINE';
        }
    }
    // Phase 1: Waiting for Mecha Jeff dialogue to finish (handled by dialogue system)
    // Phase 2: Mecha explodes dramatically (200 frames)
    else if (scene.phase === 2) {
        // Generate explosion particles
        if (t < 60 && t % 5 === 0) {
            for (let i = 0; i < 5; i++) {
                scene.explosionParticles.push({
                    x: scene.jeffX + (Math.random() - 0.5) * 40,
                    y: scene.jeffY + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6 - 2,
                    life: 60 + Math.random() * 40,
                    color: Math.random() > 0.5 ? '#ff9900' : '#dc2626',
                    size: 4 + Math.random() * 6
                });
            }
            if (t % 15 === 0) AudioSys.sfx.bossHit();
        }
        // Update particles
        scene.explosionParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1;
            p.life--;
            p.size *= 0.98;
        });
        scene.explosionParticles = scene.explosionParticles.filter(p => p.life > 0);

        if (t >= 200) {
            scene.phase = 3;
            scene.phaseTimer = 0;
            scene.transformProgress = 0;
        }
    }
    // Phase 3: Slow transformation back to regular Jeff (250 frames)
    else if (scene.phase === 3) {
        scene.transformProgress = Math.min(1, t / 220);

        // Steam/smoke particles during transformation
        if (t % 8 === 0 && t < 180) {
            scene.explosionParticles.push({
                x: scene.jeffX + (Math.random() - 0.5) * 30,
                y: scene.jeffY,
                vx: (Math.random() - 0.5) * 1,
                vy: -1 - Math.random() * 2,
                life: 40 + Math.random() * 30,
                color: '#888888',
                size: 8 + Math.random() * 8
            });
        }
        // Update particles
        scene.explosionParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            p.size *= 0.97;
        });
        scene.explosionParticles = scene.explosionParticles.filter(p => p.life > 0);

        if (t >= 250) {
            scene.phase = 4;
            scene.phaseTimer = 0;
            // Show Jeff's one-liner after transformation
            GAME.dialogBackgroundState = 'BEZOS_ESCAPE';
            showDialog(JEFF_TRANSFORM_LINE.text, JEFF_TRANSFORM_LINE.speaker, GFX.jeffYard, true);
            GAME.nextState = 'BEZOS_ESCAPE_JEFF_LINE';
        }
    }
    // Phase 4: Waiting for Jeff's dialogue to finish (handled by dialogue system)
    // Phase 5: Show throne room backdrop, Jeff runs to rocket (200 frames)
    else if (scene.phase === 5) {
        // Move Jeff toward the big centered rocket
        const targetX = scene.rocketX - 20; // Left of the rocket
        const targetY = scene.rocketY + 60; // Near bottom of rocket
        scene.jeffX += (targetX - scene.jeffX) * 0.03;
        scene.jeffY += (targetY - scene.jeffY) * 0.03;

        if (t >= 200) {
            scene.phase = 6;
            scene.phaseTimer = 0;
            // Initialize camera for phase 6
            scene.cameraZoom = 1.0;
            scene.cameraY = 0;
        }
    }
    // Phase 6: Epic rocket launch sequence (600 frames total)
    else if (scene.phase === 6) {
        // Sub-phases: 0-60 = boarding, 61-120 = countdown, 121+ = launch

        // Initialize countdown if not started
        if (t === 1) {
            scene.launchCountdown = 3;
            scene.countdownTimer = 0;
        }

        // Boarding phase (first 60 frames)
        if (t <= 60 && !scene.rocketLaunched) {
            scene.jeffVisible = true;
            // Jeff moves toward rocket hatch
            const hatchX = scene.rocketX + 32;
            const hatchY = scene.rocketY + 50;
            scene.jeffX += (hatchX - scene.jeffX) * 0.08;
            scene.jeffY += (hatchY - scene.jeffY) * 0.08;
        }
        // Countdown phase (frames 61-120)
        else if (t > 60 && t <= 180 && !scene.rocketLaunched) {
            scene.jeffVisible = false; // Jeff is inside
            scene.countdownTimer++;
            // Update countdown every 40 frames (about 0.67 seconds each)
            if (scene.countdownTimer >= 40 && scene.launchCountdown > 0) {
                scene.launchCountdown--;
                scene.countdownTimer = 0;
                AudioSys.sfx.bossHit(); // Countdown beep
            }
            // Camera starts zooming out slightly
            scene.cameraZoom = Math.max(0.7, scene.cameraZoom - 0.003);
        }
        // Launch phase (frames 181+)
        else if (t > 180) {
            if (!scene.rocketLaunched) {
                scene.rocketLaunched = true;
                scene.rocketVelocity = 0.5;
                AudioSys.sfx.bossIntro(); // Big launch sound
                // Initialize stars for space
                scene.stars = [];
                for (let i = 0; i < 100; i++) {
                    scene.stars.push({
                        x: Math.random() * canvas.width * 2,
                        y: Math.random() * 2000 - 2000, // Stars above the screen
                        size: Math.random() * 2 + 1,
                        twinkle: Math.random() * Math.PI * 2
                    });
                }
            }

            // Rocket acceleration - starts slow, then speeds up dramatically
            const launchTime = t - 180;
            scene.rocketVelocity = 0.5 + launchTime * 0.025; // Smooth acceleration
            scene.rocketY -= scene.rocketVelocity;

            // Camera follows the rocket
            scene.followingRocket = true;
            // Camera target follows rocket, keeping it in lower third of screen
            scene.cameraTargetY = scene.rocketY - canvas.height * 0.6;
            // Smooth camera follow
            scene.cameraY += (scene.cameraTargetY - scene.cameraY) * 0.08;

            // Continue zooming out as rocket goes higher
            if (launchTime < 200) {
                scene.cameraZoom = Math.max(0.4, scene.cameraZoom - 0.002);
            }

            // Transition to space when rocket is high enough
            if (scene.rocketY < -500) {
                scene.inSpace = true;
            }

            // End phase when rocket is far in space
            if (scene.rocketY < -1500 || launchTime >= 420) {
                scene.phase = 7;
                scene.dialogueStep = 0;
                scene.phaseTimer = 0;
                // Reset camera for dialogue
                scene.cameraY = 0;
                scene.cameraZoom = 1.0;
                scene.followingRocket = false;
                // Start snarky dialogue exchange
                showBezosEscapeDialogue(0);
            }
        }
    }
    // Phase 7: Dialogue exchange (handled by dialogue system)
    // Phase 8: Simon joins player from warehouse entrance
    else if (scene.phase === 8) {
        if (!scene.simonJoined) {
            scene.simonJoined = true;
            scene.simonX = -30;
            scene.simonY = canvas.height - 45;
            MusicSys.play('victory');
        }
        // Simon walks in from left
        if (scene.simonX < canvas.width / 2 - 50) {
            scene.simonX += 1.5;
        }
        // After Simon arrives and some time passes, go to credits
        if (t >= 350) {
            GAME.state = 'CREDITS';
            GAME.stateTimer = 0;
            GAME.creditsType = 'mecha';
        }
    }
}

function showBezosEscapeDialogue(index) {
    if (index >= BEZOS_ESCAPE_DIALOGUES.length) {
        // All dialogues done, move to Simon joining (phase 8)
        GAME.escapeScene.phase = 8;
        GAME.escapeScene.phaseTimer = 0;
        // Show Simon's congratulations
        GAME.dialogBackgroundState = 'BEZOS_ESCAPE';
        showDialog(
            'OUTSTANDING! You actually did it! You defeated the corporate overlord himself! ' +
            'This calls for a celebration... and possibly a promotion. ' +
            'The warehouse is finally safe from maniacal billionaire tyranny!',
            'Simon Unglaube',
            GFX.simonFaceLarge,
            false
        );
        GAME.nextState = 'BEZOS_ESCAPE'; // Stay in escape to continue animation
        return;
    }

    const dialogue = BEZOS_ESCAPE_DIALOGUES[index];
    let portrait = GFX.jeffYard;
    if (dialogue.portrait === 'player') {
        portrait = GFX.chars[GAME.selectedChar];
    }

    // Update speaker name for player
    let speaker = dialogue.speaker;
    if (dialogue.portrait === 'player') {
        speaker = GAME.selectedChar;
    }

    GAME.dialogBackgroundState = 'BEZOS_ESCAPE';
    showDialog(dialogue.text, speaker, portrait, true);
    GAME.escapeScene.dialogueStep = index;
    GAME.nextState = 'BEZOS_ESCAPE_DIALOGUE'; // Special state for escape dialogue continuation
}

function advanceBezosEscapeDialogue() {
    const scene = GAME.escapeScene;
    if (!scene) return;

    // Close current dialog
    stopPortraitAnimation();
    document.getElementById('dialog-box').style.display = 'none';
    TTSSys.cancel();

    // Move to next dialogue
    const nextIndex = scene.dialogueStep + 1;
    showBezosEscapeDialogue(nextIndex);
}

function drawBezosEscape() {
    const t = GAME.stateTimer;
    const scene = GAME.escapeScene;
    if (!scene) return;

    const pt = scene.phaseTimer || 0;

    // Draw throne room backdrop for phases 0-7 (keep throne room during dialogue)
    if (scene.phase <= 7) {
        drawThroneRoomBackdrop(t);
    } else {
        // After dialogue, switch to victory scene for Simon joining
        drawVictoryBackdrop(t);
    }

    // Phase 0: Mecha sparks and shakes (defeated but still standing)
    if (scene.phase === 0) {
        const shake = Math.sin(pt * 0.5) * (4 + pt * 0.05);

        // Warning sparks flying off
        for (let i = 0; i < 8; i++) {
            const sparkAngle = (i / 8) * Math.PI * 2 + pt * 0.1;
            const sparkDist = 20 + Math.sin(pt * 0.3 + i) * 10;
            const sx = scene.jeffX + Math.cos(sparkAngle) * sparkDist;
            const sy = scene.jeffY + Math.sin(sparkAngle) * sparkDist;
            ctx.fillStyle = pt % 4 < 2 ? '#ff9900' : '#ffff00';
            ctx.globalAlpha = 0.6 + Math.sin(pt * 0.5 + i) * 0.4;
            ctx.fillRect(sx - 2, sy - 2, 4, 4);
        }
        ctx.globalAlpha = 1;

        // Damaged Mecha Jeff shaking
        ctx.save();
        ctx.translate(scene.jeffX + shake, scene.jeffY);
        // Flickering/damage effect
        if (pt % 6 < 4) {
            ctx.globalAlpha = 0.8;
            ctx.drawImage(GFX.mechaJeff, -32, -32);
        }
        ctx.restore();

        // Damage indicators
        ctx.fillStyle = '#ff4444';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('CRITICAL DAMAGE', canvas.width / 2, 30);
        ctx.fillStyle = '#ff9900';
        ctx.font = '8px "Press Start 2P"';
        const warningFlash = pt % 30 < 15 ? 'WARNING' : 'SYSTEM FAILURE';
        ctx.fillText(warningFlash, canvas.width / 2, 48);
    }
    // Phase 1: Waiting for Mecha dialogue (still show damaged mecha)
    else if (scene.phase === 1) {
        const shake = Math.sin(pt * 0.3) * 3;
        ctx.save();
        ctx.translate(scene.jeffX + shake, scene.jeffY);
        ctx.globalAlpha = 0.9;
        ctx.drawImage(GFX.mechaJeff, -32, -32);
        ctx.restore();

        // Continuous sparks
        for (let i = 0; i < 5; i++) {
            const sx = scene.jeffX + (Math.random() - 0.5) * 50;
            const sy = scene.jeffY + (Math.random() - 0.5) * 50;
            ctx.fillStyle = Math.random() > 0.5 ? '#ff9900' : '#ffff00';
            ctx.globalAlpha = 0.7;
            ctx.fillRect(sx - 1, sy - 1, 3, 3);
        }
        ctx.globalAlpha = 1;
    }
    // Phase 2: Mecha explodes dramatically
    else if (scene.phase === 2) {
        const progress = Math.min(1, pt / 180);

        // Explosion core
        if (pt < 100) {
            const coreSize = 30 + progress * 80;
            const coreGrad = ctx.createRadialGradient(scene.jeffX, scene.jeffY, 0, scene.jeffX, scene.jeffY, coreSize);
            coreGrad.addColorStop(0, 'rgba(255, 255, 255, ' + (1 - progress) + ')');
            coreGrad.addColorStop(0.3, 'rgba(255, 200, 50, ' + (0.8 - progress * 0.5) + ')');
            coreGrad.addColorStop(0.6, 'rgba(255, 100, 0, ' + (0.6 - progress * 0.4) + ')');
            coreGrad.addColorStop(1, 'rgba(200, 0, 0, 0)');
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(scene.jeffX, scene.jeffY, coreSize, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw explosion particles
        scene.explosionParticles.forEach(p => {
            ctx.globalAlpha = Math.min(1, p.life / 30);
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        });
        ctx.globalAlpha = 1;

        // Screen flash
        if (pt < 30 && pt % 8 < 4) {
            ctx.fillStyle = 'rgba(255, 255, 255, ' + (0.6 - pt * 0.02) + ')';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Mecha fading out (first half only)
        if (pt < 60) {
            ctx.save();
            ctx.translate(scene.jeffX, scene.jeffY);
            ctx.globalAlpha = Math.max(0, 1 - pt / 50);
            const scale = 1 + pt * 0.01;
            ctx.scale(scale, scale);
            ctx.drawImage(GFX.mechaJeff, -32, -32);
            ctx.restore();
        }

        // Text
        ctx.fillStyle = '#ff4444';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('MECHA DESTROYED', canvas.width / 2, 30);

        if (pt > 100) {
            ctx.fillStyle = '#ffcc00';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText('FORM DESTABILIZING...', canvas.width / 2, 50);
        }
    }
    // Phase 3: Slow transformation back to regular Jeff
    else if (scene.phase === 3) {
        const progress = scene.transformProgress || 0;

        // Transformation energy field
        const fieldSize = 50 - progress * 20;
        const fieldGrad = ctx.createRadialGradient(scene.jeffX, scene.jeffY, 0, scene.jeffX, scene.jeffY, fieldSize);
        fieldGrad.addColorStop(0, 'rgba(100, 200, 255, ' + (0.3 - progress * 0.2) + ')');
        fieldGrad.addColorStop(0.5, 'rgba(50, 150, 255, ' + (0.2 - progress * 0.15) + ')');
        fieldGrad.addColorStop(1, 'rgba(0, 100, 200, 0)');
        ctx.fillStyle = fieldGrad;
        ctx.beginPath();
        ctx.arc(scene.jeffX, scene.jeffY, fieldSize, 0, Math.PI * 2);
        ctx.fill();

        // Steam/smoke particles
        scene.explosionParticles.forEach(p => {
            ctx.globalAlpha = Math.min(0.6, p.life / 40);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Morphing sprites with smooth transition
        ctx.save();
        ctx.translate(scene.jeffX, scene.jeffY);

        // Mecha fading out
        if (progress < 0.6) {
            ctx.globalAlpha = Math.max(0, 1 - progress * 1.8);
            const mechaScale = 1 - progress * 0.3;
            ctx.scale(mechaScale, mechaScale);
            ctx.drawImage(GFX.mechaJeff, -32, -32);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.translate(scene.jeffX, scene.jeffY);
        }

        // Jeff fading in
        if (progress > 0.3) {
            ctx.globalAlpha = Math.min(1, (progress - 0.3) / 0.6);
            const jeffScale = 0.7 + progress * 0.3;
            ctx.scale(jeffScale, jeffScale);
            ctx.drawImage(GFX.jeffYard, -24, -24);
        }
        ctx.restore();

        // Text progression
        ctx.fillStyle = '#22d3ee';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';
        if (progress < 0.3) {
            ctx.fillText('REVERTING...', canvas.width / 2, 30);
        } else if (progress < 0.7) {
            ctx.fillText('TRANSFORMATION...', canvas.width / 2, 30);
        } else {
            ctx.fillStyle = '#ff9900';
            ctx.fillText('BEZOS RETURNS!', canvas.width / 2, 30);
        }
    }
    // Phase 4: Waiting for Jeff's dialogue
    else if (scene.phase === 4) {
        // Jeff standing (post-transformation)
        ctx.drawImage(GFX.jeffYard, scene.jeffX - 24, scene.jeffY - 24);

        // Residual steam
        for (let i = 0; i < 3; i++) {
            const smokeX = scene.jeffX + Math.sin(t * 0.05 + i * 2) * 15;
            const smokeY = scene.jeffY - 30 - i * 12;
            ctx.fillStyle = `rgba(150, 150, 150, ${0.2 - i * 0.05})`;
            ctx.beginPath();
            ctx.arc(smokeX, smokeY, 6 + i * 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    // Phase 5: Jeff runs to rocket (throne room with rocket visible)
    else if (scene.phase === 5) {
        // Draw rocket on platform (bigger rocket now)
        ctx.drawImage(GFX.escapeRocket, scene.rocketX, scene.rocketY);

        // "SECRET ESCAPE POD" label
        ctx.fillStyle = '#ff9900';
        ctx.font = '8px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('BEZOS ESCAPE POD', scene.rocketX + 32, scene.rocketY - 12);

        // Jeff running animation
        const runFrame = Math.floor(pt / 8) % 2;
        ctx.save();
        ctx.translate(scene.jeffX, scene.jeffY + (runFrame * 3));
        // Face right (toward rocket)
        ctx.scale(-1, 1);
        ctx.drawImage(GFX.jeffYard, -24, -24);
        ctx.restore();

        // Running dust clouds
        if (pt % 12 === 0) {
            ctx.fillStyle = 'rgba(150, 150, 150, 0.4)';
            ctx.beginPath();
            ctx.arc(scene.jeffX - 20, scene.jeffY + 20, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Text
        ctx.fillStyle = '#fbbf24';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('TACTICAL RETREAT!', canvas.width / 2, 30);
        ctx.fillStyle = '#888';
        ctx.font = '7px monospace';
        ctx.fillText('"To the secret escape pod!"', canvas.width / 2, 45);
    }
    // Phase 6: Epic rocket launch with camera follow
    else if (scene.phase === 6) {
        const launchTime = Math.max(0, pt - 180);

        // Apply camera transform for zoom and follow
        ctx.save();

        // Calculate zoom center (center of screen)
        const zoomCenterX = canvas.width / 2;
        const zoomCenterY = canvas.height / 2;

        // Apply zoom and camera follow
        ctx.translate(zoomCenterX, zoomCenterY);
        ctx.scale(scene.cameraZoom || 1, scene.cameraZoom || 1);
        ctx.translate(-zoomCenterX, -zoomCenterY - (scene.cameraY || 0));

        // Draw space background (gradient from blue to black) when in upper atmosphere
        if (scene.followingRocket) {
            const spaceProgress = Math.min(1, Math.max(0, -scene.rocketY / 1000));

            // Sky gradient - blue to dark blue to black
            const gradient = ctx.createLinearGradient(0, scene.cameraY - 500, 0, scene.cameraY + canvas.height);
            gradient.addColorStop(0, `rgba(0, 0, 20, ${spaceProgress})`);
            gradient.addColorStop(0.3, `rgba(10, 20, 60, ${spaceProgress * 0.8})`);
            gradient.addColorStop(0.6, `rgba(30, 60, 120, ${spaceProgress * 0.5})`);
            gradient.addColorStop(1, `rgba(100, 150, 200, ${spaceProgress * 0.3})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, scene.cameraY - 1000, canvas.width * 2, 3000);

            // Draw stars (when getting into space)
            if (scene.stars && spaceProgress > 0.2) {
                for (const star of scene.stars) {
                    const twinkle = Math.sin(t * 0.1 + star.twinkle) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * spaceProgress})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y + scene.cameraY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw Earth horizon curving away (when high enough)
            if (spaceProgress > 0.5) {
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height + 800 + scene.cameraY, 900, Math.PI, 2 * Math.PI);
                ctx.fill();
                // Atmosphere glow
                ctx.strokeStyle = `rgba(135, 206, 250, ${spaceProgress * 0.6})`;
                ctx.lineWidth = 20;
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height + 800 + scene.cameraY, 910, Math.PI, 2 * Math.PI);
                ctx.stroke();
            }
        }

        // Draw the big rocket
        ctx.drawImage(GFX.escapeRocket, scene.rocketX, scene.rocketY);

        // Boarding phase - Jeff running to rocket
        if (pt <= 60 && !scene.rocketLaunched) {
            ctx.drawImage(GFX.jeffYard, scene.jeffX - 12, scene.jeffY - 12);
            ctx.fillStyle = '#ff9900';
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('BOARDING...', canvas.width / 2, 30 + (scene.cameraY || 0));
        }
        // Countdown phase
        else if (pt > 60 && pt <= 180 && !scene.rocketLaunched) {
            // Countdown display
            const countdown = scene.launchCountdown !== undefined ? scene.launchCountdown : 3;

            // Big countdown number
            ctx.fillStyle = countdown === 0 ? '#22c55e' : '#ff4444';
            ctx.font = '32px "Press Start 2P"';
            ctx.textAlign = 'center';
            const countText = countdown === 0 ? 'LAUNCH!' : countdown.toString();
            ctx.fillText(countText, canvas.width / 2, canvas.height / 2 - 20 + (scene.cameraY || 0));

            // Warning flashing
            if (t % 20 < 10) {
                ctx.fillStyle = '#ff9900';
                ctx.font = '8px "Press Start 2P"';
                ctx.fillText('T-MINUS', canvas.width / 2, canvas.height / 2 - 50 + (scene.cameraY || 0));
            }

            // Rocket rumble/vibration
            ctx.drawImage(GFX.escapeRocket, scene.rocketX + (Math.random() - 0.5) * 2, scene.rocketY);

            // Pre-launch smoke
            for (let i = 0; i < 5; i++) {
                const smokeX = scene.rocketX + 32 + (Math.random() - 0.5) * 40;
                const smokeY = scene.rocketY + 120 + Math.random() * 20;
                ctx.fillStyle = `rgba(200, 200, 200, ${0.4 - i * 0.08})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, 10 + Math.random() * 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        // Launch phase - rocket flying with massive flames
        else if (scene.rocketLaunched) {
            // Screen shake during initial launch
            const shakeAmount = Math.max(0, 8 - launchTime * 0.02);
            if (shakeAmount > 0) {
                ctx.translate((Math.random() - 0.5) * shakeAmount, (Math.random() - 0.5) * shakeAmount);
            }

            // Massive rocket flames (3 engines worth)
            const flameIntensity = Math.min(1, launchTime / 30);
            for (let engine = 0; engine < 3; engine++) {
                const engineX = scene.rocketX + 25 + engine * 7;
                for (let i = 0; i < 15; i++) {
                    const flameY = scene.rocketY + 128 + i * 12;
                    const flameWidth = (30 - i * 1.8) * flameIntensity;
                    const colors = ['#ffffff', '#ffffaa', '#ffff00', '#ffcc00', '#ff9900', '#ff6600', '#ff3300', '#cc0000'];
                    ctx.fillStyle = colors[Math.min(i, colors.length - 1)];
                    ctx.globalAlpha = (0.95 - i * 0.06) * flameIntensity;
                    const wobble = Math.sin(t * 0.8 + i * 0.5 + engine) * (4 + i * 0.3);
                    ctx.fillRect(engineX - flameWidth/2 + wobble, flameY, flameWidth, 12);
                }
            }
            ctx.globalAlpha = 1;

            // Massive smoke/exhaust trail
            for (let i = 0; i < 40; i++) {
                const smokeY = scene.rocketY + 180 + i * 20;
                const smokeX = scene.rocketX + 32 + Math.sin(t * 0.05 + i * 0.3) * (15 + i * 0.8);
                const smokeSize = 15 + i * 2.5;
                ctx.fillStyle = `rgba(180, 180, 180, ${0.6 - i * 0.015})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw rocket on top of flames
            ctx.drawImage(GFX.escapeRocket, scene.rocketX, scene.rocketY);
        }

        ctx.restore(); // End camera transform

        // HUD elements (not affected by camera)
        ctx.fillStyle = '#ff4444';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';

        if (scene.rocketLaunched) {
            ctx.fillText('BEZOS ESCAPES!', canvas.width / 2, 25);
            ctx.fillStyle = '#ff9900';
            ctx.font = '8px monospace';
            ctx.fillText('"To infinity and tax evasion!"', canvas.width / 2, 42);

            // Altitude indicator
            const altitude = Math.max(0, Math.floor(-scene.rocketY / 10));
            ctx.fillStyle = '#00ff00';
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'right';
            ctx.fillText(`ALT: ${altitude}km`, canvas.width - 10, 20);

            // Speed indicator
            const speed = Math.floor((scene.rocketVelocity || 0) * 100);
            ctx.fillText(`SPD: ${speed}m/s`, canvas.width - 10, 32);
        }
    }
    // Phase 7: Dialogue exchange with animated wide view of rocket in space
    else if (scene.phase === 7) {
        // Initialize space view animation state
        if (!scene.spaceViewInit) {
            scene.spaceViewInit = true;
            scene.spaceRocketY = 60; // Start position in the upper part of screen
            scene.spaceRocketScale = 0.5; // Starting scale (will shrink)
            scene.spaceStars = [];
            for (let i = 0; i < 80; i++) {
                scene.spaceStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.7,
                    size: Math.random() * 2 + 0.5,
                    twinkle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.5 + 0.1
                });
            }
        }

        // Draw epic space backdrop over throne room ceiling
        ctx.save();

        // Dark space gradient at the top (through the blasted ceiling)
        const spaceGrad = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);
        spaceGrad.addColorStop(0, '#000010');
        spaceGrad.addColorStop(0.3, '#050520');
        spaceGrad.addColorStop(0.6, '#0a0a30');
        spaceGrad.addColorStop(1, 'rgba(15, 15, 40, 0.8)');
        ctx.fillStyle = spaceGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height * 0.65);

        // Animated twinkling stars
        for (const star of scene.spaceStars) {
            star.twinkle += 0.05;
            const twinkle = Math.sin(star.twinkle) * 0.4 + 0.6;
            ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw Earth horizon curving at the bottom of the space view
        const earthY = canvas.height * 0.55;
        ctx.fillStyle = '#1e40af';
        ctx.beginPath();
        ctx.arc(canvas.width / 2, earthY + 400, 420, Math.PI, 2 * Math.PI);
        ctx.fill();

        // Atmosphere glow around Earth
        const atmosGrad = ctx.createRadialGradient(
            canvas.width / 2, earthY + 400, 400,
            canvas.width / 2, earthY + 400, 450
        );
        atmosGrad.addColorStop(0, 'rgba(135, 206, 250, 0)');
        atmosGrad.addColorStop(0.5, 'rgba(135, 206, 250, 0.4)');
        atmosGrad.addColorStop(1, 'rgba(135, 206, 250, 0)');
        ctx.fillStyle = atmosGrad;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, earthY + 400, 450, Math.PI, 2 * Math.PI);
        ctx.fill();

        // Animate rocket moving upward and shrinking
        scene.spaceRocketY -= 0.3; // Slowly moving up
        scene.spaceRocketScale = Math.max(0.1, scene.spaceRocketScale - 0.001); // Slowly shrinking

        const rocketCenterX = canvas.width / 2 + 30;
        const rocketDrawY = scene.spaceRocketY;
        const scale = scene.spaceRocketScale;

        // Draw rocket flames (scaled)
        const flameColors = ['#ffffff', '#ffff00', '#ff9900', '#ff6600', '#ff3300'];
        for (let i = 0; i < 5; i++) {
            const flameY = rocketDrawY + (20 + i * 8) * scale;
            const flameWidth = (12 - i * 2) * scale;
            const wobble = Math.sin(t * 0.8 + i * 0.5) * (2 * scale);
            ctx.fillStyle = flameColors[i];
            ctx.globalAlpha = 0.9 - i * 0.15;
            ctx.fillRect(rocketCenterX - flameWidth/2 + wobble, flameY, flameWidth, 8 * scale);
        }
        ctx.globalAlpha = 1;

        // Draw scaled rocket (simplified when small)
        if (scale > 0.3) {
            // Draw actual rocket sprite scaled
            ctx.save();
            ctx.translate(rocketCenterX, rocketDrawY);
            ctx.scale(scale, scale);
            ctx.drawImage(GFX.escapeRocket, -32, -64);
            ctx.restore();
        } else {
            // Very small rocket - just a simple shape
            ctx.fillStyle = '#e5e7eb';
            const rocketH = Math.max(4, 20 * scale);
            const rocketW = Math.max(2, 8 * scale);
            ctx.fillRect(rocketCenterX - rocketW/2, rocketDrawY - rocketH, rocketW, rocketH);
            ctx.fillStyle = '#1e40af';
            ctx.beginPath();
            ctx.moveTo(rocketCenterX, rocketDrawY - rocketH - 4 * scale);
            ctx.lineTo(rocketCenterX - rocketW/2, rocketDrawY - rocketH);
            ctx.lineTo(rocketCenterX + rocketW/2, rocketDrawY - rocketH);
            ctx.closePath();
            ctx.fill();
        }

        // Smoke trail behind rocket
        for (let i = 0; i < 12; i++) {
            const trailY = rocketDrawY + (30 + i * 15) * scale;
            const trailX = rocketCenterX + Math.sin(t * 0.05 + i * 0.4) * (5 + i * 0.5);
            const trailSize = (8 - i * 0.5) * scale;
            if (trailSize > 0.5) {
                ctx.fillStyle = `rgba(200, 200, 200, ${0.4 - i * 0.03})`;
                ctx.beginPath();
                ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.restore();

        // Player character looking up at the sky
        ctx.drawImage(GFX.chars[GAME.selectedChar], canvas.width / 2 - 40, canvas.height - 55);

        // HUD - altitude indicator continues
        const altitude = Math.floor(1500 + pt * 2);
        ctx.fillStyle = '#00ff00';
        ctx.font = '6px "Press Start 2P"';
        ctx.textAlign = 'right';
        ctx.fillText(`ALT: ${altitude}km`, canvas.width - 10, 20);
    }
    // Phase 8: Simon joins
    else if (scene.phase === 8) {
        // Fading rocket trail (almost gone)
        const trailX = canvas.width - 40;
        for (let i = 0; i < 4; i++) {
            const trailY = 8 + i * 4;
            ctx.fillStyle = `rgba(255, 153, 0, ${0.2 - i * 0.04})`;
            ctx.fillRect(trailX - 1, trailY, 2, 3);
        }

        // Player character
        ctx.drawImage(GFX.chars[GAME.selectedChar], 90, canvas.height - 50);

        // Simon walking in
        if (scene.simonX !== undefined) {
            ctx.drawImage(GFX.simon, scene.simonX, scene.simonY);
        }

        // Victory text
        ctx.fillStyle = '#22c55e';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('VICTORY!', canvas.width / 2, 40);

        ctx.fillStyle = '#fbbf24';
        ctx.font = '8px "Press Start 2P"';
        const celebrateText = scene.simonX >= canvas.width / 2 - 50 ?
            'THE WAREHOUSE IS SAFE!' : 'Simon approaches...';
        ctx.fillText(celebrateText, canvas.width / 2, 58);

        // Confetti particles
        for (let i = 0; i < 25; i++) {
            const confettiX = (i * 47 + t * 2.5) % canvas.width;
            const confettiY = (i * 31 + t * 2) % canvas.height;
            const colors = ['#ff9900', '#22c55e', '#3b82f6', '#fbbf24', '#ec4899'];
            ctx.fillStyle = colors[i % colors.length];
            ctx.fillRect(confettiX, confettiY, 4, 4);
        }
    }

    ctx.textAlign = 'left';
    ctx.globalAlpha = 1;
}

// Draw throne room backdrop for escape sequence - AMAZON THEMED
function drawThroneRoomBackdrop(t) {
    // Dark Amazon-themed gradient (orange tinted dark)
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#0a0508');
    grad.addColorStop(0.4, '#150810');
    grad.addColorStop(0.7, '#1a0a12');
    grad.addColorStop(1, '#0d0608');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Subtle Amazon orange ambient glow
    const ambientGlow = Math.sin(t * 0.02) * 0.02 + 0.04;
    ctx.fillStyle = `rgba(255, 153, 0, ${ambientGlow})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Amazon-themed pillars on sides (orange accents)
    ctx.fillStyle = '#2a1a10';
    ctx.fillRect(0, 20, 24, canvas.height - 20);
    ctx.fillRect(canvas.width - 24, 20, 24, canvas.height - 20);

    // Amazon orange stripe on pillars
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(20, 20, 4, canvas.height - 20);
    ctx.fillRect(canvas.width - 24, 20, 4, canvas.height - 20);

    // Pillar details with Prime blue accents
    ctx.fillStyle = '#00a8e1';
    ctx.fillRect(5, 25, 10, 5);
    ctx.fillRect(canvas.width - 15, 25, 10, 5);

    // Golden Amazon trim on pillars
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(0, 18, 26, 3);
    ctx.fillRect(canvas.width - 26, 18, 26, 3);

    // PRIME banners on pillars
    ctx.fillStyle = '#00a8e1';
    ctx.font = '5px "Press Start 2P"';
    ctx.save();
    ctx.translate(12, 80);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('PRIME', 0, 0);
    ctx.restore();
    ctx.save();
    ctx.translate(canvas.width - 8, 80);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('PRIME', 0, 0);
    ctx.restore();

    // Amazon package stacks decorating the sides
    for (let i = 0; i < 3; i++) {
        // Left side packages
        const pkgY = canvas.height - 55 - i * 18;
        ctx.fillStyle = '#8b6914';
        ctx.fillRect(28, pkgY, 16, 14);
        ctx.fillStyle = '#a67c00';
        ctx.fillRect(30, pkgY + 2, 12, 10);
        // Amazon smile on package
        ctx.strokeStyle = '#232f3e';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(32, pkgY + 8);
        ctx.quadraticCurveTo(36, pkgY + 12, 40, pkgY + 7);
        ctx.stroke();

        // Right side packages
        ctx.fillStyle = '#8b6914';
        ctx.fillRect(canvas.width - 44, pkgY, 16, 14);
        ctx.fillStyle = '#a67c00';
        ctx.fillRect(canvas.width - 42, pkgY + 2, 12, 10);
        ctx.strokeStyle = '#232f3e';
        ctx.beginPath();
        ctx.moveTo(canvas.width - 40, pkgY + 8);
        ctx.quadraticCurveTo(canvas.width - 36, pkgY + 12, canvas.width - 32, pkgY + 7);
        ctx.stroke();
    }

    // Grand Amazon Throne in background
    const throneX = canvas.width / 2 - 25;
    const throneY = 55;

    // Throne back (cardboard box styled)
    ctx.fillStyle = '#5a4020';
    ctx.fillRect(throneX - 8, throneY - 25, 66, 55);
    ctx.fillStyle = '#8b6914';
    ctx.fillRect(throneX - 3, throneY - 20, 56, 45);

    // Amazon orange trim on throne
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(throneX - 3, throneY - 22, 56, 4);
    ctx.fillRect(throneX - 3, throneY + 22, 56, 4);

    // Throne seat (Prime blue cushion)
    ctx.fillStyle = '#00a8e1';
    ctx.fillRect(throneX + 5, throneY - 8, 40, 25);
    ctx.fillStyle = '#0090c5';
    ctx.fillRect(throneX + 8, throneY - 5, 34, 19);

    // Large Amazon smile logo on throne (pulsing)
    const logoPulse = Math.sin(t * 0.08) * 0.15 + 0.85;
    ctx.fillStyle = `rgba(255, 153, 0, ${logoPulse})`;
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('a', throneX + 25, throneY + 8);
    // Amazon smile arrow
    ctx.strokeStyle = `rgba(255, 153, 0, ${logoPulse})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(throneX + 10, throneY + 12);
    ctx.quadraticCurveTo(throneX + 25, throneY + 22, throneX + 42, throneY + 10);
    ctx.stroke();

    // "FULFILLMENT CENTER" text above throne
    ctx.fillStyle = '#ff9900';
    ctx.font = '5px "Press Start 2P"';
    ctx.fillText('FULFILLMENT', throneX + 25, throneY - 30);
    ctx.fillText('CENTER', throneX + 25, throneY - 22);

    // Royal carpet/floor (Amazon branded)
    ctx.fillStyle = '#1a0a08';
    ctx.fillRect(0, canvas.height - 38, canvas.width, 38);

    // Orange carpet runner with smile pattern
    ctx.fillStyle = '#cc7a00';
    ctx.fillRect(canvas.width / 2 - 35, canvas.height - 38, 70, 38);
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(canvas.width / 2 - 30, canvas.height - 38, 60, 4);
    // Smile pattern on carpet
    ctx.strokeStyle = '#232f3e';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2 - 20, canvas.height - 15);
    ctx.quadraticCurveTo(canvas.width / 2, canvas.height - 5, canvas.width / 2 + 20, canvas.height - 18);
    ctx.stroke();

    // Torch lights styled as warehouse lights (Amazon orange flames)
    for (let i = 0; i < 2; i++) {
        const torchX = i === 0 ? 50 : canvas.width - 60;
        const flicker = Math.sin(t * 0.15 + i) * 3;

        // Industrial torch holder
        ctx.fillStyle = '#333';
        ctx.fillRect(torchX, 45, 10, 25);

        // Amazon orange flame
        ctx.fillStyle = '#ff9900';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffcc00';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Floating Prime delivery drones in background
    for (let i = 0; i < 2; i++) {
        const droneX = 60 + i * (canvas.width - 120);
        const droneY = 100 + Math.sin(t * 0.05 + i * 2) * 8;
        ctx.fillStyle = '#444';
        ctx.fillRect(droneX - 6, droneY, 12, 6);
        ctx.fillStyle = '#00a8e1';
        ctx.fillRect(droneX - 3, droneY + 1, 6, 4);
        // Rotor blur
        ctx.fillStyle = `rgba(100, 100, 100, ${0.3 + Math.sin(t * 0.5 + i) * 0.2})`;
        ctx.fillRect(droneX - 10, droneY - 2, 8, 2);
        ctx.fillRect(droneX + 2, droneY - 2, 8, 2);
    }

    ctx.textAlign = 'left';
}

// Draw victory backdrop for Simon joining - STAY IN AMAZON THEMED THRONE ROOM
function drawVictoryBackdrop(t) {
    // Keep the Amazon throne room backdrop (post-battle calm with victory atmosphere)
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#0a0508');
    grad.addColorStop(0.4, '#150810');
    grad.addColorStop(0.7, '#1a0a12');
    grad.addColorStop(1, '#0d0608');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Victory glow effect (celebratory Amazon orange/gold tint)
    const victoryGlow = Math.sin(t * 0.03) * 0.05 + 0.12;
    ctx.fillStyle = `rgba(255, 153, 0, ${victoryGlow})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Amazon-themed pillars on sides (matching throne room)
    ctx.fillStyle = '#2a1a10';
    ctx.fillRect(0, 20, 24, canvas.height - 20);
    ctx.fillRect(canvas.width - 24, 20, 24, canvas.height - 20);

    // Amazon orange stripe on pillars
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(20, 20, 4, canvas.height - 20);
    ctx.fillRect(canvas.width - 24, 20, 4, canvas.height - 20);

    // Pillar details with Prime blue accents
    ctx.fillStyle = '#00a8e1';
    ctx.fillRect(5, 25, 10, 5);
    ctx.fillRect(canvas.width - 15, 25, 10, 5);

    // Golden Amazon trim on pillars
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(0, 18, 26, 3);
    ctx.fillRect(canvas.width - 26, 18, 26, 3);

    // Scattered packages on sides (some knocked over from battle)
    for (let i = 0; i < 3; i++) {
        const pkgY = canvas.height - 55 - i * 18;
        // Left side packages (some tilted)
        ctx.save();
        ctx.translate(36, pkgY + 7);
        ctx.rotate(Math.sin(i * 0.5) * 0.2);
        ctx.fillStyle = '#8b6914';
        ctx.fillRect(-8, -7, 16, 14);
        ctx.fillStyle = '#a67c00';
        ctx.fillRect(-6, -5, 12, 10);
        ctx.restore();

        // Right side packages
        ctx.save();
        ctx.translate(canvas.width - 36, pkgY + 7);
        ctx.rotate(-Math.sin(i * 0.7) * 0.15);
        ctx.fillStyle = '#8b6914';
        ctx.fillRect(-8, -7, 16, 14);
        ctx.fillStyle = '#a67c00';
        ctx.fillRect(-6, -5, 12, 10);
        ctx.restore();
    }

    // Empty Amazon Throne in background (Bezos escaped!)
    const throneX = canvas.width / 2 - 25;
    const throneY = 55;

    // Throne back (cardboard box styled - slightly damaged)
    ctx.fillStyle = '#5a4020';
    ctx.fillRect(throneX - 8, throneY - 25, 66, 55);
    ctx.fillStyle = '#8b6914';
    ctx.fillRect(throneX - 3, throneY - 20, 56, 45);

    // Amazon orange trim on throne
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(throneX - 3, throneY - 22, 56, 4);
    ctx.fillRect(throneX - 3, throneY + 22, 56, 4);

    // Throne seat (Prime blue cushion - empty)
    ctx.fillStyle = '#00a8e1';
    ctx.fillRect(throneX + 5, throneY - 8, 40, 25);
    ctx.fillStyle = '#0090c5';
    ctx.fillRect(throneX + 8, throneY - 5, 34, 19);

    // Dimmed Amazon smile logo on empty throne
    ctx.fillStyle = 'rgba(255, 153, 0, 0.4)';
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('a', throneX + 25, throneY + 8);
    // Dimmed smile arrow
    ctx.strokeStyle = 'rgba(255, 153, 0, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(throneX + 10, throneY + 12);
    ctx.quadraticCurveTo(throneX + 25, throneY + 22, throneX + 42, throneY + 10);
    ctx.stroke();

    // "VACANT - WORKER VICTORY!" sign on throne (blinking)
    if (Math.sin(t * 0.1) > 0) {
        ctx.fillStyle = '#22c55e';
        ctx.font = '5px "Press Start 2P"';
        ctx.fillText('WORKER VICTORY!', throneX + 25, throneY - 30);
    } else {
        ctx.fillStyle = '#ff9900';
        ctx.font = '5px "Press Start 2P"';
        ctx.fillText('POSITION VACANT', throneX + 25, throneY - 30);
    }

    // Royal carpet/floor (Amazon branded)
    ctx.fillStyle = '#1a0a08';
    ctx.fillRect(0, canvas.height - 38, canvas.width, 38);

    // Orange carpet runner
    ctx.fillStyle = '#cc7a00';
    ctx.fillRect(canvas.width / 2 - 35, canvas.height - 38, 70, 38);
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(canvas.width / 2 - 30, canvas.height - 38, 60, 4);

    // Victory confetti particles (Amazon themed colors)
    for (let i = 0; i < 20; i++) {
        const confettiX = (i * 37 + t * 0.6) % canvas.width;
        const confettiY = (i * 53 + t * 0.4) % (canvas.height - 45);
        const colors = ['#ff9900', '#ffd700', '#00a8e1', '#22c55e', '#fff'];
        ctx.fillStyle = colors[i % colors.length];
        ctx.globalAlpha = 0.7 + Math.sin(t * 0.1 + i) * 0.3;
        ctx.fillRect(confettiX, confettiY, 3 + (i % 2), 3 + (i % 3));
    }
    ctx.globalAlpha = 1;

    // Celebratory warehouse lights (Amazon orange flames - bigger for victory)
    for (let i = 0; i < 2; i++) {
        const torchX = i === 0 ? 50 : canvas.width - 60;
        const flicker = Math.sin(t * 0.2 + i) * 4;

        // Industrial torch holder
        ctx.fillStyle = '#333';
        ctx.fillRect(torchX, 45, 10, 25);

        // Celebratory bright Amazon orange flame
        ctx.fillStyle = '#ff9900';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Celebratory Prime drones doing victory loops
    for (let i = 0; i < 2; i++) {
        const droneAngle = t * 0.03 + i * Math.PI;
        const droneX = canvas.width / 2 + Math.cos(droneAngle) * 60 * (i === 0 ? 1 : -1);
        const droneY = 90 + Math.sin(droneAngle * 2) * 15;
        ctx.fillStyle = '#444';
        ctx.fillRect(droneX - 6, droneY, 12, 6);
        ctx.fillStyle = '#22c55e'; // Victory green instead of Prime blue
        ctx.fillRect(droneX - 3, droneY + 1, 6, 4);
        // Rotor blur
        ctx.fillStyle = `rgba(100, 100, 100, ${0.4 + Math.sin(t * 0.5 + i) * 0.2})`;
        ctx.fillRect(droneX - 10, droneY - 2, 8, 2);
        ctx.fillRect(droneX + 2, droneY - 2, 8, 2);
    }

    ctx.textAlign = 'left';
}

function drawCredits() {
    const t = GAME.stateTimer;
    const isMecha = GAME.creditsType === 'mecha';

    // Fade in effect
    const fadeIn = Math.min(1, t / 60);
    ctx.globalAlpha = fadeIn;

    if (isMecha) {
        // === FANCY MECHA CREDITS ===
        // Epic gradient background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a0020');
        grad.addColorStop(0.3, '#1a0040');
        grad.addColorStop(0.5, '#2a0060');
        grad.addColorStop(0.7, '#1a0040');
        grad.addColorStop(1, '#0a0020');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated star field
        for (let i = 0; i < 50; i++) {
            const x = (i * 47 + t * 0.5) % canvas.width;
            const y = (i * 73 + t * 0.2) % canvas.height;
            const twinkle = Math.sin(t * 0.08 + i * 0.7) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255,215,0,${twinkle * 0.8})`;
            ctx.fillRect(x, y, 2, 2);
        }

        // Golden border glow
        ctx.strokeStyle = `rgba(255,215,0,${0.5 + Math.sin(t * 0.05) * 0.3})`;
        ctx.lineWidth = 3;
        ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
        ctx.strokeStyle = `rgba(255,140,0,${0.3 + Math.sin(t * 0.07) * 0.2})`;
        ctx.lineWidth = 1;
        ctx.strokeRect(8, 8, canvas.width - 16, canvas.height - 16);

        // Big congratulations header with glow
        ctx.textAlign = 'center';
        ctx.font = 'bold 16px monospace';
        const glowIntensity = 0.5 + Math.sin(t * 0.1) * 0.3;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 15 * glowIntensity;
        ctx.fillStyle = '#ffd700';
        ctx.fillText('CONGRATULATIONS!', canvas.width / 2, 30);
        ctx.font = 'bold 12px monospace';
        ctx.fillStyle = '#ff6600';
        ctx.fillText('MECHA JEFF DEFEATED!', canvas.width / 2, 48);
        ctx.shadowBlur = 0;

        // Subtitle
        ctx.font = '9px monospace';
        ctx.fillStyle = '#aaa';
        ctx.fillText('The Warehouse is Finally Safe', canvas.width / 2, 64);

    } else {
        // === NORMAL CREDITS ===
        // Dark blue background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(6, 6, canvas.width - 12, canvas.height - 12);

        // Simple border
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 2;
        ctx.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);

        // Congratulations header
        ctx.textAlign = 'center';
        ctx.font = 'bold 14px monospace';
        ctx.fillStyle = '#eab308';
        ctx.fillText('CONGRATULATIONS!', canvas.width / 2, 28);
        ctx.font = '10px monospace';
        ctx.fillStyle = '#22d3ee';
        ctx.fillText('SURPRISE VISITOR DEFEATED!', canvas.width / 2, 44);

        // Subtitle
        ctx.font = '8px monospace';
        ctx.fillStyle = '#888';
        ctx.fillText('Safety Audit Complete', canvas.width / 2, 58);
    }

    // Credits list - 35 positions all by Erwin Esener
    const credits = [
        'Executive Producer',
        'Director',
        'Lead Developer',
        'Senior Programmer',
        'Game Designer',
        'Level Designer',
        'Art Director',
        'Lead Artist',
        'Character Designer',
        'Background Artist',
        'Pixel Art Specialist',
        'Animation Director',
        'UI/UX Designer',
        'Sound Director',
        'Music Composer',
        'Sound Effects Designer',
        'Audio Engineer',
        'Quality Assurance Lead',
        'Lead Tester',
        'Bug Hunter',
        'Narrative Designer',
        'Dialogue Writer',
        'Localization Manager',
        'Marketing Director',
        'Community Manager',
        'Technical Director',
        'Engine Developer',
        'Tool Programmer',
        'DevOps Engineer',
        'Project Manager',
        'Producer',
        'Catering',
        'Coffee Maker',
        'Moral Support',
        'Everything Else'
    ];

    // Scrolling credits
    const scrollSpeed = isMecha ? 0.3 : 0.25;
    const startY = canvas.height + 80 - t * scrollSpeed;
    const lineHeight = isMecha ? 20 : 18;

    ctx.font = isMecha ? '9px monospace' : '8px monospace';

    credits.forEach((role, i) => {
        const y = startY + i * lineHeight;
        if (y > 70 && y < canvas.height - 20) {
            if (isMecha) {
                // Fancy golden text with role
                ctx.fillStyle = '#ffd700';
                ctx.fillText(role + ':', canvas.width / 2, y);
                ctx.fillStyle = '#fff';
                ctx.fillText('Erwin Esener', canvas.width / 2, y + 10);
            } else {
                // Simple white text
                ctx.fillStyle = '#ccc';
                ctx.fillText(role + ': Erwin Esener', canvas.width / 2, y);
            }
        }
    });

    // Final thank you message (appears after credits scroll)
    const thankYouY = startY + credits.length * lineHeight + 40;
    if (thankYouY > 70 && thankYouY < canvas.height - 20) {
        ctx.font = isMecha ? 'bold 12px monospace' : 'bold 10px monospace';
        ctx.fillStyle = isMecha ? '#ffd700' : '#eab308';
        ctx.fillText('THANK YOU FOR PLAYING!', canvas.width / 2, thankYouY);
        if (isMecha) {
            ctx.font = '8px monospace';
            ctx.fillStyle = '#ff6600';
            ctx.fillText('You are the Ultimate Safety Champion!', canvas.width / 2, thankYouY + 16);
        }
    }

    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';

    // Skip prompt
    if (GAME.stateTimer > 600) {
        ctx.fillStyle = '#94a3b8';
        ctx.font = '8px monospace';
        ctx.fillText('[SPACE TO CONTINUE]', 8, canvas.height - 10);
    }
}

function draw() {
    if (GAME.state === 'LOSE_SPLASH') { drawSnesSplash(false); return; }
    if (GAME.state === 'WIN_SPLASH') { drawSnesSplash(true); return; }
    if (GAME.state === 'GAMEOVER_SPLASH') { drawGameOverSplash(); return; }

    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
    let dxShake = 0, dyShake = 0;
    if (GAME.shake > 0) { dxShake = (Math.random() - 0.5) * GAME.shake; dyShake = (Math.random() - 0.5) * GAME.shake; }
    ctx.save(); ctx.translate(dxShake, dyShake);

    if (GAME.state === 'PRESS_START') {
        // Black screen with pulsing "PRESS SPACEBAR" prompt
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Starfield background (subtle)
        for(let i = 0; i < 20; i++) {
            let seed = i * 123.456;
            let x = ((seed * 9301 + 49297) % 233280) / 910;
            let y = ((seed * 1234 + 8765) % 233280) / 1040;
            let brightness = Math.sin(GAME.stateTimer * 0.05 + i) * 0.2 + 0.3;
            ctx.fillStyle = `rgba(255,255,255,${brightness})`;
            ctx.fillRect(x, y, 1, 1);
        }

        // Pulsing text
        const pulse = 0.4 + Math.abs(Math.sin(GAME.stateTimer * 0.05)) * 0.6;
        ctx.textAlign = 'center';
        ctx.font = '12px monospace';
        ctx.fillStyle = `rgba(255, 215, 0, ${pulse})`;
        ctx.fillText('PRESS SPACEBAR', canvas.width/2, canvas.height/2);

        ctx.font = '8px monospace';
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillText('(Audio will be enabled)', canvas.width/2, canvas.height/2 + 20);

        ctx.textAlign = 'start';
        ctx.restore();
        return;
    }
    if (GAME.state === 'LOGO') {
        // Extended to 420 frames (7 seconds) for title-eeproductions.mp3
        let alpha = 1.0;
        if(GAME.stateTimer < 30) alpha = GAME.stateTimer / 30;
        if(GAME.stateTimer > 380) alpha = (420 - GAME.stateTimer) / 40;

        // SNES-style starfield background effect
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, 256, 224);
        for(let i = 0; i < 30; i++) {
            let seed = i * 123.456;
            let x = ((seed * 9301 + 49297) % 233280) / 910;
            let y = ((seed * 1234 + 8765) % 233280) / 1040;
            let speed = (i % 3) + 1;
            let starY = (y + GAME.stateTimer * speed * 0.3) % 224;
            let brightness = Math.sin(GAME.stateTimer * 0.1 + i) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255,255,255,${brightness * alpha})`;
            ctx.fillRect(x, starY, 1, 1);
        }

        // Color cycling effect for background glow
        let hue = (GAME.stateTimer * 2) % 360;
        let gradient = ctx.createRadialGradient(128, 112, 0, 128, 112, 150);
        gradient.addColorStop(0, `hsla(${hue}, 70%, 30%, ${alpha * 0.3})`);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 224);

        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        let offset = Math.max(0, 100 - GAME.stateTimer * 2);

        // Draw logo with chromatic aberration effect
        if(GAME.stateTimer > 60 && GAME.stateTimer < 90) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = alpha * 0.3;
            ctx.drawImage(GFX.logo, 28 - offset - 2, 90);
            ctx.globalAlpha = alpha * 0.3;
            ctx.drawImage(GFX.logo, 28 - offset + 2, 90);
            ctx.globalCompositeOperation = 'source-over';
        }

        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        ctx.drawImage(GFX.logo, 28 - offset, 90);

        // Enhanced text with color cycling
        if (GAME.stateTimer > 80) {
            let textHue = (GAME.stateTimer * 3) % 60 + 180; // Cycle through blue-cyan range
            ctx.fillStyle = '#fff';
            ctx.font = '10px monospace';
            ctx.fillText("ERWIN ESENER", 80, 105);

            // Color cycling on PRODUCTIONS text
            let prodHue = (GAME.stateTimer * 5) % 60 + 30; // Cycle through yellow-orange range
            ctx.fillStyle = `hsl(${prodHue}, 90%, 50%)`;
            ctx.font = '14px monospace';
            ctx.fillText("PRODUCTIONS", 80, 125);

            // Add sparkle effects
            for(let i = 0; i < 5; i++) {
                let sparkleTime = (GAME.stateTimer - 80 - i * 15) % 120;
                if(sparkleTime < 20) {
                    let sparkleAlpha = sparkleTime < 10 ? sparkleTime / 10 : (20 - sparkleTime) / 10;
                    ctx.globalAlpha = sparkleAlpha * alpha;
                    ctx.fillStyle = '#fff';
                    let sx = 75 + i * 30 + Math.sin(GAME.stateTimer * 0.1 + i) * 3;
                    let sy = 100 + Math.cos(GAME.stateTimer * 0.15 + i) * 10;
                    ctx.fillRect(sx, sy, 2, 2);
                    ctx.fillRect(sx - 3, sy, 1, 1);
                    ctx.fillRect(sx + 3, sy, 1, 1);
                    ctx.fillRect(sx, sy - 3, 1, 1);
                    ctx.fillRect(sx, sy + 3, 1, 1);
                }
            }
        }

        // White flash effect
        if(GAME.stateTimer > 60 && GAME.stateTimer < 65) {
            ctx.globalAlpha = 1.0;
            ctx.fillStyle='white';
            ctx.fillRect(0,0,256,224);
        }

        // SNES-style scanlines
        ctx.globalAlpha = 0.15;
        for(let y = 0; y < 224; y += 2) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, y, 256, 1);
        }

        ctx.restore(); return;
    }
    if (GAME.state === 'INTRO') { 
        ctx.fillStyle='#eab308'; ctx.fillText("THE WAREHOUSE...", 20, 60); ctx.fillStyle='#fff';
        ctx.fillText("Ops Managers obsess over rates.", 20, 90); ctx.fillText("They throw Crazy Requests.", 20, 110);
        ctx.fillText("You must protect Safety.", 20, 130); ctx.fillText("Stop runners. Fix hazards.", 20, 150);
        ctx.fillStyle='#888'; ctx.fillText("[SPACE TO SKIP]", 80, 200); ctx.restore(); return; 
    }
    if (GAME.state === 'STORY') {
        ctx.fillStyle='#eab308'; ctx.font='10px monospace'; ctx.fillText("MISSION BRIEFING", 20, 40); ctx.fillStyle='#fff';
        ctx.fillText("Simon Unglaube asks you to:", 20, 70); ctx.fillText("- Do the safety audit", 20, 90);
        ctx.fillText("- Dodge crazy Ops requests", 20, 110); ctx.fillText("- Push back with rules", 20, 130);
        ctx.fillText("- Deal with 'visitors'", 20, 150); ctx.fillStyle='#888'; ctx.fillText("[PRESS SPACE]", 80, 200); ctx.restore(); return;
    }
    if (GAME.state === 'TITLE') {
        const t = GAME.stateTimer;

        // Premium animated background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.3, '#0a1525');
        grad.addColorStop(0.6, '#0f172a');
        grad.addColorStop(1, '#0a0a18');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated stars
        for (let i = 0; i < 30; i++) {
            const x = (i * 37 + t * 0.3) % canvas.width;
            const y = (i * 61) % canvas.height;
            const twinkle = Math.sin(t * 0.1 + i) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255,255,255,${twinkle * 0.6})`;
            ctx.fillRect(x, y, 1, 1);
        }

        // Animated grid lines with perspective
        const offset = (t * 1.2) % 32;
        ctx.strokeStyle = 'rgba(34, 211, 238, 0.15)';
        ctx.lineWidth = 1;
        for (let i = -1; i < 16; i++) {
            const y = i * 16 + offset;
            const alpha = 0.1 + (y / canvas.height) * 0.2;
            ctx.strokeStyle = `rgba(34, 211, 238, ${alpha})`;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        for (let i = 0; i < 17; i++) {
            ctx.strokeStyle = 'rgba(34, 211, 238, 0.1)';
            ctx.beginPath();
            ctx.moveTo(i * 16, 0);
            ctx.lineTo(i * 16, canvas.height);
            ctx.stroke();
        }

        // Warehouse silhouette at bottom
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(0, 180, canvas.width, 44);
        ctx.fillStyle = '#1a1a2e';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect(i * 32 + 4, 185, 24, 35);
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(i * 32 + 8, 190, 16, 12);
            ctx.fillStyle = '#1a1a2e';
        }

        ctx.textAlign = 'center';

        // Title glow effect
        const glowIntensity = Math.sin(t * 0.08) * 0.3 + 0.7;
        ctx.shadowColor = '#ff9900';
        ctx.shadowBlur = 15 * glowIntensity;

        // Title with multiple layers
        ctx.font = '16px "Press Start 2P"';
        ctx.fillStyle = '#7c2d12';
        ctx.fillText('AMZL WHS QUEST', canvas.width / 2 + 2, 44);
        ctx.fillStyle = '#ea580c';
        ctx.fillText('AMZL WHS QUEST', canvas.width / 2 + 1, 43);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText('AMZL WHS QUEST', canvas.width / 2, 42);
        ctx.shadowBlur = 0;

        // Subtitle with glow
        ctx.shadowColor = '#22d3ee';
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#22d3ee';
        ctx.font = '7px "Press Start 2P"';
        ctx.fillText('SAFETY COORDINATOR EDITION', canvas.width / 2, 60);
        ctx.shadowBlur = 0;

        // Animated character showcase
        const charIdx = Math.floor(t / 90) % 5;
        const chars = ['Carrie', 'Nevena', 'Joao', 'Roman', 'Erwin'];
        const charName = chars[charIdx];
        const charBounce = Math.sin(t * 0.15) * 3;
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(GFX.chars[charName], canvas.width / 2 - 16, 85 + charBounce, 32, 32);
        ctx.restore();

        // Animated prompt with pulse
        ctx.textAlign = 'center';
        const blink = Math.sin(t * 0.12) > 0;
        const pulseScale = 1 + Math.sin(t * 0.1) * 0.05;
        if (blink) {
            ctx.fillStyle = '#fff';
            ctx.font = '9px "Press Start 2P"';
            ctx.fillText('PRESS SPACE', canvas.width / 2, 160);
        }

        // Decorative lines
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(40, 170, 176, 2);
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(60, 175, 136, 1);

        // Credits with style
        ctx.fillStyle = '#64748b';
        ctx.font = '7px monospace';
        ctx.fillText('CREATED BY ERWIN ESENER', canvas.width / 2, 190);
        ctx.fillStyle = '#475569';
        ctx.font = '6px monospace';
        ctx.fillText('© 2024 ERWIN ESENER PRODUCTIONS', canvas.width / 2, 220);

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'HOWTO') {
        const t = GAME.stateTimer;
        // Background gradient
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a1525');
        grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Panel background
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);

        // Title with glow
        ctx.textAlign = 'center';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#fbbf24';
        ctx.font = '12px "Press Start 2P"';
        ctx.fillText('HOW TO PLAY', canvas.width / 2, 30);
        ctx.shadowBlur = 0;

        ctx.textAlign = 'left';
        ctx.font = '8px "Press Start 2P"';

        // Controls section
        ctx.fillStyle = '#22d3ee';
        ctx.fillText('WASD / ARROWS', 25, 52);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '7px monospace';
        ctx.fillText('Navigate the warehouse floor', 25, 64);

        ctx.fillStyle = '#22d3ee';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('SPACE', 25, 82);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '7px monospace';
        ctx.fillText('Interact with hazards / Attack', 25, 94);

        // Goal section
        ctx.fillStyle = '#ef4444';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('YOUR MISSION:', 25, 115);
        ctx.fillStyle = '#fbbf24';
        ctx.font = '7px monospace';
        ctx.fillText('1. Find and fix 5 safety hazards', 25, 128);
        ctx.fillText('2. Dodge crazy Ops requests!', 25, 140);
        ctx.fillText('3. Defeat the surprise visitor', 25, 152);

        // Tips section
        ctx.fillStyle = '#22d3ee';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('TIPS:', 25, 175);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '7px monospace';
        ctx.fillText('- Collect packages for power-ups', 25, 188);
        ctx.fillText('- Fire books to push back enemies', 25, 200);

        // Animated prompt
        ctx.textAlign = 'center';
        const blink = Math.sin(t * 0.12) > 0;
        if (blink) {
            ctx.fillStyle = '#fff';
            ctx.font = '7px "Press Start 2P"';
            ctx.fillText('[SPACE TO CONTINUE]', canvas.width / 2, 218);
        }
        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'SELECT') {
        const t = GAME.stateTimer;
        const frameX = 14, frameY = 22, frameW = 228, frameH = 180;

        // Background gradient
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.5, '#0a1525');
        grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated background particles
        for (let i = 0; i < 20; i++) {
            const x = (i * 31 + t * 0.2) % canvas.width;
            const y = (i * 47 + t * 0.1) % canvas.height;
            ctx.fillStyle = `rgba(251, 191, 36, ${0.1 + Math.sin(t * 0.05 + i) * 0.1})`;
            ctx.fillRect(x, y, 2, 2);
        }

        // Main frame with glow
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(frameX, frameY, frameW, frameH);
        ctx.shadowBlur = 0;

        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.strokeRect(frameX, frameY, frameW, frameH);
        ctx.strokeStyle = '#92400e';
        ctx.strokeRect(frameX + 2, frameY + 2, frameW - 4, frameH - 4);

        // Inner panel
        ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
        ctx.fillRect(frameX + 6, frameY + 35, frameW - 12, frameH - 50);

        ctx.textAlign = 'center';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#fbbf24';
        ctx.font = '11px "Press Start 2P"';
        ctx.fillText("SELECT COORDINATOR", frameX + frameW / 2, frameY + 18);
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#64748b';
        ctx.font = '7px monospace';
        ctx.fillText("< ARROWS TO BROWSE > | SPACE TO START", frameX + frameW / 2, frameY + 30);

        let name = GAME.charList[GAME.charIndex]; let data = CHAR_DATA[name];
        const portraitX = frameX + 18, portraitY = frameY + 46;
        ctx.fillStyle = '#000'; ctx.fillRect(portraitX - 2, portraitY - 2, 56, 56);
        ctx.strokeStyle = '#333'; ctx.strokeRect(portraitX - 4, portraitY - 4, 60, 60);
        ctx.save(); ctx.imageSmoothingEnabled = false; ctx.drawImage(GFX.chars[name], portraitX, portraitY, 52, 52); ctx.restore();

        ctx.fillStyle='#eab308'; ctx.font='12px monospace';
        ctx.fillText("< " + name + " >", frameX + frameW / 2, frameY + 54);

        ctx.textAlign = 'left';
        ctx.font='8px monospace'; ctx.fillStyle='#00ffff';
        const textStartX = portraitX + 70; const textStartY = frameY + 70;
        ctx.fillText("ROLE: " + data.role, textStartX, textStartY);

        const wrapText = (text, maxChars = 30) => {
            const words = text.split(' '); const lines = []; let line = '';
            words.forEach(word => { const candidate = line.length ? line + ' ' + word : word; if (candidate.length > maxChars) { lines.push(line); line = word; } else { line = candidate; } });
            if (line) lines.push(line); return lines;
        };
        const backstoryLines = wrapText(data.backstory, 30).slice(0, 3);
        ctx.fillStyle='#fff'; backstoryLines.forEach((l, idx) => ctx.fillText(l, textStartX, textStartY + 14 + idx * 12));

        ctx.fillStyle='#ff00ff';
        ctx.fillText("ATTACK: " + data.attack, frameX + 18, frameY + frameH - 45);

        // Display unique ability
        ctx.fillStyle='#22d3ee';
        ctx.fillText("ABILITY: " + data.ability, frameX + 18, frameY + frameH - 32);
        ctx.fillStyle='#94a3b8'; ctx.font='7px monospace';
        ctx.fillText(data.abilityDesc, frameX + 18, frameY + frameH - 20);

        ctx.textAlign = 'center';
        ctx.fillStyle='#888'; ctx.font='10px monospace';
        ctx.fillText("PRESS SPACE", frameX + frameW / 2, frameY + frameH - 12);
        ctx.restore(); return;
    }
    if (GAME.state === 'YARD_INTRO') {
        // Dark gradient background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a0a14');
        grad.addColorStop(0.5, '#1a1a2e');
        grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Warning stripes
        ctx.fillStyle = '#facc15';
        for (let i = 0; i < canvas.width; i += 24) {
            ctx.fillRect(i, 0, 12, 6);
            ctx.fillRect(i + 12, canvas.height - 6, 12, 6);
        }

        // Title
        ctx.fillStyle = '#ff9900';
        ctx.font = '16px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('THE YARD', canvas.width / 2, 50);

        // Subtitle
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px "Press Start 2P"';
        ctx.fillText('DANGER ZONE', canvas.width / 2, 70);

        // Instructions
        ctx.fillStyle = '#f0f0ff';
        ctx.font = '9px monospace';
        ctx.fillText('You sneak through the fire exit', canvas.width / 2, 100);
        ctx.fillText('into the Amazon logistics yard.', canvas.width / 2, 115);

        ctx.fillStyle = '#facc15';
        ctx.fillText('Dodge DSP vans and semis!', canvas.width / 2, 140);
        ctx.fillText('Reach the top without getting hit!', canvas.width / 2, 155);

        ctx.fillStyle = '#ef4444';
        ctx.font = '8px monospace';
        ctx.fillText('WARNING: Vehicles WILL reset you!', canvas.width / 2, 175);

        // Prompt
        ctx.fillStyle = '#00ffff';
        ctx.font = '9px "Press Start 2P"';
        const blink = Math.sin(GAME.stateTimer * 0.1) > 0;
        if (blink) ctx.fillText('[PRESS SPACE TO RUN]', canvas.width / 2, 205);

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'YARD_LEVEL') { drawYardLevel(); ctx.restore(); return; }
    if (GAME.state === 'VISITOR_SPLASH') {
        const t = GAME.stateTimer;
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a0f2e');
        gradient.addColorStop(1, '#2a1b44');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let y = -20; y < canvas.height + 20; y += 12) {
            const offset = (t * 2) % 24;
            ctx.fillStyle = y % 24 === 0 ? 'rgba(255,215,0,0.08)' : 'rgba(255,255,255,0.05)';
            ctx.fillRect(((t * 3) + y * 2) % canvas.width, y + offset, canvas.width, 6);
        }

        ctx.save();
        ctx.translate(canvas.width / 2, 90);
        ctx.textAlign = 'center';
        const wobble = 1 + Math.sin(t / 10) * 0.05;
        ctx.scale(wobble, wobble);
        ctx.fillStyle = '#000';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.fillText("SURPRISE VISITOR!", 0, 0);
        ctx.fillStyle = '#eab308';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 8;
        ctx.fillText("SURPRISE VISITOR!", -2, -2);
        ctx.restore();

        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd166';
        ctx.font = '8px monospace';
        ctx.fillText("An unannounced Visitor is stepping onto the floor...", canvas.width / 2, 148);
        ctx.fillStyle = '#fff';
        ctx.fillText("Simon braces: tighten PPE, breathe, and stand tall.", canvas.width / 2, 166);

        ctx.fillStyle = '#ff00ff';
        ctx.font = '10px monospace';
        ctx.fillText("[PRESS SPACE TO CONTINUE]", canvas.width / 2, 204);
        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'MECHA_BOSS_INTRO' && GAME.mecha) {
        ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#eab308'; ctx.font = '16px monospace'; ctx.fillText('MECHA JEFF RISES', 30, 40);
        ctx.drawImage(GFX.mechaJeff, 92, 60, 72, 72);
        ctx.fillStyle = '#fff'; ctx.font = '9px monospace';
        ctx.fillText('Prime Drone Swarm', 20, 150);
        ctx.fillText('2-Day Shipping Storm', 20, 166);
        ctx.fillText('Orbital Beam Audit', 20, 182);
        ctx.fillStyle = '#9ca3af'; ctx.fillText('[PRESS SPACE TO DEFY]', 60, 206);
        ctx.restore(); return;
    }
    if (GAME.state === 'MECHA_BOSS') { drawMechaBattle(); ctx.restore(); return; }
    if (GAME.state === 'THRONE_CONFRONTATION') { drawThroneConfrontation(); ctx.restore(); return; }
    // Draw throne room background during dialog if we came from throne confrontation
    if (GAME.state === 'DIALOG' && GAME.dialogBackgroundState === 'THRONE_CONFRONTATION') {
        drawThroneConfrontation();
        ctx.restore();
        return;
    }
    // Draw escape scene background during dialog if we came from bezos escape
    if (GAME.state === 'DIALOG' && GAME.dialogBackgroundState === 'BEZOS_ESCAPE') {
        drawBezosEscape();
        ctx.restore();
        return;
    }
    if (GAME.state === 'MECHA_TRANSFORM') { drawMechaTransform(); ctx.restore(); return; }
    if (GAME.state === 'SIMON_MECHA_TRANSFORM') { drawSimonMechaTransform(); ctx.restore(); return; }
    if (GAME.state === 'MECHA_SIMON_SPLASH') { drawMechaSimonSplash(); ctx.restore(); return; }
    if (GAME.state === 'BEZOS_ESCAPE') { updateBezosEscape(); drawBezosEscape(); ctx.restore(); return; }
    if (GAME.state === 'CREDITS') { drawCredits(); ctx.restore(); return; }
    if (GAME.state === 'BOSS_INTRO' && GAME.boss) {
        ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#eab308'; ctx.font = '16px monospace'; ctx.fillText("WARNING", 80, 50);
        ctx.fillStyle = '#ff0000'; ctx.font = '12px monospace'; ctx.fillText(GAME.boss.name.toUpperCase(), 20, 90);
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace'; ctx.fillText(GAME.boss.title, 20, 110);
        ctx.fillStyle = '#888'; ctx.fillText(GAME.boss.desc, 20, 130);
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        const portraitFrameX = 170, portraitFrameY = 70, portraitSize = 88;
        ctx.fillStyle = '#000';
        ctx.fillRect(portraitFrameX - 4, portraitFrameY - 4, portraitSize + 8, portraitSize + 8);
        ctx.strokeStyle = '#444';
        ctx.strokeRect(portraitFrameX - 6, portraitFrameY - 6, portraitSize + 12, portraitSize + 12);
        const bossSprite = (GAME.boss.sprite && GFX[GAME.boss.sprite]) ? GFX[GAME.boss.sprite] : GFX.boss_manager;
        ctx.drawImage(bossSprite, portraitFrameX, portraitFrameY, portraitSize, portraitSize);
        ctx.restore();
        ctx.fillStyle = '#eab308'; ctx.fillText("ATTACK: " + GAME.boss.attackName, 20, 160);
        ctx.fillStyle = '#fff'; ctx.fillText("[PRESS SPACE TO FIGHT]", 50, 200); ctx.restore(); return;
    }

    // Bezos intro screen
    if (GAME.state === 'BEZOS_INTRO' && GAME.boss) {
        ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Dramatic lines
        for (let i = 0; i < 10; i++) {
            ctx.strokeStyle = `rgba(255, 153, 0, ${0.3 - i * 0.03})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(128, 112);
            const angle = (GAME.stateTimer * 0.05 + i * 0.3) % (Math.PI * 2);
            ctx.lineTo(128 + Math.cos(angle) * 200, 112 + Math.sin(angle) * 200);
            ctx.stroke();
        }

        ctx.fillStyle = '#ff9900'; ctx.font = '16px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText("FINAL BOSS", 128, 40);
        ctx.fillStyle = '#ff0000'; ctx.font = '14px "Press Start 2P"';
        ctx.fillText("MECHA JEFF BEZOS", 128, 70);
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace';
        ctx.fillText("AUTOMATION PROTOCOL ACTIVATED", 128, 90);

        // Boss sprite
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(GFX.mechaBezos, 104, 100, 48, 48);
        ctx.restore();

        ctx.fillStyle = '#eab308'; ctx.font = '8px monospace';
        ctx.fillText("PRIME MISSILES READY", 128, 170);
        ctx.fillStyle = '#fff';
        ctx.fillText("[PRESS SPACE]", 128, 200);
        ctx.textAlign = 'left';
        ctx.restore();
        return;
    }

    // Bezos boss fight rendering
    if (GAME.state === 'BEZOS_BOSS') {
        // Space background - changes color when enraged
        const bgColor = GAME.boss && GAME.boss.enraged ? '#140a0a' : '#0a0a14';
        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 256, 224);

        // Stars
        for (let i = 0; i < 50; i++) {
            const x = (i * 37) % 256;
            const y = (i * 61) % 224;
            ctx.fillStyle = GAME.boss && GAME.boss.enraged ? '#ff6666' : '#fff';
            ctx.fillRect(x, y, 1, 1);
        }

        // === FALLING PACKAGES ===
        if (GAME.boss && GAME.boss.fallingPackages) {
            GAME.boss.fallingPackages.forEach(pkg => {
                // Package shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(pkg.x + 2, 210, 10, 4);
                // Package
                ctx.fillStyle = '#a16207';
                ctx.fillRect(pkg.x, pkg.y, pkg.w, pkg.h);
                ctx.fillStyle = '#78350f';
                ctx.fillRect(pkg.x + 2, pkg.y + 2, pkg.w - 4, pkg.h - 4);
                // Amazon smile
                ctx.fillStyle = '#ff9900';
                ctx.fillRect(pkg.x + 3, pkg.y + 6, 6, 2);
                ctx.fillRect(pkg.x + 8, pkg.y + 6, 2, 4);
            });
        }

        // === SHOCKWAVE EFFECT ===
        if (GAME.boss && GAME.boss.shockwaveTimer > 0) {
            const progress = 1 - (GAME.boss.shockwaveTimer / 30);
            const radius = progress * 80;
            const alpha = 1 - progress;
            ctx.strokeStyle = `rgba(255, 153, 0, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(GAME.boss.x + 24, GAME.boss.y + 24, radius, 0, Math.PI * 2);
            ctx.stroke();
            GAME.boss.shockwaveTimer--;
        }

        // Boss
        if (GAME.boss) {
            // Enrage glow effect
            if (GAME.boss.enraged) {
                const glowPulse = Math.sin(GAME.ticks * 0.15) * 10 + 30;
                const glowGrad = ctx.createRadialGradient(
                    GAME.boss.x + 24, GAME.boss.y + 24, 10,
                    GAME.boss.x + 24, GAME.boss.y + 24, glowPulse
                );
                glowGrad.addColorStop(0, 'rgba(255, 0, 0, 0.4)');
                glowGrad.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
                glowGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(GAME.boss.x + 24, GAME.boss.y + 24, glowPulse, 0, Math.PI * 2);
                ctx.fill();
            }

            // Dash trail effect
            if (GAME.boss.dashTarget) {
                ctx.fillStyle = 'rgba(255, 153, 0, 0.3)';
                for (let i = 0; i < 3; i++) {
                    const trailX = GAME.boss.x - (GAME.boss.dashTarget.x - GAME.boss.x) * 0.1 * i;
                    const trailY = GAME.boss.y - (GAME.boss.dashTarget.y - GAME.boss.y) * 0.1 * i;
                    ctx.globalAlpha = 0.3 - i * 0.1;
                    ctx.drawImage(GFX.mechaBezos, trailX, trailY);
                }
                ctx.globalAlpha = 1;
            }

            ctx.drawImage(GFX.mechaBezos, GAME.boss.x, GAME.boss.y);

            // Boss attack indicator
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'center';
            if (GAME.boss.attackPhase === 0) {
                ctx.fillStyle = '#ff9900';
                ctx.fillText('MISSILES', GAME.boss.x + 24, GAME.boss.y - 8);
            } else if (GAME.boss.attackPhase === 1) {
                ctx.fillStyle = '#00ffff';
                ctx.fillText('LASER SWEEP', GAME.boss.x + 24, GAME.boss.y - 8);
            } else if (GAME.boss.attackPhase === 2) {
                ctx.fillStyle = '#ff00ff';
                ctx.fillText('DRONE SWARM', GAME.boss.x + 24, GAME.boss.y - 8);
            }
        }

        // Drones
        GAME.entities.forEach(e => {
            if (e.type === 'drone') {
                ctx.drawImage(GFX.drone, e.x, e.y);
            }
        });

        // Player
        const p = GAME.player;
        if (p.iframe % 4 < 2) {
            ctx.drawImage(GFX.chars[GAME.selectedChar], p.x, p.y);
        }

        // Projectiles
        GAME.projectiles.forEach(proj => {
            if (proj.type === 'bezos_missile') {
                ctx.drawImage(GFX.bezosProj, proj.x, proj.y);
            } else if (proj.type === 'bezos_laser') {
                // Render laser beam
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillRect(proj.x - 2, proj.y - 2, 6, 6);
                ctx.shadowBlur = 0;
            } else if (proj.type === 'attack') {
                const sprite = (GFX.attacks && GFX.attacks[proj.owner]) ? GFX.attacks[proj.owner] : GFX.book;
                ctx.drawImage(sprite, proj.x, proj.y);
            }
        });

        ctx.restore();
        return;
    }

    // Bezos victory screen
    if (GAME.state === 'BEZOS_WIN') {
        // Victory gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a4d1a');
        gradient.addColorStop(1, '#0a1a0a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Fireworks effect
        for (let i = 0; i < 20; i++) {
            const x = (i * 31 + GAME.stateTimer * 2) % 256;
            const y = (i * 47 + GAME.stateTimer * 3) % 224;
            const colors = ['#ff9900', '#ffd700', '#ff6b6b', '#4ecdc4'];
            ctx.fillStyle = colors[i % colors.length];
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.textAlign = 'center';
        ctx.font = '16px "Press Start 2P"';
        ctx.fillStyle = '#ffd700';
        ctx.fillText("CONGRATULATIONS!", 128, 40);

        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = '#fff';
        ctx.fillText("YOU DEFEATED", 128, 70);
        ctx.fillText("MECHA JEFF BEZOS!", 128, 90);

        // Digitized face (using character sprite as placeholder)
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        const faceSize = 64;
        ctx.fillStyle = '#000';
        ctx.fillRect(96, 100, faceSize, faceSize);
        ctx.drawImage(GFX.chars[GAME.selectedChar], 96, 100, faceSize, faceSize);
        ctx.restore();

        ctx.font = '10px "Press Start 2P"';
        ctx.fillStyle = '#00ff00';
        ctx.fillText("TRUE HERO OF WHS!", 128, 175);

        // Credits
        ctx.font = '8px monospace';
        ctx.fillStyle = '#888';
        const creditsY = 190;
        ctx.fillText("CREDITS:", 128, creditsY);
        const credits = ["Director: Erwin Esener", "Producer: Erwin Esener", "Lead Dev: Erwin Esener", "Art: Erwin Esener", "Music: Erwin Esener"];
        credits.forEach((credit, i) => {
            ctx.fillText(credit, 128, creditsY + 12 + i * 10);
        });

        ctx.textAlign = 'left';
        ctx.restore();
        return;
    }

    const cx = Math.floor(GAME.camera.x); const cy = Math.floor(GAME.camera.y);
    let sx = Math.floor(cx/TILE_SIZE); let ex = sx + 17; let sy = Math.floor(cy/TILE_SIZE); let ey = sy + 15;
    for(let y=sy; y<=ey; y++) {
        for(let x=sx; x<=ex; x++) {
            if(x>=0 && x<MAP_W && y>=0 && y<MAP_H) {
                let t = GAME.map[y][x]; let dx = x*TILE_SIZE - cx; let dy = y*TILE_SIZE - cy;
                if (t===0) ctx.drawImage(GFX.floor, dx, dy); if (t===1) ctx.drawImage(GFX.wall, dx, dy);
                if (t===2) { ctx.drawImage(GFX.floor, dx, dy); ctx.drawImage(GFX.shelf, dx, dy); }
                if (t===3) {
                    ctx.drawImage(GFX.wall, dx, dy);
                    ctx.drawImage(GFX.door, dx, dy);
                    // Glow effect when door is accessible (4+ hazards cleared)
                    if (GAME.issuesFixed >= 4 && GAME.fireExitDoor) {
                        const pulse = Math.sin(GAME.ticks * 0.1) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(255, 215, 0, ${pulse * 0.4})`;
                        ctx.fillRect(dx - 2, dy - 2, 20, 20);
                    }
                }
            }
        }
    }

    GAME.clutter.forEach(c => { let img = GFX.clutter[c.type]; if(img) ctx.drawImage(img, c.x-cx, c.y-cy); });
    GAME.activeIssues.forEach(h => { if(!h.fixed) { let img = GFX.hazards[h.data.type] || GFX.hazards.box; ctx.drawImage(img, h.x-cx, h.y-cy); } });

    // === WAREHOUSE ATMOSPHERE RENDERING ===
    if (GAME.state === 'PLAY' || GAME.state === 'BOSS') {
        // Draw conveyor belts with animated texture
        const conveyorOffset = (GAME.ticks * 0.5) % 8;
        GAME.conveyorBelts.forEach(belt => {
            const dx = belt.x - cx;
            const dy = belt.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.conveyorBelt, dx, dy);
                // Animated belt line
                ctx.fillStyle = '#555';
                const lineOffset = belt.dir > 0 ? conveyorOffset : -conveyorOffset;
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(dx + ((lineOffset + i * 8) % 16), dy + 7, 3, 2);
                }
            }
        });

        // Draw packages on conveyors
        GAME.packages.forEach(pkg => {
            const dx = pkg.x - cx;
            const dy = pkg.y - cy;
            if (dx > -20 && dx < 272 && dy > -20 && dy < 240) {
                const sprite = pkg.type === 'small' ? GFX.packageSmall : GFX.packageLarge;
                ctx.drawImage(sprite, dx, dy);
            }
        });

        // Draw pallet stacks (static)
        GAME.palletStacks.forEach(pallet => {
            const dx = pallet.x - cx;
            const dy = pallet.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.palletStack, dx, dy);
            }
        });

        // Draw sorting stations
        GAME.sortStations.forEach(station => {
            const dx = station.x - cx;
            const dy = station.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.sortStation, dx, dy);
            }
        });

        // Draw warehouse zone signs
        GAME.warehouseSigns.forEach(sign => {
            const dx = sign.x - cx;
            const dy = sign.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                if (sign.type === 'pick') ctx.drawImage(GFX.signPick, dx, dy);
                else if (sign.type === 'pack') ctx.drawImage(GFX.signPack, dx, dy);
                else if (sign.type === 'ship') ctx.drawImage(GFX.signShip, dx, dy);
            }
        });

        // Draw cart workers
        GAME.cartWorkers.forEach(worker => {
            const dx = worker.x - cx;
            const dy = worker.y - cy;
            if (dx > -24 && dx < 272 && dy > -20 && dy < 240) {
                ctx.save();
                if (worker.dir < 0) {
                    // Flip horizontally when going left
                    ctx.translate(dx + 10, dy);
                    ctx.scale(-1, 1);
                    ctx.drawImage(GFX.cartWorker, -10, 0);
                } else {
                    ctx.drawImage(GFX.cartWorker, dx, dy);
                }
                ctx.restore();
            }
        });
    }

    let renderList = [GAME.player, ...GAME.entities, ...GAME.projectiles];
    if (GAME.state === 'BOSS' && GAME.boss) renderList.push(GAME.boss);
    renderList.sort((a,b) => a.y - b.y);

    // Performance: Cache screen bounds for visibility culling
    const screenPadding = 32; // Extra padding for large sprites
    const screenLeft = -screenPadding;
    const screenRight = canvas.width + screenPadding;
    const screenTop = -screenPadding;
    const screenBottom = canvas.height + screenPadding;

    renderList.forEach(e => {
        let dx = Math.floor(e.x - cx); let dy = Math.floor(e.y - cy);
        // Performance: Skip offscreen entities
        if (dx < screenLeft || dx > screenRight || dy < screenTop || dy > screenBottom) return;

        if (e.maxHp) {
            let img = (e.sprite && GFX[e.sprite]) ? GFX[e.sprite] : GFX.boss_manager;
            if (e.name === "SIMON UNGLAUBE") img = GFX.simonBoss;
            if (e.name === "MEGA SIMON") img = GFX.simonBoss;
            if (e.name === "MECHA MEGA SIMON" || e.isMecha) img = GFX.mechaMegaSimon;
            // Draw Mecha Mega Simon larger (48x48) vs normal bosses (32x32)
            const bossSize = (e.isMecha || e.name === "MECHA MEGA SIMON") ? 48 : 32;

            // 🔥 DESPERATION MODE: Pulsing red glow effect!
            if (e.desperationMode) {
                const glowPulse = Math.sin(GAME.ticks * 0.2) * 8 + 24;
                const glowGrad = ctx.createRadialGradient(
                    dx + 16, dy + 16, 8,
                    dx + 16, dy + 16, glowPulse
                );
                glowGrad.addColorStop(0, 'rgba(255, 0, 0, 0.5)');
                glowGrad.addColorStop(0.5, 'rgba(255, 69, 0, 0.3)');
                glowGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = glowGrad;
                ctx.fillRect(dx - glowPulse, dy - glowPulse, bossSize + glowPulse * 2, bossSize + glowPulse * 2);
            }

            ctx.drawImage(img, dx - (bossSize - 32)/2, dy - (bossSize - 32)/2, bossSize, bossSize);
        } else {
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(dx+8, dy+14, 6, 3, 0, 0, Math.PI*2); ctx.fill();
            if (e.type === 'simon') ctx.drawImage(GFX.simon, dx, dy);
            else if (e.type === 'ops') ctx.drawImage(GFX.ops, dx, dy);
            else if (e.type === 'assoc') ctx.drawImage(GFX.assoc, dx, dy);
            else if (e.type === 'runner') ctx.drawImage(GFX.runner, dx, dy);
            else if (e === GAME.player) {
                if (e.iframe%4 < 2) ctx.drawImage(GFX.chars[GAME.selectedChar], dx, dy);
                if (e.cooldown > 0) { ctx.fillStyle = '#555'; ctx.fillRect(dx, dy-4, 16, 2); ctx.fillStyle = '#00ffff'; ctx.fillRect(dx, dy-4, 16 * (1 - e.cooldown/Math.max(1, e.cooldownMax || 120)), 2); }
                else { ctx.fillStyle = '#00ff00'; ctx.fillRect(dx+6, dy-6, 4, 4); }
            }
            else if (e.type === 'attack') {
                const sprite = (GFX.attacks && GFX.attacks[e.owner]) ? GFX.attacks[e.owner] : GFX.book;
                ctx.drawImage(sprite, dx+2, dy+4);
            }
            else if (e.type === 'book') ctx.drawImage(GFX.book, dx, dy);
            else if (e.type === 'req') { if (e.boss) ctx.drawImage(GFX.bossProj, dx, dy); else ctx.drawImage(GFX.req, dx, dy); }
        }
    });

    // Performance: Batch particle rendering with visibility checks
    const particles = GAME.particles;
    const particleLen = particles.length;
    for (let i = 0; i < particleLen; i++) {
        const p = particles[i];
        const px = p.x - cx;
        const py = p.y - cy;
        // Skip offscreen particles
        if (px < -10 || px > canvas.width + 10 || py < -10 || py > canvas.height + 10) continue;

        const alpha = p.alpha || (p.life / 50);
        ctx.globalAlpha = Math.min(1, alpha);
        if (p.sparkle) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(px - 1, py, 3, 1);
            ctx.fillRect(px, py - 1, 1, 3);
        }
        ctx.fillStyle = p.color;
        ctx.fillRect(px, py, p.size || 2, p.size || 2);
    }
    ctx.globalAlpha = 1;

    // Render Floating Text with fade out and shrink effect
    ctx.textAlign = 'center';
    const texts = GAME.floatingTexts;
    const textsLen = texts.length;
    for (let i = 0; i < textsLen; i++) {
        const t = texts[i];
        const dx = Math.floor(t.x - cx);
        const dy = Math.floor(t.y - cy);
        // Skip offscreen texts
        if (dx < -50 || dx > canvas.width + 50 || dy < -20 || dy > canvas.height + 20) continue;

        const lifePercent = t.life / GAME_CONSTANTS.FLOATING_TEXT_LIFE;

        // Fade out slowly in the last 30% of life
        let alpha = 1.0;
        if (lifePercent < 0.3) {
            alpha = lifePercent / 0.3; // Smooth fade out
        }

        // Shrink gradually from 100% to 70% size over entire lifetime
        const scale = 0.7 + (lifePercent * 0.3);
        const baseFontSize = 8;
        const fontSize = Math.max(5, Math.floor(baseFontSize * scale));

        ctx.save();
        ctx.globalAlpha = Math.max(0.1, Math.min(1, alpha));
        ctx.font = `${fontSize}px "Press Start 2P"`;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeText(t.text, dx, dy);
        ctx.fillStyle = t.color;
        ctx.fillText(t.text, dx, dy);
        ctx.restore();
    }
    ctx.textAlign = 'left'; // Reset

    if (GAME.flash > 0) { ctx.globalAlpha = GAME.flash / 10; ctx.fillStyle = 'white'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.globalAlpha = 1.0; }

    // 🔥 DESPERATION MODE - Full screen red pulse effect
    if (GAME.state === 'BOSS' && GAME.boss && GAME.boss.desperationMode) {
        const pulse = Math.sin(GAME.ticks * 0.1) * 0.5 + 0.5; // Pulsing value between 0 and 1
        ctx.globalAlpha = pulse * 0.15; // Max 15% opacity for red overlay
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1.0;
    }

    // 🔥 DESPERATION MODE WARNING - Pulsing text below boss health bar
    if (GAME.state === 'BOSS' && GAME.boss && GAME.boss.desperationMode) {
        const pulse = Math.sin(GAME.ticks * 0.15) * 0.3 + 0.7; // Pulsing alpha between 0.4 and 1.0
        ctx.globalAlpha = pulse;
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeText("* DESPERATION MODE! *", canvas.width / 2, 60);
        ctx.fillStyle = '#ff0000';
        ctx.fillText("* DESPERATION MODE! *", canvas.width / 2, 60);
        ctx.globalAlpha = 1.0;
        ctx.textAlign = 'left';
    }

    ctx.restore();
}

function updateCamera() {
    GAME.camera.x = Math.max(0, Math.min(GAME.player.x - 120, MAP_W*TILE_SIZE - 256));
    GAME.camera.y = Math.max(0, Math.min(GAME.player.y - 100, MAP_H*TILE_SIZE - 224));
}

// Frame rate independence - target 60 FPS
let lastFrameTime = performance.now();
const TARGET_FPS = 60;
const TARGET_FRAME_TIME = 1000 / TARGET_FPS;

function loop() {
    const now = performance.now();
    const elapsed = now - lastFrameTime;

    // Only update game logic when enough time has passed (targeting 60 FPS)
    if (elapsed >= TARGET_FRAME_TIME) {
        // Handle multiple frames if we're running behind (but cap at 3 to prevent spiral)
        const framesToRun = Math.min(Math.floor(elapsed / TARGET_FRAME_TIME), 3);
        for (let i = 0; i < framesToRun; i++) {
            update();
        }
        lastFrameTime = now - (elapsed % TARGET_FRAME_TIME);
    }

    draw();
    requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
