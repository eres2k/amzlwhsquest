<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMZL WHS Coordinator Quest</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #0a0a12;
            --accent-gold: #ffd700;
            --accent-cyan: #00ffff;
            --accent-orange: #ff9900;
        }

        html, body {
            overflow-x: hidden;
        }

        body {
            margin: 0; padding: 0;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a12 50%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', monospace; color: white; user-select: none;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #game-wrapper {
            position: relative; width: 768px; height: 672px;
            background: linear-gradient(135deg, #0f0f1a 0%, #000 100%);
            border: 4px solid #333;
            border-radius: 24px;
            box-shadow:
                0 0 60px rgba(255, 153, 0, 0.15),
                0 0 120px rgba(0, 255, 255, 0.08),
                inset 0 0 60px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #game-wrapper::before {
            content: '';
            position: absolute;
            top: -4px; left: -4px; right: -4px; bottom: -4px;
            background: linear-gradient(45deg, #ff9900, #00ffff, #ff00ff, #ff9900);
            background-size: 400% 400%;
            animation: borderGlow 8s ease infinite;
            border-radius: 28px;
            z-index: -1;
            opacity: 0.5;
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeSpeed;
            font-smooth: never;
        }

        #crt-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background:
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%),
                linear-gradient(90deg, rgba(255, 100, 0, 0.03), rgba(0, 255, 100, 0.02), rgba(100, 0, 255, 0.03));
            background-size: 100% 3px, 4px 100%; pointer-events: none; z-index: 900;
            animation: flicker 0.08s infinite, scanline 10s linear infinite;
        }

        @keyframes scanline {
            0% { background-position: 0 0, 0 0; }
            100% { background-position: 0 100%, 0 0; }
        }

        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(0,0,0,0.5) 80%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 901; border-radius: 20px;
        }

        @keyframes flicker {
            0%, 100% { opacity: 0.97; }
            50% { opacity: 1; }
        }

        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: flex-end; padding: 20px; box-sizing: border-box; z-index: 1000;
        }

        #dialog-box {
            width: 100%; min-height: 140px;
            background: linear-gradient(180deg, #0a1628 0%, #061020 100%);
            border: 3px solid #3b82f6;
            border-radius: 12px; display: none;
            flex-direction: row; padding: 16px; box-sizing: border-box;
            box-shadow:
                0 0 20px rgba(59, 130, 246, 0.4),
                6px 6px 0px rgba(0,0,0,0.6),
                inset 0 0 30px rgba(59, 130, 246, 0.1);
            pointer-events: auto;
        }

        #portrait {
            width: 64px; height: 64px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a14 100%);
            border: 3px solid #ffd700;
            border-radius: 8px;
            margin-right: 20px; flex-shrink: 0; image-rendering: pixelated;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        #text-content {
            flex-grow: 1; font-size: 13px; line-height: 1.7; color: #f0f0ff;
            font-family: 'Press Start 2P', monospace;
            text-shadow: 2px 2px 4px #000, 0 0 10px rgba(255, 255, 255, 0.1);
            white-space: pre-wrap;
        }

        #press-space-hint {
            font-size: 10px; color: #ffd700; margin-top: 10px;
            animation: blink 0.8s ease-in-out infinite; display: block;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }

        .gemini-badge {
            font-size: 11px; color: #ffd700; margin-bottom: 8px; display: none;
            text-transform: uppercase; text-shadow: 0 0 10px #ffd700, 0 0 20px rgba(255, 215, 0, 0.5);
            letter-spacing: 2px; font-weight: bold;
        }

        .loading-dots::after {
            content: ' .';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: ' .'; }
            40% { content: ' ..'; }
            60% { content: ' ...'; }
            80%, 100% { content: ''; }
        }

        /* INTRO CONVERSATION CENTERED PORTRAIT WINDOW */
        #intro-portrait-window {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #0a1628 0%, #061020 100%);
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 12px;
            box-shadow:
                0 0 20px rgba(255, 215, 0, 0.6),
                4px 4px 0px rgba(0,0,0,0.8),
                inset 0 0 20px rgba(255, 215, 0, 0.15);
            z-index: 1000;
            width: 70%;
            max-width: 450px;
            max-height: 90%;
            pointer-events: auto;
            animation: intro-window-appear 0.3s ease-out;
            overflow: hidden;
            box-sizing: border-box;
        }

        @keyframes intro-window-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        #intro-portrait-frame {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 8px;
        }

        #intro-portrait {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a14 100%);
            border: 2px solid #ffd700;
            border-radius: 8px;
            image-rendering: pixelated;
            box-shadow:
                0 0 10px rgba(255, 215, 0, 0.4),
                inset 0 0 10px rgba(255, 215, 0, 0.1);
            margin-bottom: 6px;
        }

        #intro-speaker-name {
            font-size: 10px;
            font-weight: bold;
            color: #ffd700;
            text-shadow:
                2px 2px 4px #000,
                0 0 15px rgba(255, 215, 0, 0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #intro-dialog-content {
            display: flex;
            flex-direction: column;
            max-height: 220px;
            overflow: hidden;
        }

        #intro-text-content {
            flex-grow: 1;
            font-size: 11px;
            line-height: 1.5;
            color: #f0f0ff;
            text-shadow: 1px 1px 2px #000;
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: pre-wrap;
            text-align: center;
            padding: 0 20px;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        #intro-press-space-hint {
            font-size: 9px;
            color: #ffd700;
            margin-top: 8px;
            animation: blink 0.8s ease-in-out infinite;
            text-align: center;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        #intro-gemini-badge {
            display: none; /* Hide - intro uses dedicated name element */
        }

        /* Banner hidden as requested */
        #slogan-display {
            display: none; 
        }
        
        @keyframes blink { 50% { opacity: 0; } }

        .hud-text {
            position: absolute; top: 12px; right: 12px; color: white;
            text-align: right; text-shadow: 0 0 8px rgba(0,0,0,0.8), 2px 2px 4px black; font-size: 11px;
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(135deg, rgba(10, 15, 30, 0.95) 0%, rgba(5, 8, 20, 0.98) 100%);
            padding: 10px 14px; border: 2px solid #fbbf24; border-radius: 6px;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4), inset 0 0 15px rgba(0, 0, 0, 0.6), 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        .hud-text div:first-child { color: #ef4444; margin-bottom: 6px; letter-spacing: 1px; }
        .hud-text div:last-child { color: #22c55e; letter-spacing: 1px; }

        #boss-hud {
            position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
            width: 65%; display: none;
            background: linear-gradient(180deg, rgba(40, 10, 10, 0.9) 0%, rgba(20, 5, 5, 0.95) 100%);
            padding: 10px 16px; border-radius: 10px;
            border: 2px solid #dc2626;
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.4);
        }

        .boss-bar-bg {
            width: 100%; height: 14px;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #444; border-radius: 4px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
        }
        .boss-bar-fill {
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #ff4444 0%, #cc0000 50%, #aa0000 100%);
            transition: width 0.3s ease-out;
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5), inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }
        .boss-name {
            color: #ff4444; text-align: center; font-size: 11px; margin-bottom: 6px;
            text-shadow: 2px 2px 4px black, 0 0 10px rgba(255, 0, 0, 0.5);
            letter-spacing: 2px;
        }
        
        #ai-status {
            display: none !important;
            position: absolute; top: 10px; left: 10px; font-size: 10px; color: #00ffff;
            background: rgba(0,0,0,0.8); padding: 4px; border: 1px solid #00ffff; pointer-events: none;
            z-index: 2000;
        }

        /* MOBILE CONTROLS - Hidden by default, shown on touch devices */
        #mobile-controls {
            display: none;
            width: 768px;
            padding: 15px 20px;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            background: linear-gradient(180deg, rgba(10, 10, 20, 0.9) 0%, rgba(5, 5, 15, 0.95) 100%);
            border: 3px solid #333;
            border-top: none;
            border-radius: 0 0 20px 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        }

        /* Show on touch/mobile devices */
        @media (hover: none) and (pointer: coarse) {
            #mobile-controls {
                display: flex;
            }
        }

        /* D-PAD CONTAINER */
        .dpad-container {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .dpad-btn {
            position: absolute;
            width: 48px;
            height: 48px;
            background: linear-gradient(145deg, rgba(40, 40, 60, 0.95) 0%, rgba(20, 20, 35, 0.98) 100%);
            border: 3px solid #ffd700;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: #ffd700;
            box-shadow:
                0 0 15px rgba(255, 215, 0, 0.3),
                inset 0 0 10px rgba(0, 0, 0, 0.5),
                0 4px 8px rgba(0, 0, 0, 0.5);
            transition: all 0.1s ease;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .dpad-btn:active, .dpad-btn.pressed {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.3) 0%, rgba(200, 160, 0, 0.4) 100%);
            transform: scale(0.92);
            box-shadow:
                0 0 25px rgba(255, 215, 0, 0.6),
                inset 0 0 15px rgba(255, 215, 0, 0.3);
        }

        #dpad-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #dpad-down {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        #dpad-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        #dpad-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .dpad-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 36px;
            height: 36px;
            background: linear-gradient(145deg, #1a1a2e 0%, #0a0a14 100%);
            border: 2px solid #444;
            border-radius: 50%;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }

        /* ACTION BUTTON */
        .action-container {
            display: flex;
            align-items: center;
        }

        #action-btn {
            width: 80px;
            height: 80px;
            background: linear-gradient(145deg, rgba(255, 50, 50, 0.9) 0%, rgba(180, 30, 30, 0.95) 100%);
            border: 4px solid #ff4444;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            box-shadow:
                0 0 20px rgba(255, 68, 68, 0.5),
                inset 0 0 15px rgba(0, 0, 0, 0.3),
                0 6px 12px rgba(0, 0, 0, 0.5);
            transition: all 0.1s ease;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #action-btn:active, #action-btn.pressed {
            background: linear-gradient(145deg, rgba(255, 100, 100, 0.95) 0%, rgba(255, 68, 68, 0.98) 100%);
            transform: scale(0.92);
            box-shadow:
                0 0 35px rgba(255, 68, 68, 0.8),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
        }

        /* CONTROL MODE TOGGLE BUTTON */
        #control-mode-toggle {
            position: relative;
            width: 56px;
            height: 56px;
            flex-shrink: 0;
            background: linear-gradient(145deg, rgba(0, 200, 200, 0.9) 0%, rgba(0, 150, 150, 0.95) 100%);
            border: 3px solid #00ffff;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: #fff;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
            box-shadow:
                0 0 15px rgba(0, 255, 255, 0.5),
                inset 0 0 10px rgba(0, 0, 0, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.5);
            transition: all 0.15s ease;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            z-index: 10;
        }

        #control-mode-toggle .mode-icon {
            font-size: 16px;
            margin-bottom: 2px;
        }

        #control-mode-toggle .mode-label {
            font-size: 6px;
            letter-spacing: 0.5px;
        }

        #control-mode-toggle:active, #control-mode-toggle.pressed {
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.95) 0%, rgba(0, 200, 200, 0.98) 100%);
            transform: scale(0.92);
            box-shadow:
                0 0 25px rgba(0, 255, 255, 0.8),
                inset 0 0 15px rgba(255, 255, 255, 0.2);
        }

        #control-mode-toggle.gyro-active {
            background: linear-gradient(145deg, rgba(200, 100, 255, 0.9) 0%, rgba(150, 50, 200, 0.95) 100%);
            border-color: #cc66ff;
            box-shadow:
                0 0 15px rgba(200, 100, 255, 0.5),
                inset 0 0 10px rgba(0, 0, 0, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.5);
            animation: gyro-pulse 1.5s ease-in-out infinite;
        }

        @keyframes gyro-pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(200, 100, 255, 0.5), inset 0 0 10px rgba(0, 0, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(200, 100, 255, 0.8), inset 0 0 10px rgba(0, 0, 0, 0.3); }
        }

        /* GYRO INDICATOR - shows tilt direction */
        #gyro-indicator {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90px;
            height: 90px;
            border: 2px dashed rgba(200, 100, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
        }

        #gyro-indicator .gyro-dot {
            position: absolute;
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, #cc66ff 0%, #9933cc 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
            box-shadow: 0 0 10px rgba(200, 100, 255, 0.8);
            transition: left 0.05s ease-out, top 0.05s ease-out;
        }

        .gyro-mode #gyro-indicator {
            display: block;
        }

        .gyro-mode .dpad-btn {
            opacity: 0.3;
            pointer-events: none;
        }

        /* AUTO-SHOOT INDICATOR */
        #auto-shoot-indicator {
            display: none;
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 7px;
            color: #ff4444;
            text-shadow: 0 0 5px rgba(255, 68, 68, 0.8);
            animation: blink 0.5s ease-in-out infinite;
            white-space: nowrap;
        }

        .gyro-mode #auto-shoot-indicator {
            display: block;
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 900px) {
            body {
                justify-content: flex-start;
                padding-top: 10px;
            }

            #game-wrapper {
                width: 95vw;
                max-width: 768px;
                height: auto;
                aspect-ratio: 768 / 672;
                border-radius: 16px 16px 0 0;
            }

            #game-wrapper::before {
                border-radius: 20px 20px 0 0;
            }

            #mobile-controls {
                width: 95vw;
                max-width: 768px;
                padding: 12px 20px;
                border-radius: 0 0 16px 16px;
            }

            .dpad-container {
                width: 110px;
                height: 110px;
            }

            .dpad-btn {
                width: 42px;
                height: 42px;
                font-size: 16px;
            }

            .dpad-center {
                width: 30px;
                height: 30px;
            }

            #action-btn {
                width: 70px;
                height: 70px;
                font-size: 11px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding-top: 5px;
            }

            #game-wrapper {
                width: 100vw;
                border-radius: 0;
            }

            #game-wrapper::before {
                border-radius: 0;
            }

            #mobile-controls {
                width: 100vw;
                max-width: none;
                padding: 10px 15px;
                border-radius: 0;
                border-left: none;
                border-right: none;
            }

            .dpad-container {
                width: 100px;
                height: 100px;
            }

            .dpad-btn {
                width: 38px;
                height: 38px;
                font-size: 14px;
                border-width: 2px;
            }

            .dpad-center {
                width: 26px;
                height: 26px;
            }

            #action-btn {
                width: 60px;
                height: 60px;
                font-size: 10px;
                border-width: 3px;
            }

            /* Intro portrait window - constrain to game area */
            #intro-portrait-window {
                max-width: 90%;
                max-height: 85%;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            #intro-dialog-content {
                max-height: 150px;
                overflow-y: auto;
            }
        }

        /* Extra small screens (Galaxy Fold folded, narrow phones) */
        @media (max-width: 380px) {
            /* Intro portrait window - optimized for Fold5, constrained to game area */
            #intro-portrait-window {
                max-width: 95%;
                width: calc(100% - 16px);
                max-height: 80%;
                padding: 10px;
                border-width: 2px;
                border-radius: 8px;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            #intro-portrait {
                width: 64px;
                height: 64px;
                border-width: 2px;
                margin-bottom: 6px;
            }

            #intro-speaker-name {
                font-size: 10px;
                letter-spacing: 0.5px;
            }

            #intro-portrait-frame {
                margin-bottom: 10px;
            }

            #intro-text-content {
                font-size: 9px;
                line-height: 1.4;
                padding: 0 4px;
                word-break: break-word;
                hyphens: auto;
            }

            #intro-dialog-content {
                min-height: 70px;
                max-height: 120px;
                overflow-y: auto;
            }

            #intro-press-space-hint {
                font-size: 8px;
                margin-top: 8px;
            }

            /* Bottom dialog box - Fold5 optimized */
            #dialog-box {
                min-height: 90px;
                padding: 8px;
                border-width: 2px;
                flex-direction: column;
                align-items: center;
            }

            #portrait {
                width: 40px;
                height: 40px;
                margin-right: 0;
                margin-bottom: 6px;
                border-width: 2px;
            }

            #text-content {
                font-size: 8px;
                line-height: 1.4;
                text-align: center;
            }

            #press-space-hint {
                font-size: 7px;
                margin-top: 5px;
            }

            /* HUD elements */
            .hud-text {
                font-size: 7px;
                padding: 5px 6px;
            }

            .boss-name {
                font-size: 7px;
            }

            #boss-hud {
                width: 75%;
                padding: 6px 10px;
            }

            /* Mobile controls for narrow screens */
            .dpad-container {
                width: 80px;
                height: 80px;
            }

            .dpad-btn {
                width: 30px;
                height: 30px;
                font-size: 11px;
                border-width: 2px;
            }

            .dpad-center {
                width: 20px;
                height: 20px;
            }

            #action-btn {
                width: 48px;
                height: 48px;
                font-size: 8px;
                border-width: 2px;
            }

            #control-mode-toggle {
                width: 42px;
                height: 42px;
                border-width: 2px;
            }

            #control-mode-toggle .mode-icon {
                font-size: 12px;
            }

            #control-mode-toggle .mode-label {
                font-size: 5px;
            }

            #gyro-indicator {
                width: 70px;
                height: 70px;
            }

            #auto-shoot-indicator {
                font-size: 6px;
                bottom: -20px;
            }

            #mobile-controls {
                padding: 6px 8px;
            }
        }

        /* Very narrow screens (Galaxy Fold5 folded ~280px) */
        @media (max-width: 300px) {
            #intro-portrait-window {
                padding: 6px;
                max-height: 75%;
                border-width: 2px;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            #intro-portrait {
                width: 48px;
                height: 48px;
            }

            #intro-speaker-name {
                font-size: 8px;
            }

            #intro-text-content {
                font-size: 7px;
                line-height: 1.3;
            }

            #intro-dialog-content {
                max-height: 100px;
            }

            #intro-press-space-hint {
                font-size: 6px;
            }

            #dialog-box {
                min-height: 80px;
                padding: 6px;
            }

            #portrait {
                width: 32px;
                height: 32px;
            }

            #text-content {
                font-size: 7px;
            }

            #press-space-hint {
                font-size: 6px;
            }

            .hud-text {
                font-size: 6px;
                padding: 4px 5px;
            }

            .boss-name {
                font-size: 6px;
            }

            .dpad-container {
                width: 70px;
                height: 70px;
            }

            .dpad-btn {
                width: 26px;
                height: 26px;
                font-size: 9px;
            }

            .dpad-center {
                width: 18px;
                height: 18px;
            }

            #action-btn {
                width: 42px;
                height: 42px;
                font-size: 7px;
            }

            #control-mode-toggle {
                width: 36px;
                height: 36px;
            }

            #control-mode-toggle .mode-icon {
                font-size: 10px;
            }

            #control-mode-toggle .mode-label {
                display: none;
            }

            #gyro-indicator {
                width: 60px;
                height: 60px;
            }

            #auto-shoot-indicator {
                font-size: 5px;
                bottom: -18px;
            }

            #mobile-controls {
                padding: 5px 6px;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="game-wrapper">
        <div id="ai-status">AI Status: Init</div>
        <canvas id="gameCanvas" width="256" height="224"></canvas>
        <div id="crt-overlay"></div>
        <div id="vignette"></div>

        <div id="ui-overlay">
            <div id="slogan-display"></div>

            <div class="hud-text" id="hud-layer" style="display:none;">
                <div style="color:#ff4444; margin-bottom:5px;">LIFE <span id="life-val">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
                <div style="color:#44ff44;">HAZARDS: <span id="score-val">0/5</span></div>
                <div style="color:#ffd700; margin-top:3px; font-size:8px;">SCORE: <span id="highscore-val">0</span></div>
                <div style="color:#22d3ee; margin-top:3px; font-size:8px;">SP: <span id="sp-val">0</span></div>
                <div style="color:#66aaff; margin-top:3px; font-size:8px;">REGION: <span id="region-val">EU</span></div>
                <div id="ppe-buffs" style="color:#a855f7; margin-top:5px; font-size:7px; display:none;">PPE: <span id="ppe-buffs-val"></span></div>
            </div>
        
            <div id="boss-hud">
                <div class="boss-name" id="boss-name-el">BOSS NAME</div>
                <div class="boss-bar-bg"><div class="boss-bar-fill" id="boss-health-el"></div></div>
            </div>

            <div id="dialog-box">
                <canvas id="portrait" width="48" height="48"></canvas>
                <div style="display:flex; flex-direction:column; width:100%;">
                    <div id="gemini-badge" class="gemini-badge"></div>
                    <div id="text-content"></div>
                    <div id="press-space-hint">‚ñº TAP / SPACE</div>
                </div>
            </div>

            <!-- INTRO CONVERSATION CENTERED PORTRAIT WINDOW -->
            <div id="intro-portrait-window">
                <div id="intro-portrait-frame">
                    <canvas id="intro-portrait" width="96" height="96"></canvas>
                    <div id="intro-speaker-name"></div>
                </div>
                <div id="intro-dialog-content">
                    <div id="intro-gemini-badge" class="gemini-badge"></div>
                    <div id="intro-text-content"></div>
                    <div id="intro-press-space-hint">‚ñº TAP / SPACE</div>
                </div>
            </div>
        </div>
    </div>

    <!-- MOBILE CONTROLS -->
    <div id="mobile-controls">
        <div class="dpad-container">
            <div id="dpad-up" class="dpad-btn">‚ñ≤</div>
            <div id="dpad-left" class="dpad-btn">‚óÄ</div>
            <div class="dpad-center"></div>
            <div id="dpad-right" class="dpad-btn">‚ñ∂</div>
            <div id="dpad-down" class="dpad-btn">‚ñº</div>
            <!-- Gyro indicator overlays the dpad -->
            <div id="gyro-indicator">
                <div class="gyro-dot"></div>
            </div>
        </div>
        <!-- Control mode toggle button in middle -->
        <div id="control-mode-toggle">
            <span class="mode-icon">üéÆ</span>
            <span class="mode-label">DPAD</span>
        </div>
        <div class="action-container">
            <div id="action-btn">A</div>
            <div id="auto-shoot-indicator">AUTO-FIRE</div>
        </div>
    </div>
</div>

<!-- Load localization before main game script -->
<script src="localization.js"></script>

<script type="module">
// --- CONFIG ---
let apiKey = null;
let apiKeyPromise = null;
const MODEL_NAME = "gemini-2.5-flash-lite";

// --- GAME CONSTANTS (Performance: Avoid magic numbers) ---
const GAME_CONSTANTS = {
    // Timing
    PARTICLE_LIFE_BASE: 50,
    PARTICLE_LIFE_VARIANCE: 20,
    FLOATING_TEXT_LIFE: 210,
    IFRAME_DURATION: 60,
    CASTLE_IFRAME_DURATION: 120,
    BANTER_COOLDOWN: 5000,
    AI_BANTER_COOLDOWN: 15000,

    // Physics
    PARTICLE_GRAVITY: 0.2,
    PARTICLE_BOUNCE: -0.6,
    DIAGONAL_FACTOR: 0.707,

    // Pool sizes
    MAX_PARTICLES: 200,
    MAX_FLOATING_TEXTS: 30,
    MAX_PROJECTILES: 50,

    // Rendering
    VIEWPORT_PADDING: 16,
    SCREEN_WIDTH: 256,
    SCREEN_HEIGHT: 224
};

// --- OBJECT POOL SYSTEM (Performance: Reduce GC pressure) ---
const ObjectPool = {
    particles: [],
    floatingTexts: [],

    // Get a particle from pool or create new one
    getParticle() {
        const pool = this.particles;
        for (let i = 0; i < pool.length; i++) {
            if (!pool[i].active) {
                pool[i].active = true;
                return pool[i];
            }
        }
        // Create new if pool is empty or all active
        if (pool.length < GAME_CONSTANTS.MAX_PARTICLES) {
            const p = { active: true, x: 0, y: 0, vx: 0, vy: 0, life: 0, color: '', size: 2, alpha: 1, groundY: 0, sparkle: false };
            pool.push(p);
            return p;
        }
        // Reuse oldest if at max capacity
        pool[0].active = true;
        return pool[0];
    },

    releaseParticle(p) {
        p.active = false;
    },

    // Get a floating text from pool or create new one
    getFloatingText() {
        const pool = this.floatingTexts;
        for (let i = 0; i < pool.length; i++) {
            if (!pool[i].active) {
                pool[i].active = true;
                return pool[i];
            }
        }
        if (pool.length < GAME_CONSTANTS.MAX_FLOATING_TEXTS) {
            const t = { active: true, x: 0, y: 0, text: '', color: '#fff', life: 0, vy: 0 };
            pool.push(t);
            return t;
        }
        pool[0].active = true;
        return pool[0];
    },

    releaseFloatingText(t) {
        t.active = false;
    },

    // Reset all pools (call on game restart)
    reset() {
        this.particles.forEach(p => p.active = false);
        this.floatingTexts.forEach(t => t.active = false);
    }
};

// --- CACHED VALUES (Performance: Avoid repeated calculations) ---
const CachedValues = {
    // Will be populated at runtime
    canvasWidth: 0,
    canvasHeight: 0,
    halfCanvasWidth: 0,
    halfCanvasHeight: 0,

    init(canvas) {
        this.canvasWidth = canvas.width;
        this.canvasHeight = canvas.height;
        this.halfCanvasWidth = canvas.width / 2;
        this.halfCanvasHeight = canvas.height / 2;
    }
};

// --- BANTER DATA ---
const BANTER_DB = {
    ops: [
        "TPH is down!", "Walk faster!", "No talking!", "VTO?",
        "Scan scan scan!", "Where's your vest?", "Audit panic!",
        "My bonus!", "TOT!", "Bad rate!", "Let's go!",
        "Chase blue line!", "Less chatter!", "Time is rate!", "Trim that idle!",
        "Metrics don't nap!", "Pick it up!", "Stay in lanes!"
    ],
    assoc: [
        "My feet...", "Break time?", "Box heavy...", "Ugh...",
        "Safety shoes hurt", "Where's HR?", "Need coffee...",
        "Too early...", "Night shift...", "Pizza party?",
        "Belt keeps eating me", "Where's my badge?", "Snacks when?",
        "Scanner dying...", "Stuck in pack?", "Shift never ends"
    ],
    // Region-specific banter with local slang
    regional: {
        AT: {
            ops: [
                "Oida, TPH is down!", "Geh schneller, herst!", "Ned tratschen!",
                "Schleich di!", "Wo is dei Weste?", "Audit, oida!",
                "Mei Bonus!", "Schneller scannen!", "Des geht si ned aus!",
                "Gemma, gemma!", "Wos is mit der Rate?", "Zeit is G√∂d!",
                "Beweg di, herst!", "Weniger reden!", "Hawara, zack zack!"
            ],
            assoc: [
                "Mei F√º√üe...", "Pause, oida?", "Schachtel schwer...", "Uff...",
                "Sicherheitsschuhe zwicken", "Wo is HR?", "Brauch Kaffee...",
                "V√º zu fr√ºh...", "Nachtschicht, oida...", "Pizza Party?",
                "Band frisst mi auf", "Wo is mei Badge?", "Jausen wann?",
                "Scanner stirbt...", "Im Pack h√§ngen?", "Schicht endet nie"
            ]
        },
        DE: {
            ops: [
                "TPH ist runter!", "Schneller laufen!", "Nicht quatschen!",
                "VTO?", "Scannen scannen!", "Wo ist deine Weste?", "Audit Panik!",
                "Mein Bonus!", "TOT!", "Schlechte Rate!", "Los geht's!",
                "Blaue Linie!", "Weniger reden!", "Zeit ist Geld!", "Weniger Leerlauf!",
                "Metriken schlafen nicht!", "Aufheben!", "In der Spur bleiben!"
            ],
            assoc: [
                "Meine F√º√üe...", "Pause?", "Karton schwer...", "Ugh...",
                "Sicherheitsschuhe dr√ºcken", "Wo ist HR?", "Brauche Kaffee...",
                "Zu fr√ºh...", "Nachtschicht...", "Pizza Party?",
                "Band frisst mich", "Wo ist mein Badge?", "Snacks wann?",
                "Scanner stirbt...", "In Pack stecken?", "Schicht endet nie"
            ]
        },
        NL: {
            ops: [
                "TPH is laag!", "Sneller lopen!", "Niet kletsen!", "VTO?",
                "Scannen scannen!", "Waar is je vest?", "Audit paniek!",
                "Mijn bonus!", "TOT!", "Slechte rate!", "Kom op!",
                "Blauwe lijn!", "Minder praten!", "Tijd is geld!", "Minder stilstand!",
                "Metrics slapen niet!", "Oppakken!", "In de baan blijven!"
            ],
            assoc: [
                "Mijn voeten...", "Pauze?", "Doos zwaar...", "Pff...",
                "Veiligheidsschoenen doen pijn", "Waar is HR?", "Koffie nodig...",
                "Te vroeg...", "Nachtdienst...", "Pizza feest?",
                "Band vreet me op", "Waar is mijn badge?", "Snacks wanneer?",
                "Scanner gaat dood...", "Vast in pack?", "Dienst stopt nooit"
            ]
        }
    }
};

// Helper to get region-appropriate banter
function getRegionalBanter(type) {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : null;
    // Try region-specific banter first
    if (region && BANTER_DB.regional[region] && BANTER_DB.regional[region][type]) {
        // 70% chance to use regional banter, 30% to use generic English
        if (Math.random() < 0.7) {
            const regionalLines = BANTER_DB.regional[region][type];
            return regionalLines[Math.floor(Math.random() * regionalLines.length)];
        }
    }
    // Fall back to generic English banter
    return BANTER_DB[type][Math.floor(Math.random() * BANTER_DB[type].length)];
}

// --- CHARACTER DATA ---
const CHAR_DATA = {
    "Carrie": {
        role: "The 5S Monk",
        backstory: "Precision hawk who spots crooked tape from 50 meters and breathes calm into chaotic clusters.",
        attack: "Label Maker Burst",
        speed: 1.5,
        lives: 3,
        ability: "PRECISION FOCUS",
        abilityDesc: "2x damage, 30% slower reload"
    },
    "Nevena": {
        role: "The Oracle",
        backstory: "Safety oracle who predicts mishaps, carries emergency Palatschinken, and documents everything twice.",
        attack: "Clipboard Shockwave",
        speed: 1.5,
        lives: 4,
        ability: "FORESIGHT",
        abilityDesc: "Longer invincibility after taking damage"
    },
    "Joao": {
        role: "The Siren",
        backstory: "Espresso cannon whose warnings ring louder than the fire alarm and kick energy through the floor.",
        attack: "Sonic Shout",
        speed: 1.5,
        lives: 3,
        ability: "CAFFEINE RUSH",
        abilityDesc: "Attacks have faster cooldown"
    },
    "Roman": {
        role: "The Ghost",
        backstory: "Bald audit phantom. Appears, fixes, vanishes. Hazards straighten themselves when he is near.",
        attack: "Stealth Audit",
        speed: 1.5,
        lives: 3,
        ability: "PHANTOM STEP",
        abilityDesc: "Hazards have smaller collision radius"
    },
    "Erwin": {
        role: "The Manager",
        backstory: "Rolls in with a kid-sized Tesla and slides into briefings faster than gossip spreads.",
        attack: "Tesla Energy Pulse",
        speed: 1.95,
        lives: 1,
        ability: "TESLA RUSH",
        abilityDesc: "1 life but 30% faster movement"
    }
};

const ATTACKS = {
    "Carrie": { name: "Label Maker Burst", sprite: "attack_carrie", speed: 4.2, cooldown: 110, color: "#a855f7", text: "Aligned!" },
    "Nevena": { name: "Clipboard Shockwave", sprite: "attack_nevena", speed: 4.0, cooldown: 120, color: "#0ea5e9", text: "Documented!" },
    "Joao": { name: "Sonic Shout", sprite: "attack_joao", speed: 4.6, cooldown: 105, color: "#f97316", text: "Heard!" },
    "Roman": { name: "Stealth Audit Pulse", sprite: "attack_roman", speed: 4.0, cooldown: 115, color: "#94a3b8", text: "Noted." },
    "Erwin": { name: "Tesla Drift", sprite: "attack_erwin", speed: 5.0, cooldown: 140, color: "#22d3ee", text: "Zapped!" },
    default: { name: "Rule Book", sprite: "book", speed: 4.0, cooldown: 120, color: "#00ffff", text: "Hit!" }
};

function getAttackData(name) {
    return ATTACKS[name] || ATTACKS.default;
}

function getCharStats(name) {
    const data = CHAR_DATA[name] || {};
    return {
        speed: data.speed ?? 1.5,
        lives: data.lives ?? 3
    };
}

// --- SIMULATED AI DATABASE (FALLBACKS) ---
const SIMULATED_AI = {
    tips: [
        "Blocked exit? That box is your tombstone. Move it.",
        "Chemical spill? Entropy leaking. Contain it before you dissolve.",
        "Debris? Chaos on the floor leads to chaos in the soul. Clean it.",
        "Trip hazard? Gravity does not care about your excuses.",
        "Unstable stack? Newton is rolling in his grave. Fix it.",
        "Fire equipment blocked? Do you plan to fight fire with optimism?",
        // === GERMANY (DE) Educational Tips ===
        "[DE] DGUV V1 ¬ß15: Employees must support all OSH measures.",
        "[DE] Fluchtwegbreite: Main escape routes must be min 1.20m wide.",
        "[DE] ArbSchG ¬ß5: Employers must assess workplace hazards.",
        "[DE] BetrSichV: All work equipment requires regular inspection.",
        "[DE] DGUV V3: Electrical equipment needs annual safety testing.",
        "[DE] ASR A2.3: Emergency routes must be clearly marked.",
        "[DE] Gef√§hrdungsbeurteilung: Risk assessment is mandatory.",
        "[DE] ArbSt√§ttV: Workplaces must meet minimum safety standards.",
        // === AUSTRIA (AT) Educational Tips ===
        "[AT] ASchG ¬ß15: Employers are obligated to evaluate all risks.",
        "[AT] BauV: Construction sites require safety coordinators.",
        "[AT] Arbeitsinspektorat enforces workplace safety laws.",
        "[AT] ASchG ¬ß4: Every workplace needs a safety representative.",
        "[AT] AUVA provides accident insurance and prevention services.",
        "[AT] PSA-V: Personal protective equipment must be provided.",
        "[AT] Arbeitsplatzevaluierung is required for all workplaces.",
        "[AT] ASchG ¬ß12: Workers have the right to refuse unsafe work.",
        // === NETHERLANDS (NL) Educational Tips ===
        "[NL] RI&E: Every company must have a Risk Inventory & Evaluation.",
        "[NL] Arbowet Art 3: Employers must minimize workload pressure.",
        "[NL] Preventiemedewerker: Companies need prevention officers.",
        "[NL] BHV: Emergency response teams are mandatory in NL.",
        "[NL] Arbocatalogus: Sector-specific safety guidelines apply.",
        "[NL] Inspectie SZW enforces Dutch occupational safety laws.",
        "[NL] Plan van Aanpak: Action plans must follow RI&E findings.",
        "[NL] Arbowet Art 8: Workers must receive safety instruction."
    ],
    runners: [
        "Halt! Kinetic energy is not your friend. Slow down.",
        "You are not a photon. You have mass. Walk.",
        "Running? I've seen glaciers move with more purpose.",
        "We fight entropy, not the clock. Walk."
    ],
    taunts: [
        "My spreadsheet predicts your failure!",
        "You cannot audit the inevitable!",
        "I am the final regulation!",
        "Compliance dropping... Termination imminent!",
        "Resistance is a safety violation!"
    ],
    simon_taunts: [
        "I AM THE SAFETY STANDARD! ...And yes, I find that exhausting too.",
        "YOU CANNOT ESCAPE THE AUDIT! Trust me, I've tried.",
        "ENTROPY COMES FOR US ALL! But I'll document it first.",
        "YOUR PPE IS INSUFFICIENT! Much like my faith in humanity."
    ],
    simon_warnings: [
        "First warning: Stop flinging manuals. Compliance is not a contact sport. Though I'd pay to see that league.",
        "Final warning: Holster the rule books or I escalate this audit into a boss fight. My spreadsheets are ready."
    ],
    reviews_win: [
        "Performance: IMPROBABLE. You survived. I am... adequately pleased. Don't let it go to your head.",
        "You fought chaos and won. For today. Tomorrow, entropy tries again. It always does.",
        "Adequate. Nothing to write up. Feels strange. Almost disappointing, really."
    ],
    reviews_loss: [
        "Performance: CATASTROPHIC. Entropy won. I'll be at my desk, filing the incident report. In triplicate.",
        "You failed. Gravity and stupidity destroyed us. Physics remains undefeated.",
        "Safety is binary. You are a zero. Mathematically speaking, of course."
    ],
    // Region-specific dialogue for Simon
    regional: {
        AT: {
            runners: [
                "Halt, oida! Kinetische Energie is ned dei Freund. Langsamer!",
                "Du bist ka Photon. Du hast Masse. Geh!",
                "Rennen? I hab Gletscher gsehen die schneller san.",
                "Mir k√§mpfen gegen Entropie, ned gegen die Uhr. Geh!"
            ],
            taunts: [
                "Mei Tabellenkalkulation sagt dei Scheitern voraus!",
                "Du kannst des Audit ned entkommen!",
                "I bin die finale Vorschrift!",
                "Compliance sinkt... K√ºndigung steht bevor!",
                "Widerstand is a Sicherheitsverletzung!"
            ],
            simon_taunts: [
                "I BIN DER SICHERHEITSSTANDARD!",
                "DU KANNST DEM AUDIT NED ENTKOMMEN!",
                "ENTROPIE KOMMT F√úR UNS ALLE!",
                "DEINE PSA IS UNZUREICHEND!"
            ],
            simon_warnings: [
                "Erste Verwarnung: H√∂r auf mit die Handb√ºcher zu werfen. Compliance is ka Kontaktsport.",
                "Letzte Verwarnung: Steck die Regelb√ºcher weg oder i eskalier des Audit zum Bossfight."
            ],
            reviews_win: [
                "Leistung: UNWAHRSCHEINLICH. Du hast √ºberlebt. I bin... angemessen zufrieden.",
                "Du hast gegen das Chaos gewonnen. F√ºr heit.",
                "Ausreichend. Nix zum Aufschreiben. F√ºhlt si komisch an."
            ],
            reviews_loss: [
                "Leistung: KATASTROPHAL. Entropie hat gwonnen.",
                "Du hast versagt. Schwerkraft und Dummheit haben uns zerst√∂rt.",
                "Sicherheit is bin√§r. Du bist a Null."
            ]
        },
        DE: {
            runners: [
                "Halt! Kinetische Energie ist nicht dein Freund. Langsamer!",
                "Du bist kein Photon. Du hast Masse. Geh!",
                "Rennen? Ich habe Gletscher gesehen die zielstrebiger waren.",
                "Wir k√§mpfen gegen Entropie, nicht gegen die Uhr. Geh!"
            ],
            taunts: [
                "Meine Tabellenkalkulation sagt dein Scheitern voraus!",
                "Du kannst das Audit nicht entkommen!",
                "Ich bin die finale Vorschrift!",
                "Compliance sinkt... K√ºndigung steht bevor!",
                "Widerstand ist eine Sicherheitsverletzung!"
            ],
            simon_taunts: [
                "ICH BIN DER SICHERHEITSSTANDARD!",
                "DU KANNST DEM AUDIT NICHT ENTKOMMEN!",
                "ENTROPIE KOMMT F√úR UNS ALLE!",
                "DEINE PSA IST UNZUREICHEND!"
            ],
            simon_warnings: [
                "Erste Verwarnung: H√∂r auf Handb√ºcher zu werfen. Compliance ist kein Kontaktsport.",
                "Letzte Verwarnung: Steck die Regelb√ºcher weg oder ich eskaliere dieses Audit zum Bossfight."
            ],
            reviews_win: [
                "Leistung: UNWAHRSCHEINLICH. Du hast √ºberlebt. Ich bin... angemessen zufrieden.",
                "Du hast gegen das Chaos gewonnen. F√ºr heute.",
                "Ausreichend. Nichts aufzuschreiben. F√ºhlt sich seltsam an."
            ],
            reviews_loss: [
                "Leistung: KATASTROPHAL. Entropie hat gewonnen.",
                "Du hast versagt. Schwerkraft und Dummheit haben uns zerst√∂rt.",
                "Sicherheit ist bin√§r. Du bist eine Null."
            ]
        },
        NL: {
            runners: [
                "Stop, godver! Kinetische energie is niet je vriend. Langzamer!",
                "Je bent geen foton, eikel. Je hebt massa. Loop!",
                "Rennen? Verdomme, ik heb gletsjers gezien die doelgerichter waren.",
                "We vechten tegen entropie, niet tegen de klok. Loop, verdorie!"
            ],
            taunts: [
                "Mijn spreadsheet voorspelt je falen, klojo!",
                "Je kunt de audit niet ontsnappen, sukkel!",
                "Ik ben de finale regelgeving, godverdomme!",
                "Compliance daalt... Ontslag dreigt, eikel!",
                "Weerstand is een veiligheidsovertreding, dombo!"
            ],
            simon_taunts: [
                "IK BEN DE VEILIGHEIDSSTANDAARD! ...Godver, wat vermoeiend.",
                "JE KUNT DE AUDIT NIET ONTSNAPPEN! Geloof me, ik heb het geprobeerd, verdomme.",
                "ENTROPIE KOMT VOOR ONS ALLEMAAL! Maar ik documenteer het eerst, klote.",
                "JE PBM IS ONVOLDOENDE! Net als mijn vertrouwen in de mensheid, godver."
            ],
            simon_warnings: [
                "Eerste waarschuwing: Stop met die handboeken gooien, godver. Compliance is geen contactsport. Al zou ik daar geld voor betalen.",
                "Laatste waarschuwing: Berg die regelboeken op of ik escaleer deze audit naar een baasgevecht. Mijn spreadsheets staan klaar, verdomme."
            ],
            reviews_win: [
                "Prestatie: ONWAARSCHIJNLIJK. Je hebt overleefd, godver. Ik ben... voldoende tevreden. Laat het niet naar je hoofd stijgen.",
                "Je hebt tegen de chaos gewonnen. Voor vandaag, verdomme. Morgen probeert entropie het opnieuw.",
                "Voldoende. Niets op te schrijven. Voelt vreemd, godver. Bijna teleurstellend."
            ],
            reviews_loss: [
                "Prestatie: CATASTROFAAL. Entropie heeft gewonnen, verdomme. Ik ga het incidentrapport invullen. In drievoud.",
                "Je hebt gefaald, klojo. Zwaartekracht en domheid hebben ons vernietigd. Natuurkunde blijft onverslagen.",
                "Veiligheid is binair. Jij bent een nul, godver. Wiskundig gezien, natuurlijk."
            ]
        }
    }
};

// === BOSS DEFEAT CUTSCENE DIALOGUES ===
// Localized defeat lines for each boss and player responses
const BOSS_DEFEAT_DIALOGUES = {
    // Boss final words when defeated (by boss name)
    bossLines: {
        "Labour Inspector": {
            MEU: "No... the violations... they were all... documented...",
            DE: "Nein... die Verst√∂√üe... sie waren alle... dokumentiert...",
            AT: "Na... die Verst√∂√üe... de woan olle... dokumentiert...",
            NL: "Nee... de overtredingen... ze waren allemaal... gedocumenteerd..."
        },
        "Compliance Auditor": {
            MEU: "My audit... incomplete... the paperwork... never ends...",
            DE: "Mein Audit... unvollst√§ndig... der Papierkram... endet nie...",
            AT: "Mei Audit... unvollst√§ndig... da Papierkram... endet nia...",
            NL: "Mijn audit... onvolledig... de papierwinkel... eindigt nooit..."
        },
        "Sebastian S.": {
            MEU: "TPH... dropping... delivery targets... not met...",
            DE: "TPH... sinkt... Lieferziele... nicht erreicht...",
            AT: "TPH... sinkt... Liefaziele... ned erreicht...",
            NL: "TPH... daalt... leveringsdoelen... niet gehaald..."
        },
        "Regional OPS MGR": {
            MEU: "The KPIs... they meant nothing... safety wins...",
            DE: "Die KPIs... sie bedeuteten nichts... Sicherheit gewinnt...",
            AT: "Die KPIs... de hom nix bedeutet... Sicherheit gewinnt...",
            NL: "De KPI's... ze betekenden niets... veiligheid wint..."
        },
        "Avetta Platform": {
            MEU: "SYSTEM ERROR... risk assessment... failed... rebooting...",
            DE: "SYSTEMFEHLER... Risikobewertung... fehlgeschlagen... Neustart...",
            AT: "SYSTEMFEHLER... Risikobewertung... fehlgschlogn... Neustart...",
            NL: "SYSTEEMFOUT... risicobeoordeling... mislukt... herstarten..."
        },
        "Jelena \"Jelly\"": {
            MEU: "This will go in your file... wait, MY file?!",
            DE: "Das kommt in deine Akte... Moment, MEINE Akte?!",
            AT: "Des kummt in deine Akte... Moment, MEINE Akte?!",
            NL: "Dit komt in je dossier... wacht, MIJN dossier?!"
        }
    },
    // Player character victory responses (by character name)
    playerLines: {
        "Carrie": {
            MEU: "Another hazard eliminated. My 5S system remains... supreme.",
            DE: "Ein weiteres Risiko beseitigt. Mein 5S-System bleibt... √ºberlegen.",
            AT: "Noch a Risiko beseitigt. Mei 5S-System bleibt... √ºberlegen.",
            NL: "Nog een gevaar ge√´limineerd. Mijn 5S-systeem blijft... oppermachtig."
        },
        "Nevena": {
            MEU: "I foresaw this outcome. The clipboard never lies.",
            DE: "Ich habe dieses Ergebnis vorhergesehen. Das Klemmbrett l√ºgt nie.",
            AT: "I hob des Ergebnis vorrausgsehn. Des Klemmbrett l√ºgt nia.",
            NL: "Ik voorspelde deze uitkomst. Het klembord liegt nooit."
        },
        "Joao": {
            MEU: "SAFETY FIRST! Did everyone hear that? SAFETY FIRST!",
            DE: "SICHERHEIT ZUERST! Hat das jeder geh√∂rt? SICHERHEIT ZUERST!",
            AT: "SICHERHEIT ZUERST! Hot des jeda gh√∂rt? SICHERHEIT ZUERST!",
            NL: "VEILIGHEID EERST! Heeft iedereen dat gehoord? VEILIGHEID EERST!"
        },
        "Roman": {
            MEU: "They never saw me coming. The Ghost strikes again.",
            DE: "Sie haben mich nicht kommen sehen. Der Geist schl√§gt wieder zu.",
            AT: "De hom mi ned kumma gsehn. Da Geist schl√§gt wieder zua.",
            NL: "Ze zagen me niet aankomen. De Geest slaat weer toe."
        },
        "Erwin": {
            MEU: "Efficiency maximized. Now, back to my Tesla.",
            DE: "Effizienz maximiert. Jetzt zur√ºck zu meinem Tesla.",
            AT: "Effizienz maximiert. Jetzt zruck zu meim Tesla.",
            NL: "Effici√´ntie gemaximaliseerd. Nu, terug naar mijn Tesla."
        }
    }
};

// Get localized boss defeat line
function getBossDefeatLine(bossName) {
    const region = GAME.region || 'MEU';
    const lines = BOSS_DEFEAT_DIALOGUES.bossLines[bossName];
    if (lines && lines[region]) return lines[region];
    if (lines && lines.MEU) return lines.MEU;
    return "Defeated... by safety compliance...";
}

// Get localized player victory response
function getPlayerVictoryLine(charName) {
    const region = GAME.region || 'MEU';
    const lines = BOSS_DEFEAT_DIALOGUES.playerLines[charName];
    if (lines && lines[region]) return lines[region];
    if (lines && lines.MEU) return lines.MEU;
    return "Another victory for workplace safety!";
}

// Helper function to get localized Simon dialogue
function getLocalizedSimonDialogue(category) {
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : null;

    // Try region-specific dialogue first (80% chance if available)
    if (region && SIMULATED_AI.regional[region] && SIMULATED_AI.regional[region][category]) {
        if (Math.random() < 0.8) {
            return pick(SIMULATED_AI.regional[region][category]);
        }
    }

    // Fall back to English
    return pick(SIMULATED_AI[category] || []);
}

// Helper function to get localized dialogue by index (for warnings)
function getLocalizedSimonWarning(index) {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : null;

    // Try region-specific warning first
    if (region && SIMULATED_AI.regional[region] && SIMULATED_AI.regional[region].simon_warnings) {
        const warnings = SIMULATED_AI.regional[region].simon_warnings;
        if (warnings[index]) return warnings[index];
    }

    // Fall back to English
    const defaultWarnings = SIMULATED_AI.simon_warnings || [];
    return defaultWarnings[index] || defaultWarnings[0] || "";
}

// Helper function to pick region-specific tips when offline
function pickRegionTip() {
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

    // Get current region (may not be set during early load)
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EU';

    // Filter tips for current region (tips start with [DE], [AT], or [NL])
    const regionPrefix = `[${region}]`;
    const regionTips = SIMULATED_AI.tips.filter(tip => tip.startsWith(regionPrefix));
    const genericTips = SIMULATED_AI.tips.filter(tip => !tip.startsWith('['));

    // 60% chance to show region-specific tip if available
    if (regionTips.length > 0 && Math.random() < 0.6) {
        return pick(regionTips);
    }

    // Otherwise return a generic tip
    return pick(genericTips.length > 0 ? genericTips : SIMULATED_AI.tips);
}

// --- SIMON'S YARD SAFETY TIPS ---
const SIMON_YARD_TIPS = {
    EN: [
        "YARD SAFETY ALERT: Always use designated crosswalks. DSP vans have blind spots bigger than their ambition. I've measured both.",
        "CAUTION: The yard is NOT a shortcut. One associate versus a Prime van equals paperwork I don't want to file. And I file EVERYTHING.",
        "REMINDER: Look both ways. Then look again. Those DSP drivers run on caffeine and impossible deadlines. A dangerous combination I know well.",
        "YARD PROTOCOL: High-vis vests exist for a reason. Be seen or be statistics. I prefer you as a headcount, not a body count.",
        "CRITICAL: Vehicles have right of way. Your skeleton does not outweigh a delivery quota. Trust me, I've done the math.",
        "SAFETY FIRST: If you hear a horn, MOVE. Don't stand there contemplating the meaning of life. Spoiler: it's compliance.",
        "PRO TIP: Headphones off in the yard. Music won't cushion the blow of a reversing semi. Neither will your Spotify premium subscription.",
        "AUDIT NOTE: The yard claims more near-misses than I have patience. Stay alert, stay alive. Or don't. Your choice affects MY metrics."
    ],
    AT: [
        "HOF-SICHERHEIT: Immer die Zebrastreifen benutzen, oida. DSP-Transporter haben gr√∂√üere tote Winkel als Ehrgeiz.",
        "ACHTUNG: Der Hof is ka Abk√ºrzung. Ein Mitarbeiter gegen an Prime-Transporter bedeutet Papierkram, den i ned will.",
        "ERINNERUNG: Schau links und rechts. Dann nochmal. Die DSP-Fahrer laufen auf Koffein und unm√∂glichen Deadlines.",
        "HOF-PROTOKOLL: Warnwesten gibt's aus gutem Grund. Gsehen werden oder Statistik werden.",
        "KRITISCH: Fahrzeuge haben Vorfahrt. Dei Skelett wiegt ned mehr als a Lieferquote.",
        "SICHERHEIT ZUERST: Wenn du a Hupe h√∂rst, BEWEG DI. Steh ned rum und denk √ºber den Sinn des Lebens nach.",
        "PROFI-TIPP: Kopfh√∂rer runter im Hof. Musik d√§mpft ned den Aufprall eines r√ºckw√§rtsfahrenden LKWs.",
        "AUDIT-NOTIZ: Der Hof hat mehr Beinahe-Unf√§lle als i Geduld hab. Bleib wachsam, bleib am Leben."
    ],
    DE: [
        "HOF-SICHERHEIT: Immer die Zebrastreifen benutzen. DSP-Transporter haben gr√∂√üere tote Winkel als Ehrgeiz.",
        "ACHTUNG: Der Hof ist keine Abk√ºrzung. Ein Mitarbeiter gegen einen Prime-Transporter bedeutet Papierkram.",
        "ERINNERUNG: Schau links und rechts. Dann nochmal. Die DSP-Fahrer laufen auf Koffein und unm√∂glichen Deadlines.",
        "HOF-PROTOKOLL: Warnwesten gibt es aus gutem Grund. Gesehen werden oder Statistik werden.",
        "KRITISCH: Fahrzeuge haben Vorfahrt. Dein Skelett wiegt nicht mehr als eine Lieferquote.",
        "SICHERHEIT ZUERST: Wenn du eine Hupe h√∂rst, BEWEG DICH. Steh nicht rum und denk √ºber den Sinn des Lebens nach.",
        "PROFI-TIPP: Kopfh√∂rer runter im Hof. Musik d√§mpft nicht den Aufprall eines r√ºckw√§rtsfahrenden LKWs.",
        "AUDIT-NOTIZ: Der Hof hat mehr Beinahe-Unf√§lle als ich Geduld habe. Bleib wachsam, bleib am Leben."
    ],
    NL: [
        "TERREIN-VEILIGHEID: Gebruik altijd de zebrapaden, godver. DSP-busjes hebben grotere dode hoeken dan ambitie. Ik heb beide gemeten.",
        "LET OP: Het terrein is GEEN afkorting, eikel. E√©n medewerker tegen een Prime-bus betekent papierwerk dat ik verdomme niet wil doen.",
        "HERINNERING: Kijk links en rechts. Dan nog een keer, klojo. Die DSP-chauffeurs draaien op cafe√Øne en onmogelijke deadlines.",
        "TERREIN-PROTOCOL: Veiligheidsvesten bestaan met een reden, sukkel. Gezien worden of statistiek worden. Jouw keuze, godver.",
        "KRITIEK: Voertuigen hebben voorrang. Je skelet weegt verdomme niet meer dan een leveringsquota. Geloof me, ik heb gerekend.",
        "VEILIGHEID EERST: Als je een claxon hoort, BEWEEG, idioot. Sta niet stil na te denken over de zin van het leven. Spoiler: het is compliance.",
        "PRO TIP: Koptelefoon af op het terrein, dombo. Muziek dempt de klap van een achteruitrijdende vrachtwagen niet. Je Spotify premium ook niet.",
        "AUDIT NOTITIE: Het terrein heeft meer bijna-ongelukken dan ik geduld heb, godver. Blijf alert, blijf in leven. Of niet. Jouw keuze be√Ønvloedt MIJN metrics."
    ]
};

// Helper to get localized yard tip
function getLocalizedYardTip() {
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
    const tips = SIMON_YARD_TIPS[region] || SIMON_YARD_TIPS.EN;
    return pick(tips);
}

// --- JEFF YARD TAUNTS (Localized) ---
const JEFF_YARD_TAUNTS = {
    EN: [
        "Come on then! I haven't got all day!",
        "You call that speed? My grandmother moves faster!",
        "The yard separates the workers from the WIMPS!",
        "Every second you waste costs the company money!",
        "I built this empire from NOTHING!",
        "You want a raise? EARN IT!",
        "Keep dodging! It's good entertainment!",
        "I've seen better coordination from interns!",
        "Tick tock! Your shift is almost OVER!",
        "Almost there... just kidding, you'll never make it!",
        "This is YOUR performance review!",
        "The trucks don't stop for ANYONE!"
    ],
    AT: [
        "Na los, oida! I hab ned den ganzen Tag Zeit!",
        "Des nennst du schnell? Mei Oma is schneller!",
        "Der Hof trennt die Hackler von die Weicheier!",
        "Jede Sekunde kostet die Firma G√∂d!",
        "I hab des Imperium aus NIX aufbaut!",
        "Du willst a Gehaltserh√∂hung? VERDIEN sie da!",
        "Weiter ausweichen! Is a guate Unterhaltung!",
        "I hab bessere Koordination von Praktikanten gsehen!",
        "Tick tack! Dei Schicht is fast vorbei!",
        "Fast da... ha, Scherz, du schaffst es nie!",
        "Des is DEINE Leistungsbeurteilung!",
        "Die LKWs halten f√ºr NIEMANDEN!"
    ],
    DE: [
        "Na los! Ich hab nicht den ganzen Tag Zeit!",
        "Das nennst du Geschwindigkeit? Meine Oma ist schneller!",
        "Der Hof trennt die Arbeiter von den WEICHEIERN!",
        "Jede Sekunde kostet die Firma Geld!",
        "Ich habe dieses Imperium aus NICHTS aufgebaut!",
        "Du willst eine Gehaltserh√∂hung? VERDIEN sie dir!",
        "Weiter ausweichen! Gute Unterhaltung!",
        "Ich habe bessere Koordination von Praktikanten gesehen!",
        "Tick tack! Deine Schicht ist fast vorbei!",
        "Fast da... nur Spa√ü, du schaffst es nie!",
        "Das ist DEINE Leistungsbeurteilung!",
        "Die LKWs halten f√ºr NIEMANDEN!"
    ],
    NL: [
        "Kom op dan! Ik heb niet de hele dag!",
        "Noem je dat snelheid? Mijn oma is sneller!",
        "Het terrein scheidt de werkers van de WATJES!",
        "Elke seconde kost het bedrijf geld!",
        "Ik heb dit imperium uit NIETS opgebouwd!",
        "Wil je opslag? VERDIEN het!",
        "Blijf ontwijken! Leuke entertainment!",
        "Ik heb betere co√∂rdinatie van stagiaires gezien!",
        "Tik tak! Je dienst is bijna voorbij!",
        "Bijna... grapje, je haalt het nooit!",
        "Dit is JOUW functioneringsgesprek!",
        "De vrachtwagens stoppen voor NIEMAND!"
    ]
};

// --- JEFF CASTLE TAUNTS (Localized) ---
const JEFF_CASTLE_TAUNTS = {
    EN: [
        "WELCOME TO MY FORTRESS OF EFFICIENCY!",
        "THIS CASTLE WAS BUILT ON PRIME SUBSCRIPTIONS!",
        "EVERY BRICK IS A WORKER'S DREAM... CRUSHED!",
        "YOU DARE ENTER THE BEZOS DOMAIN?!",
        "MY TOWERS REACH HIGHER THAN YOUR AMBITIONS!",
        "THE ALGORITHMS DESIGNED THIS MAZE!",
        "NO UNION CAN SIEGE THESE WALLS!",
        "THIS IS WHERE WORKERS BECOME... OPTIMIZED!",
        "THE CASTLE IS MY FINAL WAREHOUSE!",
        "ONLY THE WORTHY MEET MECHA JEFF!"
    ],
    AT: [
        "WILLKOMMEN IN MEINER FESTUNG DER EFFIZIENZ!",
        "DES SCHLOSS WURDE AUF PRIME-ABOS GEBAUT!",
        "JEDER ZIEGEL IS A ARBEITERTRAUM... ZERMALMT!",
        "DU WAGST ES IN DIE BEZOS-DOM√ÑNE?!",
        "MEINE T√úRME REICHEN H√ñHER ALS DEINE AMBITIONEN!",
        "DIE ALGORITHMEN HABEN DES LABYRINTH DESIGNT!",
        "KA GEWERKSCHAFT KANN DIESE MAUERN BELAGERN!",
        "DO WERDEN ARBEITER... OPTIMIERT!",
        "DES SCHLOSS IS MEI LETZTES LAGER!",
        "NUR DIE W√úRDIGEN TREFFEN MECHA JEFF!"
    ],
    DE: [
        "WILLKOMMEN IN MEINER FESTUNG DER EFFIZIENZ!",
        "DIESES SCHLOSS WURDE AUF PRIME-ABOS GEBAUT!",
        "JEDER ZIEGEL IST EIN ARBEITERTRAUM... ZERMALMT!",
        "DU WAGST ES IN DIE BEZOS-DOM√ÑNE?!",
        "MEINE T√úRME REICHEN H√ñHER ALS DEINE AMBITIONEN!",
        "DIE ALGORITHMEN HABEN DIESES LABYRINTH DESIGNT!",
        "KEINE GEWERKSCHAFT KANN DIESE MAUERN BELAGERN!",
        "HIER WERDEN ARBEITER... OPTIMIERT!",
        "DAS SCHLOSS IST MEIN LETZTES LAGER!",
        "NUR DIE W√úRDIGEN TREFFEN MECHA JEFF!"
    ],
    NL: [
        "WELKOM IN MIJN FORT VAN EFFICI√ãNTIE!",
        "DIT KASTEEL IS GEBOUWD OP PRIME-ABONNEMENTEN!",
        "ELKE STEEN IS EEN ARBEIDERSDROOM... VERPLETTERD!",
        "DURF JE HET BEZOS-DOMEIN TE BETREDEN?!",
        "MIJN TORENS REIKEN HOGER DAN JE AMBITIES!",
        "DE ALGORITMES ONTWIERPEN DIT DOOLHOF!",
        "GEEN VAKBOND KAN DEZE MUREN BELEGEREN!",
        "HIER WORDEN WERKERS... GEOPTIMALISEERD!",
        "HET KASTEEL IS MIJN LAATSTE MAGAZIJN!",
        "ALLEEN DE WAARDIGEN ONTMOETEN MECHA JEFF!"
    ]
};

// --- BEZOS TAUNTS FOR BOSS FIGHT (Localized) ---
const BEZOS_TAUNTS = {
    EN: [
        "Work harder, not smarter!",
        "Day One? Try Day DONE!",
        "No bathroom breaks in space!",
        "Prime delivery: FAILURE!",
        "Your metrics are TERRIBLE!",
        "Automate or ELIMINATE!",
        "I'm watching your IDLE TIME!",
        "Customer obsession DEMANDS speed!",
        "Move faster! Time is MONEY!",
        "Safety? I have insurance!",
        "Ownership? I own EVERYTHING!",
        "Think BIG or go HOME!",
        "Deliver RESULTS or get REPLACED!",
        "Automation never complains!"
    ],
    AT: [
        "H√§rter hackeln, ned gscheiter!",
        "Tag Eins? Probier Tag ENDE!",
        "Ka Klopause im Weltall!",
        "Prime-Lieferung: VERSAGT!",
        "Deine Metriken san FURCHTBAR!",
        "Automatisieren oder ELIMINIEREN!",
        "I beobacht deine STILLSTANDSZEIT!",
        "Kundenobsession VERLANGT Tempo!",
        "Schneller! Zeit is G√ñD!",
        "Sicherheit? I hab a Versicherung!",
        "Ownership? MIR GH√ñRT ALLES!",
        "Denk GROSS oder geh HAM!",
        "Liefer ERGEBNISSE oder wirst ERSETZT!",
        "Automatisierung beschwert si nie!"
    ],
    DE: [
        "H√§rter arbeiten, nicht schlauer!",
        "Tag Eins? Versuch Tag ENDE!",
        "Keine Toilettenpause im Weltall!",
        "Prime-Lieferung: VERSAGT!",
        "Deine Metriken sind FURCHTBAR!",
        "Automatisieren oder ELIMINIEREN!",
        "Ich beobachte deine STILLSTANDSZEIT!",
        "Kundenobsession VERLANGT Geschwindigkeit!",
        "Schneller! Zeit ist GELD!",
        "Sicherheit? Ich habe Versicherung!",
        "Ownership? MIR GEH√ñRT ALLES!",
        "Denk GROSS oder geh NACH HAUSE!",
        "Liefer ERGEBNISSE oder wirst ERSETZT!",
        "Automatisierung beschwert sich nie!"
    ],
    NL: [
        "Harder werken, niet slimmer!",
        "Dag Een? Probeer Dag KLAAR!",
        "Geen toiletpauze in de ruimte!",
        "Prime-levering: MISLUKT!",
        "Je metrics zijn VERSCHRIKKELIJK!",
        "Automatiseren of ELIMINEREN!",
        "Ik bekijk je STILSTANDTIJD!",
        "Klantobsessie EIST snelheid!",
        "Sneller! Tijd is GELD!",
        "Veiligheid? Ik heb verzekering!",
        "Eigenaarschap? IK BEZIT ALLES!",
        "Denk GROOT of ga NAAR HUIS!",
        "Lever RESULTATEN of word VERVANGEN!",
        "Automatisering klaagt nooit!"
    ]
};

// Helper to get localized Jeff taunt
function getLocalizedJeffTaunt(type) {
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';

    if (type === 'yard') {
        const taunts = JEFF_YARD_TAUNTS[region] || JEFF_YARD_TAUNTS.EN;
        return pick(taunts);
    } else if (type === 'castle') {
        const taunts = JEFF_CASTLE_TAUNTS[region] || JEFF_CASTLE_TAUNTS.EN;
        return pick(taunts);
    } else {
        const taunts = BEZOS_TAUNTS[region] || BEZOS_TAUNTS.EN;
        return pick(taunts);
    }
}

// --- SNARKY CORPORATE GAME OVER MESSAGES ---
const CORPORATE_GAME_OVER = [
    "Your employment has been optimized out of existence.",
    "Thank you for your contribution to our quarterly injury statistics.",
    "Your position has been automated. Have a nice day.",
    "Performance review: Below expectations. Way below.",
    "Security will escort your badge to recycling.",
    "Your final paycheck will be mailed... eventually.",
    "Customer obsession doesn't include your safety, apparently.",
    "Think of this as a permanent growth opportunity elsewhere.",
    "Your metrics suggest a career in literally anything else.",
    "Day One mentality? More like Final Day reality.",
    "HR has prepared your exit interview. It's just a door.",
    "Your TOT just became permanent. Time Off: Total.",
    "Ownership principle achieved: You now own nothing.",
    "Congratulations! You've been promoted to customer.",
    "Your bias for action led to this inaction. Forever.",
    "Frugality win: We saved money on your benefits.",
    "Deliver results? You delivered... disappointment.",
    "Invent and simplify: Inventing a new career, simplified exit."
];

// --- CHARACTER DEFEAT VOICE LINES ---
const CHARACTER_DEFEAT_LINES = {
    "Carrie": [
        "My labels... all crooked now...",
        "The 5S system... failed me... or I failed it...",
        "Even my precision couldn't save me from this mess.",
        "Sort, Set, Shine, Standardize... Surrender."
    ],
    "Nevena": [
        "The Oracle did not foresee this outcome...",
        "My clipboard... it predicted everything except my defeat.",
        "Documentation complete: Status - Terminated.",
        "Even my emergency Palatschinken couldn't save me."
    ],
    "Joao": [
        "My warnings... nobody heard them in time...",
        "The Siren goes silent... forever...",
        "All that espresso... wasted...",
        "I couldn't shout loud enough to stop this."
    ],
    "Roman": [
        "Even ghosts can be eliminated...",
        "I vanished one too many times...",
        "The audit trail... ends here...",
        "Should have stayed invisible longer."
    ],
    "Erwin": [
        "My Tesla... my beautiful Tesla...",
        "One life wasn't enough...",
        "Drifted right into disaster...",
        "The Manager has been managed... out."
    ]
};

// --- AI TEXT HELPERS ---
function personalizeAIText(text) {
    if (!text) return text;
    const name = (typeof GAME !== 'undefined' && GAME.selectedChar) ? GAME.selectedChar : 'Coordinator';
    const patterns = [
        /\[\s*player\s*name\s*\]/gi,
        /\{\s*player\s*name\s*\}/gi,
        /<\s*player\s*name\s*>/gi,
        /player name/gi,
        /\[\s*player\s*\]/gi,
        /\{\s*player\s*\}/gi,
        /<\s*player\s*>/gi
    ];
    let cleaned = text;
    patterns.forEach(p => { cleaned = cleaned.replace(p, name); });
    return cleaned;
}

async function fetchApiKeyFromNetlify() {
    try {
        const res = await fetch('/.netlify/functions/get-gemini-key', { cache: 'no-store' });
        if (!res.ok) throw new Error(`Netlify key endpoint returned ${res.status}`);
        const data = await res.json();
        const key = (data && data.apiKey ? String(data.apiKey) : '').trim();
        if (!key) throw new Error('No apiKey field in Netlify response');
        apiKey = key;
        return apiKey;
    } catch (err) {
        return null;
    }
}

async function ensureApiKey() {
    if (apiKey) return apiKey;
    if (!apiKeyPromise) apiKeyPromise = fetchApiKeyFromNetlify();
    return apiKeyPromise;
}

// --- GEMINI API ---
async function callGemini(prompt, category = 'generic', context = {}) {
    const activeKey = await ensureApiKey();
    if (!activeKey) {
        return personalizeAIText(getRandomFallback(prompt, category, context));
    }

    const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${activeKey}`;
    const payload = { 
        contents: [{ 
            parts: [{ text: prompt }] 
        }] 
    };
    const timeout = new Promise((r) => setTimeout(() => r("TIMEOUT"), 10000));

    try {
        const fetchPromise = fetch(url, { 
            method: 'POST', 
            headers: { 'Content-Type': 'application/json' }, 
            body: JSON.stringify(payload) 
        });
        const response = await Promise.race([fetchPromise, timeout]);
        
        if (response === "TIMEOUT") return personalizeAIText(getRandomFallback(prompt, category, context));
        if (!response.ok) return personalizeAIText(getRandomFallback(prompt, category, context));
        
        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (text) return personalizeAIText(text.trim());
        return personalizeAIText(getRandomFallback(prompt, category, context));

    } catch (e) {
        return personalizeAIText(getRandomFallback(prompt, category, context));
    }
}

// Localized bezos_transform fallbacks
const BEZOS_TRANSFORM_LINES = {
    EN: [
        "WITNESS MY TRUE FORM! MECHA JEFF RISES!",
        "You forced this! BEHOLD MY ULTIMATE POWER!",
        "NOW YOU DIE! TRANSFORMATION SEQUENCE INITIATED!",
        "FOOLISH WORKER! FACE MY MECHANICAL MIGHT!",
        "PRIME TIME IS OVER! EXTINCTION MODE ACTIVATED!"
    ],
    AT: [
        "SIEH MEINE WAHRE FORM! MECHA JEFF ERHEBT SI!",
        "Du hast des erzwungen! SIEH MEINE ULTIMATIVE MACHT!",
        "JETZT STIRBST DU! TRANSFORMATIONSSEQUENZ AKTIVIERT!",
        "DUMMER HACKLER! STELL DI MEINER MECHANISCHEN MACHT!",
        "PRIME TIME IS VORBEI! AUSL√ñSCHUNGSMODUS AKTIVIERT!"
    ],
    DE: [
        "SEHT MEINE WAHRE FORM! MECHA JEFF ERHEBT SICH!",
        "Du hast das erzwungen! SEHT MEINE ULTIMATIVE MACHT!",
        "JETZT STIRBST DU! TRANSFORMATIONSSEQUENZ INITIIERT!",
        "DUMMER ARBEITER! STELL DICH MEINER MECHANISCHEN MACHT!",
        "PRIME TIME IST VORBEI! AUSL√ñSCHUNGSMODUS AKTIVIERT!"
    ],
    NL: [
        "AANSCHOUW MIJN WARE VORM! MECHA JEFF RIJST!",
        "Jij dwong dit af! AANSCHOUW MIJN ULTIEME KRACHT!",
        "NU STERF JE! TRANSFORMATIEREEKS GESTART!",
        "DWAZE WERKER! ONTMOET MIJN MECHANISCHE MACHT!",
        "PRIME TIME IS VOORBIJ! UITROEIINGSMODUS GEACTIVEERD!"
    ]
};

// Localized player_response fallbacks
const PLAYER_RESPONSE_LINES = {
    EN: [
        "Your reign of terror ends here, Bezos!",
        "The workers will NOT be silenced!",
        "Time to break your prime directive!",
        "This delivery is YOUR termination notice!",
        "No more exploiting workers! Today you fall!"
    ],
    AT: [
        "Deine Schreckensherrschaft endet do, Bezos!",
        "Die Hackler lassen si ned zum Schweigen bringen!",
        "Zeit deine Prime-Direktive zu brechen!",
        "Des is DEINE K√ºndigung!",
        "Ka Ausbeutung mehr! Heit f√§llst du!"
    ],
    DE: [
        "Deine Schreckensherrschaft endet hier, Bezos!",
        "Die Arbeiter lassen sich NICHT zum Schweigen bringen!",
        "Zeit deine Prime-Direktive zu brechen!",
        "Diese Lieferung ist DEINE K√ºndigung!",
        "Keine Ausbeutung mehr! Heute f√§llst du!"
    ],
    NL: [
        "Je schrikbewind eindigt hier, Bezos!",
        "De werkers zullen NIET zwijgen!",
        "Tijd om je prime-directief te breken!",
        "Deze levering is JOUW ontslagbrief!",
        "Geen uitbuiting meer! Vandaag val je!"
    ]
};

// Localized Mecha Bezos battle taunts
const MECHA_BEZOS_TAUNTS = {
    EN: [
        "YOUR METRICS ARE UNACCEPTABLE!",
        "TWO-DAY SHIPPING... FOR YOUR DOOM!",
        "PRIME DIRECTIVE: ELIMINATE!",
        "CUSTOMER OBSESSION... WITH DESTRUCTION!",
        "BEZOS PROTOCOL ENGAGED!"
    ],
    AT: [
        "DEINE METRIKEN SIND INAKZEPTABEL!",
        "ZWEI-TAGE-LIEFERUNG... F√úR DEIN VERDERBEN!",
        "PRIME-DIREKTIVE: ELIMINIEREN!",
        "KUNDENOBSESSION... MIT ZERST√ñRUNG!",
        "BEZOS-PROTOKOLL AKTIVIERT!"
    ],
    DE: [
        "DEINE METRIKEN SIND INAKZEPTABEL!",
        "ZWEI-TAGE-LIEFERUNG... F√úR DEIN VERDERBEN!",
        "PRIME-DIREKTIVE: ELIMINIEREN!",
        "KUNDENOBSESSION... MIT ZERST√ñRUNG!",
        "BEZOS-PROTOKOLL AKTIVIERT!"
    ],
    NL: [
        "JE METRICS ZIJN ONAANVAARDBAAR!",
        "TWEE-DAGEN-LEVERING... VOOR JE ONDERGANG!",
        "PRIME-DIRECTIEF: ELIMINEREN!",
        "KLANTOBSESSIE... MET VERNIETIGING!",
        "BEZOS-PROTOCOL GEACTIVEERD!"
    ]
};

// Localized Mecha Bezos attack messages
const MECHA_BEZOS_ATTACKS = {
    EN: { enraged: "ENRAGED!", primeDelivery: "PRIME DELIVERY!", primeNow: "PRIME NOW!" },
    AT: { enraged: "RASEND!", primeDelivery: "PRIME-LIEFERUNG!", primeNow: "PRIME JETZT!" },
    DE: { enraged: "RASEND!", primeDelivery: "PRIME-LIEFERUNG!", primeNow: "PRIME JETZT!" },
    NL: { enraged: "WOEDEND!", primeDelivery: "PRIME-LEVERING!", primeNow: "PRIME NU!" }
};

// Localized Mecha Jeff phase names
const MECHA_JEFF_PHASE_NAMES = {
    EN: ['PRIME STRIKE', 'DRONE SWARM', 'PACKAGE STORM', 'LASER GRID', 'GROUND SLAM'],
    AT: ['PRIME-ANGRIFF', 'DROHNENSCHWARM', 'PAKETSTURM', 'LASERGITTER', 'BODENSCHLAG'],
    DE: ['PRIME-ANGRIFF', 'DROHNENSCHWARM', 'PAKETSTURM', 'LASERGITTER', 'BODENSCHLAG'],
    NL: ['PRIME-AANVAL', 'DRONENZWERM', 'PAKKETSTORM', 'LASERRASTER', 'GRONDSLAG']
};

// Localized Mecha Jeff phase taunts
const MECHA_JEFF_PHASE_TAUNTS = {
    EN: [
        "PRIME DELIVERY INCOMING!",
        "RELEASE THE DRONES!",
        "BOXES FROM THE SKY!",
        "LASER PRECISION!",
        "FEEL THE EARTH SHAKE!"
    ],
    AT: [
        "PRIME-LIEFERUNG IM ANMARSCH!",
        "DROHNEN LOSGELASSEN!",
        "PAKETE VOM HIMMEL!",
        "LASERPR√ÑZISION!",
        "SP√úR DIE ERDE BEBEN!"
    ],
    DE: [
        "PRIME-LIEFERUNG IM ANMARSCH!",
        "DROHNEN LOSGELASSEN!",
        "PAKETE VOM HIMMEL!",
        "LASERPR√ÑZISION!",
        "SP√úRT DIE ERDE BEBEN!"
    ],
    NL: [
        "PRIME-LEVERING ONDERWEG!",
        "LAAT DE DRONES LOS!",
        "DOZEN UIT DE LUCHT!",
        "LASERPRECISIE!",
        "VOEL DE AARDE SCHUDDEN!"
    ]
};

// Helper to get localized Mecha Jeff phase names
function getLocalizedMechaJeffPhaseNames() {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
    return MECHA_JEFF_PHASE_NAMES[region] || MECHA_JEFF_PHASE_NAMES.EN;
}

// Helper to get localized Mecha Jeff phase taunts
function getLocalizedMechaJeffPhaseTaunts() {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
    return MECHA_JEFF_PHASE_TAUNTS[region] || MECHA_JEFF_PHASE_TAUNTS.EN;
}

// Localized Security Activation message (shown when crossing first laser beam)
const SECURITY_ACTIVATION_TEXTS = {
    EN: { title: "AMAZON SECURITY ACTIVATED", subtitle: "Laser grid online!" },
    AT: { title: "AMAZON SICHERHEIT AKTIVIERT", subtitle: "Lasergitter online!" },
    DE: { title: "AMAZON SICHERHEIT AKTIVIERT", subtitle: "Lasergitter online!" },
    NL: { title: "AMAZON BEVEILIGING GEACTIVEERD", subtitle: "Laserraster online!" }
};

// Helper to get localized security activation text
function getLocalizedSecurityActivation() {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
    return SECURITY_ACTIVATION_TEXTS[region] || SECURITY_ACTIVATION_TEXTS.EN;
}

// === WAREHOUSE RANDOM EVENTS SYSTEM ===
// One random event triggers per game with random timer
const WAREHOUSE_EVENTS = {
    OPS_GEMBA: {
        id: 'OPS_GEMBA',
        duration: 900, // 15 seconds at 60fps
        warning: {
            EN: "OPS GEMBA WALK",
            AT: "OPS GEMBA RUNDGANG",
            DE: "OPS GEMBA RUNDGANG",
            NL: "OPS GEMBA RONDE"
        },
        subtitle: {
            EN: "Management patrol incoming!",
            AT: "F√ºhrungsteam kommt!",
            DE: "F√ºhrungsteam kommt!",
            NL: "Management patrouille nadert!"
        }
    },
    ENERGY_CUTOFF: {
        id: 'ENERGY_CUTOFF',
        duration: 600, // 10 seconds
        warning: {
            EN: "POWER OUTAGE",
            AT: "STROMAUSFALL",
            DE: "STROMAUSFALL",
            NL: "STROOMSTORING"
        },
        subtitle: {
            EN: "Emergency lights only!",
            AT: "Nur Notbeleuchtung!",
            DE: "Nur Notbeleuchtung!",
            NL: "Alleen noodverlichting!"
        }
    },
    TPH_RUSH: {
        id: 'TPH_RUSH',
        duration: 720, // 12 seconds
        warning: {
            EN: "TPH RUSH HOUR",
            AT: "TPH HOCHBETRIEB",
            DE: "TPH HOCHBETRIEB",
            NL: "TPH PIEKUUR"
        },
        subtitle: {
            EN: "OPS are faster and tougher!",
            AT: "OPS sind schneller und h√§rter!",
            DE: "OPS sind schneller und h√§rter!",
            NL: "OPS zijn sneller en sterker!"
        }
    },
    FIRE_DRILL: {
        id: 'FIRE_DRILL',
        duration: 600, // 10 seconds
        warning: {
            EN: "FIRE DRILL",
            AT: "FEUERALARM",
            DE: "FEUERALARM",
            NL: "BRANDOEFENING"
        },
        subtitle: {
            EN: "Evacuate! OPS are watching!",
            AT: "Evakuieren! OPS beobachten!",
            DE: "Evakuieren! OPS beobachten!",
            NL: "Evacueren! OPS kijken toe!"
        }
    },
    PRIME_DAY: {
        id: 'PRIME_DAY',
        duration: 900, // 15 seconds
        warning: {
            EN: "PRIME DAY CHAOS",
            AT: "PRIME DAY CHAOS",
            DE: "PRIME DAY CHAOS",
            NL: "PRIME DAY CHAOS"
        },
        subtitle: {
            EN: "Dodge the package storm!",
            AT: "Weiche dem Paketsturm aus!",
            DE: "Weiche dem Paketsturm aus!",
            NL: "Ontwijken de pakketstorm!"
        }
    }
};

// Get localized event text
function getLocalizedEventText(event, field) {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
    return event[field][region] || event[field].EN;
}

// Initialize random warehouse event for this game
function initWarehouseEvent() {
    queueNextWarehouseEvent(true); // true = first event
}

// Queue the next warehouse event
function queueNextWarehouseEvent(isFirst = false) {
    const eventKeys = Object.keys(WAREHOUSE_EVENTS);
    const selectedEvent = WAREHOUSE_EVENTS[eventKeys[Math.floor(Math.random() * eventKeys.length)]];

    // Random trigger time between 15-45 seconds (900-2700 frames)
    const triggerTime = 900 + Math.floor(Math.random() * 1800);

    GAME.warehouseEvent = {
        type: selectedEvent,
        triggerTime: triggerTime,
        triggered: false,
        active: false,
        timer: 0,
        warningTimer: 0,
        warningPhase: 0, // 0 = not shown, 1 = showing, 2 = done
        gembaOps: [], // For OPS_GEMBA event
        originalOpsStats: null, // For TPH_RUSH event
        primeDayPackages: [] // For PRIME_DAY event
    };
}

// Update warehouse event system
function updateWarehouseEvent() {
    if (!GAME.warehouseEvent || GAME.state !== 'PLAY') return;

    const ev = GAME.warehouseEvent;

    // Check if event should trigger
    if (!ev.triggered) {
        ev.timer++;
        if (ev.timer >= ev.triggerTime) {
            ev.triggered = true;
            ev.warningPhase = 1;
            ev.warningTimer = 0;
            AudioSys.sfx.alert();
        }
        return;
    }

    // Warning phase
    if (ev.warningPhase === 1) {
        ev.warningTimer++;
        if (ev.warningTimer >= 180) { // 3 second warning
            ev.warningPhase = 2;
            ev.active = true;
            ev.timer = 0;
            startEventEffects(ev.type);
        }
        return;
    }

    // Active event phase
    if (ev.active) {
        ev.timer++;
        updateEventEffects(ev.type);

        if (ev.timer >= ev.type.duration) {
            ev.active = false;
            endEventEffects(ev.type);
        }
    }
}

// Start event-specific effects
function startEventEffects(eventType) {
    const p = GAME.player;

    switch (eventType.id) {
        case 'OPS_GEMBA':
            // Spawn 6 OPS in a patrol group
            const startX = Math.random() < 0.5 ? 50 : MAP_W * TILE_SIZE - 100;
            const startY = 100 + Math.random() * 100;
            for (let i = 0; i < 6; i++) {
                GAME.entities.push({
                    type: 'ops',
                    x: startX + (i % 3) * 24,
                    y: startY + Math.floor(i / 3) * 24,
                    w: 16, h: 16,
                    dir: startX < 100 ? 1 : -1,
                    gembaPatrol: true, // Mark as gemba patrol
                    patrolSpeed: 1.2
                });
            }
            GAME.shake = 10;
            break;

        case 'ENERGY_CUTOFF':
            GAME.flashlightMode = true;
            GAME.flashlightRadius = 45;
            break;

        case 'TPH_RUSH':
            // Boost all OPS speed and give them 2 HP
            GAME.warehouseEvent.originalOpsStats = [];
            GAME.entities.forEach((e, idx) => {
                if (e.type === 'ops') {
                    GAME.warehouseEvent.originalOpsStats.push({ idx, hp: e.hp || 1 });
                    e.tphRush = true;
                    e.hp = 2;
                }
            });
            break;

        case 'FIRE_DRILL':
            // Fire drill: OPS become hyper-vigilant, spawn extra patrol OPS
            GAME.fireDrillActive = true;
            GAME.shake = 15;
            // Spawn 4 extra aggressive OPS that patrol quickly
            for (let i = 0; i < 4; i++) {
                const side = i % 4;
                let fx, fy;
                if (side === 0) { fx = 50; fy = 50 + i * 60; }
                else if (side === 1) { fx = MAP_W * TILE_SIZE - 50; fy = 50 + i * 60; }
                else if (side === 2) { fx = 50 + i * 80; fy = 50; }
                else { fx = 50 + i * 80; fy = MAP_H * TILE_SIZE - 50; }
                GAME.entities.push({
                    type: 'ops',
                    x: fx, y: fy, w: 16, h: 16,
                    fireDrillOps: true,
                    hp: 2
                });
            }
            // Make existing OPS more aggressive (tracked by flag)
            GAME.entities.forEach(e => {
                if (e.type === 'ops' && !e.fireDrillOps) {
                    e.fireDrillAggro = true;
                }
            });
            break;

        case 'PRIME_DAY':
            // Prime Day chaos: Many runners, falling packages, OPS everywhere
            GAME.primeDayActive = true;
            // Spawn 8 runners
            for (let i = 0; i < 8; i++) {
                const rx = 50 + Math.random() * (MAP_W * TILE_SIZE - 100);
                const ry = 50 + Math.random() * (MAP_H * TILE_SIZE - 100);
                GAME.entities.push({
                    type: 'runner',
                    x: rx, y: ry, w: 16, h: 16,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    primeDay: true
                });
            }
            // Spawn 3 extra OPS
            for (let i = 0; i < 3; i++) {
                const ox = 100 + Math.random() * (MAP_W * TILE_SIZE - 200);
                const oy = 100 + Math.random() * (MAP_H * TILE_SIZE - 200);
                GAME.entities.push({
                    type: 'ops',
                    x: ox, y: oy, w: 16, h: 16,
                    primeDay: true,
                    hp: 1
                });
            }
            GAME.shake = 10;
            break;
    }
}

// Update event-specific effects each frame
function updateEventEffects(eventType) {
    switch (eventType.id) {
        case 'OPS_GEMBA':
            // Gemba patrol moves across the map
            GAME.entities.forEach(e => {
                if (e.gembaPatrol) {
                    e.x += e.dir * e.patrolSpeed;
                    // Remove if off screen
                    if (e.x < -50 || e.x > MAP_W * TILE_SIZE + 50) {
                        e.remove = true;
                    }
                }
            });
            GAME.entities = GAME.entities.filter(e => !e.remove);
            break;

        case 'ENERGY_CUTOFF':
            // Flashlight flickers occasionally
            if (Math.random() < 0.02) {
                GAME.flashlightRadius = 30 + Math.random() * 30;
            }
            break;

        case 'TPH_RUSH':
            // OPS move faster
            // (handled in updateEntities by checking tphRush flag)
            break;

        case 'FIRE_DRILL':
            // Alarm sounds and OPS shoot more frequently
            if (GAME.warehouseEvent.timer % 45 === 0) {
                AudioSys.sfx.alert();
            }
            // Fire drill OPS actively chase player
            GAME.entities.forEach(e => {
                if (e.fireDrillOps || e.fireDrillAggro) {
                    const d = Math.hypot(GAME.player.x - e.x, GAME.player.y - e.y);
                    if (d < 150) {
                        // Chase faster during fire drill
                        if (GAME.player.x > e.x) e.x += 0.6; else e.x -= 0.6;
                        if (GAME.player.y > e.y) e.y += 0.6; else e.y -= 0.6;
                        // Shoot more often
                        if (d < 100 && Math.random() < 0.02) {
                            const angle = Math.atan2(GAME.player.y - e.y, GAME.player.x - e.x);
                            GAME.projectiles.push({ type: 'req', x: e.x, y: e.y, vx: Math.cos(angle)*2.5, vy: Math.sin(angle)*2.5, life: 80 });
                        }
                    }
                }
            });
            break;

        case 'PRIME_DAY':
            // Continuous chaos - screen shake, spawn projectiles, runners respawn
            if (Math.random() < 0.08) {
                GAME.shake = Math.max(GAME.shake, 4);
            }
            // Spawn falling package projectiles targeting player area
            if (GAME.warehouseEvent.timer % 40 === 0) {
                const targetX = GAME.player.x + (Math.random() - 0.5) * 80;
                const targetY = GAME.player.y + (Math.random() - 0.5) * 80;
                GAME.projectiles.push({
                    type: 'req',
                    x: targetX,
                    y: targetY - 100,
                    vx: 0,
                    vy: 2.5,
                    life: 60,
                    primePackage: true
                });
            }
            // Respawn runners if too few
            const primeDayRunners = GAME.entities.filter(e => e.primeDay && e.type === 'runner').length;
            if (primeDayRunners < 4 && Math.random() < 0.02) {
                const rx = 50 + Math.random() * (MAP_W * TILE_SIZE - 100);
                const ry = 50 + Math.random() * (MAP_H * TILE_SIZE - 100);
                GAME.entities.push({
                    type: 'runner',
                    x: rx, y: ry, w: 16, h: 16,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    primeDay: true
                });
            }
            break;
    }
}

// End event-specific effects
function endEventEffects(eventType) {
    switch (eventType.id) {
        case 'OPS_GEMBA':
            // Remove any remaining gemba patrol OPS
            GAME.entities = GAME.entities.filter(e => !e.gembaPatrol);
            break;

        case 'ENERGY_CUTOFF':
            GAME.flashlightMode = false;
            break;

        case 'TPH_RUSH':
            // Restore OPS stats
            GAME.entities.forEach(e => {
                if (e.type === 'ops' && e.tphRush) {
                    e.tphRush = false;
                    e.hp = 1;
                }
            });
            break;

        case 'FIRE_DRILL':
            GAME.fireDrillActive = false;
            // Remove fire drill OPS
            GAME.entities = GAME.entities.filter(e => !e.fireDrillOps);
            break;

        case 'PRIME_DAY':
            // Remove prime day runners and packages
            GAME.entities = GAME.entities.filter(e => !e.primeDay);
            GAME.primeDayActive = false;
            break;
    }

    // Show "Event Over" floating text
    spawnFloatingText(GAME.player.x, GAME.player.y - 30, "EVENT OVER", "#22c55e");

    // Queue next event after a short delay
    queueNextWarehouseEvent();
}

function getRandomFallback(prompt, category = 'generic', context = {}) {
    const hazardName = context.hazardName;
    const stats = context.stats;
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const is = (key) => category === key || prompt.includes(key);
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';

    // Use localized Simon dialogue
    if (is("runners")) return getLocalizedSimonDialogue('runners');
    if (is("simon_warning")) {
        const idx = context.warningIndex || 0;
        return getLocalizedSimonWarning(idx);
    }
    if (is("bezos_taunt") || is("bezos_confrontation")) {
        return getLocalizedJeffTaunt('boss');
    }
    if (is("bezos_transform")) {
        const lines = BEZOS_TRANSFORM_LINES[region] || BEZOS_TRANSFORM_LINES.EN;
        return pick(lines);
    }
    if (is("player_response")) {
        const lines = PLAYER_RESPONSE_LINES[region] || PLAYER_RESPONSE_LINES.EN;
        return pick(lines);
    }
    if (is("taunt")) {
         if(prompt.includes("Simon")) return getLocalizedSimonDialogue('simon_taunts');
         return getLocalizedSimonDialogue('taunts');
    }
    if ((is("reviews_loss") || is("reviews_win")) && stats) {
        const time = stats.time ?? "?";
        const hazards = stats.hazards ?? "?";
        const books = stats.books ?? "?";
        const ops = stats.ops ?? "?";
        if (is("reviews_loss")) {
            return `Audit recap: ${hazards}/5 hazards, ${books} rule books thrown, ${ops} ops nudged in ${time} seconds. Safety tip: hydrate, then try again.`;
        }
        return `Victory recap: ${hazards}/5 hazards cleared in ${time} seconds, ${books} rule books launched, ${ops} ops redirected. Celebrate, then keep exits clear.`;
    }
    if (is("reviews_loss")) return getLocalizedSimonDialogue('reviews_loss');
    if (is("reviews_win")) return getLocalizedSimonDialogue('reviews_win');
    if (is("hazard") || is("tips")) {
        if(hazardName) return `Hazard "${hazardName}" cleared. Paperwork avoided.`;
        // Prioritize region-specific tips when available
        return pickRegionTip();
    }
    if (is("hazard_regulation")) {
        // Return a formatted fallback that will trigger static details usage
        return "FALLBACK_USE_STATIC";
    }
    if (is("banter_ops")) return getRegionalBanter('ops');
    if (is("banter_assoc")) return getRegionalBanter('assoc');

    return pickRegionTip();
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Crisp pixel text rendering helper - draws text without anti-aliasing
// Uses offscreen canvas technique for sharp, pixelated text
const crispText = (function() {
    const offscreen = document.createElement('canvas');
    const offCtx = offscreen.getContext('2d');
    const scale = 2; // Render at 2x then scale down

    return function(text, x, y, font, color, align) {
        // Parse font size from font string (e.g., "8px monospace" -> 8)
        const sizeMatch = font.match(/(\d+)px/);
        if (!sizeMatch) {
            // Fallback to regular text
            ctx.font = font;
            ctx.fillStyle = color;
            ctx.textAlign = align || 'left';
            ctx.fillText(text, x, y);
            return;
        }

        const fontSize = parseInt(sizeMatch[1]);
        const scaledFont = font.replace(/(\d+)px/, (fontSize * scale) + 'px');

        // Measure text width
        offCtx.font = scaledFont;
        const metrics = offCtx.measureText(text);
        const textWidth = Math.ceil(metrics.width);
        const textHeight = fontSize * scale * 1.5;

        // Resize offscreen canvas
        offscreen.width = textWidth + 4;
        offscreen.height = textHeight + 4;

        // Draw text on offscreen canvas
        offCtx.font = scaledFont;
        offCtx.fillStyle = color;
        offCtx.textBaseline = 'top';
        offCtx.textAlign = 'left';
        offCtx.fillText(text, 0, 0);

        // Calculate draw position based on alignment
        let drawX = Math.round(x);
        const drawY = Math.round(y - fontSize);
        const finalWidth = offscreen.width / scale;
        const finalHeight = offscreen.height / scale;

        if (align === 'center') {
            drawX = Math.round(x - finalWidth / 2);
        } else if (align === 'right') {
            drawX = Math.round(x - finalWidth);
        }

        // Draw scaled down with no smoothing
        const prevSmoothing = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(offscreen, 0, 0, offscreen.width, offscreen.height,
                      drawX, drawY, finalWidth, finalHeight);
        ctx.imageSmoothingEnabled = prevSmoothing;
    };
})();

const TILE_SIZE = 16;
const MAP_W = 60;
const MAP_H = 40;

// --- TTS SYSTEM WITH CHARACTER VOICES ---
const TTSSys = {
    synth: window.speechSynthesis,
    voice: null,
    maleVoice: null,
    femaleVoice: null,
    // Localized voices for different regions
    germanMaleVoice: null,
    germanFemaleVoice: null,
    dutchMaleVoice: null,
    dutchFemaleVoice: null,
    voices: [],
    // Map game region to TTS language code
    getRegionLang: function() {
        if (typeof GAME === 'undefined' || !GAME.region) return 'en-US';
        switch (GAME.region) {
            case 'DE': return 'de-DE';
            case 'AT': return 'de-DE'; // Austrian German uses de-DE
            case 'NL': return 'nl-NL';
            default: return 'en-US';
        }
    },
    // Get appropriate voice for region and gender
    getLocalizedVoice: function(gender = "neutral") {
        const lang = this.getRegionLang();
        if (lang === 'de-DE') {
            if (gender === "male" && this.germanMaleVoice) return this.germanMaleVoice;
            if (gender === "female" && this.germanFemaleVoice) return this.germanFemaleVoice;
            return this.germanMaleVoice || this.germanFemaleVoice;
        }
        if (lang === 'nl-NL') {
            if (gender === "male" && this.dutchMaleVoice) return this.dutchMaleVoice;
            if (gender === "female" && this.dutchFemaleVoice) return this.dutchFemaleVoice;
            return this.dutchMaleVoice || this.dutchFemaleVoice;
        }
        // English fallback
        if (gender === "male" && this.maleVoice) return this.maleVoice;
        if (gender === "female" && this.femaleVoice) return this.femaleVoice;
        return this.voice;
    },
    // Character voice configurations: pitch (0.1-2), rate (0.1-10), volume (0-1), gender preference
    characterVoices: {
        // Main characters - varied voices
        "Simon": { pitch: 0.8, rate: 0.88, volume: 1.0, gender: "male", desc: "Authoritative manager" },
        "Simon": { pitch: 0.8, rate: 0.88, volume: 1.0, gender: "male", desc: "Authoritative manager" },
        "Carrie": { pitch: 1.3, rate: 1.05, volume: 0.95, gender: "female", desc: "Energetic, precise" },
        "Nevena": { pitch: 1.15, rate: 0.95, volume: 0.9, gender: "female", desc: "Calm, oracle-like" },
        "Joao": { pitch: 0.85, rate: 1.2, volume: 1.0, gender: "male", desc: "Loud, siren-like" },
        "Roman": { pitch: 0.7, rate: 0.9, volume: 0.75, gender: "male", desc: "Ghost-like, quiet" },
        "Erwin": { pitch: 0.95, rate: 1.1, volume: 1.0, gender: "male", desc: "Manager, confident" },
        // Bosses & antagonists - gender-appropriate voices
        "Jeff Bezos": { pitch: 0.6, rate: 0.8, volume: 1.0, gender: "male", desc: "Megalomaniac" },
        "Mecha Jeff": { pitch: 0.3, rate: 0.6, volume: 1.0, gender: "male", desc: "Robotic, terrifying" },
        "MECHA MEGA SIMON": { pitch: 0.25, rate: 1.1, volume: 1.0, gender: "male", desc: "Mechanical overlord" },
        "MEGA SIMON": { pitch: 0.7, rate: 0.82, volume: 1.0, gender: "male", desc: "Final boss authority" },
        "Labour Inspector": { pitch: 1.1, rate: 1.0, volume: 1.0, gender: "female", desc: "Stern female enforcer" },
        "Compliance Auditor": { pitch: 1.05, rate: 0.85, volume: 0.9, gender: "female", desc: "Meticulous female watcher" },
        "Sebastian S.": { pitch: 0.75, rate: 1.15, volume: 1.0, gender: "male", desc: "Fast, TPH obsessed male" },
        "Regional OPS MGR": { pitch: 0.85, rate: 0.9, volume: 1.0, gender: "male", desc: "Male executive" },
        "Avetta Platform": { pitch: 0.3, rate: 0.7, volume: 0.85, gender: "neutral", desc: "AI, robotic" },
        "Jelena": { pitch: 1.15, rate: 0.95, volume: 0.95, gender: "female", desc: "HR guardian female" },
        "Jelly": { pitch: 1.15, rate: 0.95, volume: 0.95, gender: "female", desc: "HR guardian female" },
        // System voices
        "System": { pitch: 1.2, rate: 1.0, volume: 0.9, gender: "female", desc: "Female announcer" },
        "Corporate": { pitch: 0.55, rate: 0.9, volume: 1.0, gender: "male", desc: "Snarky corporate" },
        "Narrator": { pitch: 0.7, rate: 0.85, volume: 1.0, gender: "male", desc: "Dramatic narrator" }
    },
    init: function() {
        const loadVoices = () => {
            this.voices = this.synth.getVoices();

            // English voices (fallback)
            const englishVoices = this.voices.filter(v =>
                v.lang.startsWith('en') || v.name.includes('English')
            );
            // Default voice - prefer Google US English, then any US English, then any English
            this.voice = englishVoices.find(v => v.name.includes("Google US English"))
                || englishVoices.find(v => v.lang === 'en-US')
                || englishVoices.find(v => v.lang.startsWith('en'))
                || this.voices[0];

            // Try to find distinct male and female English voices
            this.maleVoice = englishVoices.find(v => v.name.toLowerCase().includes('male') && !v.name.toLowerCase().includes('female'))
                || englishVoices.find(v => v.name.includes('David'))
                || englishVoices.find(v => v.name.includes('Daniel'))
                || englishVoices.find(v => v.name.includes('Fred'))
                || englishVoices.find(v => v.name.includes('Alex'))
                || this.voice;

            this.femaleVoice = englishVoices.find(v => v.name.toLowerCase().includes('female'))
                || englishVoices.find(v => v.name.includes('Samantha'))
                || englishVoices.find(v => v.name.includes('Victoria'))
                || englishVoices.find(v => v.name.includes('Karen'))
                || englishVoices.find(v => v.name.includes('Moira'))
                || this.voice;

            // German voices for DE/AT regions
            const germanVoices = this.voices.filter(v =>
                v.lang.startsWith('de') || v.name.includes('German') || v.name.includes('Deutsch')
            );
            if (germanVoices.length > 0) {
                // Prefer Google German, then de-DE voices
                const defaultGerman = germanVoices.find(v => v.name.includes("Google Deutsch"))
                    || germanVoices.find(v => v.lang === 'de-DE')
                    || germanVoices[0];

                this.germanMaleVoice = germanVoices.find(v => v.name.toLowerCase().includes('male') && !v.name.toLowerCase().includes('female'))
                    || germanVoices.find(v => v.name.includes('Hans'))
                    || germanVoices.find(v => v.name.includes('Stefan'))
                    || defaultGerman;

                this.germanFemaleVoice = germanVoices.find(v => v.name.toLowerCase().includes('female'))
                    || germanVoices.find(v => v.name.includes('Anna'))
                    || germanVoices.find(v => v.name.includes('Petra'))
                    || germanVoices.find(v => v.name.includes('Marlene'))
                    || defaultGerman;
            }

            // Dutch voices for NL region
            const dutchVoices = this.voices.filter(v =>
                v.lang.startsWith('nl') || v.name.includes('Dutch') || v.name.includes('Nederlands')
            );
            if (dutchVoices.length > 0) {
                // Prefer Google Dutch, then nl-NL voices
                const defaultDutch = dutchVoices.find(v => v.name.includes("Google Nederlands"))
                    || dutchVoices.find(v => v.lang === 'nl-NL')
                    || dutchVoices[0];

                this.dutchMaleVoice = dutchVoices.find(v => v.name.toLowerCase().includes('male') && !v.name.toLowerCase().includes('female'))
                    || dutchVoices.find(v => v.name.includes('Xander'))
                    || defaultDutch;

                this.dutchFemaleVoice = dutchVoices.find(v => v.name.toLowerCase().includes('female'))
                    || dutchVoices.find(v => v.name.includes('Ellen'))
                    || dutchVoices.find(v => v.name.includes('Fleur'))
                    || defaultDutch;
            }
        };
        if (this.synth.onvoiceschanged !== undefined) this.synth.onvoiceschanged = loadVoices;
        loadVoices();
    },
    getVoiceConfig: function(speakerName) {
        // Find matching voice config by checking if speaker name contains any key
        for (const [name, config] of Object.entries(this.characterVoices)) {
            if (speakerName && speakerName.includes(name)) return config;
        }
        return { pitch: 0.9, rate: 1.0, volume: 0.9, gender: "neutral" }; // Default
    },
    speak: function(text, speakerName = "System", callback = null) {
        if (!this.synth || !text) {
            if (callback) callback();
            return;
        }
        this.synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);

        // Set language based on game region (de-DE for DE/AT, nl-NL for NL, en-US fallback)
        const regionLang = this.getRegionLang();
        utterance.lang = regionLang;

        // Apply character-specific voice settings
        const config = this.getVoiceConfig(speakerName);

        // Try to use localized voice based on region
        const localizedVoice = this.getLocalizedVoice(config.gender);
        if (localizedVoice) {
            utterance.voice = localizedVoice;
        } else {
            // Fallback to English voices if no localized voice available
            utterance.lang = 'en-US';
            if (config.gender === "male" && this.maleVoice) {
                utterance.voice = this.maleVoice;
            } else if (config.gender === "female" && this.femaleVoice) {
                utterance.voice = this.femaleVoice;
            } else if (this.voice) {
                utterance.voice = this.voice;
            }
        }

        utterance.pitch = config.pitch;
        utterance.rate = config.rate;
        utterance.volume = config.volume;

        // Optional callback when speech ends
        if (callback) {
            utterance.onend = callback;
            utterance.onerror = callback;
        }

        this.synth.speak(utterance);
    },
    // Speak without canceling current speech (for queuing)
    queue: function(text, speakerName = "System") {
        if (!this.synth || !text) return;
        const utterance = new SpeechSynthesisUtterance(text);

        // Set language based on game region (de-DE for DE/AT, nl-NL for NL, en-US fallback)
        const regionLang = this.getRegionLang();
        utterance.lang = regionLang;

        // Apply character-specific voice settings
        const config = this.getVoiceConfig(speakerName);

        // Try to use localized voice based on region
        const localizedVoice = this.getLocalizedVoice(config.gender);
        if (localizedVoice) {
            utterance.voice = localizedVoice;
        } else {
            // Fallback to English voices if no localized voice available
            utterance.lang = 'en-US';
            if (config.gender === "male" && this.maleVoice) {
                utterance.voice = this.maleVoice;
            } else if (config.gender === "female" && this.femaleVoice) {
                utterance.voice = this.femaleVoice;
            } else if (this.voice) {
                utterance.voice = this.voice;
            }
        }

        utterance.pitch = config.pitch;
        utterance.rate = config.rate;
        utterance.volume = config.volume;
        this.synth.speak(utterance);
    },
    cancel: function() { if (this.synth) this.synth.cancel(); }
};
TTSSys.init();

// --- TTS SETTINGS ---
const TTS_SETTINGS = {
    // TTS settings can be expanded here as needed
};


// TTS function using browser's native speech synthesis
function speakTTS(text, speakerName = "System", callback = null) {
    TTSSys.speak(text, speakerName, callback);
}

function cancelTTS() {
    TTSSys.cancel();
}

// --- AUDIO ---
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        if(!this.ctx) this.ctx = new AudioContext();
    },
    resume: function() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
    playTone: function(freq, type, duration, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol=0.1) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    sfx: {
        step: () => AudioSys.playNoise(0.05, 0.05),
        throw: () => AudioSys.playTone(400, 'square', 0.1, 0.1),
        hit: () => { AudioSys.playNoise(0.1, 0.2); AudioSys.playTone(100, 'sawtooth', 0.1, 0.2); },
        bossHit: () => { AudioSys.playNoise(0.2, 0.3); AudioSys.playTone(80, 'sawtooth', 0.2, 0.3); },
        alert: () => AudioSys.playTone(600, 'square', 0.2, 0.1),
        text: () => AudioSys.playTone(800, 'square', 0.03, 0.05),
        fix: () => { [440, 554, 659].forEach((f,i) => setTimeout(()=>AudioSys.playTone(f,'sine',0.2,0.1), i*100)); },
        hurt: () => AudioSys.playTone(150, 'sawtooth', 0.3, 0.2),
        start: () => { [440,440,440,660].forEach((f,i)=>setTimeout(()=>AudioSys.playTone(f,'square',0.2,0.2), i*150)); },
        angry: () => AudioSys.playTone(150, 'square', 0.5, 0.2),
        select: () => AudioSys.playTone(550, 'square', 0.1, 0.1),
        bossIntro: () => {
            AudioSys.playTone(100, 'sawtooth', 1.0, 0.3);
            setTimeout(() => AudioSys.playTone(80, 'sawtooth', 1.0, 0.3), 200);
        },
        pop: () => AudioSys.playTone(1200, 'sine', 0.05, 0.1), // New pop sound for banter
        // Zelda-style secret discovery tune - ascending arpeggio
        secret: () => {
            const notes = [392, 440, 494, 523, 587, 659, 698, 784]; // G4-G5 scale
            notes.forEach((freq, i) => {
                setTimeout(() => AudioSys.playTone(freq, 'sine', 0.15, 0.12), i * 60);
            });
        }
    }
};

const MusicSys = {
    tracks: {
        title: new Audio('music/title-screen.mp3'),
        intro: new Audio('music/title-eeproductions.mp3'),
        menu: new Audio('music/game-over.mp3'),
        ingame: new Audio('music/level-gameplay.mp3'),
        yard: new Audio('music/level-yard.mp3'),
        boss: new Audio('music/boss-battle.mp3'),
        victory: new Audio('music/victory.mp3'),
        mechaJeff: new Audio('music/boss-mecha-jeff.mp3'),
        megaSimon: new Audio('music/boss-mega-simon.mp3'),
        credits: new Audio('music/credits.mp3'),
        snesBoss: new Audio('music/boss-snes-theme.mp3'),
        enraged: new Audio('music/boss-enraged.mp3')
    },
    currentName: null,
    currentRate: 1,
    init() {
        Object.values(this.tracks).forEach(a => {
            a.loop = true; a.volume = 0.35; a.preload = 'auto';
        });
        // Don't loop the intro track - it's timed to match the logo animation
        this.tracks.intro.loop = false;
    },
    play(name, rate = 1) {
        const track = this.tracks[name];
        if (!track) return;
        if (this.currentName === name) {
            this.currentRate = rate;
            track.playbackRate = rate;
            if (track.paused) track.play().catch(() => {});
            return;
        }
        if (this.currentName && this.currentName !== name) this.stop();
        this.currentName = name;
        this.currentRate = rate;
        track.playbackRate = rate;
        track.currentTime = 0;
        track.play().catch(() => {});
    },
    stop() {
        if (this.currentName && this.tracks[this.currentName]) {
            const current = this.tracks[this.currentName];
            current.pause(); current.currentTime = 0;
        }
        this.currentName = null;
    },
    resume() {
        if (this.currentName && this.tracks[this.currentName]?.paused) {
            this.tracks[this.currentName].playbackRate = this.currentRate || 1;
            this.tracks[this.currentName].play().catch(() => {});
        }
    }
};

// --- ASSETS ---
const GFX = {};
function generateAssets() {
    const c = (w,h,f) => { const c=document.createElement('canvas');c.width=w;c.height=h;f(c.getContext('2d'));return c;};

    // Enhanced logo with gradient and glow
    GFX.logo = c(48, 48, ctx => {
        // Gradient background
        const grad = ctx.createLinearGradient(0, 0, 48, 48);
        grad.addColorStop(0, '#ffd700');
        grad.addColorStop(0.5, '#f59e0b');
        grad.addColorStop(1, '#d97706');
        ctx.fillStyle = grad;
        ctx.fillRect(2, 2, 44, 44);
        // Border
        ctx.strokeStyle = '#92400e';
        ctx.lineWidth = 2;
        ctx.strokeRect(2, 2, 44, 44);
        // Inner shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(4, 4, 40, 40);
        // Text with shadow
        ctx.fillStyle = '#000';
        ctx.font = 'bold 28px monospace';
        ctx.fillText("EE", 9, 35);
        ctx.fillStyle = '#fff';
        ctx.fillText("EE", 7, 33);
    });

    // PREMIUM CHARACTER SPRITES - 16x16 with full detail
    GFX.chars = {
        "Carrie": c(16,16, ctx => {
            // Shadow base
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Dark hair with enhanced detail
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,0,12,6);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(3,1,10,4);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(4,2,8,2);
            ctx.fillStyle = '#3b4766'; ctx.fillRect(5,2,6,1);
            // Meditation headband
            ctx.fillStyle = '#16a34a'; ctx.fillRect(3,5,10,1);
            ctx.fillStyle = '#22c55e'; ctx.fillRect(4,5,8,1);
            // Face with enhanced shading
            ctx.fillStyle = '#c4956a'; ctx.fillRect(4,5,8,6);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,6,6,4);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,7,4,2);
            ctx.fillStyle = '#f5d0a0'; ctx.fillRect(7,7,2,1);
            // Eyebrows
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(5,6,2,1); ctx.fillRect(9,6,2,1);
            // Purple zen eyes (enhanced)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
            ctx.fillStyle = '#a855f7'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
            ctx.fillStyle = '#fff'; ctx.fillRect(6,7,1,1); ctx.fillRect(10,7,1,1);
            // Serene mouth
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(7,9,2,1);
            // Purple zen robe with enhanced detail
            ctx.fillStyle = '#6d28d9'; ctx.fillRect(2,11,12,5);
            ctx.fillStyle = '#7c3aed'; ctx.fillRect(3,11,10,4);
            ctx.fillStyle = '#8b5cf6'; ctx.fillRect(4,12,8,2);
            ctx.fillStyle = '#a78bfa'; ctx.fillRect(5,13,6,1);
            // Meditation sash
            ctx.fillStyle = '#c4b5fd'; ctx.fillRect(7,11,2,4);
            ctx.fillStyle = '#ddd6fe'; ctx.fillRect(7,12,2,2);
            // 5S symbol
            ctx.fillStyle = '#22c55e'; ctx.fillRect(6,13,4,1);
            // Label maker prop (small)
            ctx.fillStyle = '#c4b5fd'; ctx.fillRect(12,12,2,3);
            ctx.fillStyle = '#8b5cf6'; ctx.fillRect(12,13,2,1);
            // Sandals
            ctx.fillStyle = '#1e3a8a'; ctx.fillRect(3,15,4,1); ctx.fillRect(9,15,4,1);
            ctx.fillStyle = '#3b82f6'; ctx.fillRect(4,15,2,1); ctx.fillRect(10,15,2,1);
        }),
        "Nevena": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Brown wavy hair with enhanced detail
            ctx.fillStyle = '#5c2d12'; ctx.fillRect(2,1,12,5);
            ctx.fillStyle = '#7c3d1a'; ctx.fillRect(3,2,10,3);
            ctx.fillStyle = '#9a5a32'; ctx.fillRect(4,2,8,2); // Mid-tone
            ctx.fillStyle = '#b8784a'; ctx.fillRect(5,2,6,1); // Highlight
            // Side waves (enhanced)
            ctx.fillStyle = '#9a5a32'; ctx.fillRect(2,3,2,3); ctx.fillRect(12,3,2,3);
            // Professional headband
            ctx.fillStyle = '#0369a1'; ctx.fillRect(3,3,10,2);
            ctx.fillStyle = '#0284c7'; ctx.fillRect(4,3,8,1);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(5,3,6,1);
            // Face with enhanced shading
            ctx.fillStyle = '#c4956a'; ctx.fillRect(4,5,8,6);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,6,6,4);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,7,4,2);
            ctx.fillStyle = '#f5c89a'; ctx.fillRect(7,7,2,1);
            // Eyebrows (skeptical)
            ctx.fillStyle = '#5c2d12'; ctx.fillRect(5,6,2,1); ctx.fillRect(9,6,2,1);
            // Eyes with glasses (enhanced)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
            ctx.fillStyle = '#fff'; ctx.fillRect(6,7,1,1); ctx.fillRect(10,7,1,1);
            // Glasses frame
            ctx.strokeStyle = '#475569'; ctx.lineWidth = 0.5;
            ctx.strokeRect(5,7,2,2); ctx.strokeRect(9,7,2,2);
            ctx.fillStyle = '#64748b'; ctx.fillRect(7,8,2,1); // Bridge
            // Mouth
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(7,9,2,1);
            // Red warning jacket with enhanced detail
            ctx.fillStyle = '#7f1d1d'; ctx.fillRect(2,11,12,5);
            ctx.fillStyle = '#991b1b'; ctx.fillRect(3,11,10,4);
            ctx.fillStyle = '#b91c1c'; ctx.fillRect(4,12,8,2);
            ctx.fillStyle = '#dc2626'; ctx.fillRect(5,13,6,1); // Bright center
            // Clipboard mini prop
            ctx.fillStyle = '#78350f'; ctx.fillRect(12,12,3,3);
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(12,12,2,2);
            ctx.fillStyle = '#92400e'; ctx.fillRect(12,13,2,1);
            // Documentation badge
            ctx.fillStyle = '#fff'; ctx.fillRect(6,13,4,1);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(6,13,3,1);
            // Boots
            ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
            ctx.fillStyle = '#374151'; ctx.fillRect(5,15,1,1); ctx.fillRect(10,15,1,1);
        }),
        "Joao": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // Spiky energetic dark hair with enhanced detail
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,0,12,5);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(3,1,10,4);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(4,1,8,3);
            ctx.fillStyle = '#3b4766'; ctx.fillRect(5,1,6,2);
            // Hair spikes (energetic)
            ctx.fillStyle = '#1a2744'; ctx.fillRect(3,0,2,2); ctx.fillRect(7,0,2,2); ctx.fillRect(11,0,2,2);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(4,0,1,1); ctx.fillRect(8,0,1,1); ctx.fillRect(12,0,1,1);
            // Face with warm skin tone
            ctx.fillStyle = '#c4956a'; ctx.fillRect(4,5,8,7);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,6,6,5);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,6,4,4);
            // Expressive thick eyebrows
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(5,6,2,1); ctx.fillRect(9,6,2,1);
            // Wide energetic eyes
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
            ctx.fillStyle = '#f97316'; ctx.fillRect(6,8,1,1); ctx.fillRect(10,8,1,1); // Orange fire
            ctx.fillStyle = '#fff'; ctx.fillRect(6,8,1,1); ctx.fillRect(10,8,1,1); // Bright glint
            // Open mouth (shouting)
            ctx.fillStyle = '#8b4513'; ctx.fillRect(6,10,4,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(7,10,2,1); // Teeth
            // Mic headset (communication device)
            ctx.fillStyle = '#0891b2'; ctx.fillRect(2,8,1,3);
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(2,9,1,2);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(1,10,2,2); // Mic boom
            // Orange hi-vis vest with enhanced detail
            ctx.fillStyle = '#9a3412'; ctx.fillRect(3,12,10,3);
            ctx.fillStyle = '#c2410c'; ctx.fillRect(4,12,8,3);
            ctx.fillStyle = '#ea580c'; ctx.fillRect(5,13,6,2);
            ctx.fillStyle = '#f97316'; ctx.fillRect(6,13,4,1); // Bright orange
            // Reflective safety strips
            ctx.fillStyle = '#fef08a'; ctx.fillRect(4,12,8,1); ctx.fillRect(4,14,8,1);
            ctx.fillStyle = '#fde047'; ctx.fillRect(5,12,6,1); ctx.fillRect(5,14,6,1);
        }),
        "Roman": c(16,16, ctx => {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
            // EPIC BALD HEAD with maximum shine (16x16 version)
            ctx.fillStyle = '#c4956a'; ctx.fillRect(3,1,10,7);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(4,2,8,6);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,2,6,5);
            ctx.fillStyle = '#f5deb3'; ctx.fillRect(6,1,4,4); // Major shine
            ctx.fillStyle = '#faebd7'; ctx.fillRect(7,1,2,3); // Bright shine
            ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(7,1,2,2); // Epic highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(8,1,1,1); // Gleam point
            // Mysterious narrow eyes (phantom gaze)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,6,2,1); ctx.fillRect(9,6,2,1);
            ctx.fillStyle = '#64748b'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1); // Grey stealth eyes
            ctx.fillStyle = '#94a3b8'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1); // Mysterious glint
            // Stern neutral mouth (silent)
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(7,8,2,1);
            // Mini audit document prop (clipboard)
            ctx.fillStyle = '#334155'; ctx.fillRect(12,7,3,5);
            ctx.fillStyle = '#e2e8f0'; ctx.fillRect(12,8,2,3);
            ctx.fillStyle = '#64748b'; ctx.fillRect(12,8,2,1); ctx.fillRect(12,10,2,1); // Lines
            // Dark stealth coat with enhanced detail
            ctx.fillStyle = '#020617'; ctx.fillRect(3,9,10,6);
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(4,10,8,5);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(5,11,6,3);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(6,11,4,2); // Subtle highlight
            // Mysterious collar
            ctx.fillStyle = '#334155'; ctx.fillRect(5,9,6,1);
            ctx.fillStyle = '#475569'; ctx.fillRect(6,9,4,1);
            // Shadow step boots (silent, barely visible)
            ctx.fillStyle = '#020617'; ctx.fillRect(4,14,3,1); ctx.fillRect(9,14,3,1);
            ctx.fillStyle = '#0b1224'; ctx.fillRect(5,14,2,1); ctx.fillRect(10,14,2,1);
        }),
        "Erwin": c(16,16, ctx => {
            // ERWIN - The Manager standing proud with mini Tesla behind
            // Shadow (ground effect)
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath(); ctx.ellipse(8, 15, 6, 2, 0, 0, Math.PI*2); ctx.fill();
            // Mini Tesla in background (smaller, behind Erwin)
            ctx.fillStyle = '#27272a'; ctx.fillRect(0,12,16,3);
            ctx.fillStyle = '#3f3f46'; ctx.fillRect(1,12,14,2);
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(2,12,4,1); ctx.fillRect(10,12,4,1); // Windows
            ctx.fillStyle = '#000'; ctx.fillRect(0,14,3,2); ctx.fillRect(13,14,3,2); // Wheels
            // Erwin's slicked dark hair
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(4,0,8,5);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(5,1,6,3);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(6,1,4,2); // Hair shine
            // Face
            ctx.fillStyle = '#c4956a'; ctx.fillRect(4,4,8,6);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(5,5,6,4);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(6,5,4,3);
            // Confident eyes with tech glint
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,5,2,2); ctx.fillRect(9,5,2,2);
            ctx.fillStyle = '#0891b2'; ctx.fillRect(5,5,1,1); ctx.fillRect(9,5,1,1); // Cyan glint
            // Well-groomed beard
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(5,7,6,3);
            ctx.fillStyle = '#2d2d2d'; ctx.fillRect(6,8,4,2);
            // Smug smile through beard
            ctx.fillStyle = '#f59e0b'; ctx.fillRect(6,8,4,1);
            // Tesla-gray suit jacket
            ctx.fillStyle = '#27272a'; ctx.fillRect(2,10,12,5);
            ctx.fillStyle = '#3f3f46'; ctx.fillRect(3,10,10,4);
            ctx.fillStyle = '#52525b'; ctx.fillRect(4,11,8,2); // Suit highlight
            // Cyan Tesla logo/tie
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(7,10,2,3);
            // Arms (confident pose)
            ctx.fillStyle = '#27272a'; ctx.fillRect(1,10,2,4); ctx.fillRect(13,10,2,4);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(1,13,2,1); ctx.fillRect(13,13,2,1); // Hands
            // Shoes
            ctx.fillStyle = '#000'; ctx.fillRect(3,14,4,2); ctx.fillRect(9,14,4,2);
        })
    };

    // ENHANCED ATTACK PROJECTILES
    GFX.attacks = {
        "Carrie": c(14,14, ctx => {
            // Label maker projectile with glow
            const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
            grad.addColorStop(0, '#e879f9');
            grad.addColorStop(0.5, '#a855f7');
            grad.addColorStop(1, '#7c3aed');
            ctx.fillStyle = grad;
            ctx.fillRect(1,4,12,6);
            ctx.fillStyle = '#c4b5fd';
            ctx.fillRect(2,5,10,4);
            ctx.fillStyle = '#10b981';
            ctx.fillRect(6,2,2,10);
            // Label detail
            ctx.fillStyle = '#fff';
            ctx.fillRect(4,6,6,2);
        }),
        "Nevena": c(14,14, ctx => {
            // Clipboard shockwave
            ctx.fillStyle = '#0369a1';
            ctx.fillRect(2,2,10,10);
            const grad = ctx.createLinearGradient(0, 0, 14, 14);
            grad.addColorStop(0, '#f8fafc');
            grad.addColorStop(1, '#e2e8f0');
            ctx.fillStyle = grad;
            ctx.fillRect(3,3,8,8);
            // Paper lines
            ctx.fillStyle = '#334155';
            ctx.fillRect(4,4,6,1);
            ctx.fillRect(4,6,5,1);
            ctx.fillRect(4,8,4,1);
            // Checkmark
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(8,7,2,3);
            ctx.fillRect(6,9,2,1);
        }),
        "Joao": c(14,14, ctx => {
            // Sonic shout waves
            const grad = ctx.createLinearGradient(0, 0, 14, 0);
            grad.addColorStop(0, '#ea580c');
            grad.addColorStop(0.5, '#f97316');
            grad.addColorStop(1, '#fb923c');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.moveTo(0,7); ctx.lineTo(6,2); ctx.lineTo(6,12); ctx.fill();
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath(); ctx.moveTo(4,7); ctx.lineTo(10,1); ctx.lineTo(10,13); ctx.fill();
            ctx.fillStyle = '#22d3ee';
            ctx.beginPath(); ctx.moveTo(8,7); ctx.lineTo(14,3); ctx.lineTo(14,11); ctx.fill();
            // Inner ring
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(7,7,2,0,Math.PI*2); ctx.stroke();
        }),
        "Roman": c(14,14, ctx => {
            // Stealth audit pulse
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(7,7,6,0,Math.PI*2); ctx.stroke();
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(7,7,4,0,Math.PI*2); ctx.stroke();
            ctx.fillStyle = '#1e293b';
            ctx.beginPath(); ctx.arc(7,7,2,0,Math.PI*2); ctx.fill();
            // Crosshair
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(6,0,2,3); ctx.fillRect(6,11,2,3);
            ctx.fillRect(0,6,3,2); ctx.fillRect(11,6,3,2);
        }),
        "Erwin": c(14,14, ctx => {
            // Tesla energy pulse
            const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
            grad.addColorStop(0, '#67e8f9');
            grad.addColorStop(0.5, '#22d3ee');
            grad.addColorStop(1, '#0891b2');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(7, 7, 6, 0, Math.PI*2); ctx.fill();
            // Electric arcs
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(7, 1); ctx.lineTo(5, 4); ctx.lineTo(9, 6); ctx.lineTo(7, 9);
            ctx.stroke();
            // Center core
            ctx.fillStyle = '#f0f9ff';
            ctx.beginPath(); ctx.arc(7, 7, 2, 0, Math.PI*2); ctx.fill();
        })
    };
    // IMPROVED SIMON SPRITE - Short brown hair, glasses, brown beard
    GFX.simon = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Short brown hair
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(3,0,10,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(4,1,8,2);
        ctx.fillStyle = '#7a5030'; ctx.fillRect(5,1,3,1); // Highlight
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,4,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,5,6,4);
        // Glasses
        ctx.fillStyle = '#000'; ctx.fillRect(4,5,3,2); ctx.fillRect(9,5,3,2);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(5,5,1,1); ctx.fillRect(10,5,1,1);
        ctx.fillStyle = '#475569'; ctx.fillRect(7,6,2,1);
        // Brown beard
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(4,8,8,2);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(5,8,6,2);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(6,9,4,1);
        // Gold WHS jacket
        ctx.fillStyle = '#b45309'; ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#d97706'; ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(4,11,8,2);
        // WHS badge
        ctx.fillStyle = '#fff'; ctx.fillRect(5,12,6,2);
        ctx.fillStyle = '#000'; ctx.font = '3px monospace';
        // Boots
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });
    GFX.simonFace = c(32,32, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simon,0,0,16,16,0,0,32,32); });

    // Create ENHANCED FUNNY character portraits for SNES-style dialogues (48x48)
    GFX.charFaces = {
        "Carrie": c(48,48, ctx => {
            // CARRIE - The 5S Monk - Zen precision hawk portrait
            // Background gradient (purple zen aura)
            const grad = ctx.createRadialGradient(24,24,8,24,24,24);
            grad.addColorStop(0, '#8b5cf6'); grad.addColorStop(1, '#4c1d95');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Dark hair with meditation headband
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(10,6,28,12);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(12,8,24,8);
            // Meditation headband (green)
            ctx.fillStyle = '#22c55e'; ctx.fillRect(12,10,24,4);
            ctx.fillStyle = '#16a34a'; ctx.fillRect(14,11,20,2);
            // Face (serious zen expression)
            ctx.fillStyle = '#d4a574'; ctx.fillRect(14,16,20,14);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,18,16,10);
            // Closed meditation eyes (peaceful)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(18,22,4,2); ctx.fillRect(26,22,4,2);
            // Eyebrows (focused)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(18,20,5,1); ctx.fillRect(25,20,5,1);
            // Small smile (enlightened)
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(22,26,4,1);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(20,27,8,1); // Slight smile curve
            // Purple monk robe with sash
            ctx.fillStyle = '#7c3aed'; ctx.fillRect(10,30,28,18);
            ctx.fillStyle = '#8b5cf6'; ctx.fillRect(12,32,24,14);
            ctx.fillStyle = '#a78bfa'; ctx.fillRect(16,34,16,10); // Highlight
            // Golden sash (5S master)
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(22,32,4,14);
            // Hands in prayer position
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,38,8,6);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(21,39,6,4);
        }),
        "Nevena": c(48,48, ctx => {
            // NEVENA - The Oracle - Skeptical documentation expert
            // Background (red warning gradient)
            const grad = ctx.createRadialGradient(24,24,8,24,24,24);
            grad.addColorStop(0, '#dc2626'); grad.addColorStop(1, '#7f1d1d');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Brown wavy hair
            ctx.fillStyle = '#5c2d12'; ctx.fillRect(8,8,32,12);
            ctx.fillStyle = '#7c3d1a'; ctx.fillRect(10,10,28,8);
            // Hair waves on sides
            ctx.fillStyle = '#9a5a32'; ctx.fillRect(8,12,6,8); ctx.fillRect(34,12,6,8);
            // Blue headband
            ctx.fillStyle = '#0284c7'; ctx.fillRect(12,10,24,4);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(14,11,20,2);
            // Face (skeptical expression)
            ctx.fillStyle = '#d4a574'; ctx.fillRect(14,18,20,16);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,20,16,12);
            // Large glasses (oracle vision)
            ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
            ctx.strokeRect(16,24,6,5); ctx.strokeRect(26,24,6,5);
            // Eyes (one raised eyebrow, skeptical)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,26,2,2); ctx.fillRect(28,26,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(18,26,1,1); ctx.fillRect(28,26,1,1);
            // Raised eyebrow (skeptical)
            ctx.fillStyle = '#5c2d12'; ctx.fillRect(16,22,6,2); ctx.fillRect(26,23,6,1);
            // Smirk (knowing smile)
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(22,30,4,2);
            ctx.fillRect(20,31,2,1); ctx.fillRect(26,31,2,1);
            // Red safety jacket
            ctx.fillStyle = '#991b1b'; ctx.fillRect(10,34,28,14);
            ctx.fillStyle = '#dc2626'; ctx.fillRect(12,36,24,10);
            // GIANT clipboard (obsessive documentation)
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(32,30,12,16);
            ctx.fillStyle = '#fcd34d'; ctx.fillRect(33,31,10,14);
            // Checkmarks everywhere!
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(35,33,2,2); ctx.fillRect(38,36,2,2); ctx.fillRect(35,40,2,2);
        }),
        "Joao": c(48,48, ctx => {
            // JOAO - The Siren - Caffeinated chaos energy
            // Background (orange energy explosion)
            const grad = ctx.createRadialGradient(24,24,10,24,24,24);
            grad.addColorStop(0, '#fb923c'); grad.addColorStop(1, '#c2410c');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Energy lines radiating (SCREAMING ENERGY)
            ctx.strokeStyle = '#fef08a'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(24,10); ctx.lineTo(24,0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(10,24); ctx.lineTo(0,24); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(38,24); ctx.lineTo(48,24); ctx.stroke();
            // Super spiky black hair (ENERGIZED)
            ctx.fillStyle = '#0a0f1f';
            ctx.fillRect(14,4,20,10); // Base
            ctx.fillRect(16,2,4,4); ctx.fillRect(22,0,4,6); ctx.fillRect(28,2,4,4); // Spikes!
            ctx.fillStyle = '#1a2744'; ctx.fillRect(18,6,12,6);
            // Face (INTENSE SHOUTING)
            ctx.fillStyle = '#c4956a'; ctx.fillRect(14,16,20,18);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(16,18,16,14);
            // WIDE OPEN EYES (caffeinated)
            ctx.fillStyle = '#fff'; ctx.fillRect(18,22,5,6); ctx.fillRect(25,22,5,6);
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(20,24,3,4); ctx.fillRect(27,24,3,4);
            ctx.fillStyle = '#fbbf24'; ctx.fillRect(20,25,2,2); ctx.fillRect(27,25,2,2); // Glint
            // Eyebrows (INTENSE)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(17,20,6,2); ctx.fillRect(25,20,6,2);
            // HUGE SHOUTING MOUTH (WARNING SIREN)
            ctx.fillStyle = '#8b4513'; ctx.fillRect(20,28,8,6);
            ctx.fillStyle = '#fff'; ctx.fillRect(22,28,4,2); // Teeth
            // Headset mic (always ON)
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(12,24,2,8);
            ctx.fillStyle = '#0ea5e9'; ctx.fillRect(10,28,4,4);
            // Orange hi-vis vest (MAXIMUM VISIBILITY)
            ctx.fillStyle = '#ea580c'; ctx.fillRect(10,34,28,14);
            ctx.fillStyle = '#f97316'; ctx.fillRect(12,36,24,10);
            // Reflective strips
            ctx.fillStyle = '#fef08a'; ctx.fillRect(12,36,24,2); ctx.fillRect(12,42,24,2);
            // COFFEE CUP (essential fuel)
            ctx.fillStyle = '#78350f'; ctx.fillRect(34,36,10,10);
            ctx.fillStyle = '#92400e'; ctx.fillRect(35,37,8,8);
            // Steam (HOT COFFEE)
            ctx.strokeStyle = '#e0e7ff'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(36,34); ctx.lineTo(38,30); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(40,34); ctx.lineTo(42,30); ctx.stroke();
        }),
        "Roman": c(48,48, ctx => {
            // ROMAN - The Ghost - Mysterious audit phantom
            // Background (dark stealth gradient)
            const grad = ctx.createRadialGradient(24,24,8,24,24,24);
            grad.addColorStop(0, '#2a3755'); grad.addColorStop(1, '#0a0f1f');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Ghostly wisps around edges
            ctx.fillStyle = 'rgba(148,163,184,0.2)';
            ctx.fillRect(0,20,8,8); ctx.fillRect(40,20,8,8);
            // BALD HEAD with epic shine
            ctx.fillStyle = '#c4956a'; ctx.fillRect(14,10,20,16);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(16,12,16,12);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,12,12,8);
            // LEGENDARY HEAD SHINE
            ctx.fillStyle = '#fff'; ctx.fillRect(20,10,8,4);
            ctx.fillStyle = '#f5deb3'; ctx.fillRect(22,12,6,3);
            // Narrow mysterious eyes (seen it all)
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,20,4,2); ctx.fillRect(26,20,4,2);
            ctx.fillStyle = '#64748b'; ctx.fillRect(19,20,2,1); ctx.fillRect(27,20,2,1);
            // Stern eyebrows
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(17,18,5,1); ctx.fillRect(26,18,5,1);
            // Serious mouth (disapproving)
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(22,24,4,1);
            // Dark stealth coat (mysterious)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(8,26,32,22);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(10,28,28,18);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(14,30,20,14);
            // High collar (dramatic)
            ctx.fillStyle = '#374151'; ctx.fillRect(16,26,16,4);
            // Silver audit badge (ghost credentials)
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(20,34,8,6);
            ctx.fillStyle = '#e5e7eb'; ctx.fillRect(21,35,6,4);
            // Mysterious silver cuffs
            ctx.fillStyle = '#6b7280'; ctx.fillRect(8,38,6,6); ctx.fillRect(34,38,6,6);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(9,39,4,4); ctx.fillRect(35,39,4,4);
            // Phantom shadowy hands (spooky)
            ctx.fillStyle = 'rgba(100,116,139,0.5)';
            ctx.fillRect(6,42,8,6); ctx.fillRect(34,42,8,6);
        }),
        "Erwin": c(48,48, ctx => {
            // ERWIN - The Manager - Tesla enthusiast with BIG FACE (same size as others)
            // Background (cyan Tesla energy gradient)
            const grad = ctx.createRadialGradient(24,24,10,24,24,24);
            grad.addColorStop(0, '#22d3ee'); grad.addColorStop(1, '#0e7490');
            ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
            // Electric energy arcs in background
            ctx.strokeStyle = 'rgba(103, 232, 249, 0.4)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(4,8); ctx.lineTo(12,16); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(44,8); ctx.lineTo(36,16); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(4,40); ctx.lineTo(10,34); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(44,40); ctx.lineTo(38,34); ctx.stroke();
            // Slicked-back dark hair (manager style)
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(10,4,28,14);
            ctx.fillStyle = '#1a2744'; ctx.fillRect(12,6,24,10);
            ctx.fillStyle = '#2a3755'; ctx.fillRect(14,7,20,7);
            ctx.fillStyle = '#3a4565'; ctx.fillRect(16,7,16,4); // Gel shine
            // LARGE FACE (same proportions as other characters)
            ctx.fillStyle = '#c4956a'; ctx.fillRect(12,16,24,18);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(14,18,20,14);
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,20,16,10);
            // Well-groomed beard
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(14,30,20,6);
            ctx.fillStyle = '#2d2d2d'; ctx.fillRect(16,30,16,5);
            ctx.fillStyle = '#3a3a3a'; ctx.fillRect(18,31,12,3);
            // Confident eyebrows
            ctx.fillStyle = '#0a0f1f'; ctx.fillRect(16,21,6,2); ctx.fillRect(26,21,6,2);
            // SMUG CONFIDENT EYES
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(16,24,6,5); ctx.fillRect(26,24,6,5);
            ctx.fillStyle = '#0891b2'; ctx.fillRect(17,25,4,3); ctx.fillRect(27,25,4,3); // Cyan tech eyes
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(18,25,2,2); ctx.fillRect(28,25,2,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(18,25,1,1); ctx.fillRect(28,25,1,1);
            // Nose
            ctx.fillStyle = '#c4956a'; ctx.fillRect(22,27,4,4);
            // CONFIDENT SMIRK
            ctx.fillStyle = '#c17b5f'; ctx.fillRect(20,32,8,2);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(18,33,2,1); ctx.fillRect(28,33,2,1);
            // Tesla-themed gray suit
            ctx.fillStyle = '#27272a'; ctx.fillRect(10,36,28,12);
            ctx.fillStyle = '#3f3f46'; ctx.fillRect(12,37,24,10);
            ctx.fillStyle = '#52525b'; ctx.fillRect(14,38,20,8);
            // Cyan Tesla accents on collar
            ctx.fillStyle = '#22d3ee'; ctx.fillRect(16,37,3,3); ctx.fillRect(29,37,3,3);
            // Red Tesla logo on chest
            ctx.fillStyle = '#ef4444'; ctx.fillRect(22,40,4,4);
            ctx.fillStyle = '#fff'; ctx.fillRect(23,41,2,2);
        })
    };
    GFX.simonFaceLarge = c(48,48, ctx => {
        // SIMON - Friendly WHS Manager Portrait (Professional but Approachable)
        // Background (warm professional gradient)
        const grad = ctx.createRadialGradient(24,24,10,24,24,24);
        grad.addColorStop(0, '#fbbf24'); grad.addColorStop(1, '#d97706');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Clipboard in background (professional but not threatening)
        ctx.fillStyle = '#78350f'; ctx.fillRect(4,20,12,20);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(5,21,10,18);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(7,24,6,2); ctx.fillRect(7,28,6,2); // Green checkmarks
        // Short brown hair
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,6,24,10);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(14,8,20,6);
        ctx.fillStyle = '#7a5030'; ctx.fillRect(16,8,8,3); // Highlight
        // Face (professional, friendly)
        ctx.fillStyle = '#c4956a'; ctx.fillRect(12,14,24,18);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,16,20,14);
        // Friendly eyebrows (slightly raised, welcoming)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(16,19,6,2); ctx.fillRect(26,19,6,2);
        // Glasses with normal eyes (professional but kind)
        ctx.fillStyle = '#1e293b'; ctx.fillRect(16,22,7,6); ctx.fillRect(25,22,7,6);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(17,23,5,4); ctx.fillRect(26,23,5,4); // Blue calm eyes
        ctx.fillStyle = '#1e293b'; ctx.fillRect(18,24,3,2); ctx.fillRect(27,24,3,2); // Pupils
        ctx.fillStyle = '#fff'; ctx.fillRect(19,24,1,1); ctx.fillRect(28,24,1,1); // Eye glint
        // Bridge
        ctx.fillStyle = '#475569'; ctx.fillRect(23,24,2,1);
        // Slight SMILE (friendly professional)
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(21,29,6,1);
        ctx.fillRect(20,30,2,1); ctx.fillRect(26,30,2,1); // Smile curves up
        // Brown beard (well-groomed)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(14,30,20,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(16,30,16,3);
        // Gold WHS uniform
        ctx.fillStyle = '#92400e'; ctx.fillRect(10,34,28,14);
        ctx.fillStyle = '#b45309'; ctx.fillRect(12,36,24,10);
        ctx.fillStyle = '#d97706'; ctx.fillRect(14,38,20,6);
        // Large WHS badge
        ctx.fillStyle = '#fff'; ctx.fillRect(18,40,12,4);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(20,41,8,2); // Green badge (friendly)
        // Thumbs up gesture (encouraging)
        ctx.fillStyle = '#d4a574'; ctx.fillRect(34,30,6,10);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(35,31,4,8);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(35,28,4,4); // Thumb up
    });

    // TALKING ANIMATION VARIANTS - Open mouths for dialogue
    GFX.charFacesTalking = {
        "Carrie": c(48,48, ctx => {
            // Draw base portrait first (copy from above)
            ctx.drawImage(GFX.charFaces["Carrie"], 0, 0);
            // Now modify the mouth area to be OPEN (talking)
            // Clear mouth area
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,26,8,4);
            // Open mouth (serene chanting)
            ctx.fillStyle = '#8b4513'; ctx.fillRect(22,27,4,2);
            ctx.fillStyle = '#d4a574'; ctx.fillRect(21,27,1,2); ctx.fillRect(26,27,1,2); // Sides
        }),
        "Nevena": c(48,48, ctx => {
            ctx.drawImage(GFX.charFaces["Nevena"], 0, 0);
            // Open mouth (explaining something skeptically)
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,30,8,4);
            ctx.fillStyle = '#8b4513'; ctx.fillRect(21,31,6,2);
            ctx.fillStyle = '#fff'; ctx.fillRect(23,31,2,1); // Teeth visible
        }),
        "Joao": c(48,48, ctx => {
            ctx.drawImage(GFX.charFaces["Joao"], 0, 0);
            // EVEN BIGGER mouth (SCREAMING LOUDER)
            ctx.fillStyle = '#d4a574'; ctx.fillRect(18,28,12,8);
            ctx.fillStyle = '#8b4513'; ctx.fillRect(19,29,10,6);
            ctx.fillStyle = '#fff'; ctx.fillRect(21,29,6,2); // More teeth!
            // Sound waves!
            ctx.strokeStyle = '#fef08a'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(24,32,8,0,Math.PI*2); ctx.stroke();
        }),
        "Roman": c(48,48, ctx => {
            ctx.drawImage(GFX.charFaces["Roman"], 0, 0);
            // Slightly open mouth (mysterious whisper)
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,24,8,3);
            ctx.fillStyle = '#8b6b5a'; ctx.fillRect(22,25,4,1);
            ctx.fillStyle = '#64748b'; ctx.fillRect(23,25,2,1); // Shadow
        }),
        "Erwin": c(48,48, ctx => {
            ctx.drawImage(GFX.charFaces["Erwin"], 0, 0);
            // Clear mouth area and draw open talking mouth (bragging)
            ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,31,12,5);
            ctx.fillStyle = '#8b4513'; ctx.fillRect(20,32,8,3);
            ctx.fillStyle = '#fff'; ctx.fillRect(22,32,4,2); // Teeth showing (confident grin)
            // Move beard slightly for talking
            ctx.fillStyle = '#2d2d2d'; ctx.fillRect(16,35,16,3);
        })
    };

    GFX.simonFaceTalking = c(48,48, ctx => {
        ctx.drawImage(GFX.simonFaceLarge, 0, 0);
        // Open mouth (friendly talking, not yelling)
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,29,8,4);
        ctx.fillStyle = '#8b4513'; ctx.fillRect(21,30,6,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(23,30,2,1); // Friendly teeth
        // Beard moves with mouth (slightly)
        ctx.fillStyle = '#6b4423'; ctx.fillRect(16,32,16,2);
    });

    // SIMON HAPPY FACE - For successful performance evaluation (48x48)
    GFX.simonFaceHappy = c(48,48, ctx => {
        // Background (warm professional gradient with extra glow)
        const grad = ctx.createRadialGradient(24,24,8,24,24,26);
        grad.addColorStop(0, '#fbbf24'); grad.addColorStop(1, '#92400e');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Extra happy sparkles
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(4,4,3,3); ctx.fillRect(41,5,3,3); ctx.fillRect(6,38,3,3); ctx.fillRect(39,40,3,3);
        ctx.fillRect(24,2,2,2); // Top sparkle
        // Short brown hair
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,6,24,8);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(14,7,20,6);
        ctx.fillStyle = '#7a5030'; ctx.fillRect(18,7,6,3); // Hair highlight
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(12,12,24,16);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,14,20,12);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,15,16,9);
        // HAPPY EYES - squinting from smiling, rosy cheeks
        ctx.fillStyle = '#ff9999'; ctx.fillRect(12,19,5,3); ctx.fillRect(31,19,5,3); // Rosy cheeks
        ctx.fillStyle = '#1e293b'; ctx.fillRect(16,17,6,3); ctx.fillRect(26,17,6,3);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(17,18,4,1); ctx.fillRect(27,18,4,1); // Bright green glint
        ctx.fillStyle = '#fff'; ctx.fillRect(17,17,2,1); ctx.fillRect(27,17,2,1);
        // Happy eyebrows raised
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(16,14,6,2); ctx.fillRect(26,14,6,2);
        // Glasses with golden tint
        ctx.fillStyle = '#475569'; ctx.fillRect(22,19,4,1);
        // BIG HAPPY SMILE
        ctx.fillStyle = '#d4a574'; ctx.fillRect(18,25,12,6);
        ctx.fillStyle = '#8b4513'; ctx.fillRect(19,26,10,4);
        ctx.fillStyle = '#fff'; ctx.fillRect(20,26,8,2); // Big teeth showing
        ctx.fillStyle = '#f87171'; ctx.fillRect(21,28,6,1); // Tongue
        // Brown beard (shorter to show smile)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(14,29,6,4); ctx.fillRect(28,29,6,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(15,30,5,3); ctx.fillRect(28,30,5,3);
        // Gold WHS uniform with extra polish
        ctx.fillStyle = '#92400e'; ctx.fillRect(8,32,32,16);
        ctx.fillStyle = '#b45309'; ctx.fillRect(10,32,28,12);
        ctx.fillStyle = '#d97706'; ctx.fillRect(12,34,24,8);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(14,35,20,5); // Extra shiny
        // Badge with gold star
        ctx.fillStyle = '#fff'; ctx.fillRect(18,36,12,4);
        ctx.fillStyle = '#ffd700'; ctx.fillRect(22,37,4,2); // Gold star center
    });

    // SIMON DISAPPOINTED FACE - For failed performance evaluation (48x48)
    GFX.simonFaceDisappointed = c(48,48, ctx => {
        // Background (darker, disappointed gradient)
        const grad = ctx.createRadialGradient(24,24,8,24,24,26);
        grad.addColorStop(0, '#78716c'); grad.addColorStop(1, '#44403c');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Sad rain drops
        ctx.fillStyle = '#94a3b8';
        ctx.fillRect(6,6,2,4); ctx.fillRect(40,10,2,4); ctx.fillRect(12,38,2,4); ctx.fillRect(36,42,2,4);
        // Short brown hair (less shine)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,6,24,8);
        ctx.fillStyle = '#4a2c1e'; ctx.fillRect(14,7,20,6);
        // Face (slightly more grey)
        ctx.fillStyle = '#b8a090'; ctx.fillRect(12,12,24,16);
        ctx.fillStyle = '#c4a480'; ctx.fillRect(14,14,20,12);
        ctx.fillStyle = '#d4b490'; ctx.fillRect(16,15,16,9);
        // DISAPPOINTED EYES - sad look
        ctx.fillStyle = '#1e293b'; ctx.fillRect(16,17,6,5); ctx.fillRect(26,17,6,5);
        ctx.fillStyle = '#64748b'; ctx.fillRect(17,19,4,2); ctx.fillRect(27,19,4,2); // Grey sad eyes
        ctx.fillStyle = '#fff'; ctx.fillRect(18,18,1,1); ctx.fillRect(28,18,1,1);
        // Sad eyebrows angled down
        ctx.fillStyle = '#5c3d2e';
        ctx.fillRect(15,15,2,1); ctx.fillRect(17,16,2,1); ctx.fillRect(19,17,2,1);
        ctx.fillRect(27,17,2,1); ctx.fillRect(29,16,2,1); ctx.fillRect(31,15,2,1);
        // Glasses
        ctx.fillStyle = '#475569'; ctx.fillRect(22,19,4,1);
        // DISAPPOINTED FROWN
        ctx.fillStyle = '#b8a090'; ctx.fillRect(18,26,12,4);
        ctx.fillStyle = '#8b6b5a'; ctx.fillRect(20,27,8,2); // Closed frown
        // Frown curve
        ctx.fillStyle = '#6b5545'; ctx.fillRect(19,26,2,1); ctx.fillRect(27,26,2,1);
        ctx.fillStyle = '#8b6b5a'; ctx.fillRect(21,28,6,1);
        // Brown beard (full, covering sad mouth)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(14,27,20,6);
        ctx.fillStyle = '#4a2c1e'; ctx.fillRect(16,28,16,4);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(18,30,12,3);
        // WHS uniform (less shiny, more muted)
        ctx.fillStyle = '#78350f'; ctx.fillRect(8,32,32,16);
        ctx.fillStyle = '#92400e'; ctx.fillRect(10,32,28,12);
        ctx.fillStyle = '#a45419'; ctx.fillRect(12,34,24,8);
        // Badge (less prominent)
        ctx.fillStyle = '#d4d4d4'; ctx.fillRect(18,36,12,4);
        ctx.fillStyle = '#a3a3a3'; ctx.fillRect(20,37,8,2);
    });

    // 96x96 versions for intro dialog
    GFX.simonFaceHappyLarge = c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simonFaceHappy,0,0,48,48,0,0,96,96); });
    GFX.simonFaceDisappointedLarge = c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simonFaceDisappointed,0,0,48,48,0,0,96,96); });

    // JEFF BEZOS PORTRAIT - 48x48 (for dialog boxes) - Must be before introPortraits
    GFX.jeffFace = c(48,48, ctx => {
        // Background (Amazon orange/gold gradient)
        const grad = ctx.createRadialGradient(24,24,8,24,24,24);
        grad.addColorStop(0, '#ff9900'); grad.addColorStop(1, '#b45309');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Money/power sparkles
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(4,4,2,2); ctx.fillRect(42,6,2,2); ctx.fillRect(8,38,2,2); ctx.fillRect(38,40,2,2);
        // Bald dome with epic shine
        ctx.fillStyle = '#c4956a'; ctx.fillRect(12,6,24,20);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,7,20,17);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,8,16,14);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(18,8,12,10);
        // LEGENDARY BALD HEAD SHINE
        ctx.fillStyle = '#faebd7'; ctx.fillRect(20,6,8,4);
        ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillRect(22,6,4,3);
        // Arrogant eyebrows
        ctx.fillStyle = '#3f3f46'; ctx.fillRect(16,14,6,2); ctx.fillRect(26,14,6,2);
        // Intense blue eyes (looking down on you)
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(17,17,5,5); ctx.fillRect(26,17,5,5);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(18,18,3,3); ctx.fillRect(27,18,3,3);
        ctx.fillStyle = '#60a5fa'; ctx.fillRect(18,18,2,2); ctx.fillRect(27,18,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(18,18,1,1); ctx.fillRect(27,18,1,1);
        // Nose
        ctx.fillStyle = '#c4956a'; ctx.fillRect(22,20,4,5);
        ctx.fillStyle = '#b8784a'; ctx.fillRect(23,24,2,1);
        // SMUG BILLIONAIRE SMIRK
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(18,26,12,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(20,27,8,1);
        ctx.fillStyle = '#fff'; ctx.fillRect(21,27,6,1); // Perfect teeth
        // One corner raised (smug)
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(28,25,3,1);
        // Ears
        ctx.fillStyle = '#d4a574'; ctx.fillRect(10,16,3,8); ctx.fillRect(35,16,3,8);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(11,17,2,6); ctx.fillRect(35,17,2,6);
        // Expensive suit jacket
        ctx.fillStyle = '#1a2744'; ctx.fillRect(8,30,32,18);
        ctx.fillStyle = '#223050'; ctx.fillRect(10,32,28,14);
        // Lapels
        ctx.fillStyle = '#0f1a2e'; ctx.fillRect(18,32,2,12); ctx.fillRect(28,32,2,12);
        // White shirt & red tie
        ctx.fillStyle = '#e8e8e8'; ctx.fillRect(19,32,10,10);
        ctx.fillStyle = '#ffffff'; ctx.fillRect(20,33,8,8);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(23,33,2,8);
        ctx.fillStyle = '#b91c1c'; ctx.fillRect(23,41,2,3);
    });

    // JEFF BEZOS TALKING PORTRAIT
    GFX.jeffFaceTalking = c(48,48, ctx => {
        ctx.drawImage(GFX.jeffFace, 0, 0);
        // Open mouth (arrogant speech)
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,26,12,4);
        ctx.fillStyle = '#8b4513'; ctx.fillRect(20,27,8,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(22,27,4,1); // Teeth
        // Slight beard adjustment
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(18,30,12,1);
    });

    // INTRO CONVERSATION PORTRAITS - 96x96 (2x size for centered window)
    GFX.introPortraits = {
        "Carrie": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Carrie"],0,0,48,48,0,0,96,96); }),
        "Nevena": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Nevena"],0,0,48,48,0,0,96,96); }),
        "Joao": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Joao"],0,0,48,48,0,0,96,96); }),
        "Roman": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Roman"],0,0,48,48,0,0,96,96); }),
        "Erwin": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFaces["Erwin"],0,0,48,48,0,0,96,96); }),
        "Simon": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simonFaceLarge,0,0,48,48,0,0,96,96); }),
        "Simon Happy": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simonFaceHappy,0,0,48,48,0,0,96,96); }),
        "Simon Disappointed": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simonFaceDisappointed,0,0,48,48,0,0,96,96); }),
        "Jeff Bezos": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.jeffFace,0,0,48,48,0,0,96,96); })
    };

    GFX.introPortraitsTalking = {
        "Carrie": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Carrie"],0,0,48,48,0,0,96,96); }),
        "Nevena": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Nevena"],0,0,48,48,0,0,96,96); }),
        "Joao": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Joao"],0,0,48,48,0,0,96,96); }),
        "Roman": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Roman"],0,0,48,48,0,0,96,96); }),
        "Erwin": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.charFacesTalking["Erwin"],0,0,48,48,0,0,96,96); }),
        "Simon": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.simonFaceTalking,0,0,48,48,0,0,96,96); }),
        "Jeff Bezos": c(96,96, ctx => { ctx.imageSmoothingEnabled=false; ctx.drawImage(GFX.jeffFaceTalking,0,0,48,48,0,0,96,96); })
    };

    // Secret discovery "!" icon - 48x48 for dialog portrait
    GFX.secretIcon = c(48, 48, ctx => {
        // Gradient background circle
        const grad = ctx.createRadialGradient(24, 24, 8, 24, 24, 24);
        grad.addColorStop(0, '#fbbf24');
        grad.addColorStop(0.7, '#f59e0b');
        grad.addColorStop(1, '#d97706');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(24, 24, 22, 0, Math.PI * 2);
        ctx.fill();
        // Border
        ctx.strokeStyle = '#92400e';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Big exclamation mark
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('!', 24, 22);
        // Shadow for depth
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillText('!', 25, 23);
        ctx.fillStyle = '#fff';
        ctx.fillText('!', 24, 22);
    });

    // ENHANCED SIMON BOSS - 32x32 detailed sprite - Short brown hair, glasses, brown beard
    GFX.simonBoss = c(32,32, ctx => {
        // Dark background aura
        const aura = ctx.createRadialGradient(16, 16, 4, 16, 16, 16);
        aura.addColorStop(0, 'rgba(234, 179, 8, 0.3)');
        aura.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = aura;
        ctx.fillRect(0, 0, 32, 32);
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath(); ctx.ellipse(16, 30, 10, 3, 0, 0, Math.PI*2); ctx.fill();
        // Short brown hair
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(8,2,16,6);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(10,3,12,4);
        ctx.fillStyle = '#7a5030'; ctx.fillRect(12,3,4,2); // Highlight
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(8,7,16,11);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(10,9,12,7);
        // Angry brown eyebrows
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(10,9,4,2); ctx.fillRect(18,9,4,2);
        // Glasses (glowing red)
        ctx.fillStyle = '#1e293b'; ctx.fillRect(10,11,5,4); ctx.fillRect(17,11,5,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,12,3,2); ctx.fillRect(18,12,3,2);
        ctx.fillStyle = '#475569'; ctx.fillRect(15,13,2,1);
        // Brown beard
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(8,16,16,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(10,16,12,3);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,18,8,2);
        // Gold WHS uniform
        ctx.fillStyle = '#92400e'; ctx.fillRect(6,19,20,13);
        ctx.fillStyle = '#b45309'; ctx.fillRect(8,19,16,10);
        ctx.fillStyle = '#d97706'; ctx.fillRect(10,21,12,6);
        // Large badge
        ctx.fillStyle = '#fff'; ctx.fillRect(11,23,10,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(13,24,6,2);
    });

    // MECHA MEGA SIMON - Transformed final boss
    GFX.mechaMegaSimon = c(48,48, ctx => {
        // Dark energy aura
        const aura = ctx.createRadialGradient(24, 24, 8, 24, 24, 24);
        aura.addColorStop(0, 'rgba(220, 38, 38, 0.4)');
        aura.addColorStop(0.5, 'rgba(234, 179, 8, 0.2)');
        aura.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = aura; ctx.fillRect(0, 0, 48, 48);
        // Mecha body frame
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(8,26,32,18);
        ctx.fillStyle = '#252b3d'; ctx.fillRect(10,28,28,14);
        // Body armor plates
        ctx.fillStyle = '#3d4556'; ctx.fillRect(12,30,24,10);
        ctx.fillStyle = '#4a5568'; ctx.fillRect(14,32,20,6);
        // WHS logo on chest (glowing gold)
        ctx.fillStyle = '#eab308'; ctx.fillRect(18,33,12,6);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(20,34,8,4);
        ctx.fillText('WHS', 24, 38);
        // Shoulder cannons
        ctx.fillStyle = '#374151'; ctx.fillRect(2,22,10,20);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(4,24,6,16);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(5,28,4,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(6,29,2,2);
        ctx.fillStyle = '#374151'; ctx.fillRect(36,22,10,20);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(38,24,6,16);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(39,28,4,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(40,29,2,2);
        // Neck/collar chrome
        ctx.fillStyle = '#6b7280'; ctx.fillRect(14,22,20,5);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(16,23,16,3);
        // Short brown hair with mecha headgear
        ctx.fillStyle = '#374151'; ctx.fillRect(10,2,28,8);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,4,24,5);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(14,5,20,3);
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(12,9,24,12);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,11,20,8);
        // Angry brown eyebrows with mecha enhancement
        ctx.fillStyle = '#374151'; ctx.fillRect(14,10,8,3); ctx.fillRect(26,10,8,3);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(15,11,6,2); ctx.fillRect(27,11,6,2);
        // Glowing red cyber-glasses
        ctx.fillStyle = '#1e293b'; ctx.fillRect(14,13,8,5); ctx.fillRect(26,13,8,5);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(15,14,6,3); ctx.fillRect(27,14,6,3);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(16,15,4,2); ctx.fillRect(28,15,4,2);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(17,15,2,1); ctx.fillRect(29,15,2,1);
        ctx.fillStyle = '#475569'; ctx.fillRect(22,15,4,1);
        // Brown beard with mecha jaw
        ctx.fillStyle = '#374151'; ctx.fillRect(10,18,28,6);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,19,24,4);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(14,19,20,3);
        // Ear comm devices
        ctx.fillStyle = '#4b5563'; ctx.fillRect(8,12,4,8); ctx.fillRect(36,12,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(9,14,2,4); ctx.fillRect(37,14,2,4);
        // Legs/thrusters
        ctx.fillStyle = '#374151'; ctx.fillRect(14,42,8,6); ctx.fillRect(26,42,8,6);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(16,44,4,4); ctx.fillRect(28,44,4,4);
        ctx.fillStyle = '#f97316'; ctx.fillRect(17,46,2,2); ctx.fillRect(29,46,2,2);
    });

    // IMPROVED OPS MANAGER NPC
    GFX.ops = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Slicked hair
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#2d2d2d'; ctx.fillRect(5,2,6,2);
        // Face
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,3);
        // Beady eyes
        ctx.fillStyle = '#000'; ctx.fillRect(5,6,2,2); ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,6,1,1); ctx.fillRect(9,6,1,1);
        // Frown
        ctx.fillStyle = '#8b6b5a'; ctx.fillRect(6,8,4,1);
        // Red manager polo
        ctx.fillStyle = '#991b1b'; ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#b91c1c'; ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,11,8,2);
        // Collar
        ctx.fillStyle = '#fff'; ctx.fillRect(6,10,4,1);
        // Boots
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    // ENHANCED BOSS SPRITES
    GFX.boss_manager = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,0,12,6);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(3,1,10,4);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,5,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,6,6,4);
        ctx.fillStyle = '#000'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(5,7,1,1); ctx.fillRect(9,7,1,1);
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(2,11,12,5);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(3,11,10,3);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,11,2,4);
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(4,15,3,1); ctx.fillRect(9,15,3,1);
    });

    GFX.boss_inspector = c(32,32, ctx => {
        // Clipboard in background (menacing)
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,12,8,14);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(3,13,6,12);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(4,16,4,1); ctx.fillRect(4,19,4,1); // Red violations
        // Grey hair with detail
        ctx.fillStyle = '#52525b'; ctx.fillRect(8,2,16,8);
        ctx.fillStyle = '#6b7280'; ctx.fillRect(10,3,12,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(11,4,10,4); // Highlight
        ctx.fillStyle = '#d4d4d4'; ctx.fillRect(13,4,6,2); // Bright highlight
        // Face with detail
        ctx.fillStyle = '#c4956a'; ctx.fillRect(10,10,12,12);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(11,11,10,10);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(12,12,8,8); // Center face
        // Stern eyebrows (furrowed)
        ctx.fillStyle = '#52525b'; ctx.fillRect(12,13,4,1); ctx.fillRect(18,13,4,1);
        ctx.fillRect(11,12,2,1); ctx.fillRect(21,12,2,1); // Angry angle
        // Stern eyes with glare
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(12,15,3,3); ctx.fillRect(18,15,3,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(13,15,1,1); ctx.fillRect(19,15,1,1); // Cold glint
        // Nose
        ctx.fillStyle = '#c4956a'; ctx.fillRect(15,18,2,3);
        // Frown (stern)
        ctx.fillStyle = '#8b4513'; ctx.fillRect(14,21,4,1);
        // Yellow inspector jacket with detail
        ctx.fillStyle = '#92400e'; ctx.fillRect(6,22,20,10);
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(8,23,16,8);
        ctx.fillStyle = '#eab308'; ctx.fillRect(9,24,14,6);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(10,25,12,4); // Bright center
        // Large inspector badge
        ctx.fillStyle = '#0369a1'; ctx.fillRect(12,26,8,4);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(13,27,6,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(15,27,2,1); // Badge shine
        // Pointing finger (accusatory)
        ctx.fillStyle = '#d4a574'; ctx.fillRect(24,18,4,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(25,18,2,5);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(26,16,2,3); // Pointing finger
        // Boots
        ctx.fillStyle = '#1f2937'; ctx.fillRect(9,30,5,2); ctx.fillRect(18,30,5,2);
    });

    GFX.boss_compliance = c(32,32, ctx => {
        // Document stack in background (audit papers)
        ctx.fillStyle = '#475569'; ctx.fillRect(22,14,8,16);
        ctx.fillStyle = '#e2e8f0'; ctx.fillRect(23,15,6,14);
        ctx.fillStyle = '#0891b2'; ctx.fillRect(24,17,4,1); ctx.fillRect(24,20,4,1); ctx.fillRect(24,23,4,1); // Lines
        // Dark hair with styling
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(8,1,16,9);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(9,2,14,7);
        ctx.fillStyle = '#334155'; ctx.fillRect(10,3,12,5); // Highlight
        ctx.fillStyle = '#475569'; ctx.fillRect(12,3,8,3); // Bright highlight (slicked)
        // Face with detail
        ctx.fillStyle = '#c4956a'; ctx.fillRect(10,9,12,13);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(11,10,10,11);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(12,11,8,9); // Center face
        // Sharp eyebrows (analytical)
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(12,13,4,1); ctx.fillRect(18,13,4,1);
        // Calculating narrow eyes (scrutinizing)
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(12,15,2,3); ctx.fillRect(18,15,2,3);
        ctx.fillStyle = '#64748b'; ctx.fillRect(12,16,2,1); ctx.fillRect(18,16,2,1); // Cold grey eyes
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(12,16,1,1); ctx.fillRect(18,16,1,1); // Glint
        // Nose
        ctx.fillStyle = '#c4956a'; ctx.fillRect(15,17,2,4);
        // Thin neutral mouth (calculating)
        ctx.fillStyle = '#8b4513'; ctx.fillRect(14,21,4,1);
        // Cyan compliance suit with detail
        ctx.fillStyle = '#164e63'; ctx.fillRect(6,21,20,11);
        ctx.fillStyle = '#0891b2'; ctx.fillRect(8,22,16,9);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(9,23,14,7);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(10,24,12,5); // Bright center
        // Necktie (teal)
        ctx.fillStyle = '#115e59'; ctx.fillRect(14,22,4,10);
        ctx.fillStyle = '#14b8a6'; ctx.fillRect(15,22,2,9);
        // Compliance badge
        ctx.fillStyle = '#fff'; ctx.fillRect(12,27,8,3);
        ctx.fillStyle = '#0891b2'; ctx.fillRect(13,28,6,1);
        // Hands holding tablet
        ctx.fillStyle = '#475569'; ctx.fillRect(3,24,6,6);
        ctx.fillStyle = '#64748b'; ctx.fillRect(4,25,4,4);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,26,4,2); // Screen glow
        // Shoes
        ctx.fillStyle = '#1e293b'; ctx.fillRect(9,30,5,2); ctx.fillRect(18,30,5,2);
    });

    GFX.boss_regional = c(32,32, ctx => {
        // Trophy/KPI chart in background
        ctx.fillStyle = '#422006'; ctx.fillRect(2,16,7,14);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(3,17,5,12);
        ctx.fillStyle = '#78350f'; ctx.fillRect(4,19,3,1); // Chart bars
        ctx.fillStyle = '#78350f'; ctx.fillRect(4,22,3,3);
        ctx.fillStyle = '#78350f'; ctx.fillRect(4,26,3,6);
        // Styled executive hair with gel
        ctx.fillStyle = '#1e1b4b'; ctx.fillRect(7,1,18,10);
        ctx.fillStyle = '#312e81'; ctx.fillRect(8,2,16,8);
        ctx.fillStyle = '#4c1d95'; ctx.fillRect(9,3,14,6); // Highlight
        ctx.fillStyle = '#6d28d9'; ctx.fillRect(11,3,10,4); // Bright gel shine
        // Face with detail
        ctx.fillStyle = '#c4956a'; ctx.fillRect(10,10,12,12);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(11,11,10,10);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(12,12,8,8); // Center face
        // Executive eyebrows (confident)
        ctx.fillStyle = '#1e1b4b'; ctx.fillRect(12,13,4,2); ctx.fillRect(18,13,4,2);
        // Confident eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(12,16,3,3); ctx.fillRect(18,16,3,3);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(13,17,2,2); ctx.fillRect(19,17,2,2); // Blue eyes
        ctx.fillStyle = '#fff'; ctx.fillRect(13,17,1,1); ctx.fillRect(19,17,1,1); // Sharp glint
        // Nose
        ctx.fillStyle = '#c4956a'; ctx.fillRect(15,18,2,3);
        // Smirk (confident)
        ctx.fillStyle = '#8b4513'; ctx.fillRect(14,21,3,1);
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(17,21,2,1); // Smirk corner
        // Purple executive suit with detail
        ctx.fillStyle = '#3b0764'; ctx.fillRect(6,22,20,10);
        ctx.fillStyle = '#4c1d95'; ctx.fillRect(8,23,16,8);
        ctx.fillStyle = '#6d28d9'; ctx.fillRect(9,24,14,6);
        ctx.fillStyle = '#8b5cf6'; ctx.fillRect(10,25,12,4); // Bright center
        // Gold necktie (status symbol)
        ctx.fillStyle = '#92400e'; ctx.fillRect(14,23,4,9);
        ctx.fillStyle = '#d97706'; ctx.fillRect(15,23,2,8);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(15,24,2,6); // Shine
        // Executive badge
        ctx.fillStyle = '#422006'; ctx.fillRect(11,27,10,3);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(12,28,8,1);
        ctx.fillStyle = '#fff'; ctx.fillRect(14,28,4,1); // Badge shine
        // Phone in hand (always connected)
        ctx.fillStyle = '#1e293b'; ctx.fillRect(23,20,5,8);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(24,21,3,6); // Screen glow
        // Dress shoes
        ctx.fillStyle = '#0a0a0a'; ctx.fillRect(9,30,5,2); ctx.fillRect(18,30,5,2);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(9,30,2,1); ctx.fillRect(18,30,2,1); // Shine
    });

    GFX.boss_sebastian = c(32,32, ctx => {
        // TPH monitor in background
        ctx.fillStyle = '#1e293b'; ctx.fillRect(22,10,8,12);
        ctx.fillStyle = '#14532d'; ctx.fillRect(23,11,6,10);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(24,14,4,2); // TPH number
        ctx.fillStyle = '#ef4444'; ctx.fillRect(24,17,4,2); // Red alert
        // EPIC BALD HEAD with maximum shine
        ctx.fillStyle = '#d4a574'; ctx.fillRect(8,1,16,14);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(9,2,14,12);
        ctx.fillStyle = '#f5d0a0'; ctx.fillRect(10,2,12,10);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(11,1,10,8); // Major shine area
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(12,1,8,6); // Bright shine
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(13,0,6,4); // Epic highlight
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(14,2,4,3); // Gleam
        // Focused eyebrows (stressed)
        ctx.fillStyle = '#6b5340'; ctx.fillRect(11,12,4,1); ctx.fillRect(18,12,4,1);
        ctx.fillRect(10,11,2,1); ctx.fillRect(20,11,2,1); // Furrow
        // Intense eyes (TPH-obsessed)
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(11,14,3,3); ctx.fillRect(18,14,3,3);
        ctx.fillStyle = '#92400e'; ctx.fillRect(12,15,2,2); ctx.fillRect(19,15,2,2); // Brown intense eyes
        ctx.fillStyle = '#fff'; ctx.fillRect(12,15,1,1); ctx.fillRect(19,15,1,1); // Glint
        // Nose
        ctx.fillStyle = '#c4956a'; ctx.fillRect(15,16,2,4);
        // Beard with detail (well-groomed but stressed)
        ctx.fillStyle = '#6b5340'; ctx.fillRect(11,19,10,5);
        ctx.fillStyle = '#7a6248'; ctx.fillRect(12,19,8,4);
        ctx.fillStyle = '#8b7355'; ctx.fillRect(13,20,6,3); // Lighter center
        // Mustache
        ctx.fillStyle = '#6b5340'; ctx.fillRect(13,18,6,2);
        ctx.fillStyle = '#7a6248'; ctx.fillRect(14,18,4,1);
        // Amazon blue polo with detail
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(6,22,20,10);
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(8,23,16,8);
        ctx.fillStyle = '#2563eb'; ctx.fillRect(9,24,14,6);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(10,25,12,4); // Bright center
        // Collar detail
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(10,23,12,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(11,23,10,1); // White collar
        // LARGE orange Amazon smile logo
        ctx.fillStyle = '#c2410c'; ctx.fillRect(12,26,8,4);
        ctx.fillStyle = '#ea580c'; ctx.fillRect(13,27,6,3);
        ctx.fillStyle = '#f97316'; ctx.fillRect(13,27,6,2); // Bright orange
        ctx.fillStyle = '#fb923c'; ctx.fillRect(17,26,3,4); // Smile curve
        // Clipboard in hand (always checking TPH)
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,20,5,10);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(3,21,3,8);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(3,23,3,1); ctx.fillRect(3,25,3,1); // Numbers
        // Work boots
        ctx.fillStyle = '#1f2937'; ctx.fillRect(9,30,5,2); ctx.fillRect(18,30,5,2);
        ctx.fillStyle = '#374151'; ctx.fillRect(10,30,3,1); ctx.fillRect(19,30,3,1); // Scuff marks
    });

    GFX.boss_jelly = c(32,32, ctx => {
        // Policy binder in background
        ctx.fillStyle = '#14532d'; ctx.fillRect(2,14,8,16);
        ctx.fillStyle = '#f0fdf4'; ctx.fillRect(3,15,6,14);
        ctx.fillStyle = '#166534'; ctx.fillRect(4,17,4,1); ctx.fillRect(4,20,4,1); ctx.fillRect(4,23,4,1); // Policy lines
        // Brown hair with styling (professional)
        ctx.fillStyle = '#4a2c1a'; ctx.fillRect(8,2,16,9);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(9,3,14,8);
        ctx.fillStyle = '#7a5142'; ctx.fillRect(10,4,12,6); // Mid-tone
        ctx.fillStyle = '#8b6352'; ctx.fillRect(11,4,10,4); // Highlight
        ctx.fillStyle = '#9d7861'; ctx.fillRect(12,4,8,3); // Bright highlight
        // Face with detail (warm and professional)
        ctx.fillStyle = '#c4956a'; ctx.fillRect(10,10,12,12);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(11,11,10,10);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(12,12,8,8); // Center face
        // Friendly eyebrows (raised, welcoming)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,13,4,1); ctx.fillRect(18,13,4,1);
        ctx.fillRect(12,12,3,1); ctx.fillRect(19,12,3,1); // Arch
        // Kind eyes (understanding)
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(12,15,3,3); ctx.fillRect(18,15,3,3);
        ctx.fillStyle = '#6d4c41'; ctx.fillRect(13,16,2,2); ctx.fillRect(19,16,2,2); // Warm brown eyes
        ctx.fillStyle = '#fff'; ctx.fillRect(13,16,1,1); ctx.fillRect(19,16,1,1); // Friendly glint
        // Nose
        ctx.fillStyle = '#c4956a'; ctx.fillRect(15,17,2,4);
        // Warm smile (reassuring but firm)
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(14,21,4,1);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(13,21,2,1); ctx.fillRect(17,21,2,1); // Smile curves
        ctx.fillStyle = '#8b4513'; ctx.fillRect(14,22,4,1); // Lower lip
        // Green HR jacket with detail
        ctx.fillStyle = '#14532d'; ctx.fillRect(6,22,20,10);
        ctx.fillStyle = '#166534'; ctx.fillRect(8,23,16,8);
        ctx.fillStyle = '#16a34a'; ctx.fillRect(9,24,14,6);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(10,25,12,4); // Bright center
        ctx.fillStyle = '#4ade80'; ctx.fillRect(11,26,10,2); // Highlight
        // Professional collar
        ctx.fillStyle = '#14532d'; ctx.fillRect(11,23,10,2);
        ctx.fillStyle = '#f0fdf4'; ctx.fillRect(12,23,8,1); // White collar
        // Large HR badge (name tag)
        ctx.fillStyle = '#fff'; ctx.fillRect(11,27,10,4);
        ctx.fillStyle = '#166534'; ctx.fillRect(12,28,8,2);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(13,28,6,1); // Name text
        // Pen in hand (always documenting)
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(24,22,2,8);
        ctx.fillStyle = '#60a5fa'; ctx.fillRect(24,22,1,7);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(24,28,2,2); // Pen tip
        // Professional shoes
        ctx.fillStyle = '#1f2937'; ctx.fillRect(9,30,5,2); ctx.fillRect(18,30,5,2);
    });

    GFX.boss_avetta = c(32,32, ctx => {
        // Floating data nodes in background
        ctx.fillStyle = 'rgba(34, 211, 238, 0.4)';
        ctx.fillRect(2,8,4,4); ctx.fillRect(26,12,4,4); ctx.fillRect(4,24,3,3);
        ctx.fillStyle = '#67e8f9';
        ctx.fillRect(3,9,2,2); ctx.fillRect(27,13,2,2); ctx.fillRect(5,25,1,1);
        // AI Platform - robotic chassis
        ctx.fillStyle = '#0a0f1e'; ctx.fillRect(6,6,20,20);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(7,7,18,18);
        ctx.fillStyle = '#1e293b'; ctx.fillRect(8,8,16,16);
        // Main glowing screen with animation effect
        const screenGrad = ctx.createLinearGradient(9,9,23,23);
        screenGrad.addColorStop(0, '#0ea5e9');
        screenGrad.addColorStop(0.5, '#06b6d4');
        screenGrad.addColorStop(1, '#22d3ee');
        ctx.fillStyle = screenGrad;
        ctx.fillRect(9,9,14,14);
        // Scan lines (cybernetic)
        ctx.fillStyle = 'rgba(103, 232, 249, 0.5)';
        ctx.fillRect(10,10,12,1);
        ctx.fillStyle = 'rgba(103, 232, 249, 0.3)';
        ctx.fillRect(10,12,12,1); ctx.fillRect(10,14,12,1);
        ctx.fillRect(10,16,12,1); ctx.fillRect(10,18,12,1);
        ctx.fillRect(10,20,12,1);
        // Data visualization bars
        ctx.fillStyle = '#67e8f9';
        ctx.fillRect(11,13,2,8); ctx.fillRect(14,11,2,10);
        ctx.fillRect(17,15,2,6); ctx.fillRect(20,12,2,9);
        // Central AI core indicator
        ctx.fillStyle = '#14b8a6'; ctx.fillRect(14,15,4,6);
        ctx.fillStyle = '#2dd4bf'; ctx.fillRect(15,16,2,4);
        ctx.fillStyle = '#5eead4'; ctx.fillRect(15,17,2,2); // Bright core
        // Risk assessment indicator (top)
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(14,10,4,2);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(15,10,2,1);
        // Warning light (active assessment)
        ctx.fillStyle = '#ef4444'; ctx.fillRect(19,11,2,2);
        ctx.fillStyle = '#fca5a5'; ctx.fillRect(19,11,1,1); // Pulse
        // Compliance check mark
        ctx.fillStyle = '#22c55e'; ctx.fillRect(12,19,2,2);
        ctx.fillRect(13,20,2,2); ctx.fillRect(14,18,2,2);
        // Corner brackets (sci-fi frame)
        ctx.fillStyle = '#0ea5e9';
        ctx.fillRect(7,7,3,1); ctx.fillRect(7,7,1,3); // Top left
        ctx.fillRect(22,7,3,1); ctx.fillRect(24,7,1,3); // Top right
        ctx.fillRect(7,24,3,1); ctx.fillRect(7,22,1,3); // Bottom left
        ctx.fillRect(22,24,3,1); ctx.fillRect(24,22,1,3); // Bottom right
        // Antenna array
        ctx.fillStyle = '#475569'; ctx.fillRect(14,2,4,5);
        ctx.fillStyle = '#64748b'; ctx.fillRect(15,3,2,4);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(15,3,2,1); // Signal light
        // Base platform
        ctx.fillStyle = '#1e293b'; ctx.fillRect(8,26,16,4);
        ctx.fillStyle = '#334155'; ctx.fillRect(9,27,14,2);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(11,28,2,1); ctx.fillRect(19,28,2,1); // Power indicators
    });

    GFX.boss_bot = c(16,16, ctx => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Robot body
        ctx.fillStyle = '#374151'; ctx.fillRect(2,2,12,12);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(3,3,10,10);
        ctx.fillStyle = '#6b7280'; ctx.fillRect(4,4,8,8);
        // Visor
        ctx.fillStyle = '#1e293b'; ctx.fillRect(3,5,10,3);
        // Glowing eyes
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,6,3,2);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(5,6,1,1);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(9,6,3,2);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(10,6,1,1);
        // Mouth grille
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(5,10,6,2);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(6,10,1,2); ctx.fillRect(8,10,1,2); ctx.fillRect(10,10,1,2);
        // Antenna
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(7,0,2,3);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,0,2,1);
    });

    // === BOSS PORTRAIT FACES (48x48) - For dialog boxes ===
    GFX.bossFaces = {};

    // Labour Inspector Face (48x48)
    GFX.bossFaces.boss_inspector = c(48,48, ctx => {
        // Background gradient (yellow warning)
        const grad = ctx.createRadialGradient(24,24,8,24,24,24);
        grad.addColorStop(0, '#eab308'); grad.addColorStop(1, '#92400e');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Clipboard in background
        ctx.fillStyle = '#78350f'; ctx.fillRect(4,22,10,20);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(5,23,8,18);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(6,26,6,2); ctx.fillRect(6,30,6,2);
        // Grey hair
        ctx.fillStyle = '#52525b'; ctx.fillRect(12,4,24,14);
        ctx.fillStyle = '#6b7280'; ctx.fillRect(14,6,20,10);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(16,7,16,7);
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(14,16,20,18);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(16,18,16,14);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,20,12,10);
        // Stern eyebrows
        ctx.fillStyle = '#52525b'; ctx.fillRect(18,21,6,2); ctx.fillRect(26,21,6,2);
        ctx.fillRect(16,20,2,2); ctx.fillRect(32,20,2,2);
        // Stern eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,24,4,4); ctx.fillRect(26,24,4,4);
        ctx.fillStyle = '#fff'; ctx.fillRect(19,24,1,1); ctx.fillRect(27,24,1,1);
        // Nose
        ctx.fillStyle = '#c4956a'; ctx.fillRect(22,28,4,4);
        // Frown
        ctx.fillStyle = '#8b4513'; ctx.fillRect(20,33,8,2);
        // Yellow jacket
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(10,36,28,12);
        ctx.fillStyle = '#eab308'; ctx.fillRect(12,38,24,8);
        // Badge
        ctx.fillStyle = '#0369a1'; ctx.fillRect(20,40,8,4);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(21,41,6,2);
    });

    // Compliance Auditor Face (48x48)
    GFX.bossFaces.boss_compliance = c(48,48, ctx => {
        // Background gradient (cyan compliance)
        const grad = ctx.createRadialGradient(24,24,8,24,24,24);
        grad.addColorStop(0, '#0ea5e9'); grad.addColorStop(1, '#164e63');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Documents in background
        ctx.fillStyle = '#475569'; ctx.fillRect(34,18,12,26);
        ctx.fillStyle = '#e2e8f0'; ctx.fillRect(35,19,10,24);
        ctx.fillStyle = '#0891b2'; ctx.fillRect(36,22,8,2); ctx.fillRect(36,26,8,2);
        // Dark slicked hair
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(12,2,24,14);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(14,4,20,10);
        ctx.fillStyle = '#334155'; ctx.fillRect(16,5,16,7);
        ctx.fillStyle = '#475569'; ctx.fillRect(18,5,12,4);
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(14,14,20,20);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(16,16,16,16);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,18,12,12);
        // Analytical eyebrows
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(18,20,6,2); ctx.fillRect(26,20,6,2);
        // Narrow scrutinizing eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,23,4,4); ctx.fillRect(26,23,4,4);
        ctx.fillStyle = '#64748b'; ctx.fillRect(19,24,2,2); ctx.fillRect(27,24,2,2);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(19,24,1,1); ctx.fillRect(27,24,1,1);
        // Nose
        ctx.fillStyle = '#c4956a'; ctx.fillRect(22,26,4,5);
        // Thin neutral mouth
        ctx.fillStyle = '#8b4513'; ctx.fillRect(20,32,8,2);
        // Cyan suit
        ctx.fillStyle = '#0891b2'; ctx.fillRect(10,34,28,14);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(12,36,24,10);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(14,38,20,6);
        // Teal necktie
        ctx.fillStyle = '#115e59'; ctx.fillRect(22,34,4,12);
        ctx.fillStyle = '#14b8a6'; ctx.fillRect(23,34,2,11);
    });

    // Sebastian S. Face (48x48)
    GFX.bossFaces.boss_sebastian = c(48,48, ctx => {
        // Background gradient (blue Amazon)
        const grad = ctx.createRadialGradient(24,24,8,24,24,24);
        grad.addColorStop(0, '#3b82f6'); grad.addColorStop(1, '#1e3a8a');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // TPH monitor
        ctx.fillStyle = '#1e293b'; ctx.fillRect(34,12,12,16);
        ctx.fillStyle = '#14532d'; ctx.fillRect(35,13,10,14);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(36,16,6,3);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(36,22,6,3);
        // EPIC BALD HEAD
        ctx.fillStyle = '#d4a574'; ctx.fillRect(12,2,24,22);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(14,3,20,18);
        ctx.fillStyle = '#f5d0a0'; ctx.fillRect(16,3,16,14);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(18,2,12,10);
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(20,2,8,6);
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(22,0,6,4);
        // Stressed eyebrows
        ctx.fillStyle = '#6b5340'; ctx.fillRect(16,18,6,2); ctx.fillRect(26,18,6,2);
        ctx.fillRect(14,17,2,2); ctx.fillRect(32,17,2,2);
        // Intense eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(16,21,5,4); ctx.fillRect(26,21,5,4);
        ctx.fillStyle = '#92400e'; ctx.fillRect(17,22,3,3); ctx.fillRect(27,22,3,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(17,22,1,1); ctx.fillRect(27,22,1,1);
        // Beard
        ctx.fillStyle = '#6b5340'; ctx.fillRect(16,26,16,8);
        ctx.fillStyle = '#7a6248'; ctx.fillRect(18,27,12,6);
        ctx.fillStyle = '#8b7355'; ctx.fillRect(20,28,8,4);
        // Blue Amazon polo
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(10,34,28,14);
        ctx.fillStyle = '#2563eb'; ctx.fillRect(12,36,24,10);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(14,38,20,6);
        // Orange Amazon logo
        ctx.fillStyle = '#ea580c'; ctx.fillRect(18,40,12,5);
        ctx.fillStyle = '#f97316'; ctx.fillRect(19,41,10,3);
        ctx.fillStyle = '#fb923c'; ctx.fillRect(26,40,5,5);
    });

    // Regional OPS MGR Face (48x48)
    GFX.bossFaces.boss_regional = c(48,48, ctx => {
        // Background gradient (purple executive)
        const grad = ctx.createRadialGradient(24,24,8,24,24,24);
        grad.addColorStop(0, '#8b5cf6'); grad.addColorStop(1, '#3b0764');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // KPI chart in background
        ctx.fillStyle = '#422006'; ctx.fillRect(4,20,10,20);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(5,21,8,18);
        ctx.fillStyle = '#78350f'; ctx.fillRect(6,24,4,2); ctx.fillRect(6,28,4,5); ctx.fillRect(6,34,4,8);
        // Executive hair with gel
        ctx.fillStyle = '#1e1b4b'; ctx.fillRect(10,2,28,16);
        ctx.fillStyle = '#312e81'; ctx.fillRect(12,4,24,12);
        ctx.fillStyle = '#4c1d95'; ctx.fillRect(14,5,20,9);
        ctx.fillStyle = '#6d28d9'; ctx.fillRect(16,5,16,6);
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(14,16,20,18);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(16,18,16,14);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,20,12,10);
        // Confident eyebrows
        ctx.fillStyle = '#1e1b4b'; ctx.fillRect(18,21,6,3); ctx.fillRect(26,21,6,3);
        // Confident blue eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,25,5,4); ctx.fillRect(26,25,5,4);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(19,26,3,3); ctx.fillRect(27,26,3,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(19,26,1,1); ctx.fillRect(27,26,1,1);
        // Smirk
        ctx.fillStyle = '#8b4513'; ctx.fillRect(20,31,5,2);
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(25,31,3,2);
        // Purple suit
        ctx.fillStyle = '#4c1d95'; ctx.fillRect(10,34,28,14);
        ctx.fillStyle = '#6d28d9'; ctx.fillRect(12,36,24,10);
        ctx.fillStyle = '#8b5cf6'; ctx.fillRect(14,38,20,6);
        // Gold tie
        ctx.fillStyle = '#d97706'; ctx.fillRect(22,34,4,12);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(23,35,2,10);
    });

    // Jelena "Jelly" HR Face (48x48)
    GFX.bossFaces.boss_jelly = c(48,48, ctx => {
        // Background gradient (green HR)
        const grad = ctx.createRadialGradient(24,24,8,24,24,24);
        grad.addColorStop(0, '#22c55e'); grad.addColorStop(1, '#14532d');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Policy binder
        ctx.fillStyle = '#14532d'; ctx.fillRect(4,18,12,24);
        ctx.fillStyle = '#f0fdf4'; ctx.fillRect(5,19,10,22);
        ctx.fillStyle = '#166534'; ctx.fillRect(6,22,8,2); ctx.fillRect(6,26,8,2); ctx.fillRect(6,30,8,2);
        // Brown styled hair
        ctx.fillStyle = '#4a2c1a'; ctx.fillRect(12,4,24,14);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(14,6,20,10);
        ctx.fillStyle = '#7a5142'; ctx.fillRect(16,7,16,8);
        ctx.fillStyle = '#8b6352'; ctx.fillRect(18,7,12,5);
        // Warm face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(14,16,20,18);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(16,18,16,14);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,20,12,10);
        // Friendly raised eyebrows
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(18,21,6,2); ctx.fillRect(26,21,6,2);
        ctx.fillRect(18,20,4,2); ctx.fillRect(28,20,4,2);
        // Kind warm eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,24,5,4); ctx.fillRect(26,24,5,4);
        ctx.fillStyle = '#6d4c41'; ctx.fillRect(19,25,3,3); ctx.fillRect(27,25,3,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(19,25,1,1); ctx.fillRect(27,25,1,1);
        // Warm smile
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(20,31,8,2);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(19,31,2,2); ctx.fillRect(27,31,2,2);
        // Green HR jacket
        ctx.fillStyle = '#166534'; ctx.fillRect(10,34,28,14);
        ctx.fillStyle = '#16a34a'; ctx.fillRect(12,36,24,10);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(14,38,20,6);
        ctx.fillStyle = '#4ade80'; ctx.fillRect(16,40,16,3);
        // HR badge
        ctx.fillStyle = '#fff'; ctx.fillRect(18,40,12,6);
        ctx.fillStyle = '#166534'; ctx.fillRect(19,41,10,4);
    });

    // Avetta Platform Face (48x48)
    GFX.bossFaces.boss_avetta = c(48,48, ctx => {
        // Background gradient (cyan tech)
        const grad = ctx.createRadialGradient(24,24,10,24,24,24);
        grad.addColorStop(0, '#22d3ee'); grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Floating data nodes
        ctx.fillStyle = 'rgba(34, 211, 238, 0.5)';
        ctx.fillRect(4,12,6,6); ctx.fillRect(38,16,6,6); ctx.fillRect(6,36,5,5);
        ctx.fillStyle = '#67e8f9';
        ctx.fillRect(5,13,4,4); ctx.fillRect(39,17,4,4); ctx.fillRect(7,37,3,3);
        // AI chassis
        ctx.fillStyle = '#0a0f1e'; ctx.fillRect(10,8,28,32);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(11,9,26,30);
        ctx.fillStyle = '#1e293b'; ctx.fillRect(12,10,24,28);
        // Glowing screen
        const screenGrad = ctx.createLinearGradient(13,11,35,37);
        screenGrad.addColorStop(0, '#0ea5e9'); screenGrad.addColorStop(0.5, '#06b6d4'); screenGrad.addColorStop(1, '#22d3ee');
        ctx.fillStyle = screenGrad;
        ctx.fillRect(13,11,22,26);
        // Scan lines
        ctx.fillStyle = 'rgba(103, 232, 249, 0.5)';
        for (let y = 13; y < 35; y += 3) ctx.fillRect(14,y,20,1);
        // Data bars
        ctx.fillStyle = '#67e8f9';
        ctx.fillRect(16,16,4,14); ctx.fillRect(22,13,4,17); ctx.fillRect(28,19,4,11);
        // AI core
        ctx.fillStyle = '#14b8a6'; ctx.fillRect(21,22,6,8);
        ctx.fillStyle = '#2dd4bf'; ctx.fillRect(22,23,4,6);
        ctx.fillStyle = '#5eead4'; ctx.fillRect(23,24,2,4);
        // Risk indicator
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(21,14,6,4);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(22,15,4,2);
        // Warning light
        ctx.fillStyle = '#ef4444'; ctx.fillRect(29,15,4,4);
        ctx.fillStyle = '#fca5a5'; ctx.fillRect(30,16,2,2);
        // Corner brackets
        ctx.fillStyle = '#0ea5e9';
        ctx.fillRect(11,9,5,2); ctx.fillRect(11,9,2,5);
        ctx.fillRect(32,9,5,2); ctx.fillRect(35,9,2,5);
        ctx.fillRect(11,37,5,2); ctx.fillRect(11,33,2,5);
        ctx.fillRect(32,37,5,2); ctx.fillRect(35,33,2,5);
        // Antenna
        ctx.fillStyle = '#475569'; ctx.fillRect(21,2,6,8);
        ctx.fillStyle = '#64748b'; ctx.fillRect(22,3,4,6);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(23,3,2,2);
    });

    // Generic Boss Manager Face (48x48)
    GFX.bossFaces.boss_manager = c(48,48, ctx => {
        // Background gradient (dark authority)
        const grad = ctx.createRadialGradient(24,24,8,24,24,24);
        grad.addColorStop(0, '#334155'); grad.addColorStop(1, '#0a0f1f');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Dark hair
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(12,4,24,14);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(14,6,20,10);
        ctx.fillStyle = '#2a3755'; ctx.fillRect(16,7,16,7);
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(14,16,20,18);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(16,18,16,14);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,20,12,10);
        // Stern eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,24,4,4); ctx.fillRect(26,24,4,4);
        ctx.fillStyle = '#fff'; ctx.fillRect(19,24,1,1); ctx.fillRect(27,24,1,1);
        // Frown
        ctx.fillStyle = '#8b4513'; ctx.fillRect(20,31,8,2);
        // Dark suit
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(10,34,28,14);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(12,36,24,10);
        // Red tie
        ctx.fillStyle = '#ef4444'; ctx.fillRect(22,36,4,10);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(23,37,2,8);
    });

    // Mecha Jeff Face (48x48)
    GFX.bossFaces.mechaJeff = c(48,48, ctx => {
        // Background gradient (evil red/orange)
        const grad = ctx.createRadialGradient(24,24,10,24,24,24);
        grad.addColorStop(0, '#ff9900'); grad.addColorStop(0.5, '#dc2626'); grad.addColorStop(1, '#0a0a14');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Mecha collar
        ctx.fillStyle = '#6b7280'; ctx.fillRect(10,34,28,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(12,35,24,4);
        // Shoulder cannons
        ctx.fillStyle = '#374151'; ctx.fillRect(2,24,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(4,26,6,14);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(5,28,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(6,30,2,4);
        ctx.fillStyle = '#374151'; ctx.fillRect(36,24,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(38,26,6,14);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(39,28,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(40,30,2,4);
        // EPIC BALD DOME
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(14,4,20,26);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(16,2,16,10);
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(18,2,12,6);
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(20,0,8,4);
        // EVIL RED EYES
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(16,16,7,8); ctx.fillRect(26,16,7,8);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(17,17,5,6); ctx.fillRect(27,17,5,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(18,18,3,4); ctx.fillRect(28,18,3,4);
        ctx.fillStyle = '#fff'; ctx.fillRect(19,18,1,1); ctx.fillRect(29,18,1,1);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(18,26,12,4);
        ctx.fillStyle = '#fff'; ctx.fillRect(20,27,8,2);
        // Mecha body
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(10,40,28,8);
        ctx.fillStyle = '#3d4556'; ctx.fillRect(12,41,24,6);
        // Orange Amazon logo
        ctx.fillStyle = '#ff9900'; ctx.fillRect(18,42,12,4);
        ctx.fillStyle = '#ffb347'; ctx.fillRect(20,43,8,2);
    });

    // Mecha Mega Simon Face (48x48)
    GFX.bossFaces.mechaMegaSimon = c(48,48, ctx => {
        // Background gradient (red mecha)
        const grad = ctx.createRadialGradient(24,24,10,24,24,24);
        grad.addColorStop(0, '#eab308'); grad.addColorStop(0.5, '#dc2626'); grad.addColorStop(1, '#0a0a14');
        ctx.fillStyle = grad; ctx.fillRect(0,0,48,48);
        // Mecha collar
        ctx.fillStyle = '#6b7280'; ctx.fillRect(10,32,28,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(12,33,24,4);
        // Shoulder cannons
        ctx.fillStyle = '#374151'; ctx.fillRect(2,22,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(4,24,6,14);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(5,26,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(6,28,2,4);
        ctx.fillStyle = '#374151'; ctx.fillRect(36,22,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(38,24,6,14);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(39,26,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(40,28,2,4);
        // Brown hair (mecha version)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,4,24,10);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(14,5,20,8);
        ctx.fillStyle = '#7a5030'; ctx.fillRect(16,6,16,5);
        // Face
        ctx.fillStyle = '#c4956a'; ctx.fillRect(14,12,20,18);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(16,14,16,14);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(18,16,12,10);
        // CYBER GLASSES with red glow
        ctx.fillStyle = '#1e293b'; ctx.fillRect(16,18,7,6); ctx.fillRect(26,18,7,6);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(17,19,5,4); ctx.fillRect(27,19,5,4);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(18,20,3,2); ctx.fillRect(28,20,3,2);
        // Bridge
        ctx.fillStyle = '#475569'; ctx.fillRect(23,20,2,2);
        // Beard
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(16,26,16,6);
        ctx.fillStyle = '#6b4423'; ctx.fillRect(18,27,12,4);
        // Mecha body
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(10,38,28,10);
        ctx.fillStyle = '#3d4556'; ctx.fillRect(12,39,24,8);
        // WHS logo
        ctx.fillStyle = '#eab308'; ctx.fillRect(18,40,12,6);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(20,42,8,3);
    });

    // ENHANCED MECHA JEFF - More detailed with animation support
    GFX.mechaJeff = c(64,64, ctx => {
        // === MECHA BODY FRAME - Heavy Industrial Armor ===
        // Base shadow/depth
        ctx.fillStyle = '#0a0f18'; ctx.fillRect(6,30,52,32);
        // Main body chassis
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(8,32,48,28);
        // Body armor plating with gradient effect
        ctx.fillStyle = '#252b3d'; ctx.fillRect(10,33,44,26);
        ctx.fillStyle = '#2d3548'; ctx.fillRect(12,34,40,24);
        // Chest plate with hexagonal pattern
        ctx.fillStyle = '#3d4556'; ctx.fillRect(14,36,36,20);
        ctx.fillStyle = '#4a5568'; ctx.fillRect(16,38,32,16);
        // Armor panel lines
        ctx.fillStyle = '#1a1f2e';
        ctx.fillRect(20,36,2,20); ctx.fillRect(42,36,2,20);
        ctx.fillRect(14,45,36,1);
        // Ventilation grills
        ctx.fillStyle = '#0f1318';
        for (let i = 0; i < 3; i++) {
            ctx.fillRect(22 + i * 6, 50, 4, 4);
        }

        // === AMAZON PRIME REACTOR CORE (chest) ===
        // Outer glow ring
        ctx.fillStyle = '#7f2d00'; ctx.fillRect(22,40,20,12);
        ctx.fillStyle = '#b45309'; ctx.fillRect(23,41,18,10);
        // Core reactor
        ctx.fillStyle = '#ff9900'; ctx.fillRect(24,42,16,8);
        ctx.fillStyle = '#ffb347'; ctx.fillRect(25,43,14,6);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(26,44,12,4);
        // Amazon smile arc (glowing)
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.moveTo(27,47); ctx.quadraticCurveTo(32,51,38,46);
        ctx.lineTo(39,48); ctx.quadraticCurveTo(32,54,26,48);
        ctx.fill();
        // Arrow tip
        ctx.fillStyle = '#ff9900'; ctx.fillRect(37,45,4,3);
        ctx.fillRect(39,43,2,3);

        // === MASSIVE SHOULDER CANNONS WITH MISSILES ===
        // Left shoulder mount
        ctx.fillStyle = '#1f2937'; ctx.fillRect(0,24,14,30);
        ctx.fillStyle = '#374151'; ctx.fillRect(2,26,10,26);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(3,28,8,22);
        // Left cannon barrel
        ctx.fillStyle = '#1f2937'; ctx.fillRect(4,20,6,10);
        ctx.fillStyle = '#374151'; ctx.fillRect(5,18,4,12);
        // Left missile pods
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(3,30,8,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,31,6,2);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(3,36,8,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,37,6,2);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(3,42,8,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,43,6,2);
        // Left targeting light
        ctx.fillStyle = '#ef4444'; ctx.fillRect(6,48,2,3);

        // Right shoulder mount
        ctx.fillStyle = '#1f2937'; ctx.fillRect(50,24,14,30);
        ctx.fillStyle = '#374151'; ctx.fillRect(52,26,10,26);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(53,28,8,22);
        // Right cannon barrel
        ctx.fillStyle = '#1f2937'; ctx.fillRect(54,20,6,10);
        ctx.fillStyle = '#374151'; ctx.fillRect(55,18,4,12);
        // Right missile pods
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(53,30,8,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(54,31,6,2);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(53,36,8,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(54,37,6,2);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(53,42,8,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(54,43,6,2);
        // Right targeting light
        ctx.fillStyle = '#ef4444'; ctx.fillRect(56,48,2,3);

        // === CHROME NECK/COLLAR ASSEMBLY ===
        ctx.fillStyle = '#4b5563'; ctx.fillRect(16,26,32,8);
        ctx.fillStyle = '#6b7280'; ctx.fillRect(18,27,28,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(20,28,24,4);
        // Neck hydraulics
        ctx.fillStyle = '#374151';
        ctx.fillRect(18,28,3,5); ctx.fillRect(43,28,3,5);

        // === BEZOS HEAD - Bald dome with cybernetic enhancements ===
        // Head base
        ctx.fillStyle = '#d4a574'; ctx.fillRect(18,4,28,26);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(20,6,24,22);
        // Bald dome with epic shine
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(22,2,20,14);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(24,1,16,10);
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(26,0,12,8);
        // Multiple head shine highlights
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(26,1,8,4);
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(28,2,4,2);
        ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillRect(29,1,2,2);

        // === CYBERNETIC IMPLANTS ===
        // Forehead implant
        ctx.fillStyle = '#374151'; ctx.fillRect(28,6,8,3);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(29,7,6,1);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(30,7,4,1);

        // === EVIL EYEBROWS - Angled for menace ===
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(22,12); ctx.lineTo(30,14); ctx.lineTo(30,16); ctx.lineTo(22,15); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(42,12); ctx.lineTo(34,14); ctx.lineTo(34,16); ctx.lineTo(42,15); ctx.fill();

        // === GLOWING CYBERNETIC EYES ===
        // Eye sockets (deep)
        ctx.fillStyle = '#0a0a0a'; ctx.fillRect(23,16,8,8); ctx.fillRect(33,16,8,8);
        // Eye housing
        ctx.fillStyle = '#1f2937'; ctx.fillRect(24,17,6,6); ctx.fillRect(34,17,6,6);
        // Glowing red cybernetic eyes
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(25,18,4,4); ctx.fillRect(35,18,4,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(26,19,2,2); ctx.fillRect(36,19,2,2);
        // Eye glow effect
        ctx.fillStyle = '#ef4444'; ctx.fillRect(26,19,1,1); ctx.fillRect(36,19,1,1);
        // Scanning beam effect (varies with animation)
        ctx.fillStyle = 'rgba(239,68,68,0.3)';
        ctx.fillRect(25,22,4,1); ctx.fillRect(35,22,4,1);

        // === EVIL MECHANICAL GRIN ===
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(25,25,14,4);
        ctx.fillStyle = '#374151'; ctx.fillRect(26,26,12,2);
        // Metal teeth
        ctx.fillStyle = '#9ca3af';
        for (let i = 0; i < 6; i++) {
            ctx.fillRect(27 + i * 2, 26, 1, 2);
        }

        // === CYBERNETIC EAR PIECES ===
        ctx.fillStyle = '#374151'; ctx.fillRect(14,12,6,14); ctx.fillRect(44,12,6,14);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(15,14,4,10); ctx.fillRect(45,14,4,10);
        // Ear antenna
        ctx.fillStyle = '#ef4444'; ctx.fillRect(16,10,2,4); ctx.fillRect(46,10,2,4);
        // Ear light strips
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(16,16,2,6); ctx.fillRect(46,16,2,6);

        // === HEAVY MECHA LEGS ===
        // Upper leg armor
        ctx.fillStyle = '#1f2937'; ctx.fillRect(16,56,12,8); ctx.fillRect(36,56,12,8);
        ctx.fillStyle = '#374151'; ctx.fillRect(17,57,10,6); ctx.fillRect(37,57,10,6);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(18,58,8,4); ctx.fillRect(38,58,8,4);
        // Knee joints
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(20,60,4,2); ctx.fillRect(40,60,4,2);
        // Thruster vents on legs
        ctx.fillStyle = '#0891b2'; ctx.fillRect(19,62,2,2); ctx.fillRect(39,62,2,2);
        ctx.fillRect(23,62,2,2); ctx.fillRect(43,62,2,2);
    });

    // Create animated Mecha Jeff frames for eye glow pulsing
    GFX.mechaJeffFrames = [];
    for (let frame = 0; frame < 4; frame++) {
        GFX.mechaJeffFrames[frame] = c(64,64, ctx => {
            // Draw base mecha jeff
            ctx.drawImage(GFX.mechaJeff, 0, 0);
            // Add animated eye glow based on frame
            const glowIntensity = [0.3, 0.5, 0.7, 0.5][frame];
            ctx.fillStyle = `rgba(239, 68, 68, ${glowIntensity})`;
            ctx.beginPath();
            ctx.arc(27, 20, 6 + frame, 0, Math.PI * 2);
            ctx.arc(37, 20, 6 + frame, 0, Math.PI * 2);
            ctx.fill();
            // Reactor core pulse
            const reactorPulse = [0.2, 0.4, 0.6, 0.4][frame];
            ctx.fillStyle = `rgba(255, 153, 0, ${reactorPulse})`;
            ctx.beginPath();
            ctx.arc(32, 46, 8 + frame, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    // IMPROVED ASSOCIATE NPC
    GFX.assoc = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Hair
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#52525b';
        ctx.fillRect(5,2,6,2);
        // Face
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(4,5,8,5);
        ctx.fillStyle = '#e8c49a';
        ctx.fillRect(5,6,6,3);
        // Eyes
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(5,6,2,2);
        ctx.fillRect(9,6,2,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,6,1,1);
        ctx.fillRect(9,6,1,1);
        // Yellow safety vest
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,10,12,6);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(3,10,10,4);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(4,11,8,2);
        // Reflective strips
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(3,11,10,1);
        ctx.fillRect(3,13,10,1);
        // Boots
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(4,15,3,1);
        ctx.fillRect(9,15,3,1);
    });

    // IMPROVED RUNNER NPC (with motion blur effect)
    GFX.runner = c(16,16, ctx => {
        // Motion blur shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(0, 14, 16, 2);
        // Motion lines
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillRect(0, 8, 3, 1);
        ctx.fillRect(0, 11, 2, 1);
        ctx.fillRect(13, 6, 3, 1);
        ctx.fillRect(14, 9, 2, 1);
        // Hair (windswept)
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(3,1,10,4);
        ctx.fillStyle = '#52525b';
        ctx.fillRect(4,2,8,2);
        // Face (leaning forward)
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(5,5,8,5);
        ctx.fillStyle = '#e8c49a';
        ctx.fillRect(6,6,6,3);
        // Wide eyes
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(6,6,2,2);
        ctx.fillRect(10,6,2,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(7,6,1,1);
        ctx.fillRect(11,6,1,1);
        // Yellow vest
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(3,10,11,6);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(4,10,9,4);
        // Reflective strips
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(4,11,9,1);
        ctx.fillRect(4,13,9,1);
        // Running legs
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(3,14,3,2);
        ctx.fillRect(11,14,3,2);
    });

    GFX.van = c(34,18, ctx => {
        ctx.fillStyle = '#020617'; ctx.fillRect(0,12,34,6);
        ctx.fillStyle = '#0b1224'; ctx.fillRect(1,10,32,8);
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(2,4,30,10);
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(2,10,30,2);
        ctx.fillStyle = '#2563eb'; ctx.fillRect(4,6,26,8);
        ctx.fillStyle = '#60a5fa'; ctx.fillRect(6,7,14,5);
        ctx.fillStyle = '#c7d2fe'; ctx.fillRect(20,6,8,6);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(22,9,6,2);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(6,14,8,4); ctx.fillRect(22,14,8,4);
        ctx.fillStyle = '#eab308'; ctx.fillRect(4,12,2,2); ctx.fillRect(28,12,2,2);
        ctx.fillStyle = '#f8fafc'; ctx.fillRect(14,5,2,2);
        ctx.fillStyle = '#0f172a'; ctx.font = '6px monospace'; ctx.fillText('DSP', 6, 11);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(0,15,4,3); ctx.fillRect(30,15,4,3);
    });

    GFX.truck = c(52,20, ctx => {
        ctx.fillStyle = '#020617'; ctx.fillRect(0,14,52,6);
        ctx.fillStyle = '#0b1224'; ctx.fillRect(1,12,50,8);
        ctx.fillStyle = '#cbd5e1'; ctx.fillRect(4,4,44,12);
        ctx.fillStyle = '#e5e7eb'; ctx.fillRect(6,6,40,10);
        ctx.fillStyle = '#94a3b8'; ctx.fillRect(6,8,18,8);
        ctx.fillStyle = '#f8fafc'; ctx.fillRect(24,8,24,8);
        ctx.fillStyle = '#dbeafe'; ctx.fillRect(6,6,14,3);
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(8,6,20,2);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(8,12,34,2);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(10,15,10,4); ctx.fillRect(34,15,10,4);
        ctx.fillStyle = '#facc15'; ctx.fillRect(4,4,4,10);
        ctx.fillStyle = '#0f172a'; ctx.font = '7px monospace'; ctx.fillText('PRIME', 22, 13);
        ctx.fillStyle = '#64748b'; ctx.fillRect(2,10,6,6);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(40,6,6,2);
        ctx.fillStyle = '#c2410c'; ctx.fillRect(0,16,52,1);
    });

    GFX.flyingBox = c(14,14, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,3,12,10);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,2,10,10);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(2,6,10,2);
        ctx.fillStyle = '#111827'; ctx.fillRect(4,4,2,2); ctx.fillRect(8,4,2,2);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(6,1,2,2);
    });

    // Bezos escape rocket - MASSIVE space rocket (Blue Origin style)
    GFX.escapeRocket = c(64,128, ctx => {
        // Main body (metallic silver/white)
        ctx.fillStyle = '#e5e7eb';
        ctx.fillRect(20, 16, 24, 96);
        ctx.fillStyle = '#f3f4f6';
        ctx.fillRect(24, 20, 16, 88);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(28, 24, 8, 80);

        // Nose cone (pointed, blue)
        ctx.fillStyle = '#1e40af';
        ctx.beginPath();
        ctx.moveTo(32, 0);
        ctx.lineTo(18, 24);
        ctx.lineTo(46, 24);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.moveTo(32, 4);
        ctx.lineTo(22, 20);
        ctx.lineTo(42, 20);
        ctx.closePath();
        ctx.fill();

        // Blue Origin stripe
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(20, 40, 24, 8);
        ctx.fillRect(20, 70, 24, 8);

        // Amazon arrow logo (orange)
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(24, 50, 16, 12);
        ctx.fillStyle = '#ffb347';
        ctx.beginPath();
        ctx.moveTo(24, 56);
        ctx.lineTo(40, 56);
        ctx.lineTo(40, 58);
        ctx.lineTo(32, 62);
        ctx.lineTo(24, 58);
        ctx.closePath();
        ctx.fill();

        // Windows (multiple)
        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = '#0ea5e9';
            ctx.beginPath();
            ctx.arc(32, 28 + i * 16, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#67e8f9';
            ctx.beginPath();
            ctx.arc(30, 26 + i * 16, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Landing legs / Fins (4 of them, blue)
        ctx.fillStyle = '#1e40af';
        // Left fin
        ctx.beginPath();
        ctx.moveTo(20, 96);
        ctx.lineTo(4, 124);
        ctx.lineTo(12, 124);
        ctx.lineTo(20, 108);
        ctx.closePath();
        ctx.fill();
        // Right fin
        ctx.beginPath();
        ctx.moveTo(44, 96);
        ctx.lineTo(60, 124);
        ctx.lineTo(52, 124);
        ctx.lineTo(44, 108);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.moveTo(22, 98);
        ctx.lineTo(10, 120);
        ctx.lineTo(16, 120);
        ctx.lineTo(22, 106);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(42, 98);
        ctx.lineTo(54, 120);
        ctx.lineTo(48, 120);
        ctx.lineTo(42, 106);
        ctx.closePath();
        ctx.fill();

        // Engine section (darker)
        ctx.fillStyle = '#374151';
        ctx.fillRect(18, 108, 28, 16);
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(22, 110, 20, 12);

        // Engine nozzles (3)
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(22, 120, 6, 8);
        ctx.fillRect(29, 120, 6, 8);
        ctx.fillRect(36, 120, 6, 8);
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(23, 121, 4, 6);
        ctx.fillRect(30, 121, 4, 6);
        ctx.fillRect(37, 121, 4, 6);
    });

    GFX.clutter = { cart: c(16,16, ctx => { ctx.fillStyle = '#444'; ctx.fillRect(2,6,12,8); ctx.fillStyle = '#8b4513'; ctx.fillRect(4,4,8,6); }), coffee: c(8,8, ctx => { ctx.fillStyle='#fff'; ctx.fillRect(2,2,4,5); }), paper: c(8,8, ctx => { ctx.fillStyle='#eee'; ctx.fillRect(1,3,6,4); }), tape: c(8,8, ctx => { ctx.fillStyle='#d97706'; ctx.beginPath(); ctx.arc(4,4,3,0,Math.PI*2); ctx.fill(); }) };
   GFX.hazards = {
    // --- Liquids / Spills - Chemical leak, wet floor, HazMat ---
    spill: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.ellipse(8,12,7,3,0,0,Math.PI*2); ctx.fill();
        // Dark base (chemical green/blue)
        ctx.fillStyle = '#065f46';
        ctx.beginPath(); ctx.ellipse(8,11,6,3,0,0,Math.PI*2); ctx.fill();
        // Main puddle (bleach/detergent blue-green)
        ctx.fillStyle = '#0d9488';
        ctx.beginPath(); ctx.ellipse(8,10,5,2.5,0,0,Math.PI*2); ctx.fill();
        // Chemical sheen highlight
        ctx.fillStyle = '#5eead4';
        ctx.beginPath(); ctx.ellipse(6,9,2,1,0,0,Math.PI*2); ctx.fill();
        // Wet floor warning triangle
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath(); ctx.moveTo(8,2); ctx.lineTo(12,8); ctx.lineTo(4,8); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#111';
        ctx.fillRect(7,4,2,2); ctx.fillRect(7,7,2,1);
    }),

    // --- Heavy Non-Con Package (Dog Food, Furniture) ---
    box: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(1,5,14,11);
        // Main box (larger, heavier)
        ctx.fillStyle = '#78350f';
        ctx.fillRect(0,3,15,11);
        // Front face
        ctx.fillStyle = '#92400e';
        ctx.fillRect(1,4,13,9);
        // Bulging sides (overweight)
        ctx.fillStyle = '#a16207';
        ctx.fillRect(2,5,11,7);
        // HEAVY warning label (red)
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(3,6,6,3);
        ctx.fillStyle = '#fff';
        ctx.fillRect(4,7,4,1); // "HEAVY" text
        // Weight indicator "20kg+"
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(10,6,4,3);
        ctx.fillStyle = '#111';
        ctx.fillRect(11,7,2,1);
        // Team lift icon
        ctx.fillStyle = '#111';
        ctx.fillRect(5,10,2,2); ctx.fillRect(8,10,2,2); // Two people
        ctx.fillRect(6,11,3,1); // Arms together
    }),

    // --- Chemical drum / hazmat ---
    drum: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8,14,5,2,0,0,Math.PI*2); ctx.fill();
        // Body (safety blue)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(4,3,8,10);
        // Top
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath(); ctx.ellipse(8,3,4,2,0,0,Math.PI*2); ctx.fill();
        // Bands
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(4,5,8,1);
        ctx.fillRect(4,10,8,1);
        // Hazard diamond
        ctx.fillStyle = '#facc15';
        ctx.fillRect(6,6,4,3);
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(7,7,2,1);
    }),

    // --- Damaged Racking / Bent Upright Under Load ---
    tall_pallet: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(3,14,11,2);
        // BENT racking upright (red = damaged!)
        ctx.fillStyle = '#dc2626';
        ctx.save();
        ctx.translate(2,8);
        ctx.rotate(-0.15); // Bent!
        ctx.fillRect(0,-8,2,16);
        ctx.restore();
        // Second upright (also damaged)
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(13,0,2,15);
        // Beam (sagging under weight)
        ctx.fillStyle = '#f97316';
        ctx.fillRect(2,5,12,2);
        ctx.fillRect(2,10,12,2);
        // Heavy load on damaged rack
        ctx.fillStyle = '#92400e';
        ctx.fillRect(4,1,8,4);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(5,2,6,2);
        // More boxes (overloaded!)
        ctx.fillStyle = '#78350f';
        ctx.fillRect(4,6,8,4);
        // WARNING - bent indicator
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(1,14); ctx.lineTo(3,10); ctx.lineTo(5,14); ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#111';
        ctx.fillRect(2,11,2,2);
        // Red violation X
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(10,12,1,3); ctx.fillRect(9,13,3,1);
    }),

    // --- Floor Debris - Pallet Straps, Broken Wood, Shrink Wrap ---
    debris: c(16,16, ctx => {
        // Shadow/floor
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(0,10,16,6);
        // Broken pallet plank
        ctx.save();
        ctx.translate(8,11);
        ctx.rotate(0.25);
        ctx.fillStyle = '#78350f';
        ctx.fillRect(-7,-2,14,3);
        ctx.fillStyle = '#92400e';
        ctx.fillRect(-6,-1,12,1);
        ctx.restore();
        // Pallet STRAP (blue/black - trip hazard!)
        ctx.strokeStyle = '#1e40af';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(1,8); ctx.bezierCurveTo(4,12,8,6,12,10);
        ctx.bezierCurveTo(14,12,15,8,15,12);
        ctx.stroke();
        // Loose shrink wrap
        ctx.fillStyle = '#e2e8f0';
        ctx.fillRect(2,4,5,3);
        ctx.fillStyle = '#cbd5e1';
        ctx.fillRect(3,5,3,1);
        // Nails sticking up (hazard!)
        ctx.fillStyle = '#71717a';
        ctx.fillRect(10,8,1,3);
        ctx.fillRect(6,12,1,2);
        // Warning color
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(9,7,3,2); // Caution area
    }),

    // --- Conveyor with Pinch Point / LOTO Hazard ---
    conveyor: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(2,13,13,3);
        // Frame (industrial gray)
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(0,6,16,8);
        // Belt surface (moving)
        ctx.fillStyle = '#374151';
        ctx.fillRect(1,7,14,6);
        // Drive rollers (pinch point!)
        ctx.fillStyle = '#71717a';
        ctx.beginPath(); ctx.arc(3,10,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(13,10,2,0,Math.PI*2); ctx.fill();
        // Nip point warning (red triangles)
        ctx.fillStyle = '#dc2626';
        ctx.beginPath(); ctx.moveTo(3,7); ctx.lineTo(5,9); ctx.lineTo(1,9); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(13,7); ctx.lineTo(15,9); ctx.lineTo(11,9); ctx.closePath(); ctx.fill();
        // Belt gap (pinch hazard)
        ctx.fillStyle = '#111';
        ctx.fillRect(6,9,4,1);
        // Hand reaching in (LOTO violation!)
        ctx.fillStyle = '#fcd34d';
        ctx.fillRect(7,4,2,4); // Arm
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(6,3,4,2); // Hand
        // Warning strobe
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(0,5,2,2);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(14,5,2,2);
    }),

    // --- Lithium Battery / Thermal Event Risk ---
    battery: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(3,13,10,3);
        // Battery body (swelling/damaged)
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(2,5,12,9);
        ctx.fillStyle = '#374151';
        ctx.fillRect(3,6,10,7);
        // Terminals
        ctx.fillStyle = '#eab308';
        ctx.fillRect(5,3,2,3); ctx.fillRect(9,3,2,3);
        // Thermal warning (flames!)
        ctx.fillStyle = '#f97316';
        ctx.fillRect(4,1,2,3); ctx.fillRect(10,1,2,3);
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(5,0,1,2); ctx.fillRect(11,0,1,2);
        // Swelling indicator
        ctx.fillStyle = '#4b5563';
        ctx.beginPath(); ctx.arc(8,9,3,0,Math.PI*2); ctx.fill();
        // Lightning/danger symbol
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(7,7,2,1); ctx.fillRect(6,8,2,2); ctx.fillRect(8,9,2,2);
        // Red warning label
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(4,11,8,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(6,12,4,1);
    }),

    // --- Daisy-Chained Extension Cords (Red Flag!) ---
    cord: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.ellipse(8,14,7,2,0,0,Math.PI*2); ctx.fill();
        // First cable (orange)
        ctx.strokeStyle = '#f97316';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(1,6); ctx.bezierCurveTo(4,10,6,4,8,8);
        ctx.stroke();
        // Second cable daisy-chained (yellow)
        ctx.strokeStyle = '#eab308';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(8,8); ctx.bezierCurveTo(10,12,12,6,15,10);
        ctx.stroke();
        // Connection point (danger!)
        ctx.fillStyle = '#dc2626';
        ctx.beginPath(); ctx.arc(8,8,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath(); ctx.arc(8,8,2,0,Math.PI*2); ctx.fill();
        // Sparks!
        ctx.fillStyle = '#fff';
        ctx.fillRect(6,6,1,1); ctx.fillRect(10,6,1,1);
        ctx.fillRect(7,10,1,1); ctx.fillRect(9,10,1,1);
        // Plugs
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(0,5,2,3); ctx.fillRect(14,9,2,3);
        // Warning X
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(7,2,2,3); ctx.fillRect(6,3,4,1);
    }),

    // --- Overstuffed Stow Bag / Bin Capacity Exceeded ---
    tote: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(2,13,12,3);
        // Main body (Amazon yellow - bulging)
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(1,4,14,10);
        // Front face (stressed)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(2,5,12,8);
        // OVERSTUFFED - items poking out top!
        ctx.fillStyle = '#92400e';
        ctx.fillRect(3,1,4,5); // Box sticking out
        ctx.fillStyle = '#a16207';
        ctx.fillRect(4,2,2,3);
        ctx.fillStyle = '#78350f';
        ctx.fillRect(9,2,4,4); // Another item
        // Rim (stretched)
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(1,3,14,2);
        // Capacity warning
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(4,7,8,3);
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,8,6,1); // "FULL"
        // Strain marks
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(1,6,1,4); ctx.fillRect(14,6,1,4);
        // Handle cutouts (stressed)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(3,4,3,1); ctx.fillRect(10,4,3,1);
    }),

    // --- Stretch wrap / shrink wrap ---
    wrap: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(3,12,10,3);
        // Crumpled wrap
        ctx.fillStyle = '#e2e8f0';
        ctx.beginPath();
        ctx.moveTo(2,5); ctx.lineTo(14,4); ctx.lineTo(13,12); ctx.lineTo(3,13);
        ctx.closePath(); ctx.fill();
        // Texture lines
        ctx.fillStyle = '#cbd5e1';
        ctx.fillRect(4,6,8,1); ctx.fillRect(5,9,6,1);
        // Stretched tension
        ctx.fillStyle = '#f1f5f9';
        ctx.fillRect(6,7,4,2);
        // Torn edge
        ctx.fillStyle = '#94a3b8';
        ctx.fillRect(10,10,3,2);
    }),

    // --- Heavy Cage with Stuck Wheels / High Rolling Resistance ---
    cage: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(3,14,11,2);
        // Frame (blue warehouse cage - overloaded)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(1,1,14,13);
        // Wire mesh pattern
        ctx.fillStyle = '#3b82f6';
        for (let x = 2; x <= 13; x += 2) { ctx.fillRect(x,2,1,11); }
        for (let y = 3; y <= 11; y += 2) { ctx.fillRect(2,y,12,1); }
        // OVERLOADED contents (bulging)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(3,3,10,9);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(4,4,8,7);
        // Heavy weight indicator
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,5,6,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(6,6,4,1);
        // DAMAGED/STUCK wheels (red)
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(2,13,3,3); ctx.fillRect(11,13,3,3);
        // Wheel jam indicator
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(0,14,2,1); ctx.fillRect(14,14,2,1);
        // Door jamming on floor
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(7,12,2,4);
    }),

    // --- Go-Cart with Bad Wheels (200kg+ Heavy Load) ---
    cart: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(2,13,13,3);
        // Platform (Amazon blue, overloaded)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(1,8,14,5);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(2,7,12,2);
        // Heavy load on top (boxes)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(3,3,10,5);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(4,4,8,3);
        // Weight indicator (200kg+)
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,4,6,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(6,5,4,1);
        // Handle frame
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(1,2,2,7);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(1,2,3,1);
        // BAD WHEELS (damaged, stuck)
        ctx.fillStyle = '#ef4444'; // Red = bad
        ctx.fillRect(2,12,3,3); ctx.fillRect(11,12,3,3);
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(3,13,1,1); ctx.fillRect(12,13,1,1);
        // Struggle lines (hard to push)
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(0,10,2,1); ctx.fillRect(14,10,2,1);
    }),

    // --- Blocked Fire Exit (Red Flag Violation!) ---
    door: c(16,16, ctx => {
        // Frame (emergency red)
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(2,0,12,16);
        // Door panel (safety green)
        ctx.fillStyle = '#15803d';
        ctx.fillRect(3,1,10,14);
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(4,2,8,12);
        // EXIT sign (lit)
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,1,6,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(6,1,4,1);
        // Push bar
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(4,7,8,2);
        // Running person icon
        ctx.fillStyle = '#fff';
        ctx.fillRect(7,4,2,1); // Head
        ctx.fillRect(6,5,4,2); // Body
        // BLOCKING PALLET (hazard!)
        ctx.fillStyle = '#92400e';
        ctx.fillRect(0,8,6,7);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(1,9,4,5);
        // Boxes on pallet blocking exit
        ctx.fillStyle = '#78350f';
        ctx.fillRect(1,6,5,3);
        // Big red X (violation)
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(11,10,4,1); ctx.fillRect(13,8,1,5);
        ctx.fillRect(11,8,1,1); ctx.fillRect(14,12,1,1);
    }),

    // --- Open Dock Door - Cold Stress / Temperature Extreme ---
    dock: c(16,16, ctx => {
        // Outside (cold blue - winter)
        ctx.fillStyle = '#0c4a6e';
        ctx.fillRect(0,0,16,8);
        // Snow/ice outside
        ctx.fillStyle = '#e0f2fe';
        ctx.fillRect(1,5,3,2); ctx.fillRect(6,4,4,3); ctx.fillRect(12,5,3,2);
        // Dock opening frame
        ctx.fillStyle = '#374151';
        ctx.fillRect(0,7,16,2);
        // Dock plate
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(1,9,14,6);
        // Diamond plate
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(2,10,2,1); ctx.fillRect(6,10,2,1); ctx.fillRect(10,10,2,1);
        // Yellow safety edge
        ctx.fillStyle = '#eab308';
        ctx.fillRect(1,8,14,2);
        ctx.fillStyle = '#111';
        ctx.fillRect(3,8,2,2); ctx.fillRect(7,8,2,2); ctx.fillRect(11,8,2,2);
        // Cold air coming in (wind lines)
        ctx.fillStyle = '#93c5fd';
        ctx.fillRect(2,2,4,1); ctx.fillRect(8,1,5,1); ctx.fillRect(4,4,6,1);
        // Snowflake icon
        ctx.fillStyle = '#fff';
        ctx.fillRect(13,1,1,3); ctx.fillRect(12,2,3,1);
        // Temperature warning
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(1,11,3,4); // Thermometer
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(2,12,1,2);
    }),

    // --- Noise Exposure / Environmental Hazard (>85dB) ---
    facility: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8,15,5,2,0,0,Math.PI*2); ctx.fill();
        // Alarm/speaker unit
        ctx.fillStyle = '#374151';
        ctx.fillRect(4,5,8,8);
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(5,6,6,6);
        // Speaker cone
        ctx.fillStyle = '#1f2937';
        ctx.beginPath(); ctx.arc(8,9,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(8,9,2,0,Math.PI*2); ctx.fill();
        // Sound waves (noise!)
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(8,9,5,5.5,0.8); ctx.stroke();
        ctx.beginPath(); ctx.arc(8,9,6,5.5,0.8); ctx.stroke();
        // dB warning label
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(3,1,10,4);
        ctx.fillStyle = '#111';
        ctx.fillRect(5,2,6,2); // ">85dB"
        // Ear protection required icon
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(1,6,3,5);
        ctx.fillStyle = '#fff';
        ctx.fillRect(2,7,1,3);
        // Mount
        ctx.fillStyle = '#374151';
        ctx.fillRect(6,12,4,3);
    }),

    // --- Ergonomic Hazard Worker (Awkward Posture/Overreaching) ---
    npc: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath(); ctx.ellipse(8,15,5,2,0,0,Math.PI*2); ctx.fill();
        // Bent/twisted body posture
        ctx.fillStyle = '#ca8a04';
        ctx.save();
        ctx.translate(8,10);
        ctx.rotate(0.3); // Twisted spine!
        ctx.fillRect(-3,-3,6,7);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(-2,-2,4,5);
        ctx.restore();
        // Head (looking up - overreaching)
        ctx.fillStyle = '#fcd34d';
        ctx.beginPath(); ctx.arc(9,4,3,0,Math.PI*2); ctx.fill();
        // Hi-vis stripes
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(5,8,6,1); ctx.fillRect(5,11,6,1);
        // Arm reaching HIGH (top shelf hazard)
        ctx.fillStyle = '#fcd34d';
        ctx.fillRect(11,2,2,5); // Arm up high
        ctx.fillRect(12,0,3,2); // Hand at top
        // Pain indicator (red back)
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(6,9,4,2); // Lower back strain
        // Stow bag above (what they're reaching for)
        ctx.fillStyle = '#374151';
        ctx.fillRect(13,0,3,4);
        // Legs (bent awkwardly)
        ctx.fillStyle = '#1e3a8a';
        ctx.fillRect(5,13,2,2); ctx.fillRect(9,12,2,3);
    }),

    // --- EPJ / Pallet Jack - Foot Injury Hazard ---
    forklift: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(2,13,13,3);
        // EPJ body (Amazon orange)
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(5,6,6,5);
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(6,7,4,3);
        // Handle/controls
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(6,2,4,5);
        ctx.fillStyle = '#374151';
        ctx.fillRect(7,3,2,3);
        // Control buttons
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(7,4,1,1);
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(8,4,1,1);
        // Forks (yellow safety)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(1,10,5,2); ctx.fillRect(10,10,5,2);
        // Wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(2,11,2,3); ctx.fillRect(12,11,2,3);
        ctx.fillRect(7,11,2,3);
        // FOOT being run over (hazard!)
        ctx.fillStyle = '#fcd34d';
        ctx.fillRect(0,12,3,2); // Foot
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(1,12,2,1); // Injury indicator
        // Warning stripes on forks
        ctx.fillStyle = '#111';
        ctx.fillRect(2,10,1,2); ctx.fillRect(4,10,1,2);
        ctx.fillRect(11,10,1,2); ctx.fillRect(13,10,1,2);
    }),

    // --- DSP Van / yard hazard ---
    yard: c(16,16, ctx => {
        // Asphalt
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(0,6,16,10);
        // Lane markings
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,10,3,1); ctx.fillRect(7,10,3,1); ctx.fillRect(12,10,3,1);
        // Prime van body
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(3,3,10,7);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(4,4,8,5);
        // Windshield
        ctx.fillStyle = '#0c4a6e';
        ctx.fillRect(10,4,3,3);
        // Prime smile logo
        ctx.fillStyle = '#f97316';
        ctx.fillRect(5,6,4,1); ctx.fillRect(8,5,1,1);
        // Wheels
        ctx.fillStyle = '#111';
        ctx.fillRect(4,9,2,3); ctx.fillRect(10,9,2,3);
        // Headlights
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(11,8,2,1);
    }),

    // --- LOTO Violation / Safety Compliance Failure ---
    compliance: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(3,13,10,3);
        // LOTO Padlock (missing/open - violation!)
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(1,2,6,6);
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(2,3,4,4);
        // Open shackle (not locked!)
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,0,1,3);
        ctx.fillRect(5,0,1,3);
        ctx.fillRect(2,0,4,1);
        // Missing padlock body
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(3,4,2,2);
        // Clipboard with violations
        ctx.fillStyle = '#92400e';
        ctx.fillRect(8,1,7,14);
        ctx.fillStyle = '#f5f5f4';
        ctx.fillRect(9,3,5,10);
        // Checklist with X marks
        ctx.fillStyle = '#71717a';
        ctx.fillRect(10,4,3,1); ctx.fillRect(10,6,3,1); ctx.fillRect(10,8,3,1);
        // All FAILED (red X)
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(13,4,1,1); ctx.fillRect(13,6,1,1); ctx.fillRect(13,8,1,1);
        // VIOLATION stamp
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(9,10,5,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(10,11,3,1);
        // Warning triangle
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath(); ctx.moveTo(4,10); ctx.lineTo(7,15); ctx.lineTo(1,15); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#111';
        ctx.fillRect(3,12,2,1); ctx.fillRect(3,14,2,1);
    }),

    // --- Box cutter / safety blade ---
    blade: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(4,12,10,3);
        // Handle (safety orange)
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(2,7,9,4);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(3,8,7,2);
        // Grip ridges
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(4,8,1,2); ctx.fillRect(6,8,1,2); ctx.fillRect(8,8,1,2);
        // Blade (exposed!)
        ctx.fillStyle = '#d4d4d8';
        ctx.fillRect(10,8,4,2);
        ctx.fillStyle = '#a1a1aa';
        ctx.fillRect(11,8,3,1);
        // Blade edge (sharp!)
        ctx.fillStyle = '#e4e4e7';
        ctx.fillRect(13,8,1,2);
        // Guard tab
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(10,7,1,4);
    }),

    // --- Pallet Jack / Manual Pump Truck ---
    jack: c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 14, 6, 2, 0, 0, Math.PI*2); ctx.fill();
        // Fork base (yellow safety color)
        ctx.fillStyle = '#eab308';
        ctx.fillRect(2,10,12,3);
        // Fork tines
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,12,3,2);
        ctx.fillRect(11,12,3,2);
        // Main body/pump
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(6,5,4,6);
        // Handle
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(7,2,2,4);
        ctx.fillRect(6,2,4,1);
        // Wheels
        ctx.fillStyle = '#111827';
        ctx.fillRect(3,13,2,2);
        ctx.fillRect(11,13,2,2);
        // Small steering wheel
        ctx.fillStyle = '#374151';
        ctx.fillRect(7,8,2,1);
    })
};
    // ENHANCED FIRE EXIT DOOR
    GFX.door = c(16,16, ctx => {
        // Door frame shadow
        ctx.fillStyle = '#064e3b';
        ctx.fillRect(1,0,14,16);
        // Door frame
        ctx.fillStyle = '#065f46';
        ctx.fillRect(2,1,12,14);
        // Main door panel
        const doorGrad = ctx.createLinearGradient(3, 0, 13, 0);
        doorGrad.addColorStop(0, '#10b981');
        doorGrad.addColorStop(0.5, '#34d399');
        doorGrad.addColorStop(1, '#10b981');
        ctx.fillStyle = doorGrad;
        ctx.fillRect(3,2,10,12);
        // Window with glow
        ctx.fillStyle = '#0d9488';
        ctx.fillRect(4,3,8,4);
        ctx.fillStyle = '#5eead4';
        ctx.fillRect(5,4,6,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,4,3,1);
        // Handle
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(10,8,3,2);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(11,8,1,2);
        // EXIT text indicator
        ctx.fillStyle = '#ecfdf5';
        ctx.fillRect(5,10,6,2);
    });

    // ENHANCED WAREHOUSE FLOOR - industrial concrete look
    GFX.floor = c(16,16, ctx => {
        // Warehouse concrete base
        ctx.fillStyle = '#3a3f4a';
        ctx.fillRect(0,0,16,16);
        // Concrete texture variation
        ctx.fillStyle = '#424750';
        ctx.fillRect(2,2,4,4);
        ctx.fillRect(10,8,3,3);
        ctx.fillRect(5,11,4,3);
        // Subtle grid lines
        ctx.strokeStyle = '#4a5058';
        ctx.lineWidth = 1;
        ctx.strokeRect(0,0,16,16);
        // Scuff marks
        ctx.fillStyle = '#32363d';
        ctx.fillRect(8,3,2,1);
        ctx.fillRect(3,9,1,2);
    });

    // 5S FLOOR MARKINGS - Amazon warehouse style
    // Yellow walkway line (horizontal)
    GFX.floor5sLineH = c(16,16, ctx => {
        // Base floor
        ctx.fillStyle = '#3a3f4a';
        ctx.fillRect(0,0,16,16);
        // Yellow walkway tape - horizontal
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(0,6,16,4);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(0,7,16,2);
    });

    // Yellow walkway line (vertical)
    GFX.floor5sLineV = c(16,16, ctx => {
        // Base floor
        ctx.fillStyle = '#3a3f4a';
        ctx.fillRect(0,0,16,16);
        // Yellow walkway tape - vertical
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(6,0,4,16);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(7,0,2,16);
    });

    // Yellow walkway corner (top-left to bottom)
    GFX.floor5sCornerTL = c(16,16, ctx => {
        ctx.fillStyle = '#3a3f4a';
        ctx.fillRect(0,0,16,16);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(6,6,10,4);
        ctx.fillRect(6,6,4,10);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(7,7,9,2);
        ctx.fillRect(7,7,2,9);
    });

    // Yellow walkway corner (top-right to bottom)
    GFX.floor5sCornerTR = c(16,16, ctx => {
        ctx.fillStyle = '#3a3f4a';
        ctx.fillRect(0,0,16,16);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(0,6,10,4);
        ctx.fillRect(6,6,4,10);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(0,7,9,2);
        ctx.fillRect(7,7,2,9);
    });

    // Hazard zone tape (yellow/black diagonal stripes)
    GFX.floor5sHazard = c(16,16, ctx => {
        ctx.fillStyle = '#3a3f4a';
        ctx.fillRect(0,0,16,16);
        // Yellow/black hazard stripes on edges
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(0,0,16,3);
        ctx.fillRect(0,13,16,3);
        // Black stripes
        ctx.fillStyle = '#1f2937';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect(i*4, 0, 2, 3);
            ctx.fillRect(i*4+2, 13, 2, 3);
        }
    });

    // Pedestrian crossing / zebra marking
    GFX.floor5sZebra = c(16,16, ctx => {
        ctx.fillStyle = '#3a3f4a';
        ctx.fillRect(0,0,16,16);
        // White zebra stripes
        ctx.fillStyle = '#e5e7eb';
        ctx.fillRect(0,2,16,2);
        ctx.fillRect(0,6,16,2);
        ctx.fillRect(0,10,16,2);
        ctx.fillRect(0,14,16,2);
    });

    // Equipment zone (blue marking)
    GFX.floor5sEquip = c(16,16, ctx => {
        ctx.fillStyle = '#3a3f4a';
        ctx.fillRect(0,0,16,16);
        // Blue equipment zone border
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2;
        ctx.strokeRect(1,1,14,14);
        // Blue corner marks
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(0,0,4,2);
        ctx.fillRect(0,0,2,4);
        ctx.fillRect(12,0,4,2);
        ctx.fillRect(14,0,2,4);
        ctx.fillRect(0,14,4,2);
        ctx.fillRect(0,12,2,4);
        ctx.fillRect(12,14,4,2);
        ctx.fillRect(14,12,2,4);
    });

    // ENHANCED WAREHOUSE WALL - Amazon orange shelf racking with packages
    GFX.wall = c(16,16, ctx => {
        // Metal shelf frame (orange Amazon-style)
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(0,0,16,16);
        // Shelf structure
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(1,0,2,16); // Left upright
        ctx.fillRect(13,0,2,16); // Right upright
        ctx.fillRect(0,1,16,2); // Top beam
        ctx.fillRect(0,7,16,2); // Middle beam
        ctx.fillRect(0,13,16,2); // Bottom beam
        // Highlight on metal
        ctx.fillStyle = '#fb923c';
        ctx.fillRect(1,0,1,16);
        ctx.fillRect(13,0,1,16);
        // Packages on shelf - top section
        ctx.fillStyle = '#92400e';
        ctx.fillRect(3,3,5,3);
        ctx.fillStyle = '#a3520f';
        ctx.fillRect(9,3,4,4);
        // Packages on shelf - bottom section
        ctx.fillStyle = '#78350f';
        ctx.fillRect(4,9,4,3);
        ctx.fillStyle = '#92400e';
        ctx.fillRect(9,10,3,2);
    });
    // ENHANCED WAREHOUSE SHELF - Amazon orange racking with yellow/blue totes
    GFX.shelf = c(16,16, ctx => {
        // Metal frame (orange)
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(0,0,16,16);
        ctx.fillStyle = '#ea580c';
        ctx.fillRect(0,0,2,16);
        ctx.fillRect(14,0,2,16);
        ctx.fillRect(0,7,16,2);
        // Yellow totes - top
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(2,1,5,5);
        ctx.fillStyle = '#eab308';
        ctx.fillRect(3,2,3,3);
        ctx.fillStyle = '#ca8a04';
        ctx.fillRect(8,2,5,4);
        // Blue totes - bottom
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(3,9,4,5);
        ctx.fillStyle = '#2563eb';
        ctx.fillRect(4,10,2,3);
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(8,10,5,4);
    });

    // Amazon logo sign (32x16)
    GFX.signAmazon = c(32,16, ctx => {
        ctx.fillStyle = '#232f3e';
        ctx.fillRect(0,0,32,16);
        ctx.fillStyle = '#ff9900';
        ctx.font = 'bold 8px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('amazon', 16, 9);
        ctx.strokeStyle = '#ff9900';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(8, 12);
        ctx.quadraticCurveTo(16, 15, 24, 11);
        ctx.stroke();
    });

    // Region-specific warehouse codes and country names
    const WAREHOUSE_SIGNS = {
        AT: { code: 'DVI1', country: 'AUSTRIA', flag: ['#ed1c24', '#ffffff', '#ed1c24'] },
        DE: { code: 'DMU3', country: 'GERMANY', flag: ['#000000', '#dd0000', '#ffcc00'] },
        NL: { code: 'DNL1', country: 'NETHERLANDS', flag: ['#ae1c28', '#ffffff', '#21468b'] }
    };

    // Helper to get current region's warehouse info
    GFX.getWarehouseInfo = function() {
        const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'AT';
        return WAREHOUSE_SIGNS[region] || WAREHOUSE_SIGNS.AT;
    };

    // Function to regenerate region-specific signs (called when region changes)
    GFX.regenerateRegionSigns = function() {
        const info = GFX.getWarehouseInfo();

        // Regenerate warehouse code sign
        GFX.signDVI1 = c(32,16, ctx => {
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0,0,32,16);
            ctx.fillStyle = '#374151';
            ctx.fillRect(1,1,30,14);
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.strokeRect(2,2,28,12);
            ctx.fillStyle = '#f59e0b';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(info.code, 16, 12);
        });

        // Regenerate country location sign with flag colors
        GFX.signAustria = c(32,16, ctx => {
            // Draw flag stripes
            ctx.fillStyle = info.flag[0];
            ctx.fillRect(0,0,32,5);
            ctx.fillStyle = info.flag[1];
            ctx.fillRect(0,5,32,6);
            ctx.fillStyle = info.flag[2];
            ctx.fillRect(0,11,32,5);
            // Country name overlay
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(4,4,24,8);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 5px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(info.country, 16, 10);
        });
    };

    // Initial warehouse code sign (Austria default)
    GFX.signDVI1 = c(32,16, ctx => {
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(0,0,32,16);
        ctx.fillStyle = '#374151';
        ctx.fillRect(1,1,30,14);
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.strokeRect(2,2,28,12);
        ctx.fillStyle = '#f59e0b';
        ctx.font = 'bold 10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('DVI1', 16, 12);
    });

    // Initial country location sign (Austria default)
    GFX.signAustria = c(32,16, ctx => {
        // Austrian flag colors (red-white-red)
        ctx.fillStyle = '#ed1c24';
        ctx.fillRect(0,0,32,5);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,5,32,6);
        ctx.fillStyle = '#ed1c24';
        ctx.fillRect(0,11,32,5);
        // Country name overlay
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(4,4,24,8);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 5px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('AUSTRIA', 16, 10);
    });

    // Zone signs (INBOUND, OUTBOUND, etc.)
    ['INBOUND', 'OUTBOUND', 'PICKING', 'PACKING', 'SHIPPING'].forEach(zone => {
        GFX['sign' + zone] = c(40,12, ctx => {
            ctx.fillStyle = '#1e40af';
            ctx.fillRect(0,0,40,12);
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(1,1,38,10);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 7px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(zone, 20, 9);
        });
    });

    // Aisle markers (A1-D4)
    ['A','B','C','D'].forEach(row => {
        [1,2,3,4].forEach(num => {
            GFX['aisle' + row + num] = c(16,16, ctx => {
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(0,0,16,16);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(1,1,14,14);
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(row + num, 8, 12);
            });
        });
    });
    // ENHANCED RULE BOOK projectile
    GFX.book = c(10,10, ctx => {
        // Book shadow
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(2,2,8,8);
        // Book cover
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(0,0,8,8);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(1,1,6,6);
        // Book spine
        ctx.fillStyle = '#15803d';
        ctx.fillRect(0,0,2,8);
        // Pages
        ctx.fillStyle = '#f8fafc';
        ctx.fillRect(2,1,5,6);
        // Text lines
        ctx.fillStyle = '#64748b';
        ctx.fillRect(3,2,3,1);
        ctx.fillRect(3,4,2,1);
        // WHS badge
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(3,5,2,2);
    });

    // ENHANCED REQUEST projectile (from ops managers)
    GFX.req = c(12,12, ctx => {
        // Glow effect
        ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
        ctx.beginPath();
        ctx.arc(6, 6, 6, 0, Math.PI * 2);
        ctx.fill();
        // Diamond shape
        ctx.fillStyle = '#fef2f2';
        ctx.beginPath();
        ctx.moveTo(6,0);
        ctx.lineTo(12,6);
        ctx.lineTo(6,12);
        ctx.lineTo(0,6);
        ctx.closePath();
        ctx.fill();
        // Inner diamond
        ctx.fillStyle = '#fecaca';
        ctx.beginPath();
        ctx.moveTo(6,2);
        ctx.lineTo(10,6);
        ctx.lineTo(6,10);
        ctx.lineTo(2,6);
        ctx.closePath();
        ctx.fill();
        // Exclamation mark
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(5,3,2,4);
        ctx.fillRect(5,8,2,2);
    });
    // ENHANCED BOSS PROJECTILE
    GFX.bossProj = c(14,14, ctx => {
        // Outer glow
        const grad = ctx.createRadialGradient(7, 7, 1, 7, 7, 7);
        grad.addColorStop(0, '#f5d0fe');
        grad.addColorStop(0.3, '#e879f9');
        grad.addColorStop(0.6, '#c026d3');
        grad.addColorStop(1, '#86198f');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(7, 7, 6, 0, Math.PI * 2);
        ctx.fill();
        // Core
        ctx.fillStyle = '#fdf4ff';
        ctx.beginPath();
        ctx.arc(7, 7, 2, 0, Math.PI * 2);
        ctx.fill();
        // Sparkle effect
        ctx.fillStyle = '#fff';
        ctx.fillRect(6, 1, 2, 2);
        ctx.fillRect(6, 11, 2, 2);
        ctx.fillRect(1, 6, 2, 2);
        ctx.fillRect(11, 6, 2, 2);
    });

    // Hidden level assets - HIGH QUALITY SNES style
    GFX.van = c(32,22, ctx => {
        // Main body outline
        ctx.fillStyle = '#0a3d5c'; ctx.fillRect(0,1,32,19);
        // Main body - Amazon blue with gradient effect
        ctx.fillStyle = '#146eb4'; ctx.fillRect(1,2,30,17);
        ctx.fillStyle = '#1e7fc4'; ctx.fillRect(1,2,30,2); // Top highlight
        ctx.fillStyle = '#0a4d7c'; ctx.fillRect(1,17,30,2); // Bottom shadow
        // Windshield (angled)
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(2,4,11,8);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(3,5,9,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(4,6,7,4);
        // Side windows
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(14,5,7,7);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(15,6,5,5);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(15,6,4,4);
        ctx.fillStyle = '#4a5f7f'; ctx.fillRect(22,5,7,7);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(23,6,5,5);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(23,6,4,4);
        // Amazon smile arrow
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(15,13,10,2);
        ctx.fillRect(23,13,2,3);
        // Front grille
        ctx.fillStyle = '#222'; ctx.fillRect(2,11,4,3);
        // Wheels (detailed)
        ctx.fillStyle = '#000'; ctx.fillRect(5,19,6,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(6,19,4,3);
        ctx.fillStyle = '#444'; ctx.fillRect(7,20,2,1);
        ctx.fillStyle = '#000'; ctx.fillRect(21,19,6,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(22,19,4,3);
        ctx.fillStyle = '#444'; ctx.fillRect(23,20,2,1);
        // Highlights
        ctx.fillStyle = '#fff'; ctx.fillRect(2,3,2,1); ctx.fillRect(5,5,1,2);
    });
    GFX.truck = c(42,26, ctx => {
        // Outline
        ctx.fillStyle = '#4a2511'; ctx.fillRect(0,1,42,23);
        // Main body - brown with shading
        ctx.fillStyle = '#8b4513'; ctx.fillRect(1,2,40,21);
        ctx.fillStyle = '#a0522d'; ctx.fillRect(1,2,40,3); // Top highlight
        ctx.fillStyle = '#5d2a0a'; ctx.fillRect(1,20,40,3); // Bottom shadow
        // Cab section
        ctx.fillStyle = '#654321'; ctx.fillRect(1,3,14,15);
        // Windshield
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(2,5,13,9);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(3,6,11,7);
        ctx.fillStyle = '#6a9fbe'; ctx.fillRect(4,7,9,5);
        // Cargo section windows
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(17,6,9,8);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(18,7,7,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(19,8,5,4);
        ctx.fillStyle = '#2a3f5f'; ctx.fillRect(28,6,9,8);
        ctx.fillStyle = '#4a6f8f'; ctx.fillRect(29,7,7,6);
        ctx.fillStyle = '#87ceeb'; ctx.fillRect(30,8,5,4);
        // Amazon logo (large on side)
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(18,15,18,4);
        ctx.fillRect(32,15,4,5);
        ctx.fillStyle = '#000';
        ctx.font = '6px monospace';
        ctx.fillText('PRIME', 20, 18);
        // Front grille
        ctx.fillStyle = '#222'; ctx.fillRect(2,13,6,4);
        // Wheels (detailed)
        ctx.fillStyle = '#000'; ctx.fillRect(7,23,7,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,23,5,3);
        ctx.fillStyle = '#555'; ctx.fillRect(9,24,3,1);
        ctx.fillStyle = '#000'; ctx.fillRect(29,23,7,3);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(30,23,5,3);
        ctx.fillStyle = '#555'; ctx.fillRect(31,24,3,1);
        // Highlights
        ctx.fillStyle = '#fff'; ctx.fillRect(2,3,3,1); ctx.fillRect(5,6,1,3);
    });
    GFX.bezosHead = c(24,24, ctx => {
        // Shadow base
        ctx.fillStyle = '#0a0a14'; ctx.fillRect(2,2,20,20);
        // Bald head with shading
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,3,16,17);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(5,4,14,14);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(6,5,12,12);
        // Head shine highlight
        ctx.fillStyle = '#faebd7'; ctx.fillRect(7,4,8,4);
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(8,5,5,2);
        // Evil eyebrows (angled)
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(7,9,5,2); ctx.fillRect(12,9,5,2);
        ctx.fillRect(6,10,1,1); ctx.fillRect(17,10,1,1);
        // Eyes with glint
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,12,4,3); ctx.fillRect(12,12,4,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(9,13,1,1); ctx.fillRect(13,13,1,1);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(8,17,8,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(9,17,6,1);
        // Ears
        ctx.fillStyle = '#d4a574'; ctx.fillRect(2,11,3,5); ctx.fillRect(19,11,3,5);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(3,12,2,3); ctx.fillRect(19,12,2,3);
    });
    // Jeff character for yard level - full body standing with arms crossed
    GFX.jeffYard = c(48,48, ctx => {
        // Transparent background - no fill needed
        // Legs (dark pants)
        ctx.fillStyle = '#1a1f2e'; ctx.fillRect(16,38,6,10); ctx.fillRect(26,38,6,10);
        ctx.fillStyle = '#2d3748'; ctx.fillRect(17,39,4,9); ctx.fillRect(27,39,4,9);
        // Shoes
        ctx.fillStyle = '#0f0f0f'; ctx.fillRect(15,46,8,2); ctx.fillRect(25,46,8,2);
        // Body (expensive suit jacket)
        ctx.fillStyle = '#1a2744'; ctx.fillRect(12,22,24,18);
        ctx.fillStyle = '#223050'; ctx.fillRect(14,24,20,14);
        // Suit lapels
        ctx.fillStyle = '#0f1a2e'; ctx.fillRect(20,24,2,12); ctx.fillRect(26,24,2,12);
        // White shirt underneath
        ctx.fillStyle = '#e8e8e8'; ctx.fillRect(21,24,6,10);
        ctx.fillStyle = '#ffffff'; ctx.fillRect(22,25,4,8);
        // Tie
        ctx.fillStyle = '#dc2626'; ctx.fillRect(23,25,2,8);
        ctx.fillStyle = '#b91c1c'; ctx.fillRect(23,33,2,3);
        // Arms crossed (in front of body)
        ctx.fillStyle = '#1a2744'; ctx.fillRect(10,26,28,8);
        ctx.fillStyle = '#223050'; ctx.fillRect(11,27,26,6);
        // Hands (flesh tone)
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(10,28,4,4); ctx.fillRect(34,28,4,4);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(11,29,2,2); ctx.fillRect(35,29,2,2);
        // Neck
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,18,8,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(21,19,6,4);
        // Head (bald)
        ctx.fillStyle = '#d4a574'; ctx.fillRect(14,2,20,18);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(16,3,16,15);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(18,4,12,12);
        // Dome shine
        ctx.fillStyle = '#faebd7'; ctx.fillRect(20,3,8,4);
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(22,3,4,2);
        // Eyebrows (arrogant raised)
        ctx.fillStyle = '#3f3f46'; ctx.fillRect(18,8,5,2); ctx.fillRect(25,8,5,2);
        // Eyes (looking down smugly)
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(19,11,4,3); ctx.fillRect(25,11,4,3);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(20,12,2,2); ctx.fillRect(26,12,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(20,12,1,1); ctx.fillRect(26,12,1,1);
        // Smug smirk
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(20,16,8,2);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(21,16,6,1);
        // One corner raised (smirk)
        ctx.fillStyle = '#b45a3c'; ctx.fillRect(26,15,3,1);
        // Ears
        ctx.fillStyle = '#d4a574'; ctx.fillRect(12,10,3,6); ctx.fillRect(33,10,3,6);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(13,11,2,4); ctx.fillRect(33,11,2,4);
    });

    GFX.mechaBezos = c(48,48, ctx => {
        // Base plate
        ctx.fillStyle = '#0a0f18'; ctx.fillRect(0,0,48,48);
        // Mecha body with armor
        ctx.fillStyle = '#2d3748'; ctx.fillRect(8,22,32,20);
        ctx.fillStyle = '#3d4a5c'; ctx.fillRect(10,24,28,16);
        ctx.fillStyle = '#4a5568'; ctx.fillRect(12,26,24,12);
        // Amazon logo chest (glowing)
        ctx.fillStyle = '#ff9900'; ctx.fillRect(18,28,12,8);
        ctx.fillStyle = '#ffb347'; ctx.fillRect(20,30,8,4);
        ctx.fillStyle = '#ff6600'; ctx.fillRect(26,32,4,4);
        // Shoulder cannons with glow
        ctx.fillStyle = '#374151'; ctx.fillRect(0,22,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,24,6,14);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(3,28,4,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(4,29,2,2);
        ctx.fillStyle = '#374151'; ctx.fillRect(38,22,10,18);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(40,24,6,14);
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(41,28,4,4);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(42,29,2,2);
        // Neck chrome
        ctx.fillStyle = '#6b7280'; ctx.fillRect(14,18,20,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(16,19,16,4);
        // Bald dome with highlight
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(14,2,20,18);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(16,1,16,8);
        ctx.fillStyle = '#fff5e6'; ctx.fillRect(20,0,8,4);
        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(18,2,6,3);
        // Evil eyebrows
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(16,8,6,2); ctx.fillRect(26,8,6,2);
        // Glowing red eyes
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(17,11,5,5); ctx.fillRect(26,11,5,5);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(18,12,3,3); ctx.fillRect(27,12,3,3);
        ctx.fillStyle = '#ff4444'; ctx.fillRect(19,13,1,1); ctx.fillRect(28,13,1,1);
        // Evil grin
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(19,17,10,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(21,17,6,1);
        // Ear sensors
        ctx.fillStyle = '#4b5563'; ctx.fillRect(10,8,4,8); ctx.fillRect(34,8,4,8);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,10,2,4); ctx.fillRect(35,10,2,4);
        // Legs
        ctx.fillStyle = '#374151'; ctx.fillRect(14,42,8,6); ctx.fillRect(26,42,8,6);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(16,44,4,4); ctx.fillRect(28,44,4,4);
    });
    GFX.bezosProj = c(12,12, ctx => { ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(6,6,5,0,Math.PI*2); ctx.fill(); ctx.fillStyle = '#ff9900'; ctx.beginPath(); ctx.arc(6,6,3,0,Math.PI*2); ctx.fill(); });

    // === DEFEATED BOSS SPRITES (64x64) - Larger, more detailed for defeat cutscene ===
    GFX.bossDefeated = {};

    // Defeated Labour Inspector (64x64) - Slumped, clipboard broken
    GFX.bossDefeated.boss_inspector = c(64,64, ctx => {
        // Dark defeated aura
        const grad = ctx.createRadialGradient(32,40,5,32,40,32);
        grad.addColorStop(0, 'rgba(239, 68, 68, 0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        // Broken clipboard scattered on floor
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,50,14,10);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(4,52,10,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(5,54,3,2); // Red X marks
        // Clipboard piece broken off
        ctx.save(); ctx.translate(50,55); ctx.rotate(0.3);
        ctx.fillStyle = '#78350f'; ctx.fillRect(0,0,8,6);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(1,1,6,4);
        ctx.restore();
        // Grey disheveled hair (messed up)
        ctx.fillStyle = '#52525b'; ctx.fillRect(18,6,28,14);
        ctx.fillStyle = '#6b7280'; ctx.fillRect(20,8,24,10);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(22,9,20,7);
        // Hair strands falling (defeat)
        ctx.fillStyle = '#6b7280'; ctx.fillRect(16,10,2,6); ctx.fillRect(46,12,2,5);
        // Face - defeated expression, tilted down
        ctx.fillStyle = '#c4956a'; ctx.fillRect(20,18,24,22);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(22,20,20,18);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(24,22,16,14);
        // Closed/squinting defeated eyes (X X)
        ctx.fillStyle = '#1a1a1a';
        // Left X eye
        ctx.fillRect(26,27,2,1); ctx.fillRect(28,28,2,1); ctx.fillRect(26,29,2,1);
        ctx.fillRect(28,27,2,1); ctx.fillRect(26,28,2,1); ctx.fillRect(28,29,2,1);
        // Right X eye
        ctx.fillRect(34,27,2,1); ctx.fillRect(36,28,2,1); ctx.fillRect(34,29,2,1);
        ctx.fillRect(36,27,2,1); ctx.fillRect(34,28,2,1); ctx.fillRect(36,29,2,1);
        // Sweat drops
        ctx.fillStyle = '#7dd3fc'; ctx.fillRect(18,24,2,3); ctx.fillRect(44,26,2,3);
        // Open mouth in shock/despair
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(28,34,8,4);
        ctx.fillStyle = '#8b4513'; ctx.fillRect(29,35,6,2);
        // Yellow jacket - wrinkled and defeated
        ctx.fillStyle = '#92400e'; ctx.fillRect(10,40,44,24);
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(12,42,40,20);
        ctx.fillStyle = '#eab308'; ctx.fillRect(14,44,36,16);
        // Wrinkle lines
        ctx.fillStyle = '#92400e'; ctx.fillRect(16,46,2,10); ctx.fillRect(46,48,2,8);
        // Badge falling off (crooked)
        ctx.save(); ctx.translate(22,50); ctx.rotate(-0.2);
        ctx.fillStyle = '#0369a1'; ctx.fillRect(0,0,12,6);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(1,1,10,4);
        ctx.restore();
        // Slumped arms
        ctx.fillStyle = '#d4a574'; ctx.fillRect(8,44,6,12); ctx.fillRect(50,46,6,10);
    });

    // Defeated Compliance Auditor (64x64) - Documents scattered, glasses cracked
    GFX.bossDefeated.boss_compliance = c(64,64, ctx => {
        // Cyan sparks effect
        const grad = ctx.createRadialGradient(32,38,5,32,38,32);
        grad.addColorStop(0, 'rgba(14, 165, 233, 0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        // Scattered documents everywhere
        ctx.fillStyle = '#e2e8f0';
        ctx.save(); ctx.translate(4,52); ctx.rotate(-0.2); ctx.fillRect(0,0,10,8); ctx.restore();
        ctx.save(); ctx.translate(50,48); ctx.rotate(0.3); ctx.fillRect(0,0,10,8); ctx.restore();
        ctx.save(); ctx.translate(20,58); ctx.rotate(0.1); ctx.fillRect(0,0,8,6); ctx.restore();
        // Document text lines (scattered)
        ctx.fillStyle = '#0891b2';
        ctx.fillRect(6,54,6,1); ctx.fillRect(52,50,6,1); ctx.fillRect(22,60,4,1);
        // Dark hair messed up
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(16,4,32,16);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(18,6,28,12);
        ctx.fillStyle = '#334155'; ctx.fillRect(20,7,24,9);
        // Hair out of place
        ctx.fillStyle = '#1a2744'; ctx.fillRect(14,8,4,8); ctx.fillRect(46,10,4,6);
        // Face - shocked/defeated
        ctx.fillStyle = '#c4956a'; ctx.fillRect(18,18,28,24);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,20,24,20);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(22,22,20,16);
        // Cracked glasses
        ctx.fillStyle = '#1e293b'; ctx.fillRect(22,26,10,8); ctx.fillRect(34,26,10,8);
        ctx.fillStyle = '#475569'; ctx.fillRect(23,27,8,6); ctx.fillRect(35,27,8,6);
        // Crack lines on glasses
        ctx.fillStyle = '#fff'; ctx.fillRect(24,28,1,4); ctx.fillRect(25,29,2,1); ctx.fillRect(38,27,3,1); ctx.fillRect(40,28,1,3);
        // Dizzy spiral eyes behind glasses
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(26,29,3,3); ctx.fillRect(38,29,3,3);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(27,30,1,1); ctx.fillRect(39,30,1,1);
        // Open mouth
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(28,38,8,3);
        // Cyan suit disheveled
        ctx.fillStyle = '#164e63'; ctx.fillRect(12,42,40,22);
        ctx.fillStyle = '#0891b2'; ctx.fillRect(14,44,36,18);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(16,46,32,14);
        // Loose tie
        ctx.save(); ctx.translate(30,44); ctx.rotate(0.15);
        ctx.fillStyle = '#115e59'; ctx.fillRect(0,0,6,16);
        ctx.fillStyle = '#14b8a6'; ctx.fillRect(1,0,4,14);
        ctx.restore();
    });

    // Defeated Sebastian S. (64x64) - TPH monitor showing 0, sweating profusely
    GFX.bossDefeated.boss_sebastian = c(64,64, ctx => {
        // Blue sparks from broken monitor
        const grad = ctx.createRadialGradient(32,36,5,32,36,32);
        grad.addColorStop(0, 'rgba(34, 197, 94, 0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        // Broken TPH monitor on ground
        ctx.fillStyle = '#1e293b'; ctx.fillRect(44,48,16,14);
        ctx.fillStyle = '#14532d'; ctx.fillRect(46,50,12,10);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(48,52,8,6); // Error display
        ctx.fillStyle = '#fff'; ctx.fillRect(50,54,4,2); // "0"
        // Spark particles from monitor
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(42,46,2,2); ctx.fillRect(56,52,2,2);
        ctx.fillStyle = '#fff'; ctx.fillRect(44,50,1,1); ctx.fillRect(58,48,1,1);
        // EPIC BALD HEAD - sweaty and red from stress
        ctx.fillStyle = '#e8a574'; ctx.fillRect(16,2,32,24);
        ctx.fillStyle = '#f5c49a'; ctx.fillRect(18,3,28,22);
        ctx.fillStyle = '#fad0a0'; ctx.fillRect(20,3,24,18);
        ctx.fillStyle = '#faebd7'; ctx.fillRect(22,2,20,14);
        // Multiple sweat drops cascading down
        ctx.fillStyle = '#7dd3fc';
        ctx.fillRect(14,8,2,4); ctx.fillRect(48,10,2,4);
        ctx.fillRect(18,14,2,3); ctx.fillRect(44,12,2,4);
        ctx.fillRect(50,16,2,3); ctx.fillRect(12,18,2,3);
        // Stressed eyebrows (very furrowed)
        ctx.fillStyle = '#6b5340'; ctx.fillRect(22,18,8,2); ctx.fillRect(34,18,8,2);
        ctx.fillRect(20,17,2,2); ctx.fillRect(42,17,2,2);
        // Stressed spiral eyes
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(22,22,6,6); ctx.fillRect(36,22,6,6);
        ctx.fillStyle = '#92400e'; ctx.fillRect(24,24,3,3); ctx.fillRect(38,24,3,3);
        ctx.fillStyle = '#fff'; ctx.fillRect(25,25,1,1); ctx.fillRect(39,25,1,1);
        // Beard - disheveled
        ctx.fillStyle = '#6b5340'; ctx.fillRect(20,30,24,10);
        ctx.fillStyle = '#7a6248'; ctx.fillRect(22,31,20,8);
        ctx.fillStyle = '#8b7355'; ctx.fillRect(24,32,16,6);
        // Mustache
        ctx.fillStyle = '#6b5340'; ctx.fillRect(26,29,12,3);
        // Open mouth yelling in defeat
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(28,36,8,4);
        ctx.fillStyle = '#8b4513'; ctx.fillRect(29,37,6,2);
        // Amazon polo wrinkled
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(10,42,44,22);
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(12,44,40,18);
        ctx.fillStyle = '#2563eb'; ctx.fillRect(14,46,36,14);
        // Orange logo flickering/broken
        ctx.fillStyle = '#7f1d00'; ctx.fillRect(24,50,16,8);
        ctx.fillStyle = '#c2410c'; ctx.fillRect(26,51,12,6);
        // Broken clipboard
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,44,10,16);
        ctx.fillStyle = '#fcd34d'; ctx.fillRect(4,46,6,12);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(5,48,4,8); // Red X marks everywhere
    });

    // Defeated Regional OPS MGR (64x64) - Trophy broken, phone cracked
    GFX.bossDefeated.boss_regional = c(64,64, ctx => {
        // Purple defeated glow
        const grad = ctx.createRadialGradient(32,38,5,32,38,32);
        grad.addColorStop(0, 'rgba(139, 92, 246, 0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        // Broken trophy on floor
        ctx.fillStyle = '#92400e'; ctx.fillRect(4,52,10,10);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(6,54,6,6);
        // Trophy top broken off
        ctx.save(); ctx.translate(48,56); ctx.rotate(-0.4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(0,0,6,8);
        ctx.restore();
        // Cracked phone on floor
        ctx.fillStyle = '#1e293b'; ctx.fillRect(50,44,8,14);
        ctx.fillStyle = '#334155'; ctx.fillRect(51,46,6,10);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(52,48,4,6); // Cracked screen (red)
        ctx.fillStyle = '#fff'; ctx.fillRect(53,49,1,4); ctx.fillRect(52,50,3,1); // Crack lines
        // Executive hair - completely messed
        ctx.fillStyle = '#1e1b4b'; ctx.fillRect(14,4,36,16);
        ctx.fillStyle = '#312e81'; ctx.fillRect(16,6,32,12);
        ctx.fillStyle = '#4c1d95'; ctx.fillRect(18,7,28,9);
        // Hair sticking up in panic
        ctx.fillStyle = '#312e81'; ctx.fillRect(22,2,4,6); ctx.fillRect(34,1,4,7); ctx.fillRect(42,3,4,5);
        // Face - defeated shock
        ctx.fillStyle = '#c4956a'; ctx.fillRect(18,18,28,22);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,20,24,18);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(22,22,20,14);
        // Wide shocked eyes
        ctx.fillStyle = '#fff'; ctx.fillRect(24,26,6,6); ctx.fillRect(36,26,6,6);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(26,28,3,3); ctx.fillRect(38,28,3,3);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(27,29,2,2); ctx.fillRect(39,29,2,2);
        // Small pupils (shocked)
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(27,29,1,1); ctx.fillRect(39,29,1,1);
        // Open mouth screaming
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(28,36,8,5);
        ctx.fillStyle = '#8b4513'; ctx.fillRect(30,37,4,3);
        // Purple suit wrinkled
        ctx.fillStyle = '#3b0764'; ctx.fillRect(10,40,44,24);
        ctx.fillStyle = '#4c1d95'; ctx.fillRect(12,42,40,20);
        ctx.fillStyle = '#6d28d9'; ctx.fillRect(14,44,36,16);
        // Tie loosened and crooked
        ctx.save(); ctx.translate(28,42); ctx.rotate(-0.2);
        ctx.fillStyle = '#92400e'; ctx.fillRect(0,0,8,18);
        ctx.fillStyle = '#d97706'; ctx.fillRect(1,1,6,16);
        ctx.restore();
    });

    // Defeated Jelena "Jelly" HR Guardian (64x64) - Policy binder exploded
    GFX.bossDefeated.boss_jelly = c(64,64, ctx => {
        // Green defeated glow
        const grad = ctx.createRadialGradient(32,38,5,32,38,32);
        grad.addColorStop(0, 'rgba(34, 197, 94, 0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        // Exploded policy binder - pages everywhere
        ctx.fillStyle = '#f0fdf4';
        ctx.save(); ctx.translate(2,48); ctx.rotate(-0.3); ctx.fillRect(0,0,12,10); ctx.restore();
        ctx.save(); ctx.translate(52,50); ctx.rotate(0.4); ctx.fillRect(0,0,10,8); ctx.restore();
        ctx.save(); ctx.translate(8,56); ctx.rotate(0.15); ctx.fillRect(0,0,8,6); ctx.restore();
        ctx.save(); ctx.translate(42,58); ctx.rotate(-0.2); ctx.fillRect(0,0,10,5); ctx.restore();
        // Policy text on scattered pages
        ctx.fillStyle = '#166534';
        ctx.fillRect(4,50,6,1); ctx.fillRect(54,52,5,1); ctx.fillRect(10,58,4,1);
        // Binder spine broken
        ctx.fillStyle = '#14532d'; ctx.fillRect(26,54,12,8);
        ctx.fillStyle = '#166534'; ctx.fillRect(28,55,8,6);
        // Brown hair - completely disheveled
        ctx.fillStyle = '#4a2c1a'; ctx.fillRect(14,4,36,16);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(16,6,32,12);
        ctx.fillStyle = '#7a5142'; ctx.fillRect(18,7,28,9);
        // Hair strands flying
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(12,8,4,8); ctx.fillRect(48,10,4,6);
        ctx.fillRect(20,2,3,6); ctx.fillRect(38,1,4,7);
        // Face - exhausted defeat
        ctx.fillStyle = '#c4956a'; ctx.fillRect(18,18,28,22);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,20,24,18);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(22,22,20,14);
        // Tired closed eyes (defeat)
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(24,28,6,2); ctx.fillRect(36,28,6,2);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(24,29,6,1); ctx.fillRect(36,29,6,1);
        // Tears
        ctx.fillStyle = '#7dd3fc'; ctx.fillRect(24,31,2,3); ctx.fillRect(40,31,2,3);
        // Defeated frown
        ctx.fillStyle = '#8b4513'; ctx.fillRect(28,36,8,2);
        ctx.fillStyle = '#c17b5f'; ctx.fillRect(26,35,2,2); ctx.fillRect(36,35,2,2);
        // Green HR jacket wrinkled
        ctx.fillStyle = '#14532d'; ctx.fillRect(10,40,44,24);
        ctx.fillStyle = '#166534'; ctx.fillRect(12,42,40,20);
        ctx.fillStyle = '#16a34a'; ctx.fillRect(14,44,36,16);
        // Name badge falling off
        ctx.save(); ctx.translate(38,52); ctx.rotate(0.5);
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,14,6);
        ctx.fillStyle = '#166534'; ctx.fillRect(2,2,10,2);
        ctx.restore();
        // Broken pen
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(56,46,2,8);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(58,44,2,6);
    });

    // Defeated Avetta Platform (64x64) - System error, sparking
    GFX.bossDefeated.boss_avetta = c(64,64, ctx => {
        // Cyan error sparks
        const grad = ctx.createRadialGradient(32,32,5,32,32,32);
        grad.addColorStop(0, 'rgba(34, 211, 238, 0.4)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        // Spark particles everywhere
        ctx.fillStyle = '#67e8f9';
        ctx.fillRect(8,12,3,3); ctx.fillRect(52,16,3,3); ctx.fillRect(10,48,3,3);
        ctx.fillRect(50,44,3,3); ctx.fillRect(4,32,2,2); ctx.fillRect(58,28,2,2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(9,13,1,1); ctx.fillRect(53,17,1,1); ctx.fillRect(11,49,1,1);
        // Broken data nodes falling
        ctx.fillStyle = 'rgba(34, 211, 238, 0.5)';
        ctx.fillRect(4,8,4,4); ctx.fillRect(56,14,4,4); ctx.fillRect(6,52,3,3);
        // Main AI chassis - damaged
        ctx.fillStyle = '#0a0f1e'; ctx.fillRect(12,10,40,40);
        ctx.fillStyle = '#0f172a'; ctx.fillRect(14,12,36,36);
        ctx.fillStyle = '#1e293b'; ctx.fillRect(16,14,32,32);
        // Cracked screen with error
        ctx.fillStyle = '#7f1d1d'; ctx.fillRect(18,16,28,28); // Red error background
        ctx.fillStyle = '#ef4444'; ctx.fillRect(20,18,24,24);
        // ERROR text
        ctx.fillStyle = '#fff';
        ctx.fillRect(24,26,2,4); ctx.fillRect(26,26,1,1); ctx.fillRect(26,28,1,1); ctx.fillRect(26,30,1,1); // E
        ctx.fillRect(29,26,2,4); ctx.fillRect(31,26,1,2); ctx.fillRect(31,29,1,2); // R
        ctx.fillRect(34,26,2,4); ctx.fillRect(36,26,1,2); ctx.fillRect(36,29,1,2); // R
        // Skull/X on screen
        ctx.fillStyle = '#fff';
        ctx.fillRect(26,34,4,1); ctx.fillRect(34,34,4,1);
        ctx.fillRect(28,35,2,1); ctx.fillRect(34,35,2,1);
        ctx.fillRect(30,36,4,2);
        // Crack lines on screen
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(22,20,1,8); ctx.fillRect(23,24,4,1);
        ctx.fillRect(38,18,1,10); ctx.fillRect(35,22,4,1);
        // Broken corner brackets
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(14,14,4,1); ctx.fillRect(14,14,1,4);
        ctx.fillRect(46,14,4,1); ctx.fillRect(49,14,1,4);
        ctx.fillRect(14,45,4,1); ctx.fillRect(14,42,1,4);
        ctx.fillRect(46,45,4,1); ctx.fillRect(49,42,1,4);
        // Broken antenna - bent
        ctx.fillStyle = '#475569'; ctx.fillRect(28,4,8,8);
        ctx.fillStyle = '#64748b'; ctx.fillRect(30,5,4,7);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(30,4,4,2); // Error light blinking
        // Antenna bent to side
        ctx.fillStyle = '#475569'; ctx.fillRect(36,6,6,3);
        // Smoking base platform
        ctx.fillStyle = '#1e293b'; ctx.fillRect(16,50,32,8);
        ctx.fillStyle = '#334155'; ctx.fillRect(18,52,28,4);
        // Smoke particles
        ctx.fillStyle = 'rgba(100,100,100,0.5)';
        ctx.fillRect(24,46,4,4); ctx.fillRect(36,44,4,6);
        ctx.fillStyle = 'rgba(150,150,150,0.4)';
        ctx.fillRect(26,42,3,4); ctx.fillRect(38,40,3,5);
    });

    // Defeated Generic Boss Manager (64x64)
    GFX.bossDefeated.boss_manager = c(64,64, ctx => {
        // Dark defeated aura
        const grad = ctx.createRadialGradient(32,38,5,32,38,32);
        grad.addColorStop(0, 'rgba(239, 68, 68, 0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        // Dark disheveled hair
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(16,6,32,14);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(18,8,28,10);
        ctx.fillStyle = '#2a3755'; ctx.fillRect(20,9,24,7);
        // Hair messed up
        ctx.fillStyle = '#1a2744'; ctx.fillRect(14,10,4,6); ctx.fillRect(46,12,4,5);
        // Face - defeated
        ctx.fillStyle = '#c4956a'; ctx.fillRect(18,18,28,22);
        ctx.fillStyle = '#d4a574'; ctx.fillRect(20,20,24,18);
        ctx.fillStyle = '#e8c49a'; ctx.fillRect(22,22,20,14);
        // X eyes
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(26,27,2,1); ctx.fillRect(28,28,2,1); ctx.fillRect(26,29,2,1);
        ctx.fillRect(28,27,2,1); ctx.fillRect(26,28,2,1); ctx.fillRect(28,29,2,1);
        ctx.fillRect(36,27,2,1); ctx.fillRect(38,28,2,1); ctx.fillRect(36,29,2,1);
        ctx.fillRect(38,27,2,1); ctx.fillRect(36,28,2,1); ctx.fillRect(38,29,2,1);
        // Open mouth
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(28,34,8,4);
        // Dark suit
        ctx.fillStyle = '#0a0f1f'; ctx.fillRect(12,40,40,24);
        ctx.fillStyle = '#1a2744'; ctx.fillRect(14,42,36,20);
        // Loose tie
        ctx.save(); ctx.translate(30,42); ctx.rotate(0.2);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(0,0,6,16);
        ctx.fillStyle = '#dc2626'; ctx.fillRect(1,1,4,14);
        ctx.restore();
    });

    GFX.drone = c(16,16, ctx => {
        // Drone body
        ctx.fillStyle = '#2a2a2a'; ctx.fillRect(4,6,8,4);
        // Propellers
        ctx.fillStyle = '#444'; ctx.fillRect(2,4,3,8); ctx.fillRect(11,4,3,8);
        // Eye/camera
        ctx.fillStyle = '#ff0000'; ctx.fillRect(7,7,2,2);
        // Amazon logo
        ctx.fillStyle = '#ff9900'; ctx.fillRect(5,7,2,2); ctx.fillRect(9,7,2,2);
    });

    // === NEW WAREHOUSE ATMOSPHERE SPRITES ===

    // Animated Conveyor Belt (horizontal)
    GFX.conveyorBelt = c(16,16, ctx => {
        // Belt frame
        ctx.fillStyle = '#374151'; ctx.fillRect(0,4,16,8);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(1,5,14,6);
        // Belt surface with ridges
        ctx.fillStyle = '#1f2937';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect(i * 2, 6, 1, 4);
        }
        // Rollers at ends
        ctx.fillStyle = '#6b7280'; ctx.fillRect(0,4,2,8); ctx.fillRect(14,4,2,8);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(0,6,2,4); ctx.fillRect(14,6,2,4);
        // Safety stripe
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(0,3,16,1); ctx.fillRect(0,12,16,1);
    });

    // Package on conveyor (small)
    GFX.packageSmall = c(12,12, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,2,10,9);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,3,8,7);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,5,4,2); // tape
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(3,3,6,1); // label
    });

    // Package on conveyor (large)
    GFX.packageLarge = c(16,14, ctx => {
        ctx.fillStyle = '#78350f'; ctx.fillRect(1,2,14,11);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,3,12,9);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(2,2,12,2); // flap
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(5,6,6,2); // tape
        ctx.fillStyle = '#111'; ctx.fillRect(7,8,2,2); // barcode
    });

    // Manual Pallet Jack
    GFX.palletJack = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 14, 6, 2, 0, 0, Math.PI*2); ctx.fill();
        // Fork tines (yellow safety)
        ctx.fillStyle = '#eab308'; ctx.fillRect(2,10,12,3);
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,12,3,2); ctx.fillRect(11,12,3,2);
        // Main pump body (red)
        ctx.fillStyle = '#dc2626'; ctx.fillRect(6,5,4,6);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(7,6,2,4);
        // Handle
        ctx.fillStyle = '#1f2937'; ctx.fillRect(7,2,2,4);
        ctx.fillStyle = '#374151'; ctx.fillRect(6,2,4,1);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(3,13,2,2); ctx.fillRect(11,13,2,2);
    });

    // Pallet Jack with Load
    GFX.palletJackLoaded = c(16,20, ctx => {
        // Pallet on top
        ctx.fillStyle = '#92400e'; ctx.fillRect(1,0,14,3);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,1,12,2);
        // Boxes on pallet
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,3,6,6);
        ctx.fillStyle = '#a16207'; ctx.fillRect(3,4,4,4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(3,3,4,1); // tape
        ctx.fillStyle = '#78350f'; ctx.fillRect(8,4,6,5);
        ctx.fillStyle = '#a16207'; ctx.fillRect(9,5,4,3);
        // Fork tines
        ctx.fillStyle = '#eab308'; ctx.fillRect(2,10,12,3);
        // Pump body
        ctx.fillStyle = '#dc2626'; ctx.fillRect(6,13,4,4);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(3,16,2,2); ctx.fillRect(11,16,2,2);
    });

    // Worker pushing cart
    GFX.cartWorker = c(20,16, ctx => {
        // Cart first (behind worker)
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(10,8,9,6);
        ctx.fillStyle = '#3b82f6'; ctx.fillRect(11,7,7,5);
        // Packages on cart
        ctx.fillStyle = '#a16207'; ctx.fillRect(11,4,3,4);
        ctx.fillStyle = '#78350f'; ctx.fillRect(14,5,4,3);
        // Cart wheels
        ctx.fillStyle = '#111'; ctx.fillRect(11,13,2,2); ctx.fillRect(17,13,2,2);
        // Worker shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(5, 15, 4, 2, 0, 0, Math.PI*2); ctx.fill();
        // Worker body (hi-vis)
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,7,6,8);
        ctx.fillStyle = '#eab308'; ctx.fillRect(3,8,4,6);
        // Reflective strips
        ctx.fillStyle = '#fef08a'; ctx.fillRect(3,9,4,1); ctx.fillRect(3,12,4,1);
        // Head
        ctx.fillStyle = '#d4a574'; ctx.fillRect(3,3,4,4);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(3,2,4,2); // hair
        // Arms pushing
        ctx.fillStyle = '#d4a574'; ctx.fillRect(7,8,3,1);
    });

    // Package handler scanning
    GFX.packageHandler = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(6, 15, 4, 2, 0, 0, Math.PI*2); ctx.fill();
        // Body (hi-vis)
        ctx.fillStyle = '#ca8a04'; ctx.fillRect(2,7,8,8);
        ctx.fillStyle = '#eab308'; ctx.fillRect(3,8,6,6);
        ctx.fillStyle = '#fef08a'; ctx.fillRect(3,9,6,1); ctx.fillRect(3,12,6,1);
        // Head
        ctx.fillStyle = '#d4a574'; ctx.fillRect(4,3,4,4);
        ctx.fillStyle = '#3f3f46'; ctx.fillRect(4,2,4,2); // cap
        // Scanner in hand
        ctx.fillStyle = '#111'; ctx.fillRect(10,6,4,6);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(11,7,2,1); // screen
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,11,2,1); // laser
        // Package being scanned
        ctx.fillStyle = '#a16207'; ctx.fillRect(10,12,5,3);
    });

    // Pallet stack (multiple boxes)
    GFX.palletStack = c(16,16, ctx => {
        // Pallet base
        ctx.fillStyle = '#92400e'; ctx.fillRect(1,13,14,3);
        ctx.fillStyle = '#a16207'; ctx.fillRect(2,14,12,1);
        // Bottom layer boxes
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,9,5,4); ctx.fillRect(8,9,6,4);
        ctx.fillStyle = '#a16207'; ctx.fillRect(3,10,3,2); ctx.fillRect(9,10,4,2);
        // Top layer boxes
        ctx.fillStyle = '#b45309'; ctx.fillRect(3,5,4,4); ctx.fillRect(8,6,5,3);
        ctx.fillStyle = '#d97706'; ctx.fillRect(4,6,2,2); ctx.fillRect(9,7,3,1);
        // Labels
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,7,2,1); ctx.fillRect(10,7,2,1);
    });

    // Sorting station
    GFX.sortStation = c(16,16, ctx => {
        // Main station body
        ctx.fillStyle = '#374151'; ctx.fillRect(1,6,14,9);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,7,12,7);
        // Chute openings
        ctx.fillStyle = '#1f2937'; ctx.fillRect(3,8,3,5); ctx.fillRect(7,8,3,5); ctx.fillRect(11,8,3,5);
        // Labels above chutes
        ctx.fillStyle = '#22c55e'; ctx.fillRect(3,6,3,2);
        ctx.fillStyle = '#eab308'; ctx.fillRect(7,6,3,2);
        ctx.fillStyle = '#ef4444'; ctx.fillRect(11,6,3,2);
        // Top scanner bar
        ctx.fillStyle = '#111'; ctx.fillRect(2,3,12,3);
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(4,4,8,1);
    });

    // Conveyor junction
    GFX.conveyorJunction = c(16,16, ctx => {
        // Cross pattern
        ctx.fillStyle = '#374151'; ctx.fillRect(0,5,16,6); ctx.fillRect(5,0,6,16);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(1,6,14,4); ctx.fillRect(6,1,4,14);
        // Center platform
        ctx.fillStyle = '#6b7280'; ctx.fillRect(5,5,6,6);
        ctx.fillStyle = '#9ca3af'; ctx.fillRect(6,6,4,4);
        // Direction arrows
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(2,7,2,2); ctx.fillRect(12,7,2,2);
        ctx.fillRect(7,2,2,2); ctx.fillRect(7,12,2,2);
    });

    // Warehouse signage
    GFX.signPick = c(16,10, ctx => {
        ctx.fillStyle = '#1d4ed8'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('PICK', 2, 7);
    });

    GFX.signPack = c(16,10, ctx => {
        ctx.fillStyle = '#16a34a'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('PACK', 2, 7);
    });

    GFX.signShip = c(16,10, ctx => {
        ctx.fillStyle = '#dc2626'; ctx.fillRect(0,0,16,10);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText('SHIP', 2, 7);
    });

    // Floor arrow markings
    GFX.floorArrow = c(16,16, ctx => {
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(8, 2); ctx.lineTo(14, 8); ctx.lineTo(10, 8);
        ctx.lineTo(10, 14); ctx.lineTo(6, 14); ctx.lineTo(6, 8);
        ctx.lineTo(2, 8);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#92400e'; ctx.lineWidth = 1; ctx.stroke();
    });

    // === YARD LEVEL NEW SPRITES ===

    // Forklift (moving obstacle)
    GFX.forkliftMoving = c(24,20, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(2,17,20,3);
        // Main body
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(6,8,12,9);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(7,9,10,7);
        // Cabin
        ctx.fillStyle = '#1f2937'; ctx.fillRect(7,4,10,5);
        ctx.fillStyle = '#6a8fb8'; ctx.fillRect(8,5,8,3);
        // Mast
        ctx.fillStyle = '#374151'; ctx.fillRect(2,2,4,15);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(3,3,2,13);
        // Forks
        ctx.fillStyle = '#1f2937'; ctx.fillRect(0,15,6,2); ctx.fillRect(0,13,6,2);
        // Pallet on forks
        ctx.fillStyle = '#92400e'; ctx.fillRect(0,8,6,5);
        ctx.fillStyle = '#a16207'; ctx.fillRect(1,9,4,3);
        // Wheels
        ctx.fillStyle = '#111'; ctx.fillRect(8,16,4,3); ctx.fillRect(14,16,4,3);
        // Warning light
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(10,3,4,2);
    });

    // Power-up: Speed Boost
    GFX.powerSpeed = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#22d3ee');
        grad.addColorStop(0.5, '#0891b2');
        grad.addColorStop(1, 'rgba(8, 145, 178, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Lightning bolt
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(9, 2); ctx.lineTo(5, 8); ctx.lineTo(8, 8);
        ctx.lineTo(6, 14); ctx.lineTo(12, 7); ctx.lineTo(9, 7);
        ctx.closePath();
        ctx.fill();
    });

    // Power-up: Shield
    GFX.powerShield = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#a855f7');
        grad.addColorStop(0.5, '#7c3aed');
        grad.addColorStop(1, 'rgba(124, 58, 237, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Shield shape
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(8, 2); ctx.lineTo(13, 5); ctx.lineTo(13, 9);
        ctx.lineTo(8, 14); ctx.lineTo(3, 9); ctx.lineTo(3, 5);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#7c3aed'; ctx.fillRect(7, 6, 2, 4);
    });

    // Power-up: Extra Life
    GFX.powerLife = c(16,16, ctx => {
        // Glow
        const grad = ctx.createRadialGradient(8, 8, 2, 8, 8, 8);
        grad.addColorStop(0, '#f87171');
        grad.addColorStop(0.5, '#dc2626');
        grad.addColorStop(1, 'rgba(220, 38, 38, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
        // Heart
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(8, 13);
        ctx.bezierCurveTo(2, 8, 2, 3, 8, 6);
        ctx.bezierCurveTo(14, 3, 14, 8, 8, 13);
        ctx.fill();
    });

    // Collectible package (bonus points)
    GFX.collectPackage = c(14,14, ctx => {
        // Sparkle glow
        ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
        ctx.beginPath(); ctx.arc(7, 7, 7, 0, Math.PI*2); ctx.fill();
        // Box
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(2,3,10,9);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(3,4,8,7);
        // Smile logo
        ctx.fillStyle = '#ff9900'; ctx.fillRect(4,7,6,2);
        ctx.fillRect(8,7,2,3);
        // Sparkles
        ctx.fillStyle = '#fff';
        ctx.fillRect(1, 1, 2, 1); ctx.fillRect(11, 2, 2, 1);
        ctx.fillRect(0, 10, 1, 2); ctx.fillRect(12, 11, 2, 1);
    });

    // Safety barrier
    GFX.safetyBarrier = c(16,12, ctx => {
        // Posts
        ctx.fillStyle = '#1f2937'; ctx.fillRect(1,0,3,12); ctx.fillRect(12,0,3,12);
        // Warning stripes
        for (let i = 0; i < 4; i++) {
            ctx.fillStyle = i % 2 === 0 ? '#fbbf24' : '#111';
            ctx.fillRect(4, i * 3, 8, 3);
        }
    });

    // Loading dock door
    GFX.dockDoor = c(32,24, ctx => {
        // Door frame
        ctx.fillStyle = '#374151'; ctx.fillRect(0,0,32,24);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,2,28,20);
        // Segmented door
        for (let i = 0; i < 4; i++) {
            ctx.fillStyle = i % 2 === 0 ? '#6b7280' : '#9ca3af';
            ctx.fillRect(3, 3 + i * 4, 26, 4);
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(3, 3 + i * 4 + 3, 26, 1);
        }
        // Door number
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace';
        ctx.fillText('D1', 12, 14);
    });

    // Yard pedestrian
    GFX.yardPedestrian = c(16,16, ctx => {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(8, 15, 5, 2, 0, 0, Math.PI*2); ctx.fill();
        // Legs
        ctx.fillStyle = '#1f2937'; ctx.fillRect(5,12,2,3); ctx.fillRect(9,12,2,3);
        // Body (hi-vis)
        ctx.fillStyle = '#16a34a'; ctx.fillRect(3,6,10,7);
        ctx.fillStyle = '#22c55e'; ctx.fillRect(4,7,8,5);
        // Reflective X
        ctx.fillStyle = '#fef08a';
        ctx.fillRect(4,7,1,5); ctx.fillRect(11,7,1,5);
        ctx.fillRect(4,9,8,1);
        // Head with hard hat
        ctx.fillStyle = '#d4a574'; ctx.fillRect(5,3,6,4);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(4,1,8,3);
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(5,2,6,1);
    });

    // === ATMOSPHERE ENHANCEMENT SPRITES ===

    // Security Camera (animated pan)
    GFX.securityCamera = c(16,16, ctx => {
        // Mount bracket
        ctx.fillStyle = '#374151'; ctx.fillRect(1,0,4,6);
        ctx.fillStyle = '#4b5563'; ctx.fillRect(2,1,2,4);
        // Camera body
        ctx.fillStyle = '#1f2937'; ctx.fillRect(0,5,10,6);
        ctx.fillStyle = '#374151'; ctx.fillRect(1,6,8,4);
        // Lens
        ctx.fillStyle = '#0ea5e9'; ctx.fillRect(7,7,3,2);
        ctx.fillStyle = '#22d3ee'; ctx.fillRect(8,7,1,1);
        // Recording light (red blinking)
        ctx.fillStyle = '#ef4444'; ctx.fillRect(1,7,2,2);
    });

    // Wall Torch (animated flame)
    GFX.wallTorch = c(12,20, ctx => {
        // Torch bracket
        ctx.fillStyle = '#4a2c1a'; ctx.fillRect(4,12,4,8);
        ctx.fillStyle = '#5c3d2e'; ctx.fillRect(5,13,2,6);
        // Torch cup
        ctx.fillStyle = '#78350f'; ctx.fillRect(2,10,8,4);
        ctx.fillStyle = '#92400e'; ctx.fillRect(3,11,6,2);
        // Flame base
        ctx.fillStyle = '#f59e0b'; ctx.fillRect(3,4,6,8);
        ctx.fillStyle = '#fbbf24'; ctx.fillRect(4,5,4,6);
        // Flame tip
        ctx.fillStyle = '#fcd34d';
        ctx.beginPath();
        ctx.moveTo(6, 0); ctx.lineTo(3, 6); ctx.lineTo(9, 6);
        ctx.closePath();
        ctx.fill();
        // Inner flame
        ctx.fillStyle = '#fff';
        ctx.fillRect(5,6,2,3);
    });

    // Dust/Particle mote
    GFX.dustMote = c(4,4, ctx => {
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(1,1,2,2);
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillRect(1,1,1,1);
    });

    // Falling debris (for mecha fight)
    GFX.fallingDebris = c(8,8, ctx => {
        ctx.fillStyle = '#78350f';
        ctx.fillRect(1,1,6,6);
        ctx.fillStyle = '#92400e';
        ctx.fillRect(2,2,4,4);
        ctx.fillStyle = '#a16207';
        ctx.fillRect(2,2,2,2);
    });

    // === PPE VENDING MACHINE ===
    GFX.quartermasterDoor = c(48, 48, ctx => {
        // Machine body (dark blue metal)
        ctx.fillStyle = '#1e3a5f';
        ctx.fillRect(4, 2, 40, 44);

        // Outer frame highlight
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2;
        ctx.strokeRect(4, 2, 40, 44);

        // Top header bar (yellow safety color)
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(6, 4, 36, 10);
        ctx.fillStyle = '#1f2937';
        ctx.font = 'bold 7px monospace';
        ctx.fillText('PPE', 17, 12);

        // Display window (showing PPE items)
        ctx.fillStyle = '#0a1628';
        ctx.fillRect(8, 16, 32, 18);
        ctx.strokeStyle = '#60a5fa';
        ctx.lineWidth = 1;
        ctx.strokeRect(8, 16, 32, 18);

        // PPE items in display (mini icons)
        // Hard hat
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(11, 20, 6, 4);
        ctx.fillRect(10, 23, 8, 2);
        // Safety vest
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(21, 19, 6, 7);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(22, 21, 4, 1);
        ctx.fillRect(22, 24, 4, 1);
        // Goggles
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(31, 21, 3, 2);
        ctx.fillRect(35, 21, 3, 2);
        ctx.fillStyle = '#0e7490';
        ctx.fillRect(34, 21, 1, 2);

        // Second row items
        // Gloves
        ctx.fillStyle = '#f97316';
        ctx.fillRect(11, 28, 4, 5);
        ctx.fillRect(15, 30, 2, 3);
        // Boots
        ctx.fillStyle = '#374151';
        ctx.fillRect(21, 28, 6, 5);
        ctx.fillStyle = '#94a3b8';
        ctx.fillRect(22, 29, 4, 2);
        // Ear muffs
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(31, 28, 3, 5);
        ctx.fillRect(35, 28, 3, 5);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(34, 29, 1, 3);

        // Control panel area
        ctx.fillStyle = '#334155';
        ctx.fillRect(8, 36, 20, 8);

        // Selection buttons (grid)
        ctx.fillStyle = '#64748b';
        for (let row = 0; row < 2; row++) {
            for (let col = 0; col < 4; col++) {
                ctx.fillRect(10 + col * 5, 37 + row * 3, 3, 2);
            }
        }

        // Coin slot
        ctx.fillStyle = '#475569';
        ctx.fillRect(30, 36, 8, 8);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(32, 38, 4, 1);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(32, 40, 4, 2);

        // Dispensing slot at bottom
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(10, 44, 28, 3);
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.strokeRect(10, 44, 28, 3);

        // Side vents
        ctx.fillStyle = '#475569';
        for (let i = 0; i < 3; i++) {
            ctx.fillRect(5, 20 + i * 6, 2, 4);
            ctx.fillRect(41, 20 + i * 6, 2, 4);
        }
    });

    // Floating indicator for PPE vending machine
    GFX.ppeIndicator = c(32, 16, ctx => {
        // "UPGRADES" text bubble
        ctx.fillStyle = '#22c55e';
        ctx.beginPath();
        ctx.roundRect(0, 0, 32, 12, 3);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = '5px monospace';
        ctx.fillText('UPGRADES', 2, 8);
        // Arrow pointing down
        ctx.fillStyle = '#22c55e';
        ctx.beginPath();
        ctx.moveTo(16, 16);
        ctx.lineTo(12, 12);
        ctx.lineTo(20, 12);
        ctx.closePath();
        ctx.fill();
    });

    // Large vending machine sprite for dialog popup
    GFX.vendingMachineLarge = c(80, 100, ctx => {
        // Machine body
        ctx.fillStyle = '#1e3a5f';
        ctx.fillRect(5, 5, 70, 90);

        // Outer frame
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.strokeRect(5, 5, 70, 90);

        // Top header (yellow)
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(10, 8, 60, 14);
        ctx.fillStyle = '#1f2937';
        ctx.font = 'bold 10px monospace';
        ctx.fillText('PPE SHOP', 18, 19);

        // Display window
        ctx.fillStyle = '#0a1628';
        ctx.fillRect(12, 26, 56, 40);
        ctx.strokeStyle = '#60a5fa';
        ctx.lineWidth = 2;
        ctx.strokeRect(12, 26, 56, 40);

        // Shelf lines
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(12, 46);
        ctx.lineTo(68, 46);
        ctx.stroke();

        // PPE items on shelves (larger)
        // Top shelf
        // Hard hat
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(16, 30, 10, 6);
        ctx.fillRect(14, 35, 14, 3);
        // Vest
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(34, 29, 10, 12);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(35, 32, 8, 2);
        ctx.fillRect(35, 37, 8, 2);
        // Goggles
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(52, 32, 5, 4);
        ctx.fillRect(58, 32, 5, 4);
        ctx.fillStyle = '#0e7490';
        ctx.fillRect(57, 33, 1, 2);

        // Bottom shelf
        // Gloves
        ctx.fillStyle = '#f97316';
        ctx.fillRect(16, 50, 8, 10);
        ctx.fillRect(24, 54, 4, 6);
        // Boots
        ctx.fillStyle = '#374151';
        ctx.fillRect(34, 50, 10, 10);
        ctx.fillStyle = '#94a3b8';
        ctx.fillRect(36, 52, 6, 4);
        // Ear protection
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(52, 50, 5, 10);
        ctx.fillRect(58, 50, 5, 10);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(57, 52, 1, 6);

        // Control panel
        ctx.fillStyle = '#334155';
        ctx.fillRect(12, 70, 36, 16);
        ctx.strokeStyle = '#475569';
        ctx.strokeRect(12, 70, 36, 16);

        // Buttons grid
        ctx.fillStyle = '#64748b';
        for (let row = 0; row < 2; row++) {
            for (let col = 0; col < 5; col++) {
                ctx.fillRect(15 + col * 7, 73 + row * 6, 5, 4);
            }
        }

        // Coin/card slot
        ctx.fillStyle = '#475569';
        ctx.fillRect(52, 70, 14, 16);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(56, 74, 6, 2);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(56, 78, 6, 4);

        // Dispensing slot
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(15, 88, 50, 6);
        ctx.strokeStyle = '#475569';
        ctx.strokeRect(15, 88, 50, 6);

        // Corner screws
        ctx.fillStyle = '#94a3b8';
        [[10, 10], [70, 10], [10, 90], [70, 90]].forEach(([x, y]) => {
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#64748b';
            ctx.fillRect(x - 1, y - 1, 2, 2);
            ctx.fillStyle = '#94a3b8';
        });
    });

    // Quartermaster portrait (Simon's safety locker persona)
    GFX.quartermaster = c(48, 48, ctx => {
        // Background
        ctx.fillStyle = '#1e3a5f';
        ctx.fillRect(0, 0, 48, 48);

        // Body (blue safety vest)
        ctx.fillStyle = '#2563eb';
        ctx.fillRect(12, 28, 24, 20);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(14, 30, 20, 16);

        // Reflective strips
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(14, 32, 20, 2);
        ctx.fillRect(14, 38, 20, 2);

        // Head with hard hat
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(18, 14, 12, 14);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(14, 8, 20, 8);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(16, 10, 16, 4);

        // Eyes
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(20, 18, 3, 3);
        ctx.fillRect(26, 18, 3, 3);
        ctx.fillStyle = '#64748b';
        ctx.fillRect(21, 19, 1, 1);
        ctx.fillRect(27, 19, 1, 1);

        // Neutral expression
        ctx.fillStyle = '#8b6b5a';
        ctx.fillRect(22, 24, 4, 1);

        // Safety goggles on hat
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(18, 11, 5, 2);
        ctx.fillRect(26, 11, 5, 2);
        ctx.fillStyle = '#0e7490';
        ctx.fillRect(23, 11, 3, 2);
    });
}

// === PPE ITEMS FOR QUARTERMASTER'S SAFETY LOCKER ===
const PPE_ITEMS = [
    { id: 'safety_shoes', name: 'S3 Safety Shoes', cost: 500, icon: 'shoe',
      desc: '+15% Move Speed', context: 'Slip resistance EN ISO 20345', buff: { type: 'speed', value: 0.15 } },
    { id: 'hi_vis_vest', name: 'High-Vis Vest', cost: 1000, icon: 'vest',
      desc: '15% Dodge Chance', context: 'Visibility EN ISO 20471', buff: { type: 'dodge', value: 0.15 } },
    { id: 'ear_defenders', name: 'Ear Defenders', cost: 800, icon: 'ear',
      desc: '+1 Max HP', context: 'Noise protection >85dB', buff: { type: 'maxhp', value: 1 } },
    { id: 'cut_gloves', name: 'Cut-Resistant Gloves', cost: 1200, icon: 'glove',
      desc: '+20% Fire Rate', context: 'Hand protection EN 388', buff: { type: 'firerate', value: 0.20 } },
    { id: 'safety_goggles', name: 'Safety Goggles', cost: 750, icon: 'goggle',
      desc: '+25% Critical Hit Chance', context: 'Eye protection EN 166 - spot hazards faster', buff: { type: 'crit', value: 0.25 } },
    { id: 'back_belt', name: 'Back Support Belt', cost: 600, icon: 'belt',
      desc: '+30% Score Multiplier', context: 'Ergonomic lifting support - work efficiently', buff: { type: 'score', value: 0.30 } },
    { id: 'bump_cap', name: 'Bump Cap', cost: 900, icon: 'cap',
      desc: '+0.5s Invincibility', context: 'Head impact protection EN 812', buff: { type: 'iframe', value: 30 } },
    { id: 'hydration', name: 'Hydration Pouch', cost: 2000, icon: 'water',
      desc: 'Regen 1 HP / 30s', context: 'Heat stress prevention', buff: { type: 'regen', value: 1800 } },
    { id: 'knee_pads', name: 'Knee Pads', cost: 550, icon: 'knee',
      desc: '+50% Interact Range', context: 'Kneeling work EN 14404', buff: { type: 'interact', value: 0.50 } },
    { id: 'walkie_talkie', name: 'Walkie-Talkie', cost: 1100, icon: 'radio',
      desc: '-30% Ops Aggro', context: 'Clear communication channels', buff: { type: 'stealth', value: 0.30 } },
    // === PREMIUM TIER PPE - Expensive but powerful for long-term playability ===
    { id: 'exoskeleton', name: 'Exoskeleton Suit', cost: 5000, icon: 'exo',
      desc: '+40% Speed, +2 Max HP', context: 'EN ISO 13482 Personal care robot safety', buff: { type: 'multi', effects: [{ type: 'speed', value: 0.40 }, { type: 'maxhp', value: 2 }] } },
    { id: 'ar_helmet', name: 'AR Safety Helmet', cost: 7500, icon: 'arhelm',
      desc: 'Tag Hazards/Runners/OPS, +1s Invuln', context: 'EN 812 with integrated HMI display - highlights threats', buff: { type: 'multi', effects: [{ type: 'hazard_reveal', value: 1 }, { type: 'iframe', value: 60 }] } },
    { id: 'quantum_vest', name: 'Quantum Shield Vest', cost: 10000, icon: 'quantum',
      desc: '25% Dmg Reflect, Regen 1HP/20s', context: 'Experimental OSHA-X prototype tech', buff: { type: 'multi', effects: [{ type: 'reflect', value: 0.25 }, { type: 'regen', value: 1200 }] } },
    { id: 'bezos_armor', name: 'Prime Guardian Armor', cost: 15000, icon: 'primearmor',
      desc: '2x Damage, 50% Block Chance', context: 'Ultimate safety gear - customer obsession incarnate', buff: { type: 'multi', effects: [{ type: 'damage', value: 2.0 }, { type: 'block', value: 0.50 }] } },
    // === SPECIAL ACTIONS ===
    { id: 'return_all', name: '>> RETURN ALL PPE <<', cost: 0, icon: 'return',
      desc: 'Return ALL items for full refund', context: 'Full PPE reset - get your Safety Points back!', buff: null, isAction: true },
    { id: 'exit_shop', name: '>> EXIT SHOP <<', cost: 0, icon: 'exit',
      desc: 'Leave the Safety Locker', context: 'Return to the warehouse floor', buff: null, isAction: true, isExit: true }
];

// --- GAME STATE ---
const GAME = {
    state: 'PRESS_START',
    stateTimer: 0,
    nextState: 'PLAY',
    ticks: 0,
    player: null,
    selectedChar: "Carrie",
    charList: ["Carrie", "Nevena", "Joao", "Roman", "Erwin"],
    charIndex: 0,
    // Region-aware system
    region: 'EU',
    regionList: ['DE', 'AT', 'NL', 'MEU'],
    regionIndex: 0,
    regionNames: {
        'DE': 'Germany',
        'AT': 'Austria',
        'NL': 'Netherlands',
        'MEU': 'Mid-EU (EN)'
    },
    camera: { x: 0, y: 0 },
    map: [], clutter: [], entities: [], projectiles: [], particles: [], floatingTexts: [],
    activeIssues: [],
    issuesFixed: 0, lives: 3, genId: 0, gameOverTriggered: false, simonHits: 0, boss: null, pendingBossIntro: false,
    shake: 0, flash: 0,
    dialogText: "", dialogVisible: "", dialogTimer: 0,
    introDialogueStep: 0, // Track intro conversation sequence
    // Portrait animation state
    portraitAnimInterval: null,
    currentPortraitBase: null,
    currentPortraitTalking: null,
    portraitTalkPhase: false,
    splashTimer: 0, aiResultText: null,
    // Game Over screen state
    gameOverPhase: 0, corporateMessage: "", characterDefeatLine: "", gameOverReason: "",
    creditsType: 'normal', // 'normal' for surprise visitor, 'mecha' for Mecha Jeff
    creditsStarted: false, // Prevents credits from restarting every frame
    startTime: 0, booksFired: 0, opsPushed: 0,
    lastAIBanterTime: 0, // Throttle AI requests
    fireExitDoor: null, // Hidden level door position
    jeffTaunt: "", // Current Jeff taunt
    jeffTauntTimer: 0, // Timer for taunt display

    // === NEW WAREHOUSE ATMOSPHERE ===
    conveyorBelts: [], // Animated conveyor belt positions
    packages: [], // Moving packages on conveyors
    palletJacks: [], // Moving pallet jacks
    cartWorkers: [], // Workers pushing carts
    palletStacks: [], // Static pallet stacks
    sortStations: [], // Sorting station positions
    warehouseSigns: [], // Zone signage

    // === YARD LEVEL ENHANCEMENTS ===
    powerUps: [], // Power-ups in yard level
    collectibles: [], // Collectible packages
    forklifts: [], // Moving forklift obstacles
    playerPowerUp: null, // Current active power-up
    powerUpTimer: 0, // Power-up duration timer
    score: 0, // Bonus score from collectibles
    yardPedestrians: [], // NPC pedestrians in yard

    // === FOOTPRINT/TIRE MARK SYSTEM ===
    footprints: [], // Trail marks left by characters (footprints or tire marks)

    // === HIGHSCORE SYSTEM ===
    highscores: [], // Cached highscores from server
    highscoresLoaded: false, // Whether highscores have been fetched
    currentScore: 0, // Real-time calculated score
    nameEntry: '', // Player name entry (max 5 chars)
    nameEntryIndex: 0, // Current character position in name entry
    showingHighscores: false, // Whether viewing highscore table
    pendingHighscore: null, // Score waiting to be submitted
    highscoreSubmitted: false, // Whether current score was submitted
    lastDefeatedBoss: null, // Track which boss was defeated for scoring
    booksMissed: 0, // Track missed book throws for score penalty
    simonHitsCount: 0, // Track hitting Simon for score penalty (separate from simonHits which tracks boss damage)
    lastTimePenaltyCount: 0, // Track last time penalty count for floating indicator

    // === QUARTERMASTER'S SAFETY LOCKER (PPE SHOP) ===
    safetyPoints: 0, // Currency earned by fixing hazards
    ppeUnlocked: [], // Array of unlocked PPE item IDs
    ppeShopIndex: 0, // Current selection in shop
    quartermasterDoor: null, // Position of the safety cage door
    lastPlayerPos: null, // Position before entering shop
    regenTimer: 0, // Timer for hydration pouch regen
    shopMessage: '', // AI message in shop
    shopMessageTimer: 0, // Timer for shop message display
    ppeDialogChoice: 0, // NPC dialogue menu selection (0=Buy, 1=Leave)
    ppeDialogShown: false, // Whether intro dialogue has been shown this visit

    bossTypes: [
        { name: "Labour Inspector", sprite: "boss_inspector", hp: 25, speed: 1.2, attackDelay: 50, title: "The Enforcer", desc: "Checks every corner.", attackName: "Violation Notice", attackPattern: "sweep" },
        { name: "Compliance Auditor", sprite: "boss_compliance", hp: 30, speed: 0.8, attackDelay: 70, title: "The Watcher", desc: "Nothing escapes.", attackName: "Audit Cascade", attackPattern: "tracking" },
        { name: "Sebastian S.", sprite: "boss_sebastian", hp: 35, speed: 1.0, attackDelay: 60, title: "Delivery Station Mgr", desc: "Obsessed with TPH.", attackName: "TPH Overload", attackPattern: "burst" },
        { name: "Regional OPS MGR", sprite: "boss_regional", hp: 32, speed: 0.6, attackDelay: 90, title: "The Executive", desc: "Metrics first.", attackName: "KPI Crusher", attackPattern: "orbital" },
        { name: "Avetta Platform", sprite: "boss_avetta", hp: 40, speed: 0.4, attackDelay: 100, title: "Risk Manager", desc: "Judges all.", attackName: "Risk Assessment Beam", attackPattern: "laser" },
        { name: "Jelena \"Jelly\"", sprite: "boss_jelly", hp: 28, speed: 0.9, attackDelay: 65, title: "HR Guardian", desc: "HR legend who never forgets a policy.", attackName: "Write-Up Wave", attackPattern: "wave" }
    ]
};

const HAZARD_POOL = [
    // === ERGONOMIC HAZARDS - REPETITIVE MOTION (Stowing/Picking) ===
    { name: "Repetitive Stow Motion (1000+ scans/shift)", type: "npc" },
    { name: "Continuous Scanning/Twisting Pattern", type: "npc" },
    { name: "Same-Motion Stowing Into Bags", type: "npc" },
    { name: "High-Rate Pick Without Rotation", type: "npc" },
    { name: "Carpal Tunnel Risk Station", type: "facility" },

    // === ERGONOMIC HAZARDS - AWKWARD POSTURES ===
    { name: "Top Shelf Overreach (Stow Bag)", type: "npc" },
    { name: "Bottom Shelf Repeated Bending", type: "npc" },
    { name: "Twisted Spine While Scanning", type: "npc" },
    { name: "Shoulder-Height Stowing Station", type: "facility" },
    { name: "Kneeling Without Knee Pads", type: "npc" },
    { name: "Standing Mat Missing At Station", type: "facility" },

    // === ERGONOMIC HAZARDS - HEAVY LIFTING ===
    { name: "Non-Con Item (Dog Food 20kg+)", type: "box" },
    { name: "Oversized Furniture Solo Lift", type: "box" },
    { name: "Heavy Package Without Team Lift", type: "box" },
    { name: "Water Cases Stacked High", type: "tall_pallet" },
    { name: "Cat Litter Bucket Solo Carry", type: "box" },
    { name: "Exercise Equipment Over 23kg", type: "box" },

    // === ERGONOMIC HAZARDS - PUSHING/PULLING FORCE ===
    { name: "Go-Cart With Bad Wheels (200kg+)", type: "cart" },
    { name: "Heavy Cage High Rolling Resistance", type: "cage" },
    { name: "Stuck Pallet Jack Wheels", type: "forklift" },
    { name: "Overloaded Cart Exceeding Limit", type: "cart" },
    { name: "Cage Door Jamming On Floor", type: "cage" },
    { name: "Manual Pallet Movement No PPE", type: "cart" },

    // === CONVEYOR & MACHINERY HAZARDS ===
    { name: "Nip Point At Drive Roller", type: "conveyor" },
    { name: "Pinch Point Belt Gap Exposed", type: "conveyor" },
    { name: "Jam Breaking While Belt Running", type: "conveyor" },
    { name: "LOTO Violation At Conveyor", type: "conveyor" },
    { name: "Missing Safety Guard On Belt", type: "conveyor" },
    { name: "Package Falling From Overhead Chute", type: "conveyor" },
    { name: "Loose Clothing Near Moving Parts", type: "conveyor" },
    { name: "Hair/Lanyard Entanglement Risk", type: "conveyor" },
    { name: "E-Stop Out Of Reach", type: "conveyor" },
    { name: "Sortation System Package Jam", type: "conveyor" },

    // === SLIPS, TRIPS, AND FALLS ===
    { name: "Loose Shrink Wrap In Walkway", type: "debris" },
    { name: "Pallet Straps On Floor", type: "debris" },
    { name: "Broken Pallet Wood Scattered", type: "debris" },
    { name: "Damaged Concrete Surface", type: "spill" },
    { name: "Floor Tape Peeling Up", type: "spill" },
    { name: "Wet Floor From Winter Tracking", type: "spill" },
    { name: "Ice/Snow Tracked Inside", type: "spill" },
    { name: "Wet Floor No Warning Sign", type: "spill" },
    { name: "Narrow Aisle Blocked By Carts", type: "cart" },
    { name: "Staged Pallets Blocking Path", type: "tall_pallet" },
    { name: "Totes Forcing Squeeze-Through", type: "tote" },
    { name: "Step-Over Obstacle Hazard", type: "debris" },

    // === POWERED INDUSTRIAL TRUCKS (PIT) ===
    { name: "EPJ Running Over Toes", type: "forklift" },
    { name: "Manual Pallet Jack Foot Injury Risk", type: "forklift" },
    { name: "EPJ Collision With Racking", type: "forklift" },
    { name: "Forklift Striking Infrastructure", type: "forklift" },
    { name: "PIT-Cart Collision Zone", type: "forklift" },
    { name: "Battery Handling Without PPE", type: "battery" },
    { name: "Lead-Acid Battery Corrosive Exposure", type: "battery" },
    { name: "Charging Station Acid Spill", type: "battery" },
    { name: "PIT Operator Without Certification", type: "forklift" },
    { name: "Forklift Exceeding Speed Limit", type: "forklift" },

    // === PSYCHOSOCIAL & ENVIRONMENTAL ===
    { name: "Noise >85dB Without Ear Protection", type: "facility" },
    { name: "Constant Conveyor Alarm Noise", type: "conveyor" },
    { name: "High Takt Time Pace Pressure", type: "npc" },
    { name: "Peak Season Burnout Risk", type: "npc" },
    { name: "Rushing Due To Rate Targets", type: "npc" },
    { name: "Cold Stress Near Open Dock Door", type: "dock" },
    { name: "Winter Temperature Extreme Zone", type: "dock" },
    { name: "Summer Heatwave Non-AC Area", type: "facility" },
    { name: "Mental Fatigue Station", type: "npc" },

    // === HAZARDOUS MATERIALS (HazMat) ===
    { name: "Leaking Package (Bleach)", type: "spill" },
    { name: "Damaged Detergent Container", type: "spill" },
    { name: "Lithium Battery Package Damage", type: "battery" },
    { name: "Unknown Substance Spill", type: "spill" },
    { name: "Unmarked Dangerous Goods Package", type: "box" },
    { name: "Household Chemical Leak Trail", type: "spill" },
    { name: "Battery Thermal Event Risk", type: "battery" },

    // === RED FLAG VIOLATIONS ===
    { name: "Daisy-Chained Extension Cords", type: "cord" },
    { name: "Fire Exit Blocked By Carts", type: "door" },
    { name: "Fire Extinguisher Hidden By Pallets", type: "door" },
    { name: "Bent Racking Upright Not Offloaded", type: "tall_pallet" },
    { name: "Damaged Rack Under Load", type: "tall_pallet" },
    { name: "Missing Conveyor Safety Guard", type: "conveyor" },
    { name: "Emergency Exit Blocked By Cage", type: "door" },
    { name: "First Aid Kit Empty/Expired", type: "compliance" },
    { name: "AED Access Obstructed", type: "facility" },
    { name: "LOTO Padlock Missing", type: "compliance" },

    // === STOW & STORAGE SPECIFIC ===
    { name: "Overstuffed Stow Bag Capacity", type: "tote" },
    { name: "Heavy Item Stowed Above Shoulder", type: "tall_pallet" },
    { name: "Bin Weight Limit Exceeded", type: "box" },
    { name: "Unstable Rack Section", type: "tall_pallet" },
    { name: "Top Stock Unstable Stack", type: "tall_pallet" },

    // === INBOUND/DOCK HAZARDS ===
    { name: "Trailer Without Wheel Chocks", type: "dock" },
    { name: "Dock Plate Not Secured", type: "dock" },
    { name: "Dock Gap Foot Hazard", type: "dock" },
    { name: "Trailer Loaded Unevenly", type: "dock" },
    { name: "Vendor Pallet Leaning Dangerously", type: "tall_pallet" },

    // === COMPLIANCE & DOCUMENTATION ===
    { name: "LOTO Procedure Not Followed", type: "compliance" },
    { name: "PPE Checklist Not Completed", type: "compliance" },
    { name: "Near-Miss Incident Unreported", type: "compliance" },
    { name: "Safety Training Expired", type: "compliance" },
    { name: "Risk Assessment Overdue", type: "compliance" },

    // === GERMANY (DE) - DGUV & ArbSchG ===
    { name: "Blocked Fluchtweg (Escape Route)", type: "door", region: "DE" },
    { name: "Missing DGUV V3 Pr√ºfung Sticker", type: "battery", region: "DE" },
    { name: "Ladungssicherung Violation", type: "tall_pallet", region: "DE" },
    { name: "Fehlende Gef√§hrdungsbeurteilung", type: "compliance", region: "DE" },
    { name: "Sicherheitsbeauftragter Absent", type: "npc", region: "DE" },
    { name: "No Betriebsanweisung Posted", type: "compliance", region: "DE" },
    { name: "BetrSichV Machine Safety Violation", type: "compliance", region: "DE" },
    { name: "Missing Erste-Hilfe-Kasten", type: "facility", region: "DE" },
    { name: "Expired Pr√ºfplakette On Equipment", type: "forklift", region: "DE" },
    { name: "Feuerl√∂scher Blocked Access", type: "door", region: "DE" },

    // === AUSTRIA (AT) - ASchG & BauV ===
    { name: "Unchecked PSA (PPE)", type: "compliance", region: "AT" },
    { name: "Missing Evaluierung (Risk Assessment)", type: "compliance", region: "AT" },
    { name: "SVP Not Informed", type: "npc", region: "AT" },
    { name: "Arbeitsinspektorat Warning Ignored", type: "compliance", region: "AT" },
    { name: "Fehlende Arbeitsplatzevaluierung", type: "compliance", region: "AT" },
    { name: "AUVA Checklist Incomplete", type: "compliance", region: "AT" },
    { name: "Sicherheitsfachkraft Missing", type: "npc", region: "AT" },
    { name: "Missing Brandschutzbeauftragter", type: "npc", region: "AT" },
    { name: "Arbeitsmittelverordnung Violation", type: "facility", region: "AT" },
    { name: "Notausgang Sign Obscured", type: "door", region: "AT" },

    // === NETHERLANDS (NL) - Arbowet & RI&E ===
    { name: "Missing RI&E Assessment", type: "compliance", region: "NL" },
    { name: "Blocked Nooduitgang", type: "door", region: "NL" },
    { name: "Preventiemedewerker Absent", type: "npc", region: "NL" },
    { name: "Preventiemedewerker Not Trained", type: "npc", region: "NL" },
    { name: "Arbocatalogus Not Followed", type: "compliance", region: "NL" },
    { name: "Arbodeskundige Report Overdue", type: "compliance", region: "NL" },
    { name: "BHV Team Understaffed", type: "npc", region: "NL" },
    { name: "Missing Plan van Aanpak", type: "compliance", region: "NL" },
    { name: "Werkplekinspectie Skipped", type: "compliance", region: "NL" },
    { name: "Veiligheidskundige Advice Ignored", type: "compliance", region: "NL" },
];

// === HAZARD REGULATORY DETAILS ===
// Detailed regulatory information for hazard types and specific hazards
const HAZARD_DETAILS = {
    // Type-based details (US/OSHA standards as default)
    byType: {
        forklift: {
            regulation: "OSHA 29 CFR 1910.178",
            title: "Powered Industrial Trucks",
            detail: "Operators must be trained & certified. Speed limits enforced. Pedestrians have right-of-way. Seatbelts required when equipped. Load capacity must not be exceeded.",
            penalty: "Up to $15,625 per serious violation"
        },
        conveyor: {
            regulation: "OSHA 29 CFR 1910.212",
            title: "Machine Guarding",
            detail: "Conveyors must have emergency stops within reach. Pinch points must be guarded. Jams cleared only when system is locked out. Regular maintenance required.",
            penalty: "Up to $15,625 per serious violation"
        },
        box: {
            regulation: "OSHA 29 CFR 1910.176",
            title: "Materials Handling & Storage",
            detail: "Storage areas must be kept free of hazards. Stacking must be stable and secure. Aisles must remain clear. Weight limits posted and followed.",
            penalty: "Up to $15,625 per serious violation"
        },
        debris: {
            regulation: "OSHA 29 CFR 1910.22",
            title: "Walking-Working Surfaces",
            detail: "All work areas must be clean and orderly. Debris creates slip/trip hazards. Immediate cleanup required. Housekeeping is everyone's responsibility.",
            penalty: "Up to $15,625 per serious violation"
        },
        blade: {
            regulation: "OSHA 29 CFR 1910.212",
            title: "Machine Guarding / Hand Tools",
            detail: "Cutting tools must have guards when not in use. Retractable blades required. Proper disposal of used blades. Never leave exposed blades unattended.",
            penalty: "Up to $15,625 per serious violation"
        },
        wrap: {
            regulation: "OSHA 29 CFR 1910.132",
            title: "Personal Protective Equipment",
            detail: "Proper handling of packaging materials required. Avoid entanglement hazards. Keep materials organized. Report damaged equipment immediately.",
            penalty: "Up to $15,625 per serious violation"
        },
        tall_pallet: {
            regulation: "OSHA 29 CFR 1910.176",
            title: "Materials Handling & Storage",
            detail: "Pallets must be stable before stacking. Height limits enforced. Heavy items on bottom. Damaged pallets removed from service. Proper unloading sequence required.",
            penalty: "Up to $15,625 per serious violation"
        },
        dock: {
            regulation: "OSHA 29 CFR 1910.26 & 1910.178",
            title: "Docking Operations",
            detail: "Wheel chocks required before loading/unloading. Dock plates must be secured. Trailer brakes set. Visual communication with driver required. Dock gaps must be bridged.",
            penalty: "Up to $15,625 per serious violation"
        },
        cart: {
            regulation: "OSHA 29 CFR 1910.176",
            title: "Materials Handling",
            detail: "Carts must not block aisles. Load limits followed. Proper pushing technique (not pulling). Wheels maintained. Secure loads before moving.",
            penalty: "Up to $15,625 per serious violation"
        },
        tote: {
            regulation: "OSHA 29 CFR 1910.176",
            title: "Materials Handling",
            detail: "Tote stacking limits enforced. Inspect for damage before use. Proper lifting techniques required. Do not overfill containers. Label hazardous contents.",
            penalty: "Up to $15,625 per serious violation"
        },
        spill: {
            regulation: "OSHA 29 CFR 1910.22 & 1910.141",
            title: "Housekeeping / Sanitation",
            detail: "Spills must be cleaned immediately or marked. Wet floor signs required. Report spills you cannot clean. Know location of spill kits. Document hazmat spills.",
            penalty: "Up to $15,625 per serious violation"
        },
        cord: {
            regulation: "OSHA 29 CFR 1910.305",
            title: "Electrical Wiring Methods",
            detail: "Cords must not create trip hazards. Damaged cords removed from service. Proper cord management required. No cords across walkways without protection.",
            penalty: "Up to $15,625 per serious violation"
        },
        facility: {
            regulation: "OSHA 29 CFR 1910.37",
            title: "Maintenance / Means of Egress",
            detail: "Safety equipment must be accessible and functional. Regular inspections required. Report defects immediately. Emergency equipment clearly marked.",
            penalty: "Up to $15,625 per serious violation"
        },
        battery: {
            regulation: "OSHA 29 CFR 1910.178(g)",
            title: "Battery Charging & Handling",
            detail: "Charging areas must be designated and ventilated. Eye wash stations nearby. No smoking/flames. Proper PPE required. Battery acid is corrosive.",
            penalty: "Up to $15,625 per serious violation"
        },
        door: {
            regulation: "OSHA 29 CFR 1910.37",
            title: "Means of Egress",
            detail: "Exit routes must never be blocked. Exit signs illuminated at all times. Doors must open in direction of travel. Fire equipment accessible 24/7.",
            penalty: "Up to $156,259 for willful violations"
        },
        compliance: {
            regulation: "OSHA 29 CFR 1904",
            title: "Recording & Reporting",
            detail: "All incidents must be documented. Training records maintained. Safety audits completed on schedule. Near-misses reported for prevention. Logs kept for 5 years.",
            penalty: "Up to $15,625 per serious violation"
        },
        npc: {
            regulation: "OSHA 29 CFR 1910.132 & General Duty Clause",
            title: "Employee Safety Conduct",
            detail: "Safe work practices required at all times. No distractions while walking. Follow traffic patterns. Report unsafe behaviors. Ergonomic practices enforced.",
            penalty: "Up to $15,625 per serious violation"
        },
        cage: {
            regulation: "OSHA 29 CFR 1910.176",
            title: "Materials Storage",
            detail: "Roll cages must be secured before moving. Brakes engaged when stationary. Load evenly distributed. Inspect wheels and latches. Never ride on equipment.",
            penalty: "Up to $15,625 per serious violation"
        }
    },
    // Region-specific regulatory details
    byRegion: {
        DE: {
            default: {
                regulation: "ArbSchG / DGUV Vorschriften",
                title: "Arbeitsschutzgesetz",
                detail: "German workplace safety law requires employer risk assessment (Gef√§hrdungsbeurteilung), safety officers, and compliance with DGUV rules.",
                penalty: "Bu√ügeld bis zu ‚Ç¨25.000"
            },
            specific: {
                "Blocked Fluchtweg (Escape Route)": {
                    regulation: "ASR A2.3 / ArbSt√§ttV",
                    title: "Fluchtwege und Notausg√§nge",
                    detail: "Escape routes must be kept clear at all times. Minimum width 1m for up to 20 persons. Emergency lighting required. Signs per ISO 7010.",
                    penalty: "Bu√ügeld bis zu ‚Ç¨5.000 / Betriebsschlie√üung m√∂glich"
                },
                "Missing DGUV V3 Sticker": {
                    regulation: "DGUV Vorschrift 3",
                    title: "Elektrische Anlagen und Betriebsmittel",
                    detail: "All electrical equipment must be inspected and tagged. Portable equipment: every 6 months to 2 years. Failed equipment removed from service immediately.",
                    penalty: "Bu√ügeld + Haftung bei Unf√§llen"
                },
                "Unsecured Pallet (Ladungssicherung)": {
                    regulation: "DGUV Regel 108-007 / StVO ¬ß22",
                    title: "Ladungssicherung",
                    detail: "Loads must be secured against shifting, falling, rolling. VDI 2700 standards apply. Proper securing equipment required. Driver/loader responsible.",
                    penalty: "Bu√ügeld bis zu ‚Ç¨50.000"
                },
                "Fehlende Gef√§hrdungsbeurteilung": {
                    regulation: "ArbSchG ¬ß5",
                    title: "Gef√§hrdungsbeurteilung",
                    detail: "Employers must assess all workplace hazards. Document findings and measures. Update after changes or incidents. Employee participation required.",
                    penalty: "Bu√ügeld bis zu ‚Ç¨25.000"
                },
                "Sicherheitsbeauftragter Absent": {
                    regulation: "DGUV Vorschrift 1 ¬ß20",
                    title: "Sicherheitsbeauftragte",
                    detail: "Required: 1 safety officer per 20+ employees. Must be trained. Supports safety culture. Not liable but responsible for awareness.",
                    penalty: "Bu√ügeld + BG-Auflagen"
                },
                "No Betriebsanweisung Posted": {
                    regulation: "ArbSchG ¬ß12 / GefStoffV ¬ß14",
                    title: "Betriebsanweisungen",
                    detail: "Written operating instructions required for hazardous activities. Must be in German. Accessible at workplace. Annual training on contents.",
                    penalty: "Bu√ügeld bis zu ‚Ç¨5.000"
                },
                "BetrSichV Violation Notice": {
                    regulation: "BetrSichV",
                    title: "Betriebssicherheitsverordnung",
                    detail: "Equipment must be safe for use. Regular inspections required. Documentation mandatory. Employer responsible for safety state.",
                    penalty: "Bu√ügeld bis zu ‚Ç¨100.000 bei Gef√§hrdung"
                },
                "Missing Erste-Hilfe-Kasten": {
                    regulation: "DGUV Vorschrift 1 / ASR A4.3",
                    title: "Erste Hilfe",
                    detail: "First aid materials mandatory: Small kit (<50 employees) or Large kit (>50). Contents per DIN 13157/13169. Regular inventory checks.",
                    penalty: "Bu√ügeld + Haftung bei Verletzungen"
                },
                "Expired Pr√ºfplakette on Forklift": {
                    regulation: "BetrSichV / DGUV Vorschrift 68",
                    title: "Flurf√∂rderzeuge Pr√ºfung",
                    detail: "Annual inspection by qualified person required. UVV-Pr√ºfung documented. Defects corrected before use. Operator daily check also required.",
                    penalty: "Bu√ügeld + Betriebsverbot"
                },
                "Feuerl√∂scher Access Blocked": {
                    regulation: "ASR A2.2",
                    title: "Brandschutzeinrichtungen",
                    detail: "Fire extinguishers must be accessible within 20m walking distance. Marked with signs. Monthly visual check. Professional inspection every 2 years.",
                    penalty: "Bu√ügeld + Versicherungsausschluss bei Brand"
                }
            }
        },
        AT: {
            default: {
                regulation: "ASchG / AUVA",
                title: "ArbeitnehmerInnenschutzgesetz",
                detail: "Austrian workplace protection law. Employer must evaluate hazards, appoint safety personnel, and follow AUVA guidelines.",
                penalty: "Geldstrafe bis ‚Ç¨14.530"
            },
            specific: {
                "Unchecked PSA (PPE)": {
                    regulation: "PSA-V / ASchG ¬ß70",
                    title: "Pers√∂nliche Schutzausr√ºstung",
                    detail: "PPE must be provided free, maintained, and inspected. Training on proper use required. Replace damaged equipment immediately.",
                    penalty: "Geldstrafe bis ‚Ç¨7.260"
                },
                "Missing Evaluierung (Risk Assessment)": {
                    regulation: "ASchG ¬ß4",
                    title: "Arbeitsplatzevaluierung",
                    detail: "Systematic hazard evaluation required. Document all risks and countermeasures. Update after incidents or changes. SVP involvement mandatory.",
                    penalty: "Geldstrafe bis ‚Ç¨14.530"
                },
                "SVP Not Informed": {
                    regulation: "ASchG ¬ß¬ß76-83",
                    title: "Sicherheitsvertrauensperson",
                    detail: "Safety representative required (>10 employees). Must be informed of all safety matters. Protected from retaliation. Training provided.",
                    penalty: "Geldstrafe bis ‚Ç¨7.260"
                },
                "Arbeitsinspektorat Warning Ignored": {
                    regulation: "ArbIG",
                    title: "Arbeitsinspektion",
                    detail: "Labor inspectorate warnings are legally binding. Compliance deadlines must be met. Appeals possible but don't suspend requirements.",
                    penalty: "Geldstrafe bis ‚Ç¨72.670 / Betriebssperre"
                },
                "Fehlende Arbeitsplatzevaluierung": {
                    regulation: "ASchG ¬ß4",
                    title: "Arbeitsplatzevaluierung",
                    detail: "Every workplace must be evaluated for hazards. Physical, psychological, and ergonomic risks included. Documentation kept 5 years.",
                    penalty: "Geldstrafe bis ‚Ç¨14.530"
                },
                "AUVA Checklist Incomplete": {
                    regulation: "AUVA M.plus Standards",
                    title: "AUVA Sicherheitsmanagement",
                    detail: "AUVA provides mandatory safety checklists. Completion required for insurance compliance. Regular audits conducted.",
                    penalty: "H√∂here Beitr√§ge / Regressanspr√ºche"
                },
                "Sicherheitsfachkraft Missing": {
                    regulation: "ASchG ¬ß¬ß73-75",
                    title: "Sicherheitsfachkraft (SFK)",
                    detail: "Safety specialist required based on employee count and risk. External SFK allowed for small businesses. Minimum hours defined by law.",
                    penalty: "Geldstrafe bis ‚Ç¨14.530"
                },
                "Missing Brandschutzbeauftragter": {
                    regulation: "TRVB O 119 / ASchG",
                    title: "Brandschutzbeauftragter",
                    detail: "Fire safety officer required for larger facilities. Training certification needed. Responsible for evacuation plans and drills.",
                    penalty: "Geldstrafe + Auflagen durch Beh√∂rde"
                },
                "Arbeitsmittelverordnung Violation": {
                    regulation: "AM-VO",
                    title: "Arbeitsmittelverordnung",
                    detail: "Work equipment must be safe and suitable. Regular inspections documented. Only trained personnel operate machinery.",
                    penalty: "Geldstrafe bis ‚Ç¨7.260"
                },
                "Notausgang Sign Obscured": {
                    regulation: "AStV ¬ß20 / TRVB E 102",
                    title: "Notausg√§nge Kennzeichnung",
                    detail: "Emergency exit signs must be visible at all times. Illuminated signs for larger buildings. Regular function tests required.",
                    penalty: "Geldstrafe + beh√∂rdliche Auflagen"
                }
            }
        },
        NL: {
            default: {
                regulation: "Arbowet / RI&E",
                title: "Arbeidsomstandighedenwet",
                detail: "Dutch Working Conditions Act requires risk inventory (RI&E), prevention officer, and employee participation in safety matters.",
                penalty: "Boete tot ‚Ç¨90.000"
            },
            specific: {
                "Missing RI&E Assessment": {
                    regulation: "Arbowet Art. 5",
                    title: "Risico-Inventarisatie en -Evaluatie",
                    detail: "Every employer must have RI&E. Identify all risks, evaluate severity, plan improvements. Review after incidents or changes. Certified validation may be required.",
                    penalty: "Boete tot ‚Ç¨45.000"
                },
                "Blocked Nooduitgang": {
                    regulation: "Arbobesluit Art. 3.7 / Bouwbesluit",
                    title: "Nooduitgangen",
                    detail: "Emergency exits must remain clear. Doors open outward. Panic hardware required. Maximum travel distance to exit: 30m. Regular evacuation drills.",
                    penalty: "Boete tot ‚Ç¨22.500 / sluiting"
                },
                "Prevention Officer Absent": {
                    regulation: "Arbowet Art. 13",
                    title: "Preventiemedewerker",
                    detail: "Every company needs at least one prevention officer. For <25 employees, owner may fulfill role. Assists with RI&E and safety measures.",
                    penalty: "Boete tot ‚Ç¨4.500"
                },
                "Preventiemedewerker Not Trained": {
                    regulation: "Arbowet Art. 13",
                    title: "Preventiemedewerker Opleiding",
                    detail: "Prevention officers must be trained and competent. Training covers RI&E, incident investigation, and legal requirements. Regular refresher recommended.",
                    penalty: "Boete tot ‚Ç¨4.500"
                },
                "Arbocatalogus Not Followed": {
                    regulation: "Arbowet Art. 2a",
                    title: "Arbocatalogus",
                    detail: "Sector-specific safety standards agreed between employers and unions. Legal compliance presumed when followed. Must be applied in RI&E.",
                    penalty: "Boete tot ‚Ç¨22.500"
                },
                "Arbodeskundige Report Overdue": {
                    regulation: "Arbowet Art. 14",
                    title: "Arbodeskundige/Arbodienst",
                    detail: "Certified occupational health service required for certain tasks. RI&E validation, sick leave guidance, medical exams. Contract mandatory.",
                    penalty: "Boete tot ‚Ç¨13.500"
                },
                "BHV Team Understaffed": {
                    regulation: "Arbowet Art. 15",
                    title: "Bedrijfshulpverlening (BHV)",
                    detail: "Emergency response team required. 1 BHV'er per 50 employees minimum. Trained in first aid, fire response, evacuation. Annual refresher.",
                    penalty: "Boete tot ‚Ç¨4.500"
                },
                "Missing Plan van Aanpak": {
                    regulation: "Arbowet Art. 5",
                    title: "Plan van Aanpak",
                    detail: "Action plan required as part of RI&E. Concrete measures with deadlines. Responsible persons assigned. Progress tracked annually.",
                    penalty: "Boete tot ‚Ç¨45.000"
                },
                "Werkplekinspectie Skipped": {
                    regulation: "Arbowet / Arbobesluit",
                    title: "Werkplekinspecties",
                    detail: "Regular workplace inspections required. Document findings and corrective actions. Employee participation encouraged. Part of continuous improvement.",
                    penalty: "Boete tot ‚Ç¨22.500"
                },
                "Veiligheidskundige Advice Ignored": {
                    regulation: "Arbowet Art. 14",
                    title: "Veiligheidskundige",
                    detail: "Safety expert advice must be considered. Document reasons if not followed. Employer remains responsible for worker safety.",
                    penalty: "Boete tot ‚Ç¨45.000 / aansprakelijkheid"
                }
            }
        },
        US: {
            default: {
                regulation: "OSHA 29 CFR 1910",
                title: "General Industry Standards",
                detail: "Federal workplace safety standards. Employers must provide a workplace free from recognized hazards. Training, PPE, and documentation required.",
                penalty: "Up to $15,625 per serious violation"
            }
        }
    }
};

// Get detailed regulatory information for a hazard
function getHazardDetail(hazard) {
    if (!hazard || !hazard.data) return null;

    const region = hazard.data.region || GAME.region || 'US';
    const hazardName = hazard.data.name;
    const hazardType = hazard.data.type;

    // First check for specific hazard detail by name (regional)
    if (HAZARD_DETAILS.byRegion[region]) {
        const regionData = HAZARD_DETAILS.byRegion[region];
        if (regionData.specific && regionData.specific[hazardName]) {
            return regionData.specific[hazardName];
        }
        // Fall back to region default
        if (regionData.default) {
            // Combine region default with type-specific info
            const typeDetail = HAZARD_DETAILS.byType[hazardType];
            if (typeDetail) {
                return {
                    regulation: regionData.default.regulation + " / " + typeDetail.regulation,
                    title: typeDetail.title,
                    detail: typeDetail.detail,
                    penalty: regionData.default.penalty
                };
            }
            return regionData.default;
        }
    }

    // Fall back to type-based detail (US/OSHA)
    if (HAZARD_DETAILS.byType[hazardType]) {
        return HAZARD_DETAILS.byType[hazardType];
    }

    // Ultimate fallback
    return {
        regulation: "General Safety Standards",
        title: "Workplace Safety",
        detail: "This hazard poses risks to worker safety. Follow established safety procedures and report concerns to your supervisor.",
        penalty: "Varies by jurisdiction"
    };
}

function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function pickRandomHazards(count) {
    const region = GAME.region;

    // Separate generic hazards (no region) from region-specific ones
    const genericHazards = HAZARD_POOL.filter(h => !h.region);
    const regionHazards = HAZARD_POOL.filter(h => h.region === region);

    // Prioritize region-specific hazards: include at least 2 regional hazards if available
    const regionCount = Math.min(2, regionHazards.length, count);
    const genericCount = count - regionCount;

    const shuffledRegional = shuffleArray([...regionHazards]);
    const shuffledGeneric = shuffleArray([...genericHazards]);

    // Combine regional and generic hazards
    const combined = [
        ...shuffledRegional.slice(0, regionCount),
        ...shuffledGeneric.slice(0, genericCount)
    ];

    // Shuffle the final selection so regional hazards aren't always first
    return shuffleArray(combined);
}

function randomDoorPlacement() {
    const side = ['top', 'bottom', 'left', 'right'][Math.floor(Math.random() * 4)];
    const buffer = 2;
    let doorX = 0, doorY = 0, hazardX = 0, hazardY = 0;

    if (side === 'top') {
        doorY = 0; doorX = Math.floor(Math.random() * (MAP_W - buffer * 2)) + buffer;
        hazardX = doorX; hazardY = 1;
    } else if (side === 'bottom') {
        doorY = MAP_H - 1; doorX = Math.floor(Math.random() * (MAP_W - buffer * 2)) + buffer;
        hazardX = doorX; hazardY = MAP_H - 2;
    } else if (side === 'left') {
        doorX = 0; doorY = Math.floor(Math.random() * (MAP_H - buffer * 2)) + buffer;
        hazardX = 1; hazardY = doorY;
    } else {
        doorX = MAP_W - 1; doorY = Math.floor(Math.random() * (MAP_H - buffer * 2)) + buffer;
        hazardX = MAP_W - 2; hazardY = doorY;
    }

    return { doorX, doorY, hazardX, hazardY };
}

function isTileFree(tx, ty) {
    if (GAME.map[ty][tx] !== 0) return false;
    return !GAME.activeIssues.some(h => Math.round(h.x / TILE_SIZE) === tx && Math.round(h.y / TILE_SIZE) === ty);
}

function pickRandomFloorTile() {
    let attempts = 0;
    while (attempts < 500) {
        const tx = Math.floor(Math.random() * (MAP_W - 2)) + 1;
        const ty = Math.floor(Math.random() * (MAP_H - 2)) + 1;
        if (isTileFree(tx, ty)) return { tx, ty };
        attempts++;
    }
    return { tx: 1, ty: 1 };
}

// --- INPUT ---
const KEYS = { up: false, down: false, left: false, right: false, action: false };
window.addEventListener('keydown', e => {
    if(e.key==='w'||e.key==='ArrowUp') {
        KEYS.up=true;
        // Handle UP key for hazard detail in dialog
        if (GAME.state === 'DIALOG' && GAME.hasHazardDetail &&
            GAME.dialogVisible.length >= GAME.dialogText.length) {
            showHazardDetail();
            e.preventDefault();
            return;
        }
    }
    if(e.key==='s'||e.key==='ArrowDown') KEYS.down=true;
    if(e.key==='a'||e.key==='ArrowLeft') KEYS.left=true;
    if(e.key==='d'||e.key==='ArrowRight') KEYS.right=true;
    if(e.code==='Space') { if(!KEYS.action) handleAction(); KEYS.action=true; }
    if(e.key==='Enter') { handleAction(); }

    // Name entry state input handling
    if (GAME.state === 'NAME_ENTRY') {
        if(e.key==='ArrowLeft' || e.key==='a') { handleNameEntryInput('left'); e.preventDefault(); }
        else if(e.key==='ArrowRight' || e.key==='d') { handleNameEntryInput('right'); e.preventDefault(); }
        else if(e.key==='ArrowUp' || e.key==='w') { handleNameEntryInput('up'); e.preventDefault(); }
        else if(e.key==='ArrowDown' || e.key==='s') { handleNameEntryInput('down'); e.preventDefault(); }
        else if(e.key==='Backspace' || e.key==='b' || e.key==='B') { handleNameEntryInput('back'); e.preventDefault(); }
        else if(e.key==='Enter') { handleNameEntryInput('submit'); e.preventDefault(); }
        return;
    }

    // Highscores state - H key to view from title
    if (GAME.state === 'TITLE' && (e.key==='h' || e.key==='H')) {
        fetchHighscores().then(() => {
            GAME.state = 'HIGHSCORES';
            GAME.stateTimer = 0;
        });
        e.preventDefault();
        return;
    }

    // Escape key to exit PPE dialog/shop
    if(e.key==='Escape') {
        if (GAME.state === 'PPE_DIALOG') {
            // Exit dialogue and return to game
            if (GAME.lastPlayerPos) {
                GAME.player.x = GAME.lastPlayerPos.x;
                GAME.player.y = GAME.lastPlayerPos.y;
            }
            GAME.state = 'PLAY';
            GAME.nextState = 'PLAY';
            AudioSys.sfx.select();
            e.preventDefault();
        } else if (GAME.state === 'PPE_SHOP') {
            exitPPEShop();
            e.preventDefault();
        }
    }
});
window.addEventListener('keyup', e => {
    if(e.key==='w'||e.key==='ArrowUp') KEYS.up=false;
    if(e.key==='s'||e.key==='ArrowDown') KEYS.down=false;
    if(e.key==='a'||e.key==='ArrowLeft') KEYS.left=false;
    if(e.key==='d'||e.key==='ArrowRight') KEYS.right=false;
    if(e.code==='Space') KEYS.action=false;
});

// --- MOBILE CONTROLS ---
// Enhanced mobile controls with gyroscope mode and vibration feedback

// Global Vibration System - can be called from anywhere in the game
const VibrationSystem = {
    enabled: true,

    // Vibrate with a pattern or duration
    vibrate(pattern) {
        if (!this.enabled || !navigator.vibrate) return;
        navigator.vibrate(pattern);
    },

    // Pre-defined vibration patterns for different game events
    patterns: {
        buttonPress: 15,
        actionButton: 30,
        damage: [50, 30, 100],
        heavyDamage: [100, 50, 150, 50, 100],
        bossHit: [30, 20, 50],
        bossDefeat: [50, 50, 100, 50, 150, 50, 200],
        gameOver: [200, 100, 300, 100, 400],
        victory: [50, 50, 100, 50, 150],
        hazardFixed: [20, 30, 40],
        secretFound: [30, 30, 60, 30, 90],
        levelUp: [40, 40, 80, 40, 120],
        gyroToggle: [25, 25],
        autoShoot: 10
    },

    // Event-specific vibration methods
    onButtonPress() { this.vibrate(this.patterns.buttonPress); },
    onActionButton() { this.vibrate(this.patterns.actionButton); },
    onDamage() { this.vibrate(this.patterns.damage); },
    onHeavyDamage() { this.vibrate(this.patterns.heavyDamage); },
    onBossHit() { this.vibrate(this.patterns.bossHit); },
    onBossDefeat() { this.vibrate(this.patterns.bossDefeat); },
    onGameOver() { this.vibrate(this.patterns.gameOver); },
    onVictory() { this.vibrate(this.patterns.victory); },
    onHazardFixed() { this.vibrate(this.patterns.hazardFixed); },
    onSecretFound() { this.vibrate(this.patterns.secretFound); },
    onLevelUp() { this.vibrate(this.patterns.levelUp); },
    onGyroToggle() { this.vibrate(this.patterns.gyroToggle); },
    onAutoShoot() { this.vibrate(this.patterns.autoShoot); }
};

// Gyroscope Control System
const GyroControlSystem = {
    enabled: false,
    available: false,
    calibrated: false,
    baseGamma: 0,
    baseBeta: 0,
    currentGamma: 0,
    currentBeta: 0,
    sensitivity: 15, // Degrees of tilt needed for full movement
    deadzone: 3, // Degrees of deadzone
    autoShootEnabled: true,
    autoShootInterval: null,
    autoShootCooldown: 200, // ms between auto shots

    init() {
        // Check if DeviceOrientationEvent is available
        if (typeof DeviceOrientationEvent !== 'undefined') {
            // Check for iOS 13+ permission requirement
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                this.available = 'requires-permission';
            } else {
                this.available = true;
                this.setupListener();
            }
        }
    },

    async requestPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') {
                    this.available = true;
                    this.setupListener();
                    return true;
                }
            } catch (e) {
                console.log('Gyro permission denied:', e);
            }
            return false;
        }
        return true;
    },

    setupListener() {
        window.addEventListener('deviceorientation', (e) => {
            if (!this.enabled) return;

            // gamma: left-right tilt (-90 to 90)
            // beta: front-back tilt (-180 to 180)
            this.currentGamma = e.gamma || 0;
            this.currentBeta = e.beta || 0;

            // Calibrate on first valid reading
            if (!this.calibrated && (this.currentGamma !== 0 || this.currentBeta !== 0)) {
                this.calibrate();
            }

            this.updateMovement();
            this.updateIndicator();
        }, true);
    },

    calibrate() {
        this.baseGamma = this.currentGamma;
        this.baseBeta = this.currentBeta;
        this.calibrated = true;
    },

    updateMovement() {
        if (!this.enabled || !this.calibrated) return;

        // Calculate relative tilt from calibrated position
        const relativeGamma = this.currentGamma - this.baseGamma;
        const relativeBeta = this.currentBeta - this.baseBeta;

        // Clear all keys first
        KEYS.up = false;
        KEYS.down = false;
        KEYS.left = false;
        KEYS.right = false;

        // Apply movement based on tilt (with deadzone)
        if (Math.abs(relativeGamma) > this.deadzone) {
            if (relativeGamma < -this.deadzone) {
                KEYS.left = true;
            } else if (relativeGamma > this.deadzone) {
                KEYS.right = true;
            }
        }

        if (Math.abs(relativeBeta) > this.deadzone) {
            if (relativeBeta < -this.deadzone) {
                KEYS.up = true;
            } else if (relativeBeta > this.deadzone) {
                KEYS.down = true;
            }
        }
    },

    updateIndicator() {
        const dot = document.querySelector('#gyro-indicator .gyro-dot');
        if (!dot) return;

        // Calculate dot position based on tilt (normalized to indicator bounds)
        const relativeGamma = this.currentGamma - this.baseGamma;
        const relativeBeta = this.currentBeta - this.baseBeta;

        // Map tilt to percentage (clamped to indicator bounds)
        const maxTilt = this.sensitivity * 2;
        const xPercent = 50 + Math.max(-45, Math.min(45, (relativeGamma / maxTilt) * 45));
        const yPercent = 50 + Math.max(-45, Math.min(45, (relativeBeta / maxTilt) * 45));

        dot.style.left = xPercent + '%';
        dot.style.top = yPercent + '%';
    },

    startAutoShoot() {
        if (this.autoShootInterval) return;

        this.autoShootInterval = setInterval(() => {
            if (!this.enabled || !this.autoShootEnabled) return;

            // Only auto-shoot during gameplay states
            const shootableStates = ['PLAY', 'BOSS', 'BEZOS_BOSS', 'MECHA_BOSS'];
            if (shootableStates.includes(GAME.state)) {
                VibrationSystem.onAutoShoot();
                throwBook();
            }
        }, this.autoShootCooldown);
    },

    stopAutoShoot() {
        if (this.autoShootInterval) {
            clearInterval(this.autoShootInterval);
            this.autoShootInterval = null;
        }
    },

    toggle() {
        this.enabled = !this.enabled;
        VibrationSystem.onGyroToggle();

        const mobileControls = document.getElementById('mobile-controls');
        const toggleBtn = document.getElementById('control-mode-toggle');
        const modeIcon = toggleBtn?.querySelector('.mode-icon');
        const modeLabel = toggleBtn?.querySelector('.mode-label');

        if (this.enabled) {
            // Switching to gyro mode
            if (this.available === 'requires-permission') {
                this.requestPermission().then(granted => {
                    if (granted) {
                        this.activateGyroMode(mobileControls, toggleBtn, modeIcon, modeLabel);
                    } else {
                        this.enabled = false;
                    }
                });
            } else if (this.available) {
                this.activateGyroMode(mobileControls, toggleBtn, modeIcon, modeLabel);
            } else {
                this.enabled = false;
                alert('Gyroscope not available on this device');
            }
        } else {
            // Switching to D-Pad mode
            this.deactivateGyroMode(mobileControls, toggleBtn, modeIcon, modeLabel);
        }
    },

    activateGyroMode(mobileControls, toggleBtn, modeIcon, modeLabel) {
        mobileControls?.classList.add('gyro-mode');
        toggleBtn?.classList.add('gyro-active');
        if (modeIcon) modeIcon.textContent = 'üì±';
        if (modeLabel) modeLabel.textContent = 'GYRO';

        // Recalibrate on activation
        this.calibrated = false;

        // Start auto-shoot
        if (this.autoShootEnabled) {
            this.startAutoShoot();
        }
    },

    deactivateGyroMode(mobileControls, toggleBtn, modeIcon, modeLabel) {
        mobileControls?.classList.remove('gyro-mode');
        toggleBtn?.classList.remove('gyro-active');
        if (modeIcon) modeIcon.textContent = 'üéÆ';
        if (modeLabel) modeLabel.textContent = 'DPAD';

        // Clear gyro-set keys
        KEYS.up = false;
        KEYS.down = false;
        KEYS.left = false;
        KEYS.right = false;

        // Stop auto-shoot
        this.stopAutoShoot();
    }
};

// Touch handlers for mobile controls
// Global mobile detection flag
let isMobileDevice = false;

function initMobileControls() {
    // Detect touch capability - more reliable than CSS media queries alone
    const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    isMobileDevice = hasTouch || isMobileUA;

    if (!isMobileDevice) return;

    // Explicitly show mobile controls via JS (CSS media query is unreliable on some devices)
    const mobileControls = document.getElementById('mobile-controls');
    if (mobileControls) {
        mobileControls.style.display = 'flex';
    }

    // Initialize gyroscope system
    GyroControlSystem.init();

    // D-Pad setup
    function setupDpad(id, key) {
        const btn = document.getElementById(id);
        if (!btn) return;
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Don't process D-Pad in gyro mode
            if (GyroControlSystem.enabled) return;
            VibrationSystem.onButtonPress();
            KEYS[key] = true;
            btn.classList.add('pressed');
            // Special handling for UP in dialog with hazard detail
            if (key === 'up' && GAME.state === 'DIALOG' && GAME.hasHazardDetail &&
                GAME.dialogVisible.length >= GAME.dialogText.length) {
                showHazardDetail();
            }
        }, { passive: false });
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (GyroControlSystem.enabled) return;
            KEYS[key] = false;
            btn.classList.remove('pressed');
        }, { passive: false });
        btn.addEventListener('touchcancel', () => {
            if (GyroControlSystem.enabled) return;
            KEYS[key] = false;
            btn.classList.remove('pressed');
        });
    }

    setupDpad('dpad-up', 'up');
    setupDpad('dpad-down', 'down');
    setupDpad('dpad-left', 'left');
    setupDpad('dpad-right', 'right');

    // Control mode toggle button
    const toggleBtn = document.getElementById('control-mode-toggle');
    if (toggleBtn) {
        toggleBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleBtn.classList.add('pressed');
        }, { passive: false });
        toggleBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleBtn.classList.remove('pressed');
            GyroControlSystem.toggle();
        }, { passive: false });
        toggleBtn.addEventListener('touchcancel', () => {
            toggleBtn.classList.remove('pressed');
        });
    }

    // Action button
    const actionBtn = document.getElementById('action-btn');
    if (actionBtn) {
        actionBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            VibrationSystem.onActionButton();
            if (!KEYS.action) handleAction();
            KEYS.action = true;
            actionBtn.classList.add('pressed');
        }, { passive: false });
        actionBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            KEYS.action = false;
            actionBtn.classList.remove('pressed');
        }, { passive: false });
        actionBtn.addEventListener('touchcancel', () => {
            KEYS.action = false;
            actionBtn.classList.remove('pressed');
        });
    }

    // Make dialog boxes tappable to advance (so A button works as Space in menus)
    const introWindow = document.getElementById('intro-portrait-window');
    if (introWindow) {
        introWindow.addEventListener('touchstart', (e) => {
            e.preventDefault();
            VibrationSystem.onActionButton();
            if (!KEYS.action) handleAction();
            KEYS.action = true;
        }, { passive: false });
        introWindow.addEventListener('touchend', (e) => {
            e.preventDefault();
            KEYS.action = false;
        }, { passive: false });
        introWindow.addEventListener('click', (e) => {
            e.preventDefault();
            if (!KEYS.action) handleAction();
        });
    }

    const dialogBox = document.getElementById('dialog-box');
    if (dialogBox) {
        dialogBox.addEventListener('touchstart', (e) => {
            e.preventDefault();
            VibrationSystem.onActionButton();
            if (!KEYS.action) handleAction();
            KEYS.action = true;
        }, { passive: false });
        dialogBox.addEventListener('touchend', (e) => {
            e.preventDefault();
            KEYS.action = false;
        }, { passive: false });
        dialogBox.addEventListener('click', (e) => {
            e.preventDefault();
            if (!KEYS.action) handleAction();
        });
    }
}

// Initialize mobile controls when DOM is ready
initMobileControls();

// Canvas touch handler for PPE shop and dialog buttons
const gameCanvas = document.getElementById('gameCanvas');
if (gameCanvas) {
    gameCanvas.addEventListener('touchstart', (e) => {
        const rect = gameCanvas.getBoundingClientRect();
        const scaleX = gameCanvas.width / rect.width;
        const scaleY = gameCanvas.height / rect.height;
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) * scaleX;
        const y = (touch.clientY - rect.top) * scaleY;

        // Name entry touch controls
        if (GAME.state === 'NAME_ENTRY' && !GAME.highscoreSubmitted) {
            const btns = nameEntryTouchButtons;
            if (btns.left && x >= btns.left.x && x <= btns.left.x + btns.left.w && y >= btns.left.y && y <= btns.left.y + btns.left.h) {
                e.preventDefault();
                nameEntryCharIndex = (nameEntryCharIndex - 1 + NAME_ENTRY_CHARS.length) % NAME_ENTRY_CHARS.length;
                AudioSys.sfx.step();
                return;
            }
            if (btns.right && x >= btns.right.x && x <= btns.right.x + btns.right.w && y >= btns.right.y && y <= btns.right.y + btns.right.h) {
                e.preventDefault();
                nameEntryCharIndex = (nameEntryCharIndex + 1) % NAME_ENTRY_CHARS.length;
                AudioSys.sfx.step();
                return;
            }
            if (btns.add && x >= btns.add.x && x <= btns.add.x + btns.add.w && y >= btns.add.y && y <= btns.add.y + btns.add.h) {
                e.preventDefault();
                if (GAME.nameEntry.length < 5) {
                    GAME.nameEntry += NAME_ENTRY_CHARS[nameEntryCharIndex];
                    AudioSys.sfx.select();
                }
                return;
            }
            if (btns.del && x >= btns.del.x && x <= btns.del.x + btns.del.w && y >= btns.del.y && y <= btns.del.y + btns.del.h) {
                e.preventDefault();
                if (GAME.nameEntry.length > 0) {
                    GAME.nameEntry = GAME.nameEntry.slice(0, -1);
                    AudioSys.sfx.step();
                }
                return;
            }
            if (btns.submit && GAME.nameEntry.length > 0 && x >= btns.submit.x && x <= btns.submit.x + btns.submit.w && y >= btns.submit.y && y <= btns.submit.y + btns.submit.h) {
                e.preventDefault();
                submitPlayerHighscore();
                return;
            }
            return;
        }

        // Name entry after submission - tap anywhere to continue
        if (GAME.state === 'NAME_ENTRY' && GAME.highscoreSubmitted) {
            e.preventDefault();
            AudioSys.sfx.select();
            GAME.state = 'HIGHSCORES';
            GAME.stateTimer = 0;
            return;
        }

        // Highscores screen - tap anywhere to return to title
        if (GAME.state === 'HIGHSCORES') {
            e.preventDefault();
            AudioSys.sfx.select();
            GAME.state = 'TITLE';
            updateMusicForState();
            return;
        }

        // PPE Dialog menu options (tap to select and confirm)
        if (GAME.state === 'PPE_DIALOG' && GAME.ppeDialogButtons) {
            for (let i = 0; i < GAME.ppeDialogButtons.length; i++) {
                const btn = GAME.ppeDialogButtons[i];
                if (btn && x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                    e.preventDefault();
                    VibrationSystem.onButtonPress();
                    GAME.ppeDialogChoice = i;
                    // Simulate action to confirm selection
                    if (i === 0) {
                        // Enter shop
                        AudioSys.sfx.select();
                        GAME.state = 'PPE_SHOP';
                        GAME.ppeShopIndex = 0;
                    } else {
                        // Leave - return to game
                        if (GAME.lastPlayerPos) {
                            GAME.player.x = GAME.lastPlayerPos.x;
                            GAME.player.y = GAME.lastPlayerPos.y;
                        }
                        GAME.state = 'PLAY';
                        GAME.nextState = 'PLAY';
                        AudioSys.sfx.select();
                    }
                    return;
                }
            }
        }
    }, { passive: false });
}

function handleAction() {
    // Initialize audio systems (safely handle any errors)
    try {
        AudioSys.init();
        AudioSys.resume();
        MusicSys.init();
        MusicSys.resume();
    } catch(e) {
        console.error("Audio init error:", e);
    }

    // Force intro music to start on first user interaction (bypass autoplay restrictions)
    if (GAME.state === 'PRESS_START') {
        // Set the selected region before advancing
        GAME.region = GAME.regionList[GAME.regionIndex];
        // Regenerate dynamic signs for the selected region
        if (GFX.regenerateRegionSigns) GFX.regenerateRegionSigns();
        // Reinitialize TTS for the selected region's language
        if (TTSSys.init) TTSSys.init();
        advanceState(); // Move to LOGO state and start intro music
        return;
    }
    // Let intro music play - ignore input and auto-advance after timer
    if (GAME.state === 'LOGO') { return; }
    // Handle other states that should not process input
    if (GAME.state === 'LOSE_SPLASH' || GAME.state === 'WIN_SPLASH') return;

    updateMusicForState();
    if (['INTRO', 'STORY'].includes(GAME.state)) { AudioSys.sfx.start(); advanceState(); }
    else if (['TITLE', 'HOWTO'].includes(GAME.state)) {
        GAME.state = (GAME.state==='TITLE')?'HOWTO':'SELECT'; AudioSys.sfx.select(); updateMusicForState();
    }
    else if (GAME.state === 'SELECT') { AudioSys.sfx.select(); GAME.selectedChar = GAME.charList[GAME.charIndex]; resetGame(); }
    else if (GAME.state === 'DIALOG') {
        if (GAME.dialogVisible.length < GAME.dialogText.length) {
            GAME.dialogVisible = GAME.dialogText;
            // Update whichever window is visible
            if (document.getElementById('intro-portrait-window').style.display === 'block') {
                document.getElementById('intro-text-content').innerText = GAME.dialogVisible;
            } else {
                document.getElementById('text-content').innerText = GAME.dialogVisible;
            }
        } else {
            // Close whichever window is visible
            if (document.getElementById('intro-portrait-window').style.display === 'block') {
                closeIntroDialog();
            } else {
                closeDialog();
            }
            // Check if transitioning to yard level
            if (GAME.nextState === 'YARD_INTRO') {
                GAME.state = 'YARD_INTRO';
                GAME.stateTimer = 0;
                startYardLevel();
            }
        }
    }
    else if (GAME.state === 'HAZARD_DETAIL_MODAL') {
        // Close modal on space or down
        closeHazardDetailModal();
        return;
    }
    else if (GAME.state === 'PPE_DIALOG') {
        // NPC dialogue - select current option
        AudioSys.sfx.select();
        if (GAME.ppeDialogChoice === 0) {
            // "Buy PPE" selected - enter shop
            GAME.ppeShopIndex = 0;
            GAME.shopMessage = '';
            GAME.shopMessageTimer = 0;
            GAME.state = 'PPE_SHOP';
            GAME.stateTimer = 0;
        } else {
            // "Leave" selected - return to game
            if (GAME.lastPlayerPos) {
                GAME.player.x = GAME.lastPlayerPos.x;
                GAME.player.y = GAME.lastPlayerPos.y;
            }
            GAME.state = 'PLAY';
            GAME.nextState = 'PLAY';
        }
        return;
    }
    else if (GAME.state === 'PPE_SHOP') {
        // Buy selected item
        const item = PPE_ITEMS[GAME.ppeShopIndex];
        if (!item) return;

        // === SPECIAL ACTION: Return All PPE ===
        if (item.id === 'return_all') {
            if (GAME.ppeUnlocked.length === 0) {
                AudioSys.sfx.alert();
                GAME.shopMessage = getShopMessage('no_items_to_return');
                GAME.shopMessageTimer = 180;
            } else {
                // Calculate maxhp buffs being removed BEFORE clearing PPE
                const maxHpBeingRemoved = getPPEBuffValue('maxhp');

                // Calculate total refund at 50% value
                let totalRefund = 0;
                GAME.ppeUnlocked.forEach(ppeId => {
                    const ppe = PPE_ITEMS.find(p => p.id === ppeId);
                    if (ppe && ppe.cost > 0) totalRefund += Math.floor(ppe.cost * 0.5);
                });

                // Refund 50% of points and clear PPE
                GAME.safetyPoints += totalRefund;
                const returnedCount = GAME.ppeUnlocked.length;
                GAME.ppeUnlocked = [];

                // Disable life buffs: reduce current lives if they exceed new max
                if (maxHpBeingRemoved > 0) {
                    const stats = getCharStats(GAME.selectedChar);
                    const newMaxLives = stats.lives; // No more PPE buffs
                    if (GAME.lives > newMaxLives) {
                        GAME.lives = newMaxLives;
                    }
                }

                AudioSys.sfx.fix();
                spawnFloatingText(canvas.width / 2, canvas.height / 2, "+" + totalRefund + " " + getLocalizedText('sp_short') + "!", "#22c55e");
                updatePpeBuffsHud(); // Update PPE buffs display

                // Call AI for witty return comment
                const regionName = getRegionName();
                const langInst = getLanguageInstruction();
                callGemini(
                    `You are Simon Unglaube, the Quartermaster. The player just returned ${returnedCount} PPE items for a 50% refund of ${totalRefund} Safety Points. Make a witty comment about their decision to return gear. Max 20 words. ${langInst}`,
                    "ppe_return",
                    { count: returnedCount, refund: totalRefund, region: GAME.region }
                ).then(response => {
                    if (GAME.state === 'PPE_SHOP') {
                        GAME.shopMessage = response;
                        GAME.shopMessageTimer = 300;
                        speakTTS(response, "Simon");
                    }
                });
                saveGameProgress();
            }
            return;
        }

        // === SPECIAL ACTION: Exit Shop ===
        if (item.id === 'exit_shop' || item.isExit) {
            AudioSys.sfx.step();
            GAME.state = 'PLAY';
            GAME.shopMessage = null;
            GAME.shopMessageTimer = 0;
            return;
        }

        if (GAME.ppeUnlocked.includes(item.id)) {
            // Already owned
            AudioSys.sfx.alert();
            GAME.shopMessage = getShopMessage('already_owned');
            GAME.shopMessageTimer = 180;
        } else if (GAME.safetyPoints >= item.cost) {
            // Purchase successful
            GAME.safetyPoints -= item.cost;
            GAME.ppeUnlocked.push(item.id);
            AudioSys.sfx.fix(); // Success sound
            spawnFloatingText(canvas.width / 2, canvas.height / 2, "UNLOCKED!", "#22c55e");
            updatePpeBuffsHud(); // Update PPE buffs display

            // Call AI for witty regulation comment
            const regionName = getRegionName();
            const langInst = getLanguageInstruction();
            callGemini(
                `You are Simon Unglaube, the Quartermaster. Approve the PPE item "${item.name}" for ${regionName} regulations. Context: "${item.context}". Be witty and dry. Max 20 words. ${langInst}`,
                "ppe_purchase",
                { item: item.name, region: GAME.region }
            ).then(response => {
                if (GAME.state === 'PPE_SHOP') {
                    GAME.shopMessage = response;
                    GAME.shopMessageTimer = 300;
                    speakTTS(response, "Simon");
                }
            });
        } else {
            // Not enough points
            AudioSys.sfx.hurt();
            GAME.shopMessage = getShopMessage('insufficient_points');
            GAME.shopMessageTimer = 180;
        }
        return;
    }
    else if (GAME.state === 'VISITOR_SPLASH') { initBossEncounter(); }
    else if (GAME.state === 'BOSS_INTRO') { GAME.state = 'BOSS'; GAME.nextState = 'BOSS'; updateMusicForState(); }
    else if (GAME.state === 'BEZOS_INTRO') { GAME.state = 'BEZOS_BOSS'; GAME.nextState = 'BEZOS_BOSS'; updateMusicForState(); }
    else if (GAME.state === 'MECHA_BOSS_INTRO') { GAME.state = 'MECHA_BOSS'; GAME.nextState = 'MECHA_BOSS'; updateMusicForState(); }
    else if (GAME.state === 'MECHA_SIMON_SPLASH') { GAME.state = 'BOSS'; GAME.nextState = 'BOSS'; updateMusicForState(); }
    else if (GAME.state === 'THRONE_CONFRONTATION') {
        // Throne confrontation cutscene - wait for space to start dialogue
        const scene = GAME.throneScene;
        if (!scene) return;

        // Phase 0: Show VS screen and wait for space press (after 40 frames minimum)
        if (scene.phase === 0 && GAME.stateTimer >= 40) {
            scene.phase = 1;
            AudioSys.sfx.select();
            // Start the AI dialogue sequence
            startBezosConfrontationDialogue();
        }
    }
    else if (GAME.state === 'MECHA_TRANSFORM') {
        // Only allow skip after animation has played for a bit
        if (GAME.stateTimer > 200) {
            beginMechaEncounter(); // Proceed to Mecha boss fight
        }
    }
    else if (GAME.state === 'SIMON_MECHA_TRANSFORM') {
        // Only allow proceeding after health bar animation completes (120 frames = 2 seconds)
        if (GAME.stateTimer > 120) {
            completeSimonMechaTransformation(); // Proceed to Phase 4: Transformation
        }
    }
    else if (GAME.state === 'BEZOS_ESCAPE') {
        // Handle escape scene dialogue advances
        const scene = GAME.escapeScene;
        if (scene && scene.phase === 7) {
            // During dialogue phase (phase 7), advance to next dialogue
            advanceBezosEscapeDialogue();
        }
    }
    else if (GAME.state === 'YARD_INTRO') { startYardLevel(); }
    else if (GAME.state === 'GAMEOVER_SPLASH') {
        // After viewing game over screen, go back to title
        if (GAME.stateTimer > 60) { // Short delay before allowing skip
            GAME.state = 'TITLE'; updateMusicForState();
        }
    }
    else if (GAME.state === 'GAMEOVER' || GAME.state === 'WIN') {
        document.getElementById('boss-hud').style.display = 'none'; GAME.state = 'TITLE'; updateMusicForState();
    }
    else if (GAME.state === 'BEZOS_WIN') {
        // Transition to name entry for highscore
        GAME.state = 'NAME_ENTRY';
        GAME.stateTimer = 0;
        nameEntryCharIndex = 0;
    }
    else if (GAME.state === 'NAME_ENTRY') {
        // Handle character confirm with space, or continue after submission
        handleNameEntryInput('space');
    }
    else if (GAME.state === 'HIGHSCORES') {
        // Return to title from highscores
        GAME.state = 'TITLE';
        updateMusicForState();
    }
    else if (GAME.state === 'CREDITS') {
        // Allow skip after credits have been rolling for a while
        if (GAME.stateTimer > 600) {
            GAME.creditsStarted = false; // Reset for next time
            GAME.state = 'TITLE'; updateMusicForState();
        }
    }
    else if (GAME.state === 'PLAY' || GAME.state === 'BOSS' || GAME.state === 'BEZOS_BOSS' || GAME.state === 'MECHA_BOSS') {
        if (GAME.state === 'PLAY' && tryInteract()) return;
        throwBook();
    }
}

function init() {
    // Initialize cached values for performance
    CachedValues.init(canvas);

    generateAssets();
    loadGameProgress(); // Load saved PPE and safety points
    fetchHighscores(); // Load highscores from server
    GAME.state = 'PRESS_START';
    // DON'T call updateMusicForState() here - it will fail due to autoplay policy
    // Music will start on first user interaction in handleAction()
    requestAnimationFrame(loop);
}

function advanceState() {
    GAME.stateTimer = 0;
    if (GAME.state === 'PRESS_START') GAME.state = 'LOGO';
    else if (GAME.state === 'LOGO') GAME.state = 'INTRO';
    else if (GAME.state === 'INTRO') GAME.state = 'STORY';
    else if (GAME.state === 'STORY') GAME.state = 'TITLE';
    else if (GAME.state === 'TITLE') GAME.state = 'HOWTO';
    updateMusicForState();
}

function resetGame() {
    GAME.state = 'PLAY';
    GAME.genId++;
    GAME.gameOverTriggered = false;
    GAME.mechaSimonDefeat = false; // Reset Mecha Mega Simon defeat flag
    GAME.creditsStarted = false; // Reset credits flag for new playthrough
    const stats = getCharStats(GAME.selectedChar);
    GAME.player = { x: 100, y: 100, dir: 0, speed: stats.speed, iframe: 0, cooldown: 0, cooldownMax: 120 };
    GAME.entities = []; GAME.projectiles = []; GAME.particles = []; GAME.floatingTexts = [];
    // Performance: Reset object pools on game restart
    ObjectPool.reset();
    GAME.activeIssues = []; GAME.clutter = [];

    // === PPE BUFF: Max HP bonuses (Ear Defenders + Exoskeleton) ===
    let baseLives = stats.lives + getPPEBuffValue('maxhp');

    GAME.issuesFixed = 0; GAME.lives = baseLives; GAME.simonHits = 0; GAME.boss = null; GAME.pendingBossIntro = false;
    GAME.regenTimer = 0; // Reset hydration pouch timer
    GAME.hiddenDoor = null; GAME.yard = null; GAME.mecha = null;
    GAME.nextState = 'PLAY'; GAME.aiResultText = null;
    GAME.startTime = Date.now(); GAME.booksFired = 0; GAME.opsPushed = 0; GAME.booksMissed = 0; GAME.simonHitsCount = 0; GAME.lastTimePenaltyCount = 0;

    generateMap();
    GAME.entities.push({ type: 'simon', x: 100, y: 80, w: 16, h: 16 });
    document.getElementById('hud-layer').style.display = 'block'; updateHud();
    document.getElementById('boss-hud').style.display = 'none';

    // Initialize random warehouse event for this game
    initWarehouseEvent();
    GAME.flashlightMode = false;
    GAME.fireDrillActive = false;

    // Start warehouse theme immediately when mission intro begins
    MusicSys.play('ingame');

    // --- INTRO DIALOGUE SEQUENCE ---
    GAME.introDialogueStep = 0;
    const currentGen = GAME.genId;

    // Show Simon's thinking state in INTRO WINDOW while AI generates greeting
    showIntroThinking("Simon");
    GAME.nextState = 'INTRO_DIALOGUE_CONTINUE'; // Custom state for dialogue sequence

    // Generate Simon's greeting with objective overview (localized)
    const langInst = getLanguageInstruction();
    callGemini(`You are Simon, WHS Senior Regional Manager for Amazon MEU. Give ${GAME.selectedChar} a brief welcome with your signature dry wit, then explain their shift objective: find and fix 5 safety hazards while dodging ops manager interruptions. Keep it concise and witty. Max 45 words. ${langInst}`, "intro").then(text => {
        if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
             let finalText = text.replace(/\[.*?\]/g, GAME.selectedChar);
             // Remove speaker name prefix if AI included it
             finalText = finalText.replace(/^SIMON:?\s*/i, '').replace(/^Simon:?\s*/i, '');
             showIntroDialog(finalText, "Simon", true);
        }
    });
}

function generateMap() {
    GAME.map = [];
    // Reset warehouse atmosphere arrays
    GAME.conveyorBelts = [];
    GAME.packages = [];
    GAME.palletJacks = [];
    GAME.cartWorkers = [];
    GAME.palletStacks = [];
    GAME.sortStations = [];
    GAME.warehouseSigns = [];

    for(let y=0; y<MAP_H; y++) {
        GAME.map[y] = [];
        for(let x=0; x<MAP_W; x++) {
            if (x===0 || x===MAP_W-1 || y===0 || y===MAP_H-1) GAME.map[y][x] = 1;
            else if (x > 5 && x < 55 && y % 5 === 0 && x % 3 !== 0) GAME.map[y][x] = 2;
            else {
                GAME.map[y][x] = 0;
                if (Math.random() < 0.05) {
                    const type = ['coffee','paper','tape'][Math.floor(Math.random()*3)];
                    GAME.clutter.push({x: x*TILE_SIZE + 4, y: y*TILE_SIZE + 4, type: type});
                }
            }
        }
    }
    for(let y=15; y<25; y++) for(let x=25; x<35; x++) GAME.map[y][x] = 0;

    // === ADD CONVEYOR BELT LANES ===
    // Horizontal conveyor lanes through the warehouse
    const conveyorLanes = [8, 18, 28]; // Y positions for conveyor lanes
    conveyorLanes.forEach(laneY => {
        for (let x = 6; x < 54; x++) {
            if (x % 3 !== 0) { // Gap for crossing
                GAME.conveyorBelts.push({
                    x: x * TILE_SIZE,
                    y: laneY * TILE_SIZE,
                    dir: laneY === 18 ? -1 : 1 // Alternate directions
                });
            }
        }
    });

    // === SPAWN MOVING PACKAGES ON CONVEYORS ===
    for (let i = 0; i < 12; i++) {
        const laneY = conveyorLanes[Math.floor(Math.random() * conveyorLanes.length)];
        GAME.packages.push({
            x: Math.random() * (48 * TILE_SIZE) + 6 * TILE_SIZE,
            y: laneY * TILE_SIZE - 4,
            speed: (laneY === 18 ? -0.5 : 0.5) + Math.random() * 0.2,
            type: Math.random() < 0.5 ? 'small' : 'large'
        });
    }


    // === SPAWN CART WORKERS ===
    for (let i = 0; i < 4; i++) {
        const startY = 10 + i * 8;
        GAME.cartWorkers.push({
            x: 8 * TILE_SIZE,
            y: startY * TILE_SIZE,
            targetX: 50 * TILE_SIZE,
            dir: 1, // 1 = right, -1 = left
            speed: 0.6 + Math.random() * 0.2,
            pauseTimer: 0
        });
    }

    // === ADD PALLET STACKS (static decoration) ===
    const palletPositions = [
        {x: 4, y: 4}, {x: 4, y: 12}, {x: 4, y: 22}, {x: 4, y: 32},
        {x: 55, y: 4}, {x: 55, y: 12}, {x: 55, y: 22}, {x: 55, y: 32},
        {x: 12, y: 35}, {x: 22, y: 35}, {x: 38, y: 35}, {x: 48, y: 35}
    ];
    palletPositions.forEach(pos => {
        if (pos.x < MAP_W - 1 && pos.y < MAP_H - 1) {
            GAME.palletStacks.push({
                x: pos.x * TILE_SIZE,
                y: pos.y * TILE_SIZE
            });
        }
    });

    // === ADD SORTING STATIONS ===
    GAME.sortStations.push(
        { x: 15 * TILE_SIZE, y: 3 * TILE_SIZE },
        { x: 35 * TILE_SIZE, y: 3 * TILE_SIZE },
        { x: 25 * TILE_SIZE, y: 36 * TILE_SIZE }
    );

    // === ADD WAREHOUSE ZONE SIGNS ===
    GAME.warehouseSigns.push(
        { x: 10 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'pick' },
        { x: 30 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'pack' },
        { x: 50 * TILE_SIZE, y: 2 * TILE_SIZE, type: 'ship' }
    );

    const door = randomDoorPlacement();
    GAME.map[door.doorY][door.doorX] = 3;
    GAME.map[door.hazardY][door.hazardX] = 0;
    GAME.fireExitDoor = { x: door.doorX * TILE_SIZE, y: door.doorY * TILE_SIZE }; // Store door position for hidden level
    GAME.activeIssues.push({ x: door.hazardX*TILE_SIZE, y: door.hazardY*TILE_SIZE, data: {name: "Blocked Exit", type: "box"}, fixed: false });

    // === SPAWN QUARTERMASTER'S SAFETY CAGE ===
    // Place in TOP LEFT corner for maximum visibility
    const qmX = 1; // Top left corner
    const qmY = 1; // Against top outer wall
    // Mark a 3x3 area for the larger cage (tile type 4)
    for (let dy = 0; dy < 3; dy++) {
        for (let dx = 0; dx < 3; dx++) {
            if (qmY + dy < MAP_H && qmX + dx < MAP_W) {
                GAME.map[qmY + dy][qmX + dx] = 4;
            }
        }
    }
    // Store center position of the cage for interaction
    GAME.quartermasterDoor = {
        x: (qmX + 1) * TILE_SIZE,
        y: (qmY + 1) * TILE_SIZE,
        width: 3,
        height: 3
    };

    spawnEntity('runner'); spawnEntity('runner');

    const hazardList = pickRandomHazards(5);
    hazardList.forEach(rHazard => {
        const { tx, ty } = pickRandomFloorTile();
        GAME.activeIssues.push({ x: tx*TILE_SIZE, y: ty*TILE_SIZE, data: rHazard, fixed: false });
    });
    for(let i=0; i<8; i++) spawnEntity('ops');
    for(let i=0; i<10; i++) spawnEntity('assoc');
}

function spawnEntity(type) {
    let tx, ty;
    do { tx = Math.floor(Math.random()*(MAP_W-2))+1; ty = Math.floor(Math.random()*(MAP_H-2))+1; } while(GAME.map[ty][tx]!==0);
    GAME.entities.push({ type:type, x:tx*TILE_SIZE, y:ty*TILE_SIZE, dir:0, timer:0 });
}

function initSimonBoss() {
    GAME.state = 'BOSS_INTRO';
    AudioSys.sfx.bossIntro();
    GAME.boss = {
        name: "MEGA SIMON", sprite: "simonBoss", hp: 50, speed: 1.3, attackDelay: 30,
        title: "THE WHS FINAL BOSS", desc: "He is not impressed.", attackName: "SAFETY VIOLATION STORM", attackPattern: "storm",
        tauntsTriggered: [], tauntThresholds: [0.75, 0.5, 0.25], maxHp: 50,
        x: MAP_W * TILE_SIZE / 2, y: MAP_H * TILE_SIZE / 2, timer: 0,
        transformTriggered: false, isMecha: false, lowHealthAttackTriggered: false
    };
    GAME.entities = []; GAME.projectiles = [];
    updateMusicForState();
}

// === BOSS DEFEAT CUTSCENE SYSTEM ===
// Epic 10-second cutscene when defeating a boss (not Simon/Mecha)

function triggerBossDefeatCutscene() {
    // Store boss info before clearing
    const bossName = GAME.boss ? (GAME.boss.originalName || GAME.boss.name) : 'Unknown Boss';
    const bossSprite = GAME.boss ? GAME.boss.sprite : null;

    // Stop action and set up cutscene state
    GAME.projectiles = [];
    GAME.shake = 25;
    GAME.flash = 15;
    AudioSys.sfx.fix(); // Victory hit sound

    // Initialize cutscene state
    GAME.defeatCutscene = {
        phase: 0,           // 0=intro, 1=boss speaks, 2=player responds, 3=transition
        timer: 0,
        bossName: bossName,
        bossSprite: bossSprite,
        bossLine: null,     // Will be set by AI or fallback
        playerLine: null,   // Will be set by AI or fallback
        particles: [],
        flashIntensity: 1.0
    };

    GAME.state = 'BOSS_DEFEAT_CUTSCENE';
    GAME.stateTimer = 0;

    // Hide HUD elements during cutscene
    document.getElementById('boss-hud').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';

    // Play dramatic sound and music
    MusicSys.play('victory');
    VibrationSystem.onVictory();

    // Spawn EPIC defeat particles burst from center (where big boss sprite will display)
    const centerX = 128;
    const centerY = 92;
    // Initial explosion burst - 40 particles radiating outward
    for (let i = 0; i < 40; i++) {
        const angle = (i / 40) * Math.PI * 2 + Math.random() * 0.2;
        const speed = 2 + Math.random() * 4;
        GAME.defeatCutscene.particles.push({
            x: centerX + (Math.random() - 0.5) * 20,
            y: centerY + (Math.random() - 0.5) * 20,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1,
            life: 80 + Math.random() * 60,
            color: ['#ff6b6b', '#ffd93d', '#ff8c42', '#ffffff', '#ff4444', '#ffaa00'][Math.floor(Math.random() * 6)]
        });
    }
    // Secondary burst - sparkling stars
    for (let i = 0; i < 15; i++) {
        GAME.defeatCutscene.particles.push({
            x: centerX + (Math.random() - 0.5) * 60,
            y: centerY + (Math.random() - 0.5) * 60,
            vx: (Math.random() - 0.5) * 6,
            vy: -Math.random() * 5 - 2,
            life: 100 + Math.random() * 50,
            color: '#ffffff'
        });
    }

    // Get AI-generated lines or fallback to static
    const currentGen = GAME.genId;
    const langInst = getLanguageInstruction();

    // Request boss defeat line from AI
    callGemini(
        `You are ${bossName}, a defeated boss in a warehouse safety game. You just lost to the safety coordinator. Give a dramatic, defeated final line that fits your character (max 15 words). Be theatrical and funny. ${langInst}`,
        "boss_defeat",
        { bossName }
    ).then(line => {
        if (GAME.genId === currentGen && GAME.defeatCutscene) {
            GAME.defeatCutscene.bossLine = line;
        }
    });

    // Request player victory line from AI
    callGemini(
        `You are ${GAME.selectedChar}, a victorious WHS coordinator. You just defeated ${bossName}. Give a confident, witty one-liner celebrating your safety victory (max 15 words). Stay in character. ${langInst}`,
        "player_victory",
        { charName: GAME.selectedChar, bossName }
    ).then(line => {
        if (GAME.genId === currentGen && GAME.defeatCutscene) {
            GAME.defeatCutscene.playerLine = line;
        }
    });

    // Phase 1: Dramatic pause with visual effects (3 seconds for longer visibility)
    setTimeout(() => {
        if (GAME.state !== 'BOSS_DEFEAT_CUTSCENE') return;
        advanceDefeatCutscene();
    }, 3000);
}

function advanceDefeatCutscene() {
    if (!GAME.defeatCutscene) return;

    GAME.defeatCutscene.phase++;

    if (GAME.defeatCutscene.phase === 1) {
        // Phase 1: Boss speaks their defeat line
        const bossLine = GAME.defeatCutscene.bossLine || getBossDefeatLine(GAME.defeatCutscene.bossName);
        const bossPortrait = GFX.bossFaces[GAME.defeatCutscene.bossSprite] || GFX.bossFaces.boss_manager;

        GAME.shake = 10;
        showDialog(bossLine, GAME.defeatCutscene.bossName, bossPortrait, !!GAME.defeatCutscene.bossLine);
        GAME.nextState = 'BOSS_DEFEAT_CUTSCENE_CONTINUE';
    }
    else if (GAME.defeatCutscene.phase === 2) {
        // Phase 2: Player responds with victory line
        const playerLine = GAME.defeatCutscene.playerLine || getPlayerVictoryLine(GAME.selectedChar);

        GAME.flash = 8;
        showDialog(playerLine, GAME.selectedChar, GFX.charFaces[GAME.selectedChar], !!GAME.defeatCutscene.playerLine);
        GAME.nextState = 'BOSS_DEFEAT_CUTSCENE_END';
    }
    else if (GAME.defeatCutscene.phase === 3) {
        // Phase 3: Transition to victory screen
        GAME.defeatCutscene = null;
        winGame();
    }
}

function handleDefeatCutsceneDialogClose() {
    if (GAME.nextState === 'BOSS_DEFEAT_CUTSCENE_CONTINUE') {
        advanceDefeatCutscene();
    }
    else if (GAME.nextState === 'BOSS_DEFEAT_CUTSCENE_END') {
        // Short pause before transitioning
        setTimeout(() => {
            if (GAME.defeatCutscene) {
                advanceDefeatCutscene();
            }
        }, 500);
    }
}

function updateDefeatCutscene() {
    if (!GAME.defeatCutscene) return;

    GAME.defeatCutscene.timer++;
    const t = GAME.defeatCutscene.timer;

    // Update particles with enhanced physics
    for (let i = GAME.defeatCutscene.particles.length - 1; i >= 0; i--) {
        const p = GAME.defeatCutscene.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.04; // Slightly less gravity for longer floats
        p.vx *= 0.99; // Slight air resistance
        p.life--;
        if (p.life <= 0) {
            GAME.defeatCutscene.particles.splice(i, 1);
        }
    }

    // Spawn epic particles during intro phase (more frequent and varied)
    if (GAME.defeatCutscene.phase === 0) {
        // Center position where the big boss sprite is displayed
        const centerX = 128;
        const centerY = 92;

        // Spawn multiple particles per frame for epic effect
        const spawnCount = Math.random() < 0.5 ? 2 : 1;
        for (let s = 0; s < spawnCount; s++) {
            if (Math.random() < 0.6) {
                // Explosion particles from boss center
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                GAME.defeatCutscene.particles.push({
                    x: centerX + (Math.random() - 0.5) * 40,
                    y: centerY + (Math.random() - 0.5) * 40,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 50 + Math.random() * 50,
                    color: ['#ff6b6b', '#ffd93d', '#ff8c42', '#ffffff', '#ff4444', '#ffaa00'][Math.floor(Math.random() * 6)]
                });
            }
        }

        // Occasional big sparks
        if (Math.random() < 0.15) {
            GAME.defeatCutscene.particles.push({
                x: centerX + (Math.random() - 0.5) * 60,
                y: centerY + (Math.random() - 0.5) * 60,
                vx: (Math.random() - 0.5) * 5,
                vy: -Math.random() * 4 - 2,
                life: 70 + Math.random() * 30,
                color: '#ffffff'
            });
        }

        // Rising embers
        if (Math.random() < 0.2) {
            GAME.defeatCutscene.particles.push({
                x: centerX + (Math.random() - 0.5) * 80,
                y: 200 + Math.random() * 20,
                vx: (Math.random() - 0.5) * 1,
                vy: -Math.random() * 2 - 1.5,
                life: 80 + Math.random() * 40,
                color: ['#ff6b6b', '#ff8c42', '#ffd93d'][Math.floor(Math.random() * 3)]
            });
        }
    }

    // Fade flash effect more slowly for dramatic impact
    if (GAME.defeatCutscene.flashIntensity > 0) {
        GAME.defeatCutscene.flashIntensity -= 0.015;
    }
}

function drawDefeatCutscene() {
    if (!GAME.defeatCutscene) return;

    const t = GAME.defeatCutscene.timer;

    // Draw dramatic vignette (enhanced)
    const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 180);
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(0.5, 'rgba(0,0,0,0.2)');
    gradient.addColorStop(0.8, 'rgba(0,0,0,0.5)');
    gradient.addColorStop(1, 'rgba(0,0,0,0.85)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 256, 256);

    // Draw epic defeat particles (larger and more colorful)
    for (const p of GAME.defeatCutscene.particles) {
        const alpha = Math.min(1, p.life / 30);
        const size = 2 + Math.floor(p.life / 20);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;

        // Add glow effect for particles
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.fillRect(Math.floor(p.x), Math.floor(p.y), size, size);
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;

    // Epic flash overlay during intro (golden-red)
    if (GAME.defeatCutscene.flashIntensity > 0 && GAME.defeatCutscene.phase === 0) {
        const flashGrad = ctx.createRadialGradient(128, 92, 0, 128, 92, 150);
        flashGrad.addColorStop(0, `rgba(255,215,0,${GAME.defeatCutscene.flashIntensity * 0.4})`);
        flashGrad.addColorStop(0.5, `rgba(255,100,50,${GAME.defeatCutscene.flashIntensity * 0.3})`);
        flashGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = flashGrad;
        ctx.fillRect(0, 0, 256, 256);
    }

    // Draw epic "DEFEATED!" text during intro phase
    if (GAME.defeatCutscene.phase === 0) {
        ctx.save();

        // Boss name banner at top
        ctx.font = '8px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const bossName = GAME.defeatCutscene.bossName || 'BOSS';
        ctx.fillStyle = '#666';
        ctx.fillText(bossName.toUpperCase(), 128, 20);

        // Epic DEFEATED text with animation
        const pulse = Math.sin(t * 0.15) * 0.3 + 0.7;
        const scale = 1 + Math.sin(t * 0.1) * 0.05;
        const yOffset = Math.sin(t * 0.08) * 2;

        ctx.save();
        ctx.translate(128, 148 + yOffset);
        ctx.scale(scale, scale);

        // Multiple shadow layers for depth
        ctx.font = 'bold 20px "Press Start 2P", monospace';
        ctx.fillStyle = '#000';
        ctx.fillText('DEFEATED!', 3, 3);
        ctx.fillStyle = '#330000';
        ctx.fillText('DEFEATED!', 2, 2);
        ctx.fillStyle = '#550000';
        ctx.fillText('DEFEATED!', 1, 1);

        // Main text with gradient effect
        const textGrad = ctx.createLinearGradient(-60, -10, 60, 10);
        textGrad.addColorStop(0, `rgb(${Math.floor(255 * pulse)}, ${Math.floor(50)}, ${Math.floor(50)})`);
        textGrad.addColorStop(0.5, `rgb(${Math.floor(255)}, ${Math.floor(150 * pulse)}, ${Math.floor(50)})`);
        textGrad.addColorStop(1, `rgb(${Math.floor(255 * pulse)}, ${Math.floor(50)}, ${Math.floor(50)})`);
        ctx.fillStyle = textGrad;

        // Glow effect
        ctx.shadowColor = '#ff4444';
        ctx.shadowBlur = 15;
        ctx.fillText('DEFEATED!', 0, 0);

        // Bright highlight on top
        ctx.shadowBlur = 0;
        ctx.fillStyle = `rgba(255,255,255,${pulse * 0.4})`;
        ctx.fillText('DEFEATED!', 0, -1);

        ctx.restore();

        // Victory subtitle
        ctx.font = '6px "Press Start 2P", monospace';
        ctx.fillStyle = `rgba(255, 215, 0, ${Math.sin(t * 0.12) * 0.3 + 0.7})`;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 5;
        ctx.fillText('SAFETY PREVAILS!', 128, 170);
        ctx.shadowBlur = 0;

        ctx.restore();
    }
}

// Fake victory dialogue - player thinks they won at 0 HP, but Simon transforms
function triggerFakeVictoryDialogue() {
    // Phase 1: Player Surprise
    // Stop the action
    GAME.projectiles = [];
    GAME.shake = 15;
    GAME.flash = 10;
    AudioSys.sfx.fix(); // Victory sound

    // Initialize fake victory dialogue state
    GAME.fakeVictoryPhase = 0;
    GAME.fakeVictoryTimer = 0;
    GAME.state = 'SIMON_FAKE_VICTORY';
    GAME.stateTimer = 0;

    // Hide boss HUD temporarily to sell the "victory"
    document.getElementById('boss-hud').style.display = 'none';

    // Start the dialogue sequence after a short delay
    setTimeout(() => {
        if (GAME.state !== 'SIMON_FAKE_VICTORY') return;

        // Phase 1: Player expresses surprise (~2 seconds)
        showDialog("That was... surprisingly easy?", GAME.selectedChar, GFX.charFaces[GAME.selectedChar], false);
        GAME.fakeVictoryPhase = 1;
        GAME.nextState = 'SIMON_FAKE_VICTORY_CONTINUE';
    }, 500);
}

// Continue fake victory dialogue after player's line
function continueFakeVictoryDialogue() {
    GAME.fakeVictoryPhase++;

    if (GAME.fakeVictoryPhase === 2) {
        // Phase 2: Simon's Reveal
        GAME.shake = 20;
        AudioSys.sfx.angry();

        // Show boss HUD again with HP at 0 to start the animation
        document.getElementById('boss-hud').style.display = 'block';
        GAME.boss.hp = 0;
        GAME.boss.maxHp = 999;
        updateBossHud();

        showDialog("You fool... That wasn't even my final form!\n\nBEHOLD MY TRUE POWER!", "MEGA SIMON", GFX.simonBoss, false);
        GAME.nextState = 'SIMON_FAKE_VICTORY_TRANSFORM';
    }
}

// Handle closing dialog during fake victory sequence
function handleFakeVictoryDialogClose() {
    if (GAME.nextState === 'SIMON_FAKE_VICTORY_CONTINUE') {
        continueFakeVictoryDialogue();
    }
    else if (GAME.nextState === 'SIMON_FAKE_VICTORY_TRANSFORM') {
        // Now trigger the actual transformation
        triggerMechaSimonTransformation();
    }
}

// Mecha Mega Simon transformation - triggered after fake victory dialogue
function triggerMechaSimonTransformation() {
    // Phase 3: Health Bar Animation
    GAME.shake = 30;
    GAME.flash = 20;
    AudioSys.sfx.bossIntro();

    // Clear existing projectiles
    GAME.projectiles = [];

    // Start the transformation animation state
    GAME.state = 'SIMON_MECHA_TRANSFORM';
    GAME.stateTimer = 0;

    // Initialize health bar animation from 0% to 100%
    GAME.boss.hp = 0;
    GAME.boss.maxHp = 999;
    GAME.healthBarAnimProgress = 0; // Track animation progress (0 to 1)

    // Set flag to indicate transformation is in progress
    GAME.simonTransformTextFetched = true; // Skip AI text for simplified version
    GAME.simonTransformText = null;
}

// Complete Simon's mecha transformation after animation
function completeSimonMechaTransformation() {
    // Phase 4: Transformation Complete
    // Transform the boss
    GAME.boss.name = "MECHA MEGA SIMON";
    GAME.boss.title = "MECHANIZED AUDIT ENFORCER";
    GAME.boss.sprite = "mechaMegaSimon";
    GAME.boss.isMecha = true;
    GAME.boss.hp = 999;
    GAME.boss.maxHp = 999;
    GAME.boss.speed = 1.2; // Faster than before (was 1.0)
    GAME.boss.attackDelay = 40; // Faster attacks (was 55)
    GAME.boss.attackName = "COMPLIANCE ANNIHILATION";
    GAME.boss.mechaTimer = 0; // Timer to trigger game over
    document.getElementById('boss-name-el').innerText = GAME.boss.name;
    updateBossHud();

    // Return to boss fight immediately with massive visual effects
    GAME.state = 'BOSS';
    GAME.nextState = 'BOSS';
    GAME.shake = 50; // Massive screen shake
    GAME.flash = 30; // Massive flash

    // Spawn massive particle burst
    spawnParticleBurst(GAME.boss.x + 24, GAME.boss.y + 24, ['#eab308', '#dc2626', '#ff9900', '#ff4444'], 50);
}

// Show Mecha Mega Simon splash screen before boss fight
function showMechaSimonSplash() {
    GAME.state = 'MECHA_SIMON_SPLASH';
    GAME.stateTimer = 0;
    AudioSys.sfx.bossIntro();
}

// Region-specific boss name localizations
function localizeBossName(originalName, region) {
    const localizations = {
        'DE': {
            'Labour Inspector': 'Gewerbeaufsicht',
            'Compliance Auditor': 'Berufsgenossenschaft',
            'Regional OPS MGR': 'Regionaler Betriebsleiter',
            'Avetta Platform': 'Avetta Risikopr√ºfer'
        },
        'AT': {
            'Labour Inspector': 'Arbeitsinspektorat',
            'Compliance Auditor': 'AUVA Pr√ºfer',
            'Regional OPS MGR': 'Regionale Betriebsleitung'
        },
        'NL': {
            'Labour Inspector': 'Inspectie SZW',
            'Compliance Auditor': 'Arbo-adviseur',
            'Regional OPS MGR': 'Regiomanager Operaties',
            'Avetta Platform': 'RI&E Controleur'
        }
    };

    const regionMap = localizations[region];
    if (regionMap && regionMap[originalName]) {
        return regionMap[originalName];
    }
    return originalName;
}

function initBossEncounter() {
    GAME.state = 'BOSS_INTRO';
    GAME.stateTimer = 0;
    GAME.pendingBossIntro = false;
    GAME.nextState = 'BOSS';
    AudioSys.sfx.bossIntro();
    const bossData = GAME.bossTypes[Math.floor(Math.random() * GAME.bossTypes.length)];

    // Localize boss name based on selected region
    const localizedName = localizeBossName(bossData.name, GAME.region);

    GAME.boss = { ...bossData, name: localizedName, originalName: bossData.name, x: MAP_W * TILE_SIZE / 2, y: MAP_H * TILE_SIZE / 2, w: 32, h: 32, maxHp: bossData.hp, timer: 0, tauntsTriggered: [], tauntThresholds: [0.75, 0.5, 0.25], lowHealthAttackTriggered: false };
    GAME.entities = []; GAME.projectiles = [];
    document.getElementById('boss-name-el').innerText = GAME.boss.name;
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function startYardLevel() {
    GAME.state = 'YARD_LEVEL';
    GAME.stateTimer = 0;
    const yardHeight = 650; // Yard section height
    const hallwayHeight = 450; // Long hallway with lasers and drones
    const throneRoomHeight = 250; // Safe throne room at top
    const h = yardHeight + hallwayHeight + throneRoomHeight; // Total level height
    const castleStart = yardHeight; // Where castle/hallway begins
    const hallwayStart = throneRoomHeight; // Where the dangerous hallway starts (Y < this is safe throne room)
    GAME.yard = {
        height: h,
        yardHeight: yardHeight,
        castleStart: castleStart,
        hallwayStart: hallwayStart, // Y boundary for safe throne room
        throneRoomHeight: throneRoomHeight,
        cameraY: 0,
        playerX: canvas.width / 2 - 8,
        playerY: h - 32,
        startY: h - 32, // Remember starting position for reset
        speed: getCharStats(GAME.selectedChar).speed * 0.95,
        vehicles: [],
        forklifts: [], // Forklift hazards
        hazardZones: [], // Environmental hazard zones
        transformationTriggered: false, // Track if Mecha transformation cutscene started
        inCastle: false, // Track if player entered castle
        castleEntered: false, // Track if castle entry message shown
        inHallway: false, // Track if player entered the hallway
        hallwayEntered: false, // Track if hallway entry message shown
        firstLaserTriggered: false, // Track if first laser beam was crossed (security activation message)
        throneRoomGreeted: false, // Track if throne room AI greeting was shown
        jeffAnimFrame: 0, // Animation frame for Jeff
        // Extended vehicle lanes - more challenging gauntlet with varied patterns (in yard section only)
        lanes: [
            { y: h - 70, dir: 1, speed: 0.85, timer: 75, type: 'truck' },
            { y: h - 120, dir: -1, speed: 1.0, timer: 65, type: 'van' },
            { y: h - 170, dir: 1, speed: 1.1, timer: 55, type: 'mixed' },
            { y: h - 230, dir: -1, speed: 0.9, timer: 80, type: 'truck' },
            { y: h - 290, dir: 1, speed: 1.2, timer: 50, type: 'van' },
            { y: h - 350, dir: -1, speed: 1.0, timer: 60, type: 'mixed' },
            { y: h - 410, dir: 1, speed: 1.15, timer: 55, type: 'van' },
            { y: h - 470, dir: -1, speed: 0.95, timer: 70, type: 'truck' },
            { y: h - 530, dir: 1, speed: 1.25, timer: 45, type: 'van' },
            { y: h - 590, dir: -1, speed: 1.1, timer: 50, type: 'mixed' }
        ],
        // Forklift crossing zones
        forkliftZones: [
            { y: h - 200, timer: 180, active: false },
            { y: h - 380, timer: 240, active: false },
            { y: h - 520, timer: 200, active: false }
        ],
        // Static hazard areas (puddles, debris) - in yard section
        staticHazards: [
            { x: 30, y: h - 150, type: 'puddle' },
            { x: 180, y: h - 260, type: 'debris' },
            { x: 80, y: h - 440, type: 'puddle' },
            { x: 150, y: h - 550, type: 'debris' }
        ],
        // Hallway section hazards (all within hallway zone, NOT in throne room)
        castleDrones: [], // Patrol drones in hallway
        castleLasers: [], // Laser barriers
        castleGuards: [], // Stationary guard turrets
        // Moving platforms only in hallway section (Y > hallwayStart)
        castlePlatforms: [
            { x: 20, y: hallwayStart + 50, w: 40, dir: 1, speed: 0.8 },
            { x: 150, y: hallwayStart + 120, w: 50, dir: -1, speed: 1.0 },
            { x: 80, y: hallwayStart + 200, w: 45, dir: 1, speed: 0.9 },
            { x: 30, y: hallwayStart + 280, w: 55, dir: -1, speed: 1.1 },
            { x: 120, y: hallwayStart + 360, w: 40, dir: 1, speed: 1.2 }
        ],
        // Laser barriers in hallway section (Y > hallwayStart)
        castleLaserBarriers: [
            { y: hallwayStart + 80, onTime: 60, offTime: 90, timer: 0, active: true },
            { y: hallwayStart + 160, onTime: 50, offTime: 80, timer: 30, active: false },
            { y: hallwayStart + 260, onTime: 70, offTime: 70, timer: 50, active: true },
            { y: hallwayStart + 350, onTime: 40, offTime: 100, timer: 20, active: false },
            { y: hallwayStart + 420, onTime: 55, offTime: 75, timer: 40, active: true }
        ],
        // Patrol drones initialization
        droneSpawnTimer: 0
    };

    // Initialize hallway guard turrets (all in hallway section, NOT in throne room)
    const y = GAME.yard;
    y.castleGuards = [
        { x: 10, y: hallwayStart + 60, fireTimer: 60, fireRate: 80 },
        { x: canvas.width - 26, y: hallwayStart + 130, fireTimer: 40, fireRate: 90 },
        { x: 10, y: hallwayStart + 200, fireTimer: 20, fireRate: 70 },
        { x: canvas.width - 26, y: hallwayStart + 290, fireTimer: 0, fireRate: 85 },
        { x: 10, y: hallwayStart + 380, fireTimer: 50, fireRate: 75 },
        { x: canvas.width - 26, y: hallwayStart + 440, fireTimer: 30, fireRate: 80 }
    ];

    GAME.player.speed = GAME.yard.speed;
    GAME.projectiles = [];
    GAME.particles = [];
    GAME.floatingTexts = [];

    // === YARD ATMOSPHERE ELEMENTS (like warehouse) ===
    // Initialize yard package collectibles for bonus points
    y.yardPackages = [];
    // Spawn initial packages on the road lanes
    for (let i = 0; i < 8; i++) {
        const laneIndex = Math.floor(Math.random() * y.lanes.length);
        const lane = y.lanes[laneIndex];
        y.yardPackages.push({
            x: 30 + Math.random() * (canvas.width - 60),
            y: lane.y - 5 + Math.random() * 10,
            collected: false,
            bobTimer: Math.random() * Math.PI * 2,
            glowTimer: Math.random() * Math.PI * 2,
            type: Math.random() < 0.3 ? 'prime' : 'standard' // Prime packages worth more
        });
    }
    y.packageSpawnTimer = 0;

    // Yard atmosphere: pallet stacks, dock signs (conveyors removed)
    y.palletStacks = [
        { x: 8, y: h - 55 }, { x: 45, y: h - 55 },
        { x: canvas.width - 55, y: h - 55 }, { x: canvas.width - 25, y: h - 55 }
    ];
    y.dockWorkers = [];
    for (let i = 0; i < 3; i++) {
        y.dockWorkers.push({
            x: 60 + Math.random() * (canvas.width - 120),
            y: h - 50 + Math.random() * 20,
            dir: Math.random() < 0.5 ? 1 : -1,
            pauseTimer: Math.random() * 60,
            banterTimer: 0,
            banterText: null,
            banterLife: 0
        });
    }

    // === YARD BIRDS (3D atmosphere effect) ===
    y.birds = [];
    y.birdSpawnTimer = 0;

    // Yard scoring tracking
    y.vehicleHitPenalty = 0; // Track penalty points

    // Don't start yard music here - it will start when Simon's safety speech dialog closes

    // Show Simon's yard safety tip (localized)
    const safetyTip = getLocalizedYardTip();
    showDialog(safetyTip, "Simon", GFX.simonFaceLarge, true);
    GAME.nextState = 'YARD_LEVEL';
}

function beginMechaEncounter() {
    GAME.state = 'MECHA_BOSS_INTRO';
    GAME.stateTimer = 0;
    // Completely redesigned Mecha Boss with multiple phases
    GAME.mecha = {
        hp: 48,
        maxHp: 48,
        x: canvas.width / 2 - 32,
        y: 18,
        baseY: 18,
        timer: 0,
        // Phase system: 0=Prime Missiles, 1=Drone Swarm, 2=Package Rain, 3=Laser Grid, 4=Ground Slam
        currentPhase: 0,
        phaseTimer: 0,
        phaseDuration: 280,
        phaseTransition: false,
        transitionTimer: 0,
        // Attack state
        attackCooldown: 0,
        projectiles: [],
        shadows: [],
        beam: null,
        beams: [], // Multiple beams for laser grid
        // Movement pattern
        moveDir: 1,
        moveTimer: 0,
        bobOffset: 0,
        // Enrage at low HP
        enraged: false,
        enrageFlash: 0,
        // Dash attack
        dashing: false,
        dashTarget: null,
        dashSpeed: 0,
        // Ground slam
        slamming: false,
        slamTimer: 0,
        slamY: 18,
        // Phase names for announcements (localized)
        phaseNames: getLocalizedMechaJeffPhaseNames(),
        phaseTaunts: getLocalizedMechaJeffPhaseTaunts()
    };
    GAME.player.x = canvas.width / 2 - 8;
    GAME.player.y = canvas.height - 28;
    GAME.boss = { name: 'MECHA JEFF', hp: 48, maxHp: 48 };
    document.getElementById('boss-name-el').innerText = 'MECHA JEFF';
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function startCredits() {
    GAME.state = 'CREDITS';
    GAME.stateTimer = 0;
    GAME.creditsStarted = true; // Prevent re-initialization
    GAME.boss = null;
    stopPortraitAnimation();
    document.getElementById('boss-hud').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';
    document.getElementById('dialog-box').style.display = 'none';
    document.getElementById('intro-portrait-window').style.display = 'none'; // Also hide intro window
    GAME.projectiles = [];
    GAME.particles = [];
    GAME.floatingTexts = [];
    updateMusicForState();
}

function queueVisitorSplash() {
    if (GAME.pendingBossIntro || GAME.boss) return;
    GAME.pendingBossIntro = true;
    GAME.nextState = 'VISITOR_SPLASH';
}

function showVisitorSplash() {
    GAME.state = 'VISITOR_SPLASH';
    GAME.stateTimer = 0;
    GAME.nextState = 'BOSS_INTRO';
    AudioSys.sfx.bossIntro();
    updateMusicForState();
}

function initMechaBezos() {
    GAME.state = 'BEZOS_INTRO';
    GAME.stateTimer = 0;
    AudioSys.sfx.bossIntro();

    GAME.boss = {
        name: "MECHA JEFF BEZOS",
        sprite: "mechaBezos",
        hp: 40,
        maxHp: 40,
        speed: 1.2,
        attackDelay: 50,
        title: "THE ULTIMATE BOSS",
        desc: "Automation has gone too far!",
        attackName: "AUTOMATION PROTOCOL",
        x: 104,
        y: 60,
        w: 48,
        h: 48,
        timer: 0,
        attackPhase: 0, // Tracks which attack pattern (0-2)
        laserAngle: 0, // For laser sweep attack
        droneSpawnTimer: 0,
        tauntsTriggered: [],
        tauntThresholds: [0.75, 0.5, 0.25]
    };

    GAME.player.x = 120;
    GAME.player.y = 180;
    GAME.entities = [];
    GAME.projectiles = [];

    document.getElementById('boss-name-el').innerText = "MECHA JEFF BEZOS";
    document.getElementById('boss-hud').style.display = 'block';
    updateBossHud();
    updateMusicForState();
}

function updateMechaBezos() {
    const b = GAME.boss;
    if (!b) return;

    b.timer++;

    // Initialize new boss properties if not set
    if (!b.enraged) b.enraged = false;
    if (!b.tauntTimer) b.tauntTimer = 0;
    if (!b.fallingPackages) b.fallingPackages = [];
    if (!b.shockwaveTimer) b.shockwaveTimer = 0;
    if (!b.dashTarget) b.dashTarget = null;
    if (!b.dashCooldown) b.dashCooldown = 0;

    // === ENRAGE MODE when HP < 10 ===
    if (b.hp <= 10 && !b.enraged) {
        b.enraged = true;
        b.speed *= 1.5;
        GAME.flash = 15;
        GAME.shake = 20;
        AudioSys.sfx.bossIntro();
        MusicSys.play('enraged', 1.0);
    }

    // === FALLING PACKAGE HAZARDS ===
    if (b.timer % 90 === 0 && b.attackPhase >= 1) {
        // Spawn falling packages from top of screen
        for (let i = 0; i < (b.enraged ? 3 : 2); i++) {
            b.fallingPackages.push({
                x: Math.random() * 220 + 18,
                y: -20,
                vy: 2 + Math.random() * 1,
                w: 14,
                h: 14
            });
        }
    }

    // Update falling packages
    for (let i = b.fallingPackages.length - 1; i >= 0; i--) {
        const pkg = b.fallingPackages[i];
        pkg.y += pkg.vy;

        // Remove if off screen
        if (pkg.y > 240) {
            b.fallingPackages.splice(i, 1);
            continue;
        }

        // Check collision with player
        if (GAME.player.iframe === 0 &&
            GAME.player.x < pkg.x + pkg.w && GAME.player.x + 16 > pkg.x &&
            GAME.player.y < pkg.y + pkg.h && GAME.player.y + 16 > pkg.y) {
            GAME.lives--;
            GAME.player.iframe = 60;
            updateHud();
            AudioSys.sfx.hurt();
            GAME.shake = 6;
            b.fallingPackages.splice(i, 1);
            if (GAME.lives <= 0) {
                triggerGameOver("PRIME DELIVERED!");
            }
        }
    }

    // === BOSS DASH ATTACK (new mechanic) ===
    if (b.dashCooldown > 0) b.dashCooldown--;
    if (b.enraged && b.dashCooldown === 0 && b.timer % 180 === 0) {
        // Start dash attack
        b.dashTarget = { x: GAME.player.x, y: GAME.player.y };
        b.dashCooldown = 200;
        AudioSys.sfx.alert();
    }

    // Execute dash
    if (b.dashTarget) {
        const dx = b.dashTarget.x - b.x;
        const dy = b.dashTarget.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 10) {
            b.x += (dx / dist) * 5; // Fast dash speed
            b.y += (dy / dist) * 5;
        } else {
            b.dashTarget = null;
            // Shockwave on landing
            b.shockwaveTimer = 30;
            GAME.shake = 10;
            // Spawn ring of projectiles
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                GAME.projectiles.push({
                    type: 'bezos_missile',
                    x: b.x + 24,
                    y: b.y + 24,
                    vx: Math.cos(angle) * 2.5,
                    vy: Math.sin(angle) * 2.5,
                    life: 80,
                    boss: true
                });
            }
        }
    } else {
        // Normal movement toward player
        const dx = GAME.player.x - b.x;
        const dy = GAME.player.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 60) {
            b.x += (dx / dist) * b.speed;
            b.y += (dy / dist) * b.speed;
        }
    }

    // === TAUNT MECHANIC (visual effects only, no overlay text) ===
    b.tauntTimer++;
    if (b.tauntTimer > 300 && !b.taunting) {
        b.taunting = true;
        b.tauntTimer = 0;
        setTimeout(() => { if (b) b.taunting = false; }, 1000);
    }

    // Switch attack phases based on HP
    if (b.hp > 26) b.attackPhase = 0; // Phase 1: Missile Spread
    else if (b.hp > 13) b.attackPhase = 1; // Phase 2: Laser Sweep
    else b.attackPhase = 2; // Phase 3: Drone Swarm

    // === ATTACK PHASE 1: PRIME MISSILE SPREAD ===
    const attackDelay = b.enraged ? Math.floor(b.attackDelay * 0.7) : b.attackDelay;
    if (b.attackPhase === 0 && b.timer % attackDelay === 0) {
        // Fire missiles in a spread pattern
        const missileCount = b.enraged ? 12 : 8;
        for (let i = 0; i < missileCount; i++) {
            const angle = (i / missileCount) * Math.PI * 2;
            const vx = Math.cos(angle) * 3;
            const vy = Math.sin(angle) * 3;
            GAME.projectiles.push({
                type: 'bezos_missile',
                x: b.x + 24,
                y: b.y + 24,
                vx: vx,
                vy: vy,
                life: 120,
                boss: true
            });
        }
        AudioSys.sfx.throw();
    }

    // === ATTACK PHASE 2: LASER SWEEP ===
    if (b.attackPhase === 1) {
        const laserSpeed = b.enraged ? 0.08 : 0.05;
        b.laserAngle += laserSpeed;
        // Fire laser beam every few frames
        const laserRate = b.enraged ? 5 : 8;
        if (b.timer % laserRate === 0) {
            const vx = Math.cos(b.laserAngle) * 4;
            const vy = Math.sin(b.laserAngle) * 4;
            GAME.projectiles.push({
                type: 'bezos_laser',
                x: b.x + 24,
                y: b.y + 24,
                vx: vx,
                vy: vy,
                life: 40,
                boss: true
            });
            if (b.timer % 16 === 0) AudioSys.sfx.alert();
        }
    }

    // === ATTACK PHASE 3: DRONE SWARM ===
    if (b.attackPhase === 2) {
        b.droneSpawnTimer++;
        const droneRate = b.enraged ? 35 : 50;
        if (b.droneSpawnTimer > droneRate) {
            b.droneSpawnTimer = 0;
            // Spawn a drone that homes in on player
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 100;
            GAME.entities.push({
                type: 'drone',
                x: b.x + 24 + Math.cos(angle) * spawnDist,
                y: b.y + 24 + Math.sin(angle) * spawnDist,
                w: 16,
                h: 16,
                speed: b.enraged ? 2.0 : 1.5,
                hp: 2
            });
            AudioSys.sfx.pop();
        }

        // Update drones - they home in on player
        GAME.entities.forEach(drone => {
            if (drone.type === 'drone') {
                const dx = GAME.player.x - drone.x;
                const dy = GAME.player.y - drone.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    drone.x += (dx / dist) * drone.speed;
                    drone.y += (dy / dist) * drone.speed;
                }

                // Drone collision with player
                if (GAME.player.iframe === 0 && Math.hypot(drone.x - GAME.player.x, drone.y - GAME.player.y) < 14) {
                    GAME.lives--;
                    GAME.player.iframe = 60;
                    updateHud();
                    AudioSys.sfx.hurt();
                    GAME.shake = 8;
                    drone.hp = 0; // Destroy drone on impact

                    if (GAME.lives <= 0) {
                        triggerGameOver("AUTOMATED OUT OF EXISTENCE!");
                    }
                }
            }
        });

        // Player can destroy drones
        for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
            const proj = GAME.projectiles[i];
            if (proj.type === 'attack') {
                for (let j = GAME.entities.length - 1; j >= 0; j--) {
                    const drone = GAME.entities[j];
                    if (drone.type === 'drone' && Math.hypot(proj.x - drone.x, proj.y - drone.y) < 12) {
                        drone.hp--;
                        if (drone.hp <= 0) {
                            GAME.entities.splice(j, 1);
                            AudioSys.sfx.hit();
                        }
                        GAME.projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }
    }

    // Check player projectiles hitting boss
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const proj = GAME.projectiles[i];
        if (proj.type === 'attack' &&
            proj.x >= b.x && proj.x <= b.x + b.w &&
            proj.y >= b.y && proj.y <= b.y + b.h) {
            b.hp--;
            updateBossHud();
            AudioSys.sfx.bossHit();
            GAME.shake = 5;
            GAME.projectiles.splice(i, 1);
            spawnParticle(proj.x, proj.y, '#ff9900', 5);
            // Damage number above boss head
            spawnFloatingText(b.x + 24, b.y - 10, '-1', '#ffffff');

            if (b.hp <= 0) {
                winBezosLevel();
            }
        }
    }

    // Check boss projectiles hitting player
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const proj = GAME.projectiles[i];
        if ((proj.type === 'bezos_missile' || proj.type === 'bezos_laser') && GAME.player.iframe === 0) {
            if (Math.hypot(proj.x - GAME.player.x, proj.y - GAME.player.y) < 16) {
                GAME.lives--;
                GAME.player.iframe = 60;
                updateHud();
                AudioSys.sfx.hurt();
                GAME.shake = 8;
                GAME.projectiles.splice(i, 1);

                if (GAME.lives <= 0) {
                    triggerGameOver("AUTOMATED OUT OF EXISTENCE!");
                }
            }
        }
    }
}

function winBezosLevel() {
    GAME.state = 'BEZOS_WIN';
    GAME.stateTimer = 0;
    GAME.boss = null;
    document.getElementById('boss-hud').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';
    AudioSys.sfx.start();
    MusicSys.play('victory');
    VibrationSystem.onVictory();

    // Prepare highscore entry for Mecha Jeff victory
    prepareHighscoreEntry('Mecha Jeff');
}

// === WAREHOUSE ATMOSPHERE UPDATE ===
function updateWarehouseAtmosphere() {
    // Update moving packages on conveyors
    GAME.packages.forEach(pkg => {
        pkg.x += pkg.speed;
        // Wrap around when off screen
        if (pkg.speed > 0 && pkg.x > 54 * TILE_SIZE) {
            pkg.x = 6 * TILE_SIZE;
        } else if (pkg.speed < 0 && pkg.x < 6 * TILE_SIZE) {
            pkg.x = 54 * TILE_SIZE;
        }
    });

    // Update cart workers
    GAME.cartWorkers.forEach(worker => {
        if (worker.pauseTimer > 0) {
            worker.pauseTimer--;
            return;
        }

        worker.x += worker.dir * worker.speed;

        // Randomly pause to simulate work
        if (Math.random() < 0.002) {
            worker.pauseTimer = 60 + Math.random() * 60; // 1-2 second pause
        }

        // Turn around at edges
        if (worker.dir > 0 && worker.x > 50 * TILE_SIZE) {
            worker.dir = -1;
            worker.pauseTimer = 30; // Brief pause when turning
        } else if (worker.dir < 0 && worker.x < 8 * TILE_SIZE) {
            worker.dir = 1;
            worker.pauseTimer = 30;
        }
    });
}

// === YARD LEVEL POWER-UP AND COLLECTIBLE UPDATE ===
function updateYardPowerUps() {
    const p = GAME.player;

    // Update power-up timer
    if (GAME.playerPowerUp) {
        GAME.powerUpTimer--;
        if (GAME.powerUpTimer <= 0) {
            // Remove power-up effects
            if (GAME.playerPowerUp === 'speed') {
                p.speed = getCharStats(GAME.selectedChar).speed * 0.9;
            }
            GAME.playerPowerUp = null;
        }
    }

    // Check power-up collection
    for (let i = GAME.powerUps.length - 1; i >= 0; i--) {
        const pu = GAME.powerUps[i];
        if (Math.hypot(pu.x - p.x, pu.y - p.y) < 16) {
            AudioSys.sfx.fix();
            GAME.powerUps.splice(i, 1);

            if (pu.type === 'speed') {
                GAME.playerPowerUp = 'speed';
                GAME.powerUpTimer = 300; // 5 seconds
                p.speed = getCharStats(GAME.selectedChar).speed * 1.5;
                spawnFloatingText(p.x, p.y - 16, getLocalizedText('speed_boost'), "#22d3ee");
            } else if (pu.type === 'shield') {
                GAME.playerPowerUp = 'shield';
                GAME.powerUpTimer = 180; // 3 seconds
                p.iframe = 180; // Temporary invincibility
                spawnFloatingText(p.x, p.y - 16, "SHIELD!", "#a855f7");
            } else if (pu.type === 'life') {
                GAME.lives = Math.min(GAME.lives + 1, 5);
                updateHud();
                spawnFloatingText(p.x, p.y - 16, "+1 LIFE!", "#f87171");
            }
        }
    }

    // Check collectible package collection
    for (let i = GAME.collectibles.length - 1; i >= 0; i--) {
        const col = GAME.collectibles[i];
        if (Math.hypot(col.x - p.x, col.y - p.y) < 16) {
            AudioSys.sfx.pop();
            GAME.collectibles.splice(i, 1);
            GAME.score += 100;
            spawnFloatingText(col.x, col.y - 10, "+100", "#ffd700");
        }
    }

    // Update forklifts
    GAME.forklifts.forEach(fl => {
        fl.x += fl.speed;
        if (fl.speed > 0 && fl.x > 256) fl.x = -fl.w;
        if (fl.speed < 0 && fl.x < -fl.w) fl.x = 256;

        // Check collision with player
        if (p.iframe === 0 &&
            p.x < fl.x + fl.w && p.x + 16 > fl.x &&
            p.y < fl.y + fl.h && p.y + 16 > fl.y) {
            p.iframe = 90;
            GAME.lives--;
            updateHud();
            AudioSys.sfx.hurt();
            GAME.shake = 15;
            GAME.flash = 12;
            p.x = 128;
            p.y = 200;
            spawnFloatingText(p.x, p.y - 20, "FORKLIFT!", "#fbbf24");
            if (GAME.lives <= 0) {
                triggerGameOver("RUN OVER BY FORKLIFT!");
            }
        }
    });
}

function update() {
    GAME.ticks++;
    GAME.stateTimer++;
    if (GAME.shake > 0) GAME.shake--;
    if (GAME.flash > 0) GAME.flash--;

    if (GAME.state === 'LOSE_SPLASH' || GAME.state === 'WIN_SPLASH') {
        GAME.splashTimer--;
        const isWin = GAME.state === 'WIN_SPLASH';
        const ready = GAME.aiResultText !== null;
        const waitedEnough = GAME.splashTimer <= 0;
        const fallbackTimer = -600;

        // No phase system needed anymore - go straight to dialog like WIN_SPLASH

        if (ready && waitedEnough) {
            let finalText = GAME.aiResultText.replace(/\[.*?\]/g, GAME.selectedChar);
            if (isWin) {
                // Use intro dialog with HAPPY Simon
                showPerformanceEvalIntroDialog(`OUTSTANDING!\n${finalText}`, true);
                // nextState already set in winGame() to NAME_ENTRY
            } else {
                // Use intro dialog with DISAPPOINTED Simon
                showPerformanceEvalIntroDialog(finalText, false);
                GAME.nextState = 'GAMEOVER_SPLASH';
            }
        } else if (!ready && GAME.splashTimer <= fallbackTimer) {
            GAME.aiResultText = 'System could not load live review. Using cached performance log.';
        }
        return;
    }

    // Name entry and highscore screens - just animate, input handled by keydown
    if (GAME.state === 'NAME_ENTRY' || GAME.state === 'HIGHSCORES') {
        return;
    }

    if (GAME.state === 'LOGO' && GAME.stateTimer > 420) advanceState();

    // Region selection navigation in PRESS_START screen (up/down)
    if (GAME.state === 'PRESS_START') {
        let changed = false;
        if (KEYS.up && GAME.ticks % 10 === 0) { GAME.regionIndex--; AudioSys.sfx.step(); changed = true; }
        if (KEYS.down && GAME.ticks % 10 === 0) { GAME.regionIndex++; AudioSys.sfx.step(); changed = true; }
        if (changed) {
            if (GAME.regionIndex < 0) GAME.regionIndex = GAME.regionList.length - 1;
            if (GAME.regionIndex >= GAME.regionList.length) GAME.regionIndex = 0;
        }
        return;
    }

    if (GAME.state === 'TITLE') {
        return;
    }

    if (GAME.state === 'HOWTO') {
        return;
    }

    if (GAME.state === 'SELECT') {
        let changed = false;
        if (KEYS.left && GAME.ticks % 10 === 0) { GAME.charIndex--; AudioSys.sfx.step(); changed = true; }
        if (KEYS.right && GAME.ticks % 10 === 0) { GAME.charIndex++; AudioSys.sfx.step(); changed = true; }
        if (changed) {
            if (GAME.charIndex < 0) GAME.charIndex = GAME.charList.length - 1;
            if (GAME.charIndex >= GAME.charList.length) GAME.charIndex = 0;
            speakTTS(GAME.charList[GAME.charIndex], "System");
        }
        return;
    }

    if (GAME.state === 'DIALOG') {
        // Update press-space-hint - show UP option when hazard detail available
        const hintEl = document.getElementById('press-space-hint');
        if (GAME.hasHazardDetail && GAME.dialogVisible.length >= GAME.dialogText.length) {
            // Show both options when dialog is fully typed and detail is available
            hintEl.innerHTML = '<span style="color:#00ff00">‚ñ≤ DETAIL</span> | <span style="color:#ffd700">‚ñº CONTINUE</span>';
        } else {
            hintEl.innerText = '‚ñº TAP / SPACE';
        }
        hintEl.style.color = '#ffd700';
        hintEl.style.animation = 'blink 0.8s ease-in-out infinite';

        if (GAME.dialogVisible.length < GAME.dialogText.length) {
            if (GAME.ticks % 2 === 0) {
                GAME.dialogVisible += GAME.dialogText[GAME.dialogVisible.length];
                // Update whichever window is visible
                const regularContent = document.getElementById('text-content');
                const introContent = document.getElementById('intro-text-content');
                if (document.getElementById('intro-portrait-window').style.display === 'block') {
                    introContent.innerText = GAME.dialogVisible;
                } else {
                    regularContent.innerText = GAME.dialogVisible;
                }
                AudioSys.sfx.text();
            }
        }
        return;
    }

    // Hazard Detail Modal - handle scroll with up/down keys
    if (GAME.state === 'HAZARD_DETAIL_MODAL' && GAME.hazardModal && !GAME.hazardModal.loading) {
        if (KEYS.up && GAME.ticks % 8 === 0 && GAME.hazardModal.scrollOffset > 0) {
            GAME.hazardModal.scrollOffset--;
            AudioSys.sfx.step();
        }
        if (KEYS.down && GAME.ticks % 8 === 0 && GAME.hazardModal.scrollOffset < GAME.hazardModal.maxScroll) {
            GAME.hazardModal.scrollOffset++;
            AudioSys.sfx.step();
        }
        return;
    }

    // PPE Dialog - handle menu selection
    if (GAME.state === 'PPE_DIALOG') {
        if ((KEYS.up || KEYS.down) && GAME.ticks % 10 === 0) {
            GAME.ppeDialogChoice = GAME.ppeDialogChoice === 0 ? 1 : 0;
            AudioSys.sfx.step();
        }
        return;
    }

    // PPE Shop - handle navigation and message timer
    if (GAME.state === 'PPE_SHOP') {
        // Navigate up/down
        if (KEYS.up && GAME.ticks % 10 === 0) {
            GAME.ppeShopIndex = Math.max(0, GAME.ppeShopIndex - 1);
            AudioSys.sfx.step();
        }
        if (KEYS.down && GAME.ticks % 10 === 0) {
            GAME.ppeShopIndex = Math.min(PPE_ITEMS.length - 1, GAME.ppeShopIndex + 1);
            AudioSys.sfx.step();
        }
        // Decrement message timer
        if (GAME.shopMessageTimer > 0) GAME.shopMessageTimer--;
        return;
    }

    // Phase 3: Health Bar Animation during Simon transformation
    if (GAME.state === 'SIMON_MECHA_TRANSFORM') {
        // Animate health bar from 0% to 100% over 120 frames (~2 seconds at 60fps)
        const animDuration = 120;
        if (GAME.stateTimer <= animDuration) {
            // Smooth easing animation (ease-in-out)
            const t = GAME.stateTimer / animDuration;
            const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            GAME.healthBarAnimProgress = eased;
            GAME.boss.hp = Math.floor(eased * 999);
            updateBossHud();

            // Continuous particle effects during animation
            if (GAME.ticks % 3 === 0) {
                spawnParticle(
                    GAME.boss.x + 16 + (Math.random() - 0.5) * 20,
                    GAME.boss.y + 16 + (Math.random() - 0.5) * 20,
                    Math.random() > 0.5 ? '#eab308' : '#dc2626',
                    -1 - Math.random() * 2
                );
            }

            // Continuous screen shake
            if (GAME.shake < 5) GAME.shake = 5;
        }
        return;
    }

    if (['LOGO', 'INTRO', 'STORY', 'TITLE', 'HOWTO', 'BOSS_INTRO', 'VISITOR_SPLASH', 'BEZOS_INTRO', 'MECHA_TRANSFORM', 'MECHA_SIMON_SPLASH', 'BEZOS_ESCAPE', 'BEZOS_ESCAPE_MECHA_LINE', 'BEZOS_ESCAPE_JEFF_LINE', 'BEZOS_ESCAPE_DIALOGUE', 'SIMON_FAKE_VICTORY', 'HAZARD_DETAIL_MODAL', 'PPE_DIALOG', 'PPE_SHOP'].includes(GAME.state)) return;

    // Bezos victory screen - transition to highscore entry
    if (GAME.state === 'BEZOS_WIN') {
        // Auto-advance to NAME_ENTRY for highscore after delay
        if (GAME.stateTimer > 300) {
            GAME.state = 'NAME_ENTRY';
            GAME.stateTimer = 0;
            nameEntryCharIndex = 0;
        }
        return;
    }

    if (GAME.state === 'PLAY' || GAME.state === 'BOSS' || GAME.state === 'BEZOS_BOSS') {
        updatePlayer(); updateProjectiles(); updateParticles(); updateFloatingTexts(); updateFootprints();
        updateCamera();
        // Update HUD every second to keep score current (time penalty updates)
        if (GAME.ticks % 60 === 0) updateHud();
    }

    if (GAME.state === 'PLAY') {
        updateEntities();
        updateWarehouseAtmosphere(); // Update warehouse atmosphere (packages, kivas, cart workers)
        updateWarehouseEvent(); // Update random warehouse event system
    }
    if (GAME.state === 'BOSS') updateBoss();
    if (GAME.state === 'BEZOS_BOSS') updateMechaBezos();

    // Yard level and Mecha boss updates
    if (GAME.state === 'YARD_LEVEL') updateYardLevel();
    if (GAME.state === 'MECHA_BOSS') {
        updateMechaBattle();
        // Update HUD every second to keep score current
        if (GAME.ticks % 60 === 0) updateHud();
    }

    // Boss defeat cutscene update
    if (GAME.state === 'BOSS_DEFEAT_CUTSCENE') {
        updateDefeatCutscene();
        updateParticles();
    }
}

function updatePlayer() {
    const p = GAME.player;
    // Guard against undefined player state
    if (!p) return;
    if (p.iframe>0) p.iframe--; if (p.cooldown>0) p.cooldown--;

    // === PPE BUFF: Regeneration (Hydration Pouch + Quantum Vest) ===
    // Get the fastest regen timer from all owned items (lower value = faster regen)
    if (hasPPEBuff('regen')) {
        let fastestRegen = Infinity;
        PPE_ITEMS.forEach(item => {
            if (!GAME.ppeUnlocked.includes(item.id) || !item.buff) return;
            if (item.buff.type === 'regen') fastestRegen = Math.min(fastestRegen, item.buff.value);
            if (item.buff.type === 'multi' && item.buff.effects) {
                item.buff.effects.forEach(e => {
                    if (e.type === 'regen') fastestRegen = Math.min(fastestRegen, e.value);
                });
            }
        });

        GAME.regenTimer = (GAME.regenTimer || 0) + 1;
        if (GAME.regenTimer >= fastestRegen) {
            GAME.regenTimer = 0;
            const stats = getCharStats(GAME.selectedChar);
            const maxHp = stats.lives + getPPEBuffValue('maxhp');
            if (GAME.lives < maxHp) {
                GAME.lives++;
                updateHud();
                spawnFloatingText(p.x, p.y - 20, "+1 HP", "#22c55e");
                AudioSys.sfx.fix();
            }
        }
    }

    // === PPE BUFF: Speed bonuses (Safety Shoes + Exoskeleton) ===
    let speedMod = 1.0 + getPPEBuffValue('speed');

    let dx=0, dy=0;
    const effectiveSpeed = p.speed * speedMod;
    if (KEYS.up) dy = -effectiveSpeed; if (KEYS.down) dy = effectiveSpeed;
    if (KEYS.left) dx = -effectiveSpeed; if (KEYS.right) dx = effectiveSpeed;
    if (dx!==0 && dy!==0) { dx *= GAME_CONSTANTS.DIAGONAL_FACTOR; dy *= GAME_CONSTANTS.DIAGONAL_FACTOR; }
    if (dx!==0 || dy!==0) {
        // In Bezos boss mode, no collision detection with walls
        if (GAME.state === 'BEZOS_BOSS') {
            p.x = Math.max(0, Math.min(240, p.x + dx));
            p.y = Math.max(0, Math.min(208, p.y + dy));
        } else {
            if (!checkCol(p.x+dx, p.y)) p.x+=dx;
            if (!checkCol(p.x, p.y+dy)) p.y+=dy;
        }
        if (GAME.ticks % 20 === 0) {
            AudioSys.sfx.step();
            spawnParticle(p.x+8, p.y+16, '#555', 0);
        }
        // Add footprints/tire marks (NOT for Erwin - he's in a car!)
        if (GAME.ticks % 12 === 0 && GAME.selectedChar !== 'Erwin') {
            spawnFootprint(p.x + 8, p.y + 15);
        }
    }
}

// Spawn footprint/trail mark
function spawnFootprint(x, y) {
    // Limit footprint count for performance
    if (GAME.footprints.length > 80) GAME.footprints.shift();
    GAME.footprints.push({
        x: x,
        y: y,
        life: 180, // 3 seconds at 60fps
        maxLife: 180
    });
}

// Update footprints (fade over time)
function updateFootprints() {
    for (let i = GAME.footprints.length - 1; i >= 0; i--) {
        GAME.footprints[i].life--;
        if (GAME.footprints[i].life <= 0) {
            GAME.footprints.splice(i, 1);
        }
    }
}

// Draw footprints on the ground
function drawFootprints() {
    for (const fp of GAME.footprints) {
        const alpha = Math.max(0, fp.life / fp.maxLife) * 0.5;
        ctx.fillStyle = `rgba(40, 40, 40, ${alpha})`;
        // Draw as small shoe prints
        ctx.fillRect(fp.x - 2, fp.y, 2, 3);
        ctx.fillRect(fp.x + 1, fp.y, 2, 3);
    }
}

function updateYardLevel() {
    if (!GAME.yard) return;
    const y = GAME.yard;
    GAME.player.x = y.playerX; GAME.player.y = y.playerY;

    // Decrement invincibility frames (fixes permanent invincibility bug)
    if (GAME.player.iframe > 0) GAME.player.iframe--;

    // Check if player is in castle section
    const inCastle = y.playerY < y.castleStart;
    if (inCastle && !y.inCastle) {
        y.inCastle = true;
        if (!y.castleEntered) {
            y.castleEntered = true;
        }
    }

    // Update Jeff animation frame
    y.jeffAnimFrame++;

    // Track when entering the dangerous hallway section
    if (y.playerY < y.castleStart && !y.hallwayEntered) {
        y.hallwayEntered = true;
        y.inHallway = true;
    }

    let dx = 0, dy = 0;
    if (KEYS.up) dy = -y.speed; if (KEYS.down) dy = y.speed; if (KEYS.left) dx = -y.speed; if (KEYS.right) dx = y.speed;
    if (dx!==0 && dy!==0) { dx *= GAME_CONSTANTS.DIAGONAL_FACTOR; dy *= GAME_CONSTANTS.DIAGONAL_FACTOR; }

    // Check for static hazard slowdown (puddles slow you down) - only in yard section
    let inHazard = false;
    if (y.staticHazards && !y.inCastle) {
        y.staticHazards.forEach(h => {
            if (Math.abs(y.playerX - h.x) < 20 && Math.abs(y.playerY - h.y) < 20) {
                if (h.type === 'puddle') {
                    dx *= 0.5; dy *= 0.5; // Slow down in puddles
                    inHazard = true;
                }
            }
        });
    }

    y.playerX = Math.max(0, Math.min(canvas.width - 16, y.playerX + dx));
    y.playerY = Math.max(10, Math.min(y.height - 22, y.playerY + dy));
    GAME.player.x = y.playerX; GAME.player.y = y.playerY;

    const viewAnchor = y.playerY - canvas.height * 0.55;
    y.cameraY = Math.max(0, Math.min(y.height - canvas.height, viewAnchor));

    // === YARD SECTION UPDATES (only when in yard) ===
    if (!y.inCastle) {
        // Spawn vehicles in lanes with varied types
        y.lanes.forEach(lane => {
            lane.timer--;
            if (lane.timer <= 0) {
                let type;
                if (lane.type === 'truck') type = 'truck';
                else if (lane.type === 'van') type = 'van';
                else type = Math.random() < 0.55 ? 'van' : 'truck';

                const w = type === 'van' ? 34 : 52;
                const h = type === 'van' ? 16 : 20;
                const x = lane.dir === 1 ? -w : canvas.width + w;
                y.vehicles.push({ type, x, y: lane.y - h/2, w, h, dir: lane.dir, speed: lane.speed + Math.random()*0.25 });
                lane.timer = 50 + Math.random() * 60;
            }
        });

        // Update forklift zones
        if (y.forkliftZones) {
            y.forkliftZones.forEach(zone => {
                zone.timer--;
                if (zone.timer <= 0) {
                    zone.active = !zone.active;
                    zone.timer = zone.active ? 60 : (150 + Math.random() * 100);
                    if (zone.active && Math.abs(y.playerY - zone.y) < 100) {
                        // Spawn a forklift
                        const dir = Math.random() < 0.5 ? 1 : -1;
                        y.forklifts.push({
                            x: dir === 1 ? -30 : canvas.width + 30,
                            y: zone.y - 10,
                            dir: dir,
                            speed: 1.5 + Math.random() * 0.5,
                            w: 28, h: 20
                        });
                        AudioSys.sfx.alert();
                    }
                }
            });
        }
    }

    // Update forklifts (can still be on screen when transitioning)
    for (let i = y.forklifts.length - 1; i >= 0; i--) {
        const f = y.forklifts[i];
        f.x += f.dir * f.speed;
        if (f.x < -60 || f.x > canvas.width + 60) { y.forklifts.splice(i, 1); continue; }
        // Forklift collision - Roman's PHANTOM STEP reduces collision hitbox
        const romanMod = GAME.selectedChar === 'Roman' ? 0.6 : 1.0;
        if (Math.abs((f.x + f.w/2) - (y.playerX + 8)) < (f.w/2 + 4) * romanMod && Math.abs((f.y + f.h/2) - (y.playerY + 8)) < (f.h/2 + 4) * romanMod) {
            if (GAME.player.iframe <= 0) {
                GAME.lives--; GAME.flash = 15; GAME.shake = 20; AudioSys.sfx.hurt(); updateHud();
                VibrationSystem.onHeavyDamage(); // Heavy damage vibration for forklift
                // SCORING: -400 penalty for forklift hit
                GAME.score = (GAME.score || 0) - 400;
                y.vehicleHitPenalty = (y.vehicleHitPenalty || 0) + 400;
                spawnFloatingText(f.x, f.y - 10, "-400", "#ef4444");
                // Teleport to start - no iframe needed since player is repositioned
                y.playerX = canvas.width / 2 - 8;
                y.playerY = y.startY;
                y.inCastle = false;
                y.cameraY = Math.max(0, y.height - canvas.height);
                spawnFloatingText(y.playerX, y.playerY - 20, "FORKLIFT! NO PEDESTRIANS!", "#ff4444");
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('FORKLIFT INCIDENT!'); return; }
            }
        }
    }

    // Vehicle collision - FULL RESET to starting position
    for (let i = y.vehicles.length - 1; i >= 0; i--) {
        const v = y.vehicles[i];
        v.x += v.dir * v.speed;
        if (v.x < -80 || v.x > canvas.width + 80) { y.vehicles.splice(i,1); continue; }
        // Roman's PHANTOM STEP reduces collision hitbox
        const romanModV = GAME.selectedChar === 'Roman' ? 0.6 : 1.0;
        if (Math.abs((v.x + v.w/2) - (y.playerX + 8)) < (v.w/2 + 5) * romanModV && Math.abs((v.y + v.h/2) - (y.playerY + 8)) < (v.h/2 + 5) * romanModV) {
            if (GAME.player.iframe <= 0) {
                GAME.lives--; GAME.flash = 12; GAME.shake = 15; AudioSys.sfx.hurt(); updateHud();
                VibrationSystem.onHeavyDamage(); // Heavy damage vibration for vehicle
                // SCORING: -300 penalty for vehicle hit
                const penalty = v.type === 'truck' ? 350 : 300;
                GAME.score = (GAME.score || 0) - penalty;
                y.vehicleHitPenalty = (y.vehicleHitPenalty || 0) + penalty;
                spawnFloatingText(v.x + v.w/2, v.y - 10, "-" + penalty, "#ef4444");
                // FULL RESET - player goes back to starting position, no iframe since teleporting
                y.playerX = canvas.width / 2 - 8;
                y.playerY = y.startY;
                y.inCastle = false;
                y.cameraY = Math.max(0, y.height - canvas.height);
                spawnFloatingText(y.playerX, y.playerY - 20, "WATCH THE TRAFFIC!", "#ff4444");
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('FLATTENED BY LOGISTICS!'); return; }
            }
        }
    }

    // === UPDATE YARD PACKAGE COLLECTIBLES ===
    if (y.yardPackages && !y.inCastle) {
        // Update package animations
        y.yardPackages.forEach(pkg => {
            if (!pkg.collected) {
                pkg.bobTimer += 0.1;
                pkg.glowTimer += 0.08;
            }
        });

        // Check player collection
        for (let i = y.yardPackages.length - 1; i >= 0; i--) {
            const pkg = y.yardPackages[i];
            if (!pkg.collected && Math.abs(pkg.x - y.playerX) < 18 && Math.abs(pkg.y - y.playerY) < 18) {
                pkg.collected = true;
                const points = pkg.type === 'prime' ? 100 : 50; // Prime packages worth more
                GAME.score = (GAME.score || 0) + points;
                AudioSys.sfx.fix();
                // Show points above PLAYER'S head (screen position, accounting for camera)
                const screenPlayerY = y.playerY - y.cameraY;
                spawnFloatingText(y.playerX + 8, screenPlayerY - 24, "+" + points, pkg.type === 'prime' ? "#ff9900" : "#22c55e");
                spawnParticleBurst(pkg.x + 7, pkg.y + 7, ['#ff9900', '#fbbf24', '#fff'], 8);
                // Remove collected package
                y.yardPackages.splice(i, 1);
            }
        }

        // Spawn new packages periodically
        y.packageSpawnTimer = (y.packageSpawnTimer || 0) + 1;
        if (y.packageSpawnTimer > 300 && y.yardPackages.length < 6) { // Every ~5 seconds
            y.packageSpawnTimer = 0;
            const laneIndex = Math.floor(Math.random() * y.lanes.length);
            const lane = y.lanes[laneIndex];
            // Only spawn if player is nearby (within view)
            if (Math.abs(y.playerY - lane.y) < canvas.height) {
                y.yardPackages.push({
                    x: 30 + Math.random() * (canvas.width - 60),
                    y: lane.y - 5 + Math.random() * 10,
                    collected: false,
                    bobTimer: 0,
                    glowTimer: 0,
                    type: Math.random() < 0.25 ? 'prime' : 'standard'
                });
            }
        }
    }

    // === UPDATE DOCK WORKERS WITH CHIT-CHAT ===
    if (y.dockWorkers && !y.inCastle) {
        // Dock worker phrases (warehouse themed)
        const DOCK_BANTER = [
            "Heavy load...", "Where's that pallet?", "Scan scan scan!",
            "Truck's late!", "VTO anyone?", "My back...", "Box heavy!",
            "Lane's blocked!", "Watch the fork!", "Break soon?",
            "Prime day prep!", "So many boxes...", "Scanner dying...",
            "Safety first!", "Wrong dock!", "Where's my vest?",
            "Coffee break?", "Long shift...", "More trucks?!"
        ];

        y.dockWorkers.forEach(worker => {
            // Update banter timer
            if (worker.banterLife > 0) {
                worker.banterLife--;
                if (worker.banterLife <= 0) {
                    worker.banterText = null;
                }
            }

            // Random chance to speak (like warehouse entities)
            worker.banterTimer = (worker.banterTimer || 0) + 1;
            if (worker.banterTimer > 300 && Math.random() < 0.003 && !worker.banterText) {
                worker.banterTimer = 0;
                worker.banterText = DOCK_BANTER[Math.floor(Math.random() * DOCK_BANTER.length)];
                worker.banterLife = 180; // Show for 3 seconds
            }

            // Movement
            if (worker.pauseTimer > 0) {
                worker.pauseTimer--;
                return;
            }
            worker.x += worker.dir * 0.3;
            if (Math.random() < 0.01) worker.pauseTimer = 30 + Math.random() * 60;
            if (worker.x < 30 || worker.x > canvas.width - 30) {
                worker.dir *= -1;
                worker.pauseTimer = 20;
            }
        });
    }

    // === UPDATE YARD BIRDS (3D atmosphere effect) ===
    if (!y.inCastle) {
        // Spawn birds occasionally
        y.birdSpawnTimer = (y.birdSpawnTimer || 0) + 1;
        if (y.birdSpawnTimer > 180 && Math.random() < 0.02 && (y.birds || []).length < 5) {
            y.birdSpawnTimer = 0;
            const fromLeft = Math.random() < 0.5;
            if (!y.birds) y.birds = [];
            y.birds.push({
                x: fromLeft ? -20 : canvas.width + 20,
                y: y.cameraY + 30 + Math.random() * 60, // Near top of visible area
                vx: fromLeft ? (1.5 + Math.random() * 1.5) : -(1.5 + Math.random() * 1.5),
                vy: (Math.random() - 0.5) * 0.3,
                wingPhase: Math.random() * Math.PI * 2,
                scale: 0.6 + Math.random() * 0.4, // Size variation for depth
                shadow: true
            });
        }

        // Update birds
        if (y.birds) {
            for (let i = y.birds.length - 1; i >= 0; i--) {
                const bird = y.birds[i];
                bird.x += bird.vx;
                bird.y += bird.vy;
                bird.wingPhase += 0.3;

                // Slight vertical wobble
                bird.vy += (Math.random() - 0.5) * 0.05;
                bird.vy = Math.max(-0.5, Math.min(0.5, bird.vy));

                // Remove when off screen
                if (bird.x < -40 || bird.x > canvas.width + 40) {
                    y.birds.splice(i, 1);
                }
            }
        }
    }

    // === CASTLE SECTION UPDATES ===
    if (y.inCastle) {
        // Update castle moving platforms
        if (y.castlePlatforms) {
            y.castlePlatforms.forEach(p => {
                p.x += p.dir * p.speed;
                if (p.x <= 0 || p.x + p.w >= canvas.width) {
                    p.dir *= -1;
                }
            });
        }

        // Update hallway laser barriers (only in hallway section, NOT in throne room)
        // Throne room is Y < hallwayStart - safe zone with no hazards
        const hallwayBoundary = y.hallwayStart;

        // Trigger security activation message when first approaching laser barrier zone
        if (y.castleLaserBarriers && !y.firstLaserTriggered && y.playerY >= hallwayBoundary) {
            // Find the first laser barrier (highest Y value - first one player encounters from yard)
            const firstBarrierY = Math.max(...y.castleLaserBarriers.map(b => b.y));
            // Trigger when player gets within 60 pixels of the first barrier
            if (y.playerY <= firstBarrierY + 60) {
                y.firstLaserTriggered = true;
                y.securityActivationTimer = 180; // Show for 3 seconds
                AudioSys.sfx.alert();
                GAME.flash = 8;
            }
        }

        if (y.castleLaserBarriers && y.playerY >= hallwayBoundary) {
            y.castleLaserBarriers.forEach(barrier => {
                barrier.timer++;
                if (barrier.active && barrier.timer >= barrier.onTime) {
                    barrier.active = false;
                    barrier.timer = 0;
                } else if (!barrier.active && barrier.timer >= barrier.offTime) {
                    barrier.active = true;
                    barrier.timer = 0;
                    AudioSys.sfx.alert();
                }

                // Collision with active laser barrier
                if (barrier.active && Math.abs(y.playerY - barrier.y) < 8 && GAME.player.iframe <= 0) {
                    GAME.lives--; GAME.flash = 15; GAME.shake = 12; AudioSys.sfx.hurt(); updateHud();
                    GAME.player.iframe = 120; // 2 seconds of invincibility in castle
                    if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('VAPORIZED BY SECURITY!'); return; }
                }
            });
        }

        // Update hallway guard turrets (only in hallway section)
        if (y.castleGuards && y.playerY >= hallwayBoundary) {
            y.castleGuards.forEach(guard => {
                guard.fireTimer++;
                // Fire if player is within vertical range and in hallway
                if (guard.fireTimer >= guard.fireRate && Math.abs(y.playerY - guard.y) < 150) {
                    guard.fireTimer = 0;
                    // Fire projectile toward player
                    const dirX = guard.x < canvas.width / 2 ? 1 : -1;
                    if (!y.castleProjectiles) y.castleProjectiles = [];
                    y.castleProjectiles.push({
                        x: guard.x + 8,
                        y: guard.y + 6,
                        vx: dirX * 2.5,
                        vy: 0,
                        life: 120
                    });
                    AudioSys.sfx.throw();
                }
            });
        }

        // Update hallway projectiles
        if (y.castleProjectiles) {
            for (let i = y.castleProjectiles.length - 1; i >= 0; i--) {
                const proj = y.castleProjectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.life--;

                if (proj.life <= 0 || proj.x < -20 || proj.x > canvas.width + 20) {
                    y.castleProjectiles.splice(i, 1);
                    continue;
                }

                // Collision with player (only in hallway)
                if (y.playerY >= hallwayBoundary && Math.abs(proj.x - (y.playerX + 8)) < 12 && Math.abs(proj.y - (y.playerY + 8)) < 12) {
                    if (GAME.player.iframe <= 0) {
                        GAME.lives--; GAME.flash = 10; GAME.shake = 8; AudioSys.sfx.hurt(); updateHud();
                        GAME.player.iframe = 120; // 2 seconds of invincibility in castle
                        y.castleProjectiles.splice(i, 1);
                        if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('TERMINATED BY SECURITY!'); return; }
                    }
                }
            }
        }

        // Spawn patrol drones periodically (only in hallway section)
        y.droneSpawnTimer++;
        if (y.droneSpawnTimer > 180 && y.castleDrones.length < 4 && y.playerY >= hallwayBoundary) {
            y.droneSpawnTimer = 0;
            // Spawn drones within the hallway section only
            const droneY = hallwayBoundary + 50 + Math.random() * 350;
            y.castleDrones.push({
                x: Math.random() < 0.5 ? -20 : canvas.width + 20,
                y: droneY,
                dir: Math.random() < 0.5 ? 1 : -1,
                speed: 1.2 + Math.random() * 0.5,
                pulseTimer: 0
            });
        }

        // Clear all hazards when player enters throne room (peaceful confrontation zone)
        if (y.playerY < hallwayBoundary) {
            y.castleDrones = [];
            if (y.castleProjectiles) y.castleProjectiles = [];
        }

        // Update patrol drones (only when player is in hallway)
        if (y.playerY >= hallwayBoundary) {
            for (let i = y.castleDrones.length - 1; i >= 0; i--) {
                const drone = y.castleDrones[i];
                drone.x += drone.dir * drone.speed;
                drone.pulseTimer++;

                // Slight homing toward player Y (but stay in hallway)
                if (Math.abs(drone.y - y.playerY) > 30) {
                    const newY = drone.y + (y.playerY > drone.y ? 0.3 : -0.3);
                    if (newY >= hallwayBoundary) drone.y = newY;
                }

                // Remove if off screen
                if ((drone.dir === 1 && drone.x > canvas.width + 40) || (drone.dir === -1 && drone.x < -40)) {
                    y.castleDrones.splice(i, 1);
                    continue;
                }

                // Collision with player
                if (Math.abs(drone.x - (y.playerX + 8)) < 14 && Math.abs(drone.y - (y.playerY + 8)) < 14) {
                    if (GAME.player.iframe <= 0) {
                        GAME.lives--; GAME.flash = 12; GAME.shake = 10; AudioSys.sfx.hurt(); updateHud();
                        GAME.player.iframe = 120; // 2 seconds of invincibility in castle
                        y.castleDrones.splice(i, 1);
                        if (GAME.lives <= 0 && !GAME.gameOverTriggered) { triggerGameOver('DRONE STRIKE!'); return; }
                    }
                }
            }
        }

    }

    // Trigger THRONE CONFRONTATION CUTSCENE when player enters throne room (Y < hallwayStart)
    // Player approaches Jeff who is sitting on the throne - dialogue begins
    if (y.playerY <= y.hallwayStart && !y.transformationTriggered) {
        y.transformationTriggered = true;
        GAME.state = 'THRONE_CONFRONTATION';
        GAME.stateTimer = 0;
        GAME.throneScene = {
            phase: 0 // 0=zoom in visual, 1=AI dialogue via showDialog
        };
        AudioSys.sfx.bossIntro();
        return;
    }
}

function updateMechaBattle() {
    const m = GAME.mecha; if (!m) return;
    const p = GAME.player;
    if (p.iframe>0) p.iframe--; if (p.cooldown>0) p.cooldown--;

    // Player movement
    let dx = 0, dy = 0;
    if (KEYS.up) dy = -p.speed; if (KEYS.down) dy = p.speed; if (KEYS.left) dx = -p.speed; if (KEYS.right) dx = p.speed;
    if (dx!==0 && dy!==0) { dx *= GAME_CONSTANTS.DIAGONAL_FACTOR; dy *= GAME_CONSTANTS.DIAGONAL_FACTOR; }
    p.x = Math.max(4, Math.min(canvas.width - 20, p.x + dx));
    p.y = Math.max(40, Math.min(canvas.height - 20, p.y + dy));

    m.timer++;
    m.bobOffset = Math.sin(m.timer * 0.05) * 3;
    if (m.attackCooldown > 0) m.attackCooldown--;

    // Enrage mode at low HP
    if (m.hp <= 12 && !m.enraged) {
        m.enraged = true;
        m.phaseDuration = 200; // Faster phases
        GAME.shake = 20;
        // Attack message overlay removed to reduce screen clutter
        AudioSys.sfx.bossIntro();
        MusicSys.play('enraged', 1.0);
    }
    if (m.enraged) m.enrageFlash = (m.enrageFlash + 1) % 20;

    // Phase transition handling
    if (m.phaseTransition) {
        m.transitionTimer++;
        if (m.transitionTimer >= 60) {
            m.phaseTransition = false;
            m.transitionTimer = 0;
            m.phaseTimer = 0;
            // Phase warnings removed - attack overlays cluttered the screen
            // Visual feedback now provided via phase transition overlay only
        }
        return; // Pause attacks during transition
    }

    m.phaseTimer++;

    // Boss movement - sway side to side
    m.moveTimer++;
    if (m.moveTimer > 60) {
        m.moveTimer = 0;
        m.moveDir *= -1;
    }
    if (!m.slamming && !m.dashing) {
        const targetX = canvas.width / 2 - 32 + m.moveDir * 60;
        m.x += (targetX - m.x) * 0.02;
        m.y = m.baseY + m.bobOffset;
    }

    // Phase-specific attack patterns
    const attackRate = m.enraged ? 0.7 : 1.0;

    // Initialize attack announcement tracking
    if (!m.lastAnnounce) m.lastAnnounce = { phase: -1, timer: 0 };

    // PHASE 0: Prime Missiles - Homing missiles from shoulders
    if (m.currentPhase === 0) {
        if (m.timer % Math.floor(70 * attackRate) === 0 && m.attackCooldown <= 0) {
            const angle = Math.atan2(p.y - m.y, p.x - m.x);
            for (let i = -1; i <= 1; i += 2) {
                m.projectiles.push({
                    type: 'missile',
                    x: m.x + 32 + i * 24,
                    y: m.y + 20,
                    vx: Math.cos(angle + i * 0.3) * 1.5,
                    vy: Math.sin(angle + i * 0.3) * 1.5,
                    life: 180,
                    trail: []
                });
            }
            AudioSys.sfx.throw();
        }
    }

    // PHASE 1: Drone Swarm - Multiple homing drones
    if (m.currentPhase === 1) {
        const activeDrones = m.projectiles.filter(pr => pr.type === 'drone').length;
        if (m.timer % Math.floor(50 * attackRate) === 0 && activeDrones < (m.enraged ? 5 : 3)) {
            m.projectiles.push({
                type: 'drone',
                x: m.x + 32 + (Math.random() - 0.5) * 40,
                y: m.y + 24,
                vx: 0, vy: 0.3,
                life: 400,
                pulseTimer: 0
            });
            AudioSys.sfx.pop();
        }
    }

    // PHASE 2: Package Rain - Boxes rain from above with shadows
    if (m.currentPhase === 2) {
        if (m.timer % Math.floor(35 * attackRate) === 0) {
            const targetX = p.x + (Math.random() - 0.5) * 80;
            m.shadows.push({ x: Math.max(10, Math.min(canvas.width - 30, targetX)), timer: 45 });
        }
    }

    // PHASE 3: Laser Grid - Multiple sweeping beams
    if (m.currentPhase === 3) {
        if (m.timer % Math.floor(100 * attackRate) === 0 && m.beams.length < 3) {
            const beamCount = m.enraged ? 3 : 2;
            for (let i = 0; i < beamCount; i++) {
                m.beams.push({
                    x: (canvas.width / (beamCount + 1)) * (i + 1) - 7,
                    telegraph: 50,
                    active: 35,
                    sweepDir: i % 2 === 0 ? 1 : -1,
                    sweepSpeed: 0.8
                });
            }
            AudioSys.sfx.alert();
        }
    }

    // PHASE 4: Ground Slam - Boss slams down and creates shockwave
    if (m.currentPhase === 4) {
        if (!m.slamming && m.timer % Math.floor(120 * attackRate) === 0) {
            m.slamming = true;
            m.slamTimer = 0;
            m.slamY = m.y;
            AudioSys.sfx.alert();
        }

        if (m.slamming) {
            m.slamTimer++;
            if (m.slamTimer < 30) {
                // Wind up
                m.y = m.slamY - m.slamTimer * 0.5;
            } else if (m.slamTimer < 45) {
                // Slam down
                m.y = m.slamY - 15 + (m.slamTimer - 30) * 4;
                if (m.slamTimer === 44) {
                    GAME.shake = 25;
                    AudioSys.sfx.hurt();
                    // Create shockwave
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        m.projectiles.push({
                            type: 'shockwave',
                            x: m.x + 32,
                            y: canvas.height - 20,
                            vx: Math.cos(angle) * 2.5,
                            vy: Math.sin(angle) * 0.5 - 0.5,
                            life: 80
                        });
                    }
                }
            } else if (m.slamTimer < 80) {
                // Recovery
                m.y = m.baseY + 30 - (m.slamTimer - 45) * 0.85;
            } else {
                m.slamming = false;
                m.y = m.baseY;
            }
        }
    }

    // Phase cycling
    if (m.phaseTimer >= m.phaseDuration) {
        m.currentPhase = (m.currentPhase + 1) % 5;
        m.phaseTransition = true;
        m.shadows = [];
        m.beams = [];
        m.slamming = false;
    }

    // Update projectiles
    for (let i = m.projectiles.length - 1; i >= 0; i--) {
        const pr = m.projectiles[i];

        if (pr.type === 'missile') {
            // Slight homing
            const angle = Math.atan2(p.y - pr.y, p.x - pr.x);
            pr.vx = pr.vx * 0.95 + Math.cos(angle) * 0.08;
            pr.vy = pr.vy * 0.95 + Math.sin(angle) * 0.08;
            pr.trail.push({ x: pr.x, y: pr.y });
            if (pr.trail.length > 8) pr.trail.shift();
        } else if (pr.type === 'drone') {
            pr.pulseTimer = (pr.pulseTimer || 0) + 1;
            const angle = Math.atan2(p.y - pr.y, p.x - pr.x);
            const targetVx = Math.cos(angle) * 0.5;
            const targetVy = Math.sin(angle) * 0.5;
            pr.vx = pr.vx * 0.92 + targetVx * 0.08;
            pr.vy = pr.vy * 0.92 + targetVy * 0.08;
        } else if (pr.type === 'box') {
            pr.vy += 0.06;
            pr.rotation = (pr.rotation || 0) + 0.1;
        } else if (pr.type === 'shockwave') {
            pr.vy += 0.1; // Gravity
        }

        pr.x += pr.vx || 0;
        pr.y += pr.vy || 0;
        pr.life = (pr.life || 200) - 1;

        if (pr.y > canvas.height + 40 || pr.x < -40 || pr.x > canvas.width + 40 || pr.life <= 0) {
            m.projectiles.splice(i, 1);
            continue;
        }

        // Collision with player
        const hitW = pr.type === 'shockwave' ? 8 : 10;
        const hitH = pr.type === 'shockwave' ? 6 : 10;
        if (Math.abs((pr.x + hitW/2) - (p.x + 8)) < (hitW/2 + 6) && Math.abs((pr.y + hitH/2) - (p.y + 8)) < (hitH/2 + 6)) {
            if (p.iframe <= 0) {
                GAME.lives--;
                p.iframe = 90;
                GAME.flash = 10;
                GAME.shake = 8;
                AudioSys.sfx.hurt();
                updateHud();
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) {
                    triggerGameOver('OVERWHELMED BY MECHA JEFF!');
                    return;
                }
            }
            if (pr.type !== 'shockwave') m.projectiles.splice(i, 1);
        }
    }

    // Update shadows (package warning indicators)
    for (let i = m.shadows.length - 1; i >= 0; i--) {
        m.shadows[i].timer--;
        if (m.shadows[i].timer <= 0) {
            const x = m.shadows[i].x;
            m.projectiles.push({
                type: 'box',
                x, y: -16,
                vy: 1.8,
                vx: (Math.random() - 0.5) * 0.5,
                life: 200,
                rotation: 0
            });
            m.shadows.splice(i, 1);
            AudioSys.sfx.throw();
        }
    }

    // Update beams (laser grid)
    for (let i = m.beams.length - 1; i >= 0; i--) {
        const beam = m.beams[i];
        if (beam.telegraph > 0) {
            beam.telegraph--;
        } else if (beam.active > 0) {
            beam.active--;
            beam.x += beam.sweepDir * beam.sweepSpeed;
            // Collision
            if (p.x + 12 > beam.x && p.x < beam.x + 14 && p.iframe <= 0) {
                GAME.lives--;
                p.iframe = 90;
                GAME.flash = 12;
                AudioSys.sfx.hurt();
                updateHud();
                if (GAME.lives <= 0 && !GAME.gameOverTriggered) {
                    triggerGameOver('VAPORIZED!');
                    return;
                }
            }
        } else {
            m.beams.splice(i, 1);
        }
    }

    // Player projectile hits on boss
    for (let i = GAME.projectiles.length - 1; i >= 0; i--) {
        const a = GAME.projectiles[i];
        a.x += a.vx;
        a.y += a.vy;
        a.life--;
        if (a.x < -20 || a.x > canvas.width + 20 || a.y < -20 || a.y > canvas.height + 20 || a.life <= 0) {
            GAME.projectiles.splice(i, 1);
            continue;
        }
        // Hit detection on boss
        if (Math.abs((a.x + 6) - (m.x + 32)) < 36 && Math.abs((a.y + 6) - (m.y + 32)) < 36) {
            m.hp--;
            GAME.boss.hp = m.hp;
            updateBossHud();
            GAME.projectiles.splice(i, 1);
            AudioSys.sfx.bossHit();
            // Hit text markers removed for cleaner visuals during Mecha Jeff fight

            // Spawn hit particles
            for (let j = 0; j < 4; j++) {
                spawnParticle(m.x + 32 + (Math.random() - 0.5) * 20, m.y + 32 + (Math.random() - 0.5) * 20, '#ff9900', 1);
            }

            if (m.hp <= 0) {
                // Trigger Bezos escape sequence - show Mecha Jeff's defeat one-liner first
                GAME.state = 'BEZOS_ESCAPE';
                GAME.stateTimer = 0;
                GAME.escapeScene = {
                    // New phases: 0=mecha sparks/shakes, 1=mecha one-liner, 2=mecha explodes,
                    // 3=slow transform, 4=jeff one-liner, 5=throne room + run to rocket,
                    // 6=rocket launch with camera follow, 7=escape dialogue, 8=simon joins
                    phase: 0,
                    jeffX: m.x + 32,
                    jeffY: m.y + 32,
                    startJeffX: m.x + 32,
                    startJeffY: m.y + 32,
                    rocketX: canvas.width / 2 - 32, // Center the bigger rocket
                    rocketY: canvas.height - 150,   // Adjust for bigger rocket
                    rocketVelocity: 0,              // For acceleration
                    rocketLaunched: false,
                    launchCountdown: 0,             // For countdown sequence
                    dialogueStep: 0,
                    simonJoined: false,
                    phaseTimer: 0,
                    transformProgress: 0,
                    explosionParticles: [],
                    // Camera zoom/follow system
                    cameraZoom: 1.0,
                    cameraY: 0,
                    cameraTargetY: 0,
                    followingRocket: false,
                    stars: [],                      // Stars for space background
                    inSpace: false
                };
                document.getElementById('boss-hud').style.display = 'none';
                MusicSys.stop();
                AudioSys.sfx.bossHit();
                return;
            }
        }
    }
}

// --- BANTER SYSTEM ---
function spawnFloatingText(x, y, text, color='#fff') {
    // Performance: Limit max floating texts to prevent buildup
    if (GAME.floatingTexts.length >= GAME_CONSTANTS.MAX_FLOATING_TEXTS) return;

    GAME.floatingTexts.push({
        x: x + 8, y: y,
        text: text, color: color,
        life: GAME_CONSTANTS.FLOATING_TEXT_LIFE, vy: -0.2 // Slower, longer life (3.5s)
    });
    AudioSys.sfx.pop();
}

function triggerBanter(entity) {
    if (!entity || Math.random() > 0.8) return; // Don't trigger every time
    
    const now = Date.now();
    const useAI = (now - GAME.lastAIBanterTime > 15000) && (Math.random() < 0.3); // 30% chance if cooldown over
    const category = (entity.type === 'ops') ? 'banter_ops' : 'banter_assoc';
    
    if (useAI && apiKey) {
        GAME.lastAIBanterTime = now;
        let prompt = "";
        if (entity.type === 'ops') prompt = "Short, funny bark (max 3 words) from an Amazon Warehouse Ops Manager yelling about productivity.";
        else prompt = "Short, funny thought (max 3 words) from a tired Amazon Warehouse Associate.";

        // ASYNC CALL - DOES NOT BLOCK GAME
        callGemini(prompt, category).then(text => {
            // Check if entity still alive/relevant, otherwise just spawn near player or drop
            if (GAME.entities.includes(entity)) {
                 spawnFloatingText(entity.x, entity.y, text, (entity.type==='ops'?'#ffcc00':'#ccc'));
            }
        });
    } else {
        // Hardcoded fallback
        const text = getRandomFallback(category, category);
        spawnFloatingText(entity.x, entity.y, text, (entity.type==='ops'?'#ffcc00':'#ccc'));
    }
}

function updateEntities() {
    // === FIRE DRILL EVENT: Freeze all entities ===
    if (GAME.fireDrillActive) return;

    // === PPE BUFF: Walkie-Talkie - 30% reduced ops aggro range ===
    const stealthMod = GAME.ppeUnlocked.includes('walkie_talkie') ? 0.70 : 1.0;
    const chaseRange = Math.floor(100 * stealthMod);
    const shootRange = Math.floor(80 * stealthMod);

    // === TPH RUSH EVENT: Speed multiplier for OPS ===
    const tphRushSpeedMult = (GAME.warehouseEvent && GAME.warehouseEvent.active &&
                              GAME.warehouseEvent.type.id === 'TPH_RUSH') ? 1.5 : 1.0;

    GAME.entities.forEach(e => {
        if (e.type === 'simon') return;

        // Banter Trigger (Random Chance)
        if (Math.random() < 0.002) triggerBanter(e); // Low chance per tick

        if (e.type === 'ops') {
            // Apply TPH Rush speed multiplier
            const speedMod = e.tphRush ? tphRushSpeedMult : 1.0;
            const baseSpeed = 0.4 * speedMod;
            let d = Math.hypot(GAME.player.x - e.x, GAME.player.y - e.y);
            if (d < chaseRange) {
                if (GAME.player.x > e.x) e.x += baseSpeed; else e.x -= baseSpeed;
                if (GAME.player.y > e.y) e.y += baseSpeed; else e.y -= baseSpeed;
            }
            if (d < shootRange && Math.random() < 0.01) {
                let angle = Math.atan2(GAME.player.y - e.y, GAME.player.x - e.x);
                GAME.projectiles.push({ type: 'req', x: e.x, y: e.y, vx: Math.cos(angle)*2, vy: Math.sin(angle)*2, life: 80 });
                AudioSys.sfx.alert();
            }
        }
        if (e.type === 'assoc') {
            if (Math.random() < 0.02) e.dir = Math.floor(Math.random()*4);
            let s = 0.3;
            if (e.dir===0) e.y-=s; else if(e.dir===1) e.y+=s; else if(e.dir===2) e.x-=s; else e.x+=s;
            // Slow OPS respawn - assocs slowly turn back into OPS managers (makes warehouse more challenging)
            if (Math.random() < 0.0008) {
                e.type = 'ops';
                spawnFloatingText(e.x, e.y - 10, "PROMOTED!", "#ff4444");
            }
        }
        if (e.type === 'runner') {
            if (Math.random() < 0.05) e.dir = Math.floor(Math.random()*4);
            let s = 0.8; 
            let nx = e.x, ny = e.y;
            if (e.dir===0) ny-=s; else if(e.dir===1) ny+=s; else if(e.dir===2) nx-=s; else nx+=s;
            if (!checkCol(nx, ny)) { e.x = nx; e.y = ny; } else e.dir = Math.floor(Math.random()*4); 
        }
    });
}

function updateBoss() {
    const b = GAME.boss; const p = GAME.player;
    // Guard against undefined boss or player state
    if (!b || !p) return;
    document.getElementById('boss-hud').style.display = 'block'; document.getElementById('boss-name-el').innerText = b.name; updateBossHud();

    // Mecha Mega Simon timer - triggers inevitable game over
    if (b.isMecha) {
        b.mechaTimer = (b.mechaTimer || 0) + 1;
        // After ~8 seconds (480 ticks at 60fps), trigger game over
        if (b.mechaTimer >= 480 && !GAME.gameOverTriggered) {
            GAME.mechaSimonDefeat = true; // Flag for special game over message
            triggerGameOver("COMPLIANCE ENFORCED!");
            return;
        }
        // Periodic warning messages during mecha phase
        if (b.mechaTimer === 120 || b.mechaTimer === 300) {
            spawnFloatingText(b.x + 24, b.y, "RESISTANCE IS FUTILE!", "#dc2626");
        }
    }

    let hpPct = b.hp / b.maxHp;
    if (b.tauntThresholds && b.tauntThresholds.length > 0 && hpPct < b.tauntThresholds[0]) {
         b.tauntThresholds.shift();
         const currentGen = GAME.genId;
         const langInstTaunt = getLanguageInstruction();
         let prompt = b.name === "SIMON" ? `Simon final warning. Max 25 words. ${langInstTaunt}` : `Taunt from boss ${b.name}. Max 25 words. ${langInstTaunt}`;

         // Use appropriate portrait face (48x48) for dialog
         let portrait = b.isMecha ? GFX.bossFaces.mechaMegaSimon :
                        (b.name.includes("Simon") ? GFX.simonFaceLarge :
                        (GFX.bossFaces[b.sprite] || GFX.bossFaces.boss_manager));

         // --- CHANGED: IMMEDIATE PAUSE WITH LOADING DIALOG ---
         showThinking(b.name, portrait);
         GAME.nextState = 'BOSS_TAUNT_PLAYER_REPLY'; // Player will respond with snark

         callGemini(prompt, "taunt").then(text => {
            if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
                 showDialog(text, b.name, portrait, true);
            }
        });
    }

    // ‚ö†Ô∏è DESPERATION PHASE - SPECIAL LOW-HEALTH ATTACK (triggers once at 10% HP) ‚ö†Ô∏è
    // Exclude MEGA SIMON - he transforms into Mecha Mega Simon instead of enraging
    if (!b.lowHealthAttackTriggered && hpPct <= 0.1 && !b.isMecha && b.name !== "MEGA SIMON") {
        b.lowHealthAttackTriggered = true;
        b.desperationMode = true; // üî• ENRAGED STATE - 30% faster, 10% blocked, 10% deflected!

        // üî• RESTORE BOSS HEALTH TO 30% with animated restoration
        {
            const targetHp = Math.floor(b.maxHp * 0.3);
            const startHp = b.hp;

            // Animate health bar restoration over 2 seconds
            let animFrame = 0;
            const animDuration = 120; // 2 seconds at 60fps
            const healthRestoreAnim = setInterval(() => {
                animFrame++;
                const progress = animFrame / animDuration;
                b.hp = Math.floor(startHp + (targetHp - startHp) * Math.min(progress, 1));
                updateBossHud();

                // Spawn particles during restoration
                if (animFrame % 3 === 0) {
                    spawnParticle(b.x + Math.random() * 32, b.y + Math.random() * 32, '#00ff00', -3);
                }

                if (animFrame >= animDuration) {
                    clearInterval(healthRestoreAnim);
                    b.hp = targetHp;
                    updateBossHud();
                }
            }, 16); // ~60fps

            spawnFloatingText(b.x + 16, b.y - 40, "‚ö° HEALTH RESTORED! ‚ö°", "#00ff00");
            spawnFloatingText(b.x + 16, b.y - 55, "ENRAGED MODE!", "#ff0000");
        }

        // üî• PLAY ENRAGED MUSIC
        MusicSys.play('enraged', 1.0);

        const baseAngle = Math.atan2(p.y - b.y, p.x - b.x);

        // MASSIVE visual feedback - boss is desperate!
        GAME.shake = 25;
        GAME.flash = 15;
        spawnFloatingText(b.x + 16, b.y - 25, "*** DESPERATION! ***", "#ff0000");
        spawnParticleBurst(b.x + 16, b.y + 16, ['#ff0000', '#ff4444', '#ff9900', '#ffff00'], 40);

        // Multiple alert sounds for emphasis
        AudioSys.sfx.alert();
        setTimeout(() => AudioSys.sfx.alert(), 100);
        setTimeout(() => AudioSys.sfx.alert(), 200);

        if (b.attackPattern === 'sweep') {
            // Labour Inspector - "EMERGENCY FULL INSPECTION" - MASSIVE 15-way sweep covering entire screen
            spawnFloatingText(b.x + 16, b.y - 10, "EMERGENCY INSPECTION!", "#ff0000");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#fbbf24', '#ff9900'], 30);
            for (let i = -7; i <= 7; i++) {
                let angle = baseAngle + (i * 0.22);
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*4.0, vy: Math.sin(angle)*4.0, life: 140, boss: true, grace: 18 });
                    }
                }, Math.abs(i) * 30);
            }
        }
        else if (b.attackPattern === 'tracking') {
            // Compliance Auditor - "TOTAL LOCKDOWN" - 12 homing projectiles in all directions
            spawnFloatingText(b.x + 16, b.y - 10, "TOTAL SURVEILLANCE!", "#ff0000");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#22d3ee', '#0ea5e9'], 35);
            for (let i = 0; i < 12; i++) {
                let angle = (i / 12) * Math.PI * 2;
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*2.5, vy: Math.sin(angle)*2.5, life: 200, boss: true, grace: 20, tracking: true });
                    }
                }, i * 40);
            }
        }
        else if (b.attackPattern === 'burst') {
            // Sebastian - "MAXIMUM TPH OVERLOAD" - insane 15-shot ultra-rapid burst!
            spawnFloatingText(b.x + 16, b.y - 10, "TPH MELTDOWN!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "MAXIMUM THROUGHPUT!", "#ff9900");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#ff4444', '#ff9900'], 40);
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        let angle = Math.atan2(GAME.player.y - b.y, GAME.player.x - b.x) + (Math.random() - 0.5) * 0.6;
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*5.0, vy: Math.sin(angle)*5.0, life: 100, boss: true, grace: 10 });
                        spawnParticle(b.x + 16, b.y + 16, '#ff0000', -2);
                        AudioSys.sfx.alert();
                    }
                }, i * 35);
            }
        }
        else if (b.attackPattern === 'orbital') {
            // Regional OPS MGR - "FULL AUDIT STORM" - TRIPLE orbital rings (30 total projectiles!)
            spawnFloatingText(b.x + 16, b.y - 10, "EXECUTIVE ORDER!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "TRIPLE AUDIT!", "#fbbf24");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#eab308', '#fbbf24', '#ff9900'], 50);
            for (let i = 0; i < 10; i++) {
                let angle = (i / 10) * Math.PI * 2;
                // Inner ring
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*12, y: b.y + 16 + Math.sin(angle)*12, vx: Math.cos(angle + 0.4)*2.8, vy: Math.sin(angle + 0.4)*2.8, life: 120, boss: true, grace: 15 });
                // Middle ring
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*24, y: b.y + 16 + Math.sin(angle)*24, vx: Math.cos(angle)*2.2, vy: Math.sin(angle)*2.2, life: 130, boss: true, grace: 15 });
                // Outer ring
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*36, y: b.y + 16 + Math.sin(angle)*36, vx: Math.cos(angle - 0.4)*1.8, vy: Math.sin(angle - 0.4)*1.8, life: 140, boss: true, grace: 15 });
            }
        }
        else if (b.attackPattern === 'laser') {
            // Avetta Platform - "CRITICAL RISK MATRIX" - asterisk pattern (8 directions √ó 2 waves)
            spawnFloatingText(b.x + 16, b.y - 10, "CRITICAL RISK!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "FULL SCAN ACTIVE!", "#dc2626");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#dc2626', '#ff0000', '#ff4444'], 45);
            for (let wave = 0; wave < 2; wave++) {
                for (let i = 0; i < 8; i++) {
                    let angle = (i / 8) * Math.PI * 2;
                    setTimeout(() => {
                        if (GAME.state === 'BOSS' && GAME.boss) {
                            GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*6.0, vy: Math.sin(angle)*6.0, life: 90, boss: true, grace: 6 });
                            AudioSys.sfx.alert();
                        }
                    }, (wave * 400) + (i * 40));
                }
            }
        }
        else if (b.attackPattern === 'wave') {
            // Jelena HR - "TERMINATION NOTICE" - massive 9-wave tsunami
            spawnFloatingText(b.x + 16, b.y - 10, "FINAL WARNING!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "POLICY TSUNAMI!", "#a855f7");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#a855f7', '#c084fc', '#e9d5ff'], 40);
            for (let i = -4; i <= 4; i++) {
                let angle = baseAngle + (i * 0.18);
                let proj = { type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*3.5, vy: Math.sin(angle)*3.5, life: 160, boss: true, grace: 18, wave: true, waveTime: i * 10, waveAmplitude: 1.5, baseAngle: angle };
                GAME.projectiles.push(proj);
            }
        }
        else if (b.attackPattern === 'storm') {
            // MEGA SIMON - "TOTAL COMPLIANCE FAILURE" - absolute chaos (20 projectiles!)
            spawnFloatingText(b.x + 16, b.y - 10, "AUDIT APOCALYPSE!", "#ff0000");
            spawnFloatingText(b.x + 16, b.y + 5, "COMPLIANCE FAILURE!", "#ff9900");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#ff0000', '#ff9900', '#ffff00', '#ff4444'], 60);
            for (let i = 0; i < 20; i++) {
                let angle = (Math.random() * Math.PI * 2);
                let speed = 2.0 + Math.random() * 3.0;
                let scatter = (Math.random() - 0.5) * 40;
                let delay = Math.random() * 150;
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16 + scatter, y: b.y + 16 + scatter, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 150, boss: true, grace: 15 });
                        spawnParticle(b.x + 16, b.y + 16, '#ff0000', -2);
                    }
                }, delay);
            }
        }
    }

    if (isNaN(b.x) || isNaN(b.y)) return;
    let dx = 0, dy = 0; let dist = Math.hypot(p.x - b.x, p.y - b.y);
    if (dist > 50) {
        let angle = Math.atan2(p.y - b.y, p.x - b.x);
        // üî• DESPERATION MODE: 30% speed boost!
        const speedMultiplier = b.desperationMode ? 1.3 : 1.0;
        dx = Math.cos(angle) * b.speed * speedMultiplier; dy = Math.sin(angle) * b.speed * speedMultiplier;
        if (!checkCol(b.x + dx, b.y)) b.x += dx; if (!checkCol(b.x, b.y + dy)) b.y += dy;
    }
    b.timer++;
    if (b.timer > b.attackDelay) {
        b.timer = 0;
        const baseAngle = Math.atan2(p.y - b.y, p.x - b.x);

        // Mecha Mega Simon - Ultimate spread attack
        if (b.isMecha) {
            for (let i = -2; i <= 2; i++) {
                let angle = baseAngle + (i * 0.5);
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*10, y: b.y + 16 + Math.sin(angle)*10, vx: Math.cos(angle)*3.5, vy: Math.sin(angle)*3.5, life: 100, boss: true, grace: 10 });
            }
        }
        // Unique attack patterns based on boss personality
        else if (b.attackPattern === 'sweep') {
            // Labour Inspector - "INSPECTION LINE" - horizontal sweeping line (11 projectiles in wide arc)
            // VISUAL: Wide horizontal sweep like checking every corner
            GAME.shake = 8; // More visual feedback
            spawnParticleBurst(b.x + 16, b.y + 16, ['#fbbf24', '#ff9900'], 12);
            for (let i = -5; i <= 5; i++) {
                let angle = baseAngle + (i * 0.25); // Wider spread
                let offset = Math.abs(i) * 3; // Slight stagger
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*offset, y: b.y + 16 + Math.sin(angle)*offset, vx: Math.cos(angle)*3.2, vy: Math.sin(angle)*3.2, life: 120, boss: true, grace: 10 });
                    }
                }, Math.abs(i) * 15); // Sweep from center out
            }
        }
        else if (b.attackPattern === 'tracking') {
            // Compliance Auditor - "AUDIT GRID" - 6 slow homing projectiles
            // VISUAL: Grid pattern that slowly homes in on player
            GAME.shake = 6;
            spawnParticleBurst(b.x + 16, b.y + 16, ['#22d3ee', '#0ea5e9'], 15);
            for (let row = -1; row <= 1; row++) {
                for (let col = -1; col <= 1; col += 2) {
                    if (row === 0 && col === -1) continue; // Skip center-left for pattern
                    let angle = baseAngle + (col * 0.3) + (row * 0.25);
                    GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*1.4, vy: Math.sin(angle)*1.4, life: 200, boss: true, grace: 15, tracking: true });
                }
            }
        }
        else if (b.attackPattern === 'burst') {
            // Sebastian - "TPH BARRAGE" - 10-shot rapid machine gun burst!
            // VISUAL: Relentless rapid-fire, overwhelming volume
            GAME.shake = 10;
            spawnFloatingText(b.x + 16, b.y - 15, "TPH RUSH!", "#ff4444");
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        let angle = Math.atan2(GAME.player.y - b.y, GAME.player.x - b.x) + (Math.random() - 0.5) * 0.5;
                        let speed = 3.5 + (i * 0.15); // Accelerates with each shot
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 90, boss: true, grace: 7 });
                        spawnParticle(b.x + 16, b.y + 16, '#ff9900', -1);
                        if (i % 2 === 0) AudioSys.sfx.alert();
                    }
                }, i * 50); // Faster burst
            }
        }
        else if (b.attackPattern === 'orbital') {
            // Regional OPS MGR - "METRIC RINGS" - dual counter-rotating orbital rings (16 total projectiles!)
            // VISUAL: Two rings rotating in opposite directions - impossible to dodge without precision
            GAME.shake = 12;
            spawnParticleBurst(b.x + 16, b.y + 16, ['#eab308', '#fbbf24'], 20);
            for (let i = 0; i < 8; i++) {
                let angle = (i / 8) * Math.PI * 2;
                // Inner ring - clockwise
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*18, y: b.y + 16 + Math.sin(angle)*18, vx: Math.cos(angle + 0.3)*2.2, vy: Math.sin(angle + 0.3)*2.2, life: 110, boss: true, grace: 10 });
                // Outer ring - counter-clockwise
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*30, y: b.y + 16 + Math.sin(angle)*30, vx: Math.cos(angle - 0.3)*1.8, vy: Math.sin(angle - 0.3)*1.8, life: 120, boss: true, grace: 10 });
            }
        }
        else if (b.attackPattern === 'laser') {
            // Avetta Platform - "RISK CROSS" - + shaped cross laser pattern (5 beams in cardinal + center)
            // VISUAL: Cross/plus pattern of fast laser beams
            GAME.shake = 14;
            spawnFloatingText(b.x + 16, b.y - 15, "RISK SCAN!", "#dc2626");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#dc2626', '#ff0000'], 25);
            // Fire cross pattern in sequence
            const crossAngles = [0, Math.PI/2, Math.PI, Math.PI*1.5, baseAngle]; // 4 cardinal + aimed center
            for (let i = 0; i < crossAngles.length; i++) {
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        let angle = crossAngles[i];
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*5.5, vy: Math.sin(angle)*5.5, life: 75, boss: true, grace: 5 });
                        GAME.projectiles.push({ type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*6.5, vy: Math.sin(angle)*6.5, life: 65, boss: true, grace: 4 });
                        AudioSys.sfx.alert();
                    }
                }, i * 60);
            }
        }
        else if (b.attackPattern === 'wave') {
            // Jelena "Jelly" HR - "POLICY CASCADE" - 7-wave cascading sinusoidal attack
            // VISUAL: Multiple waves that undulate visibly
            GAME.shake = 7;
            spawnParticleBurst(b.x + 16, b.y + 16, ['#a855f7', '#c084fc'], 18);
            for (let i = -3; i <= 3; i++) {
                let angle = baseAngle + (i * 0.22);
                let proj = { type: 'req', x: b.x + 16, y: b.y + 16, vx: Math.cos(angle)*2.8, vy: Math.sin(angle)*2.8, life: 150, boss: true, grace: 12, wave: true, waveTime: i * 12, waveAmplitude: 1.2, baseAngle: angle };
                GAME.projectiles.push(proj);
            }
        }
        else if (b.attackPattern === 'storm') {
            // MEGA SIMON - "CHAOS VORTEX" - complete 360¬∞ chaotic storm (14 projectiles)
            // VISUAL: Absolute chaos, projectiles everywhere at varying speeds
            GAME.shake = 15;
            GAME.flash = 5;
            spawnFloatingText(b.x + 16, b.y - 15, "VIOLATION STORM!", "#ff0000");
            spawnParticleBurst(b.x + 16, b.y + 16, ['#ff0000', '#ff9900', '#ffff00'], 30);
            for (let i = 0; i < 14; i++) {
                let angle = (Math.random() * Math.PI * 2); // Completely random directions
                let speed = 1.8 + Math.random() * 2.5; // Wildly varying speeds
                let scatter = (Math.random() - 0.5) * 35;
                let delay = Math.random() * 100;
                setTimeout(() => {
                    if (GAME.state === 'BOSS' && GAME.boss) {
                        GAME.projectiles.push({ type: 'req', x: b.x + 16 + scatter, y: b.y + 16 + scatter, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 130, boss: true, grace: 10 });
                    }
                }, delay);
            }
        }
        else {
            // Default spread attack
            for (let i = -1; i <= 1; i++) {
                let angle = baseAngle + (i * 0.3);
                GAME.projectiles.push({ type: 'req', x: b.x + 16 + Math.cos(angle)*10, y: b.y + 16 + Math.sin(angle)*10, vx: Math.cos(angle)*2.5, vy: Math.sin(angle)*2.5, life: 100, boss: true, grace: 10 });
            }
        }
        AudioSys.sfx.alert(); GAME.shake = b.isMecha ? 8 : 5;
    }
}

function updateProjectiles() {
    for(let i=GAME.projectiles.length-1; i>=0; i--) {
        let p = GAME.projectiles[i];
        // Guard against undefined projectiles (can happen during state transitions)
        if (!p) { GAME.projectiles.splice(i, 1); continue; }
        p.x += p.vx; p.y += p.vy; p.life--; if(p.grace > 0) p.grace--;
        // Skip wall collision check in Bezos boss level
        if (GAME.state !== 'BEZOS_BOSS') {
            if (p.grace <= 0 && checkCol(p.x, p.y)) {
                // Track missed player attacks for scoring
                if (p.type === 'attack') {
                    GAME.booksMissed++;
                    spawnFloatingText(GAME.player.x, GAME.player.y - 24, "-200", "#ef4444"); // Score penalty
                }
                GAME.projectiles.splice(i,1); continue;
            }
        }
        if (p.life <= 0) {
            // Track missed player attacks for scoring (expired without hitting)
            if (p.type === 'attack') {
                GAME.booksMissed++;
                spawnFloatingText(GAME.player.x, GAME.player.y - 24, "-200", "#ef4444"); // Score penalty
            }
            GAME.projectiles.splice(i,1); continue;
        }
        // Roman's PHANTOM STEP - smaller collision radius for projectiles
        const projectileRadius = GAME.selectedChar === 'Roman' ? 6 : 10;
        if ((p.type === 'req') && Math.hypot(p.x-GAME.player.x, p.y-GAME.player.y) < projectileRadius) {
            if (GAME.player.iframe<=0) {
                // === PPE BUFF: High-Vis Vest - 15% dodge chance ===
                if (GAME.ppeUnlocked.includes('hi_vis_vest') && Math.random() < 0.15) {
                    spawnFloatingText(GAME.player.x, GAME.player.y - 16, "DODGE!", "#22d3ee");
                    GAME.projectiles.splice(i,1);
                    continue;
                }

                // Nevena's FORESIGHT ability - longer invincibility frames
                let iframeBonus = GAME.selectedChar === 'Nevena' ? 180 : 120;

                // === PPE BUFF: Invincibility frames (Bump Cap + AR Helmet) ===
                iframeBonus += getPPEBuffValue('iframe');

                // === PPE BUFF: Quantum Shield Vest - 25% damage reflection ===
                const reflectChance = getPPEBuffValue('reflect');
                if (reflectChance > 0 && Math.random() < reflectChance) {
                    // Reflect the projectile back at attacker
                    p.vx = -p.vx * 1.5;
                    p.vy = -p.vy * 1.5;
                    p.type = 'attack'; // Convert to player attack
                    p.owner = GAME.selectedChar;
                    p.life = 60;
                    spawnFloatingText(GAME.player.x, GAME.player.y - 16, "REFLECT!", "#a855f7");
                    continue; // Don't take damage
                }

                // === PPE BUFF: Prime Guardian Armor - 50% Block Chance ===
                const blockChance = getPPEBuffValue('block');
                if (blockChance > 0 && Math.random() < blockChance) {
                    spawnFloatingText(GAME.player.x, GAME.player.y - 16, "BLOCKED!", "#00ffff");
                    spawnParticleBurst(GAME.player.x + 8, GAME.player.y + 8, ['#00ffff', '#ffffff'], 6);
                    AudioSys.sfx.alert();
                    GAME.projectiles.splice(i,1);
                    continue; // Don't take damage
                }

                GAME.lives--; GAME.player.iframe = iframeBonus; GAME.shake = 10; GAME.flash = 10; AudioSys.sfx.hurt(); updateHud();
                VibrationSystem.onDamage(); // Vibrate on damage
                if (GAME.lives<=0 && !GAME.gameOverTriggered) triggerGameOver("OVERWHELMED!");
            }
            GAME.projectiles.splice(i,1);
        }
        if (p.type === 'attack') {
            const attackMeta = getAttackData(p.owner);
            // === PPE BUFF: Safety Goggles - larger boss hit radius ===
            const bossHitRadius = 24 * (p.sizeMod || 1.0);
            if (GAME.state === 'BOSS' && GAME.boss) {
                if (Math.hypot(p.x - (GAME.boss.x+16), p.y - (GAME.boss.y+16)) < bossHitRadius) {
                    // If Mecha Mega Simon, attacks are ineffective
                    if (GAME.boss.isMecha) {
                        GAME.projectiles.splice(i,1);
                        spawnFloatingText(GAME.boss.x+16, GAME.boss.y+8, "INEFFECTIVE!", "#666");
                        AudioSys.sfx.alert();
                        continue;
                    }
                    // üî• DESPERATION MODE: 10% blocked, 10% deflected!
                    if (GAME.boss.desperationMode) {
                        const roll = Math.random();
                        if (roll < 0.1) {
                            // 10% BLOCKED - attack absorbed
                            GAME.projectiles.splice(i,1);
                            spawnFloatingText(GAME.boss.x+16, GAME.boss.y+8, "BLOCKED!", "#888888");
                            spawnParticleBurst(GAME.boss.x+16, GAME.boss.y+16, ['#888888', '#666666'], 6);
                            AudioSys.sfx.alert();
                            continue;
                        } else if (roll < 0.2) {
                            // 10% DEFLECTED - attack bounces back
                            GAME.projectiles.splice(i,1);
                            spawnFloatingText(GAME.boss.x+16, GAME.boss.y+8, "DEFLECTED!", "#ff6600");
                            spawnParticleBurst(GAME.boss.x+16, GAME.boss.y+16, ['#ff6600', '#ffcc00'], 8);
                            AudioSys.sfx.alert();
                            continue;
                        }
                    }
                    // Character ability damage multipliers + PPE damage buffs
                    let dmg = 1;
                    if (GAME.selectedChar === 'Carrie') dmg = 2; // PRECISION FOCUS
                    // Apply critical hit damage modifier from projectile
                    if (p.damageMod) dmg = Math.ceil(dmg * p.damageMod);
                    // Apply Prime Guardian Armor damage buff
                    const damageBuffValue = getPPEBuffValue('damage');
                    if (damageBuffValue > 0) dmg = Math.ceil(dmg * damageBuffValue);
                    GAME.boss.hp -= dmg; updateBossHud(); AudioSys.sfx.bossHit(); VibrationSystem.onBossHit(); GAME.shake = 5; spawnParticle(p.x, p.y, p.color || '#ff0000', -2); GAME.projectiles.splice(i,1);
                    spawnFloatingText(GAME.player.x, GAME.player.y - 24, "+50", "#22c55e"); // Score indicator
                    const dmgText = p.isCrit ? `CRIT! -${dmg}` : (dmg > 1 ? `${attackMeta.text || 'Hit!'} x${dmg}` : (attackMeta.text || 'Hit!'));
                    spawnFloatingText(GAME.boss.x+16, GAME.boss.y+8, dmgText, attackMeta.color || '#ff0000');
                    // Damage number above boss head
                    spawnFloatingText(GAME.boss.x+16, GAME.boss.y-8, `-${dmg}`, '#ffffff');
                    // Check for Mecha Mega Simon transformation at 0 HP with fake victory sequence
                    if (GAME.boss.hp <= 0 && GAME.boss.name === "MEGA SIMON" && !GAME.boss.transformTriggered) {
                        GAME.boss.transformTriggered = true;
                        GAME.boss.hp = 1; // Keep boss alive during dialogue
                        triggerFakeVictoryDialogue(); // Start the fake victory sequence
                        continue;
                    }
                    // For non-Simon bosses, trigger epic defeat cutscene
                    if (GAME.boss.hp <= 0 && GAME.boss.name !== "MEGA SIMON") { triggerBossDefeatCutscene(); continue; }
                }
            }
            if (GAME.state === 'PLAY') {
                let simon = GAME.entities.find(e => e.type === 'simon');
                if (simon && Math.hypot(p.x-simon.x, p.y-simon.y) < 12) {
                     GAME.simonHits++; GAME.simonHitsCount++; // Track for scoring penalty
                     spawnFloatingText(GAME.player.x, GAME.player.y - 24, "-500", "#ef4444"); // Score penalty
                     AudioSys.sfx.angry(); GAME.projectiles.splice(i,1);
                     if (GAME.simonHits <= 2) {
                         const warningIndex = GAME.simonHits - 1;
                         const currentGen = GAME.genId;
                         GAME.nextState = 'PLAY';

                         // --- CHANGED: REMOVED HARDCODED FALLBACK DISPLAY. SHOW LOADING. ---
                         showThinking("Simon", GFX.simonFaceLarge);

                         const langInstWarn = getLanguageInstruction();
                         callGemini(`You are Simon. Deliver a ${warningIndex === 0 ? "first" : "final"} warning to the coordinator who keeps throwing rule books at you. Keep it sharp, under 24 words. ${langInstWarn}`, "simon_warning", { warningIndex }).then(text => {
                             if (GAME.genId === currentGen && GAME.state === 'DIALOG') {
                                  showDialog(text, "Simon", GFX.simonFaceLarge, true);
                             }
                         });
                     }
                     else if (GAME.simonHits >= 3) initSimonBoss();
                     continue;
                }
                let hit = false;
                // === PPE BUFF: Safety Goggles - larger projectile collision ===
                const hitRadius = 12 * (p.sizeMod || 1.0);
                GAME.entities.forEach(e => {
                    if (e.type === 'ops' && Math.hypot(p.x-e.x, p.y-e.y) < hitRadius) {
                        const rng = Math.random();
                        // üî• 10% DEFLECT CHANCE FOR OPS ENEMIES - throws projectile back at player
                        if (rng < 0.1) {
                            spawnFloatingText(e.x, e.y, "DEFLECTED!", "#ff4444");
                            spawnParticleBurst(e.x, e.y, ['#ff4444', '#ff0000'], 8);
                            AudioSys.sfx.alert();
                            // Reverse projectile direction toward player
                            const angle = Math.atan2(GAME.player.y - e.y, GAME.player.x - e.x);
                            p.vx = Math.cos(angle) * 3.0;
                            p.vy = Math.sin(angle) * 3.0;
                            p.type = 'req'; // Change to boss projectile type so it damages player
                            p.boss = true;
                            p.grace = 15; // Give player a moment to react
                            hit = false; // Don't remove projectile
                        }
                        // üî• 30% DODGE CHANCE FOR OPS ENEMIES
                        else if (rng < 0.4) { // 0.1 to 0.4 = 30% chance
                            spawnFloatingText(e.x, e.y, "DODGED!", "#ff9900");
                            spawnParticleBurst(e.x, e.y, ['#ff9900', '#ffff00'], 6);
                            AudioSys.sfx.alert();
                            hit = true;
                        } else {
                            e.type = 'assoc'; AudioSys.sfx.hit(); spawnParticle(e.x, e.y, attackMeta.color || '#fff', -2); GAME.opsPushed++;
                            spawnFloatingText(GAME.player.x, GAME.player.y - 24, "+100", "#22c55e"); // Score indicator
                            spawnFloatingText(e.x, e.y, attackMeta.text || "My Rates!", attackMeta.color || "#ff0000");
                            hit = true;
                        }
                    }
                });
                if (hit) GAME.projectiles.splice(i,1);
            }
        }
    }
}

function updateParticles() {
    // Performance: Use constants and avoid splice in hot loop
    const gravity = GAME_CONSTANTS.PARTICLE_GRAVITY;
    const bounce = GAME_CONSTANTS.PARTICLE_BOUNCE;
    const particles = GAME.particles;
    let writeIdx = 0;

    for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.life--;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += gravity;

        if (p.y > p.groundY) {
            p.y = p.groundY;
            p.vy *= bounce;
        }

        if (p.life > 0) {
            // Keep this particle - swap to write position if needed
            if (writeIdx !== i) particles[writeIdx] = p;
            writeIdx++;
        }
    }
    // Truncate array to remove dead particles
    particles.length = writeIdx;
}

function updateFloatingTexts() {
    // Performance: Avoid splice in hot loop
    const texts = GAME.floatingTexts;
    let writeIdx = 0;

    for (let i = 0; i < texts.length; i++) {
        const t = texts[i];
        t.y += t.vy;
        t.life--;

        if (t.life > 0) {
            if (writeIdx !== i) texts[writeIdx] = t;
            writeIdx++;
        }
    }
    texts.length = writeIdx;
}

function spawnParticle(x, y, color, forceY = 0) {
    // Performance: Reuse objects where possible, limit max particles
    if (GAME.particles.length >= GAME_CONSTANTS.MAX_PARTICLES) return;

    GAME.particles.push({
        x: x,
        y: y,
        color: color,
        life: GAME_CONSTANTS.PARTICLE_LIFE_BASE + Math.random() * GAME_CONSTANTS.PARTICLE_LIFE_VARIANCE,
        vx: (Math.random() - 0.5) * 3,
        vy: forceY || (Math.random() * -3 - 1),
        groundY: y + 5,
        size: 1 + Math.random() * 2,
        alpha: 1,
        sparkle: false
    });
}

// Enhanced particle burst for special effects
function spawnParticleBurst(x, y, colors, count) {
    const maxToAdd = Math.min(count, GAME_CONSTANTS.MAX_PARTICLES - GAME.particles.length);
    const colorsLen = colors.length;

    for (let i = 0; i < maxToAdd; i++) {
        const angle = (i / count) * Math.PI * 2;
        const speed = 1 + Math.random() * 2;
        const color = colors[Math.floor(Math.random() * colorsLen)];
        GAME.particles.push({
            x: x,
            y: y,
            color: color,
            life: 30 + Math.random() * 30,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1,
            groundY: y + 20,
            size: 1 + Math.random() * 2,
            alpha: 1,
            sparkle: false
        });
    }
}

// Sparkle effect for special moments
function spawnSparkles(x, y, color) {
    const maxToAdd = Math.min(8, GAME_CONSTANTS.MAX_PARTICLES - GAME.particles.length);

    for (let i = 0; i < maxToAdd; i++) {
        GAME.particles.push({
            x: x + (Math.random() - 0.5) * 10,
            y: y + (Math.random() - 0.5) * 10,
            color: color,
            life: 20 + Math.random() * 20,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 3,
            groundY: y + 30,
            size: 1 + Math.random(),
            alpha: 1,
            sparkle: true
        });
    }
}

function throwBook() {
    const p = GAME.player; if (p.cooldown > 0) return; const attackMeta = getAttackData(GAME.selectedChar);
    // Joao's CAFFEINE RUSH ability - faster cooldown (35% faster)
    // Carrie's PRECISION FOCUS penalty - slower reload (30% slower) but 2x damage
    let cooldownMod = 1.0;
    if (GAME.selectedChar === 'Joao') cooldownMod = 0.65; // 35% faster
    else if (GAME.selectedChar === 'Carrie') cooldownMod = 1.3; // 30% slower

    // === PPE BUFF: Cut-Resistant Gloves - 20% faster fire rate ===
    if (GAME.ppeUnlocked.includes('cut_gloves')) cooldownMod *= 0.80;

    const finalCooldown = Math.floor((attackMeta.cooldown || 120) * cooldownMod);
    p.cooldown = finalCooldown; p.cooldownMax = finalCooldown; GAME.booksFired++;
    const speed = attackMeta.speed || 4;
    let vx=0, vy=0;
    if (GAME.state === 'BOSS' && GAME.boss) {
        let angle = Math.atan2((GAME.boss.y+16) - p.y, (GAME.boss.x+16) - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed;
    } else if (GAME.state === 'MECHA_BOSS' && GAME.mecha) {
        let angle = Math.atan2((GAME.mecha.y+32) - p.y, (GAME.mecha.x+32) - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed;
    } else {
        let target = null; let minDist = 200;
        GAME.entities.forEach(e => { if (e.type === 'ops') { let d = Math.hypot(e.x - p.x, e.y - p.y); if (d < minDist) { minDist = d; target = e; } } });
        if (target) { let angle = Math.atan2(target.y - p.y, target.x - p.x); vx = Math.cos(angle) * speed; vy = Math.sin(angle) * speed; }
        else { if (KEYS.up) vy=-speed; else if (KEYS.down) vy=speed; else if (KEYS.left) vx=-speed; else vx=speed; }
    }

    // === PPE BUFF: Safety Goggles - 25% Critical Hit Chance (double damage) ===
    const critChance = getPPEBuffValue('crit');
    const isCrit = Math.random() < critChance;
    const critMod = isCrit ? 2.0 : 1.0;

    GAME.projectiles.push({ type:'attack', owner: GAME.selectedChar, sprite: attackMeta.sprite, color: isCrit ? '#ffff00' : (attackMeta.color || '#ff0000'), x:p.x+8, y:p.y+8, vx, vy, life:attackMeta.life || 40, text: attackMeta.text, sizeMod: 1.0, damageMod: critMod, isCrit: isCrit }); AudioSys.sfx.throw();
}

// === HELPER: Get total PPE buff value for a specific buff type (supports multi-effects) ===
function getPPEBuffValue(buffType) {
    let totalValue = 0;
    PPE_ITEMS.forEach(item => {
        if (!GAME.ppeUnlocked.includes(item.id) || !item.buff) return;

        if (item.buff.type === buffType) {
            totalValue += item.buff.value;
        } else if (item.buff.type === 'multi' && item.buff.effects) {
            // Handle multi-effect items
            item.buff.effects.forEach(effect => {
                if (effect.type === buffType) {
                    totalValue += effect.value;
                }
            });
        }
    });
    return totalValue;
}

// === HELPER: Check if player has a specific PPE buff (supports multi-effects) ===
function hasPPEBuff(buffType) {
    return getPPEBuffValue(buffType) > 0;
}

// === LOCALIZED UI TEXT SYSTEM ===
const UI_TEXT = {
    // Shop messages
    'already_owned': {
        'EN': 'Already equipped! This PPE is in your loadout.',
        'DE': 'Bereits ausger√ºstet! Diese PSA ist in deiner Ausr√ºstung.',
        'AT': 'Schon drinn! Die PSA hast scho in deiner Ausr√ºstung, oida.',
        'NL': 'Al uitgerust! Deze PBM zit in je uitrusting.'
    },
    'insufficient_points': {
        'EN': 'Insufficient Safety Points! Fix more hazards.',
        'DE': 'Nicht genug Sicherheitspunkte! Behebe mehr Gefahren.',
        'AT': 'Ned genug Sicherheitspunkte! Fix mehr Gefahren, herst.',
        'NL': 'Onvoldoende Veiligheidspunten! Los meer gevaren op.'
    },
    'no_items_to_return': {
        'EN': 'No PPE to return! Your locker is empty.',
        'DE': 'Keine PSA zum Zur√ºckgeben! Dein Spind ist leer.',
        'AT': 'Nix zum Zur√ºckgeben! Dein Spind is leer, oida.',
        'NL': 'Geen PBM om terug te geven! Je kluisje is leeg.'
    },
    'select_ppe': {
        'EN': 'Select PPE to view safety regulations...',
        'DE': 'PSA ausw√§hlen f√ºr Sicherheitsvorschriften...',
        'AT': 'PSA ausw√§hlen f√ºr Sicherheitsvorschriften...',
        'NL': 'Selecteer PBM voor veiligheidsvoorschriften...'
    },
    // PPE Vending Machine
    'ppe_vending': {
        'EN': 'PPE VENDING',
        'DE': 'PSA-AUTOMAT',
        'AT': 'PSA-AUTOMAT',
        'NL': 'PBM AUTOMAAT'
    },
    'ppe_machine': {
        'EN': 'MACHINE',
        'DE': 'MASCHINE',
        'AT': 'MASCHINE',
        'NL': 'MACHINE'
    },
    'spend_safety_points': {
        'EN': 'Spend Safety Points on',
        'DE': 'Sicherheitspunkte ausgeben f√ºr',
        'AT': 'Sicherheitspunkte ausgeben f√ºr',
        'NL': 'Besteed Veiligheidspunten aan'
    },
    'protective_equipment': {
        'EN': 'protective equipment.',
        'DE': 'Schutzausr√ºstung.',
        'AT': 'Schutzausr√ºstung.',
        'NL': 'beschermingsmiddelen.'
    },
    'each_item_grants': {
        'EN': 'Each item grants a',
        'DE': 'Jedes Teil gibt dir',
        'AT': 'Jedes Teil gibt dir',
        'NL': 'Elk item geeft een'
    },
    'permanent_buff': {
        'EN': 'permanent gameplay buff!',
        'DE': 'einen permanenten Bonus!',
        'AT': 'an permanenten Bonus!',
        'NL': 'permanente gameplay bonus!'
    },
    'select_items': {
        'EN': 'Select Items',
        'DE': 'Ausw√§hlen',
        'AT': 'Ausw√§hlen',
        'NL': 'Selecteren'
    },
    'leave': {
        'EN': 'Leave',
        'DE': 'Verlassen',
        'AT': 'Verlassen',
        'NL': 'Verlaten'
    },
    // Safety Locker
    'safety_locker': {
        'EN': 'SAFETY LOCKER',
        'DE': 'SICHERHEITSSPIND',
        'AT': 'SICHERHEITSSPIND',
        'NL': 'VEILIGHEIDSKLUISJE'
    },
    'safety_points': {
        'EN': 'SAFETY POINTS',
        'DE': 'SICHERHEITSPUNKTE',
        'AT': 'SICHERHEITSPUNKTE',
        'NL': 'VEILIGHEIDSPUNTEN'
    },
    'sp_short': {
        'EN': 'SP',
        'DE': 'SP',
        'AT': 'SP',
        'NL': 'VP'
    },
    'owned': {
        'EN': 'OWNED',
        'DE': 'BESITZT',
        'AT': 'BESITZT',
        'NL': 'BEZIT'
    },
    'page': {
        'EN': 'Page',
        'DE': 'Seite',
        'AT': 'Seite',
        'NL': 'Pagina'
    },
    'prev': {
        'EN': 'PREV',
        'DE': 'ZUR√úCK',
        'AT': 'ZUR√úCK',
        'NL': 'VORIGE'
    },
    'next': {
        'EN': 'NEXT',
        'DE': 'WEITER',
        'AT': 'WEITER',
        'NL': 'VOLG'
    },
    // Character selection
    'select_coordinator': {
        'EN': 'SELECT COORDINATOR',
        'DE': 'KOORDINATOR W√ÑHLEN',
        'AT': 'KOORDINATOR W√ÑHLEN',
        'NL': 'KIES CO√ñRDINATOR'
    },
    // Performance review
    'performance_review': {
        'EN': 'SIMON - PERFORMANCE REVIEW',
        'DE': 'SIMON - LEISTUNGSBEURTEILUNG',
        'AT': 'SIMON - LEISTUNGSBEURTEILUNG',
        'NL': 'SIMON - PRESTATIEBEOORDELING'
    },
    'exit_interview': {
        'EN': 'SIMON - EXIT INTERVIEW',
        'DE': 'SIMON - AUSTRITTSGESPR√ÑCH',
        'AT': 'SIMON - AUSTRITTSGESPR√ÑCH',
        'NL': 'SIMON - EXITGESPREK'
    },
    // Floating text
    'safe': {
        'EN': 'Safe!',
        'DE': 'Sicher!',
        'AT': 'Sicher!',
        'NL': 'Veilig!'
    },
    // Controls
    'controls_select_confirm_leave': {
        'EN': '‚ñ≤‚ñº SELECT | SPACE CONFIRM | ESC LEAVE',
        'DE': '‚ñ≤‚ñº W√ÑHLEN | LEERTASTE OK | ESC VERLASSEN',
        'AT': '‚ñ≤‚ñº W√ÑHLEN | LEERTASTE OK | ESC VERLASSEN',
        'NL': '‚ñ≤‚ñº KIEZEN | SPATIE OK | ESC VERLATEN'
    },
    'controls_select_buy_exit': {
        'EN': '‚ñ≤‚ñº SELECT | SPACE BUY | ESC EXIT',
        'DE': '‚ñ≤‚ñº W√ÑHLEN | LEERTASTE KAUFEN | ESC ZUR√úCK',
        'AT': '‚ñ≤‚ñº W√ÑHLEN | LEERTASTE KAUFEN | ESC ZUR√úCK',
        'NL': '‚ñ≤‚ñº KIEZEN | SPATIE KOPEN | ESC TERUG'
    },
    'controls_scroll_close': {
        'EN': '‚ñ≤‚ñº SCROLL | SPACE/DOWN CLOSE',
        'DE': '‚ñ≤‚ñº SCROLLEN | LEERTASTE/UNTEN SCHLIE√üEN',
        'AT': '‚ñ≤‚ñº SCROLLEN | LEERTASTE/UNTEN SCHLIE√üEN',
        'NL': '‚ñ≤‚ñº SCROLLEN | SPATIE/OMLAAG SLUITEN'
    },
    // Compliance detail
    'regulation': {
        'EN': 'REGULATION',
        'DE': 'VORSCHRIFT',
        'AT': 'VORSCHRIFT',
        'NL': 'VOORSCHRIFT'
    },
    'loading': {
        'EN': 'LOADING...',
        'DE': 'L√ÑDT...',
        'AT': 'L√ÑDT...',
        'NL': 'LADEN...'
    },
    'hazard': {
        'EN': 'HAZARD',
        'DE': 'GEFAHR',
        'AT': 'GEFAHR',
        'NL': 'GEVAAR'
    },
    'multi_country': {
        'EN': 'MULTI-COUNTRY',
        'DE': 'L√ÑNDERVERGLEICH',
        'AT': 'L√ÑNDERVERGLEICH',
        'NL': 'MEERDERE LANDEN'
    },
    'scroll': {
        'EN': 'SCROLL',
        'DE': 'SCROLLEN',
        'AT': 'SCROLLEN',
        'NL': 'SCROLLEN'
    },
    'close_short': {
        'EN': 'CLOSE',
        'DE': 'SCHLIE√üEN',
        'AT': 'SCHLIE√üEN',
        'NL': 'SLUITEN'
    },
    'comparison_mode': {
        'EN': 'COMPARISON MODE',
        'DE': 'VERGLEICHSMODUS',
        'AT': 'VERGLEICHSMODUS',
        'NL': 'VERGELIJKINGSMODUS'
    },
    'items_short': {
        'EN': 'ITM',
        'DE': 'STK',
        'AT': 'STK',
        'NL': 'STK'
    },
    'empty': {
        'EN': 'EMPTY',
        'DE': 'LEER',
        'AT': 'LEER',
        'NL': 'LEEG'
    },
    'fixed': {
        'EN': 'Fixed!',
        'DE': 'Behoben!',
        'AT': 'Behoben!',
        'NL': 'Opgelost!'
    },
    'speed_boost': {
        'EN': 'SPEED BOOST!',
        'DE': 'TEMPO-BOOST!',
        'AT': 'TEMPO-BOOST!',
        'NL': 'SNELHEIDSBOOST!'
    },
    'calculating_score': {
        'EN': 'CALCULATING SAFETY SCORE...',
        'DE': 'BERECHNE SICHERHEITSPUNKTE...',
        'AT': 'BERECHNE SICHERHEITSPUNKTE...',
        'NL': 'VEILIGHEIDSSCORE BEREKENEN...'
    },
    'preparing_exit': {
        'EN': 'PREPARING EXIT INTERVIEW...',
        'DE': 'AUSTRITTSGESPR√ÑCH VORBEREITEN...',
        'AT': 'AUSTRITTSGESPR√ÑCH VORBEREITEN...',
        'NL': 'EXITGESPREK VOORBEREIDEN...'
    },
    'arrows_browse': {
        'EN': '< ARROWS TO BROWSE > | SPACE TO START',
        'DE': '< PFEILE AUSW√ÑHLEN > | LEERTASTE START',
        'AT': '< PFEILE AUSW√ÑHLEN > | LEERTASTE START',
        'NL': '< PIJLEN BLADEREN > | SPATIE STARTEN'
    }
};

function getLocalizedText(key) {
    const region = GAME.region;
    const langMap = { 'DE': 'DE', 'AT': 'AT', 'NL': 'NL', 'MEU': 'EN' };
    const lang = langMap[region] || 'EN';
    return (UI_TEXT[key] && UI_TEXT[key][lang]) || (UI_TEXT[key] && UI_TEXT[key]['EN']) || key;
}

// Backward compatibility wrapper
function getShopMessage(key) {
    return getLocalizedText(key);
}

// Helper function to get region-specific safety context for AI prompts
function getRegionSafetyContext() {
    const region = GAME.region;
    const contexts = {
        'DE': 'Cite specific German regulations like DGUV Vorschrift 1, ArbSchG, or BetrSichV. Reference the Berufsgenossenschaft if relevant.',
        'AT': 'Cite specific Austrian regulations like ASchG or BauV. Mention the Arbeitsinspektorat or AUVA if relevant.',
        'NL': 'Cite specific Dutch regulations like Arbowet or the Arbocatalogus. Mention the RI&E or Inspectie SZW if relevant.',
        'MEU': 'Compare regulations across Germany (DGUV), Austria (ASchG), and Netherlands (Arbowet). Highlight any significant differences between countries.',
        'EU': 'Reference general EU workplace safety directives.'
    };
    return contexts[region] || contexts['EU'];
}

// Helper function to get language instruction for AI prompts based on region
function getLanguageInstruction() {
    const region = GAME.region;
    const instructions = {
        'AT': 'WICHTIG: Antworte auf DEUTSCH mit √∂sterreichischem Dialekt (Wienerisch). Verwende Ausdr√ºcke wie "oida", "herst", "ned", "is", "san", "a" statt "ein". (Respond in Austrian German dialect)',
        'DE': 'WICHTIG: Antworte auf DEUTSCH in Hochdeutsch. (Respond in standard German)',
        'NL': 'BELANGRIJK: Antwoord in het NEDERLANDS. Gebruik licht vulgaire uitdrukkingen zoals "godver", "verdomme", "klojo", "eikel" om frustratie te uiten. Wees direct en een beetje grof maar professioneel. (Respond in Dutch with mild vulgar expressions)',
        'MEU': 'Respond in English. This is a multi-country EU perspective covering Germany, Austria, and Netherlands.'
    };
    return instructions[region] || '';
}

function getRegionName() {
    return GAME.regionNames[GAME.region] || 'Europe';
}

// Get warehouse code based on region (DVI1 for AT, DMU3 for DE, DNL1 for NL)
function getWarehouseCode() {
    const codes = { AT: 'DVI1', DE: 'DMU3', NL: 'DNL1', MEU: 'EU-HQ' };
    return codes[GAME.region] || 'DVI1';
}

// Get country name for warehouse signs
function getWarehouseCountry() {
    const countries = { AT: 'AUSTRIA', DE: 'GERMANY', NL: 'NETHERLANDS', MEU: 'MID-EU' };
    return countries[GAME.region] || 'AUSTRIA';
}

function tryInteract() {
    const p = GAME.player;

    // Check if player is near fire exit door after exactly 4 hazards cleared
    if (GAME.issuesFixed >= 4 && GAME.fireExitDoor && Math.hypot(p.x - GAME.fireExitDoor.x, p.y - GAME.fireExitDoor.y) < 20) {
        AudioSys.sfx.secret(); // Zelda-style secret discovery tune
        VibrationSystem.onSecretFound(); // Vibrate on secret discovery
        showDialog("You found a hidden exit!\n\nYou step through the fire door into the Amazon yard...", "SECRET", GFX.secretIcon, false);
        GAME.nextState = 'YARD_INTRO';
        return true;
    }

    // Check if player is near Quartermaster's Safety Cage
    if (GAME.quartermasterDoor && Math.hypot(p.x - GAME.quartermasterDoor.x, p.y - GAME.quartermasterDoor.y) < 32) {
        AudioSys.sfx.text(); // Door interaction sound
        GAME.lastPlayerPos = { x: p.x, y: p.y }; // Save position for return
        GAME.ppeDialogChoice = 0; // Reset to first option
        GAME.ppeDialogShown = false;
        GAME.state = 'PPE_DIALOG';
        GAME.stateTimer = 0;
        return true;
    }

    for (let i=0; i<GAME.entities.length; i++) {
        let e = GAME.entities[i];
        if (e.type === 'runner' && Math.hypot(p.x-e.x, p.y-e.y) < 20) {
             e.type = 'assoc'; GAME.issuesFixed++; updateHud(); AudioSys.sfx.fix();
             VibrationSystem.onHazardFixed(); // Vibrate on hazard fix
             spawnFloatingText(GAME.player.x, GAME.player.y - 24, "+200", "#22c55e"); // Score indicator

             // Award safety points for stopping runner (75-125 SP)
             const runnerPoints = 75 + Math.floor(Math.random() * 50);
             GAME.safetyPoints += runnerPoints;
             spawnFloatingText(e.x, e.y - 16, "+" + runnerPoints + " " + getLocalizedText('sp_short'), "#22d3ee");
             spawnFloatingText(e.x, e.y, getLocalizedText('safe'), "#00ff00");
             saveGameProgress(); // Auto-save progress

             if (GAME.issuesFixed >= 5) { queueVisitorSplash(); }

             // SIMON COMMENTARY
             const currentGen = GAME.genId;

             // --- CHANGED: Show thinking state immediately for responsiveness ---
             showThinking("Simon", GFX.simonFaceLarge);

             const safetyContext = getRegionSafetyContext();
             const regionName = getRegionName();
             const langInstRunner = getLanguageInstruction();
             callGemini(
                 `You are Simon, WHS Senior Regional Manager in ${regionName}. Personality: bone-dry humor, deadpan delivery, secretly enjoys quoting regulations with a hint of sarcasm. The player stopped a runner. Give dry, brief praise with subtle wit, then quote the specific regulation (e.g. "DGUV Regel 108-007: No running in warehouse areas"). Be sardonic but professional. No "Safety Tip:" prefix. Max 30 words. ${safetyContext} ${langInstRunner}`,
                 "runners"
             ).then(tip => {
                if (GAME.genId === currentGen) showDialog(`Runner!\n${tip}`, "Simon", GFX.simonFaceLarge, true);
             });
             return true;
        }
    }
    for(let h of GAME.activeIssues) {
        // Apply interact range bonus from Knee Pads PPE
        const interactRange = GAME.ppeUnlocked.includes('knee_pads') ? 30 : 20;
        if (!h.fixed && Math.hypot(p.x-h.x, p.y-h.y) < interactRange) {
            h.fixed = true; GAME.issuesFixed++; updateHud(); AudioSys.sfx.fix();
            VibrationSystem.onHazardFixed(); // Vibrate on hazard fix
            spawnFloatingText(GAME.player.x, GAME.player.y - 24, "+200", "#22c55e"); // Score indicator
            if (h.hiddenDoor && GAME.hiddenDoor) GAME.hiddenDoor.unlocked = true;

            // Award safety points (100-200 based on hazard type)
            const pointsAwarded = 100 + Math.floor(Math.random() * 100);
            GAME.safetyPoints += pointsAwarded;
            spawnFloatingText(h.x, h.y - 16, "+" + pointsAwarded + " " + getLocalizedText('sp_short'), "#22d3ee");
            spawnFloatingText(h.x, h.y, getLocalizedText('fixed'), "#00ff00");
            saveGameProgress(); // Auto-save progress

            if (GAME.issuesFixed >= 5) { queueVisitorSplash(); }

            // Store current hazard for detail display option
            GAME.currentHazard = h;

            // SIMON COMMENTARY
            const currentGen = GAME.genId;

            // --- CHANGED: Show thinking state immediately ---
            showThinking("Simon", GFX.simonFaceLarge);

            const safetyCtx = getRegionSafetyContext();
            const regName = getRegionName();
            const langInstHazard = getLanguageInstruction();
            callGemini(
                `You are Simon, WHS Senior Regional Manager in ${regName}. Personality: bone-dry humor, deadpan delivery, secretly enjoys quoting regulations with a hint of sarcasm. A hazard "${h.data.name}" was fixed. Give dry, brief praise with subtle wit, then quote the specific regulation (e.g. "According to DGUV Vorschrift 68: ..."). Be sardonic but professional. No "Safety Tip:" prefix. Max 30 words. ${safetyCtx} ${langInstHazard}`,
                "hazard",
                { hazardName: h.data.name }
            ).then(tip => {
                if (GAME.genId === currentGen) showHazardDialog(`${h.data.name}!\n${tip}`, "Simon", GFX.simonFaceLarge, true, h);
            });
            return true;
        }
    }
    if (GAME.hiddenDoor && GAME.hiddenDoor.unlocked) {
        const dx = GAME.player.x - GAME.hiddenDoor.doorX * TILE_SIZE;
        const dy = GAME.player.y - GAME.hiddenDoor.doorY * TILE_SIZE;
        if (Math.hypot(dx, dy) < 18) {
            GAME.state = 'YARD_INTRO';
            GAME.stateTimer = 0;
            GAME.nextState = 'YARD_LEVEL';
            GAME.projectiles = [];
            updateMusicForState();
            return true;
        }
    }
    return false;
}

// Helper to get random item from array
function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function triggerGameOver(reason) {
    GAME.gameOverTriggered = true; GAME.nextState = 'TITLE'; GAME.state = 'LOSE_SPLASH'; GAME.splashTimer = 320; GAME.aiResultText = null; GAME.stateTimer = 0;
    GAME.gameOverPhase = 0; // Track voice phases: 0=corporate, 1=character, 2=simon
    stopPortraitAnimation();
    VibrationSystem.onGameOver(); // Vibrate on game over
    document.getElementById('boss-hud').style.display = 'none'; document.getElementById('dialog-box').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';

    // Get snarky corporate message and character defeat line
    GAME.corporateMessage = pickRandom(CORPORATE_GAME_OVER);
    const charLines = CHARACTER_DEFEAT_LINES[GAME.selectedChar] || CHARACTER_DEFEAT_LINES["Carrie"];
    GAME.characterDefeatLine = pickRandom(charLines);
    GAME.gameOverReason = reason;

    // Special message for Mecha Mega Simon defeat
    if (GAME.mechaSimonDefeat) {
        GAME.corporateMessage = "MECHA MEGA SIMON has achieved ultimate safety compliance. All resistance has been optimized.";
        GAME.characterDefeatLine = "No one could have survived that transformation...";
    }

    // Stop current music and play game over music
    MusicSys.stop();
    MusicSys.currentName = null;
    MusicSys.play('menu'); // Game Over But Not Really track

    const time = Math.floor((Date.now() - GAME.startTime)/1000); const currentGen = GAME.genId;
    const langInstLoss = getLanguageInstruction();
    if (reason === "FIRED!") { GAME.aiResultText = "Terminated for unsafe behavior."; }
    else if (GAME.mechaSimonDefeat) {
        // Special Mecha Mega Simon performance review
        const stats = { time, hazards: GAME.issuesFixed, books: GAME.booksFired, ops: GAME.opsPushed };
        callGemini(`You are MECHA MEGA SIMON, the ultimate WHS authority. You just transformed into your unstoppable mecha form and defeated the coordinator. Deliver a terrifying mechanical performance review explaining how your transformation made you invincible and how no human could ever hope to defeat pure safety compliance given form. Mention that this defeat will be permanently recorded on their performance review that will be delivered to your ultimate form - MECHA MEGA SIMON. Remind them that Mega Simon's transformation was triggered by their futile resistance. Max 70 words. ${langInstLoss}`, "reviews_loss", { stats }).then(review => {
             if (GAME.genId === currentGen) { GAME.aiResultText = review; }
        });
    }
    else {
        const stats = { time, hazards: GAME.issuesFixed, books: GAME.booksFired, ops: GAME.opsPushed };
        callGemini(`You are Simon, WHS Senior Regional Manager. Coordinator failed after ${time} seconds with ${GAME.issuesFixed}/5 hazards fixed, ${GAME.booksFired} rule books thrown, ${GAME.opsPushed} ops pushed. Deliver a scathing yet funny performance review that weaves those stats into a safety lesson. Threaten that their failure will be permanently documented and sent to upper management for review. Max 55 words. ${langInstLoss}`, "reviews_loss", { stats }).then(review => {
             if (GAME.genId === currentGen) { GAME.aiResultText = review; }
        });
    }
}

function winGame() {
    AudioSys.sfx.start(); MusicSys.play('victory'); GAME.nextState = 'NAME_ENTRY'; GAME.creditsType = 'normal'; GAME.state = 'WIN_SPLASH'; GAME.splashTimer = 260; GAME.aiResultText = null; GAME.stateTimer = 0;
    stopPortraitAnimation();
    VibrationSystem.onVictory(); // Vibrate on victory
    document.getElementById('boss-hud').style.display = 'none'; document.getElementById('dialog-box').style.display = 'none';
    document.getElementById('hud-layer').style.display = 'none';

    // Prepare highscore entry with the boss that was defeated
    const bossName = GAME.boss ? GAME.boss.originalName || GAME.boss.name : 'Unknown Boss';
    prepareHighscoreEntry(bossName);

    const currentGen = GAME.genId; const time = Math.floor((Date.now() - GAME.startTime)/1000);
    const finalScore = GAME.pendingHighscore ? GAME.pendingHighscore.score : 0;
    const stats = { time, hazards: GAME.issuesFixed, books: GAME.booksFired, ops: GAME.opsPushed, score: finalScore };
    const langInstWin = getLanguageInstruction();
    callGemini(`You are Simon, WHS Senior Regional Manager. Coordinator won in ${time} seconds clearing ${GAME.issuesFixed}/5 hazards, tossing ${GAME.booksFired} rule books, redirecting ${GAME.opsPushed} ops. Their final score: ${finalScore} points! Give warm but witty praise mentioning their score, plus one practical safety takeaway. Max 60 words. ${langInstWin}`, "reviews_win", { stats }).then(praise => {
        if (GAME.genId === currentGen) GAME.aiResultText = praise;
    });
}

function updateBossHud() { if(GAME.boss) document.getElementById('boss-health-el').style.width = Math.max(0, (GAME.boss.hp / GAME.boss.maxHp) * 100) + '%'; }

function checkCol(x, y) {
    let tx = Math.floor((x+8)/TILE_SIZE); let ty = Math.floor((y+8)/TILE_SIZE);
    if (tx<0||tx>=MAP_W||ty<0||ty>=MAP_H) return true;
    return GAME.map[ty][tx] !== 0;
}

function updateHud() {
    document.getElementById('life-val').innerText = "‚ù§Ô∏è".repeat(Math.max(0, GAME.lives));
    document.getElementById('score-val').innerText = GAME.issuesFixed + "/5";
    // Update safety points display
    const spEl = document.getElementById('sp-val');
    if (spEl) spEl.innerText = GAME.safetyPoints;
    // Update region indicator
    const regionEl = document.getElementById('region-val');
    if (regionEl) regionEl.innerText = GAME.region;
    // Update real-time score display
    const hsEl = document.getElementById('highscore-val');
    if (hsEl) {
        GAME.currentScore = calculateCurrentScore();
        hsEl.innerText = GAME.currentScore;
    }
    // Update PPE buffs display
    updatePpeBuffsHud();
}

// Update PPE buffs HUD display
function updatePpeBuffsHud() {
    const ppeBuffsEl = document.getElementById('ppe-buffs');
    const ppeBuffsValEl = document.getElementById('ppe-buffs-val');
    if (!ppeBuffsEl || !ppeBuffsValEl) return;

    if (GAME.ppeUnlocked && GAME.ppeUnlocked.length > 0) {
        // Build buff icons string
        const buffIcons = GAME.ppeUnlocked.map(id => {
            const item = PPE_ITEMS.find(p => p.id === id);
            if (!item) return '';
            // Return icon for each PPE item
            switch(id) {
                case 'shoes': return 'üëü';
                case 'vest': return 'ü¶∫';
                case 'eardef': return 'üéß';
                case 'gloves': return 'üß§';
                case 'goggles': return 'ü•Ω';
                case 'belt': return 'üí™';
                case 'bumpcap': return '‚õëÔ∏è';
                case 'hydration': return 'üíß';
                case 'kneepads': return 'ü¶µ';
                case 'walkietalkie': return 'üìª';
                case 'exosuit': return 'ü§ñ';
                case 'arhelmet': return 'üîÆ';
                case 'quantumshield': return '‚ö°';
                default: return 'üõ°Ô∏è';
            }
        }).filter(i => i).join('');

        ppeBuffsValEl.innerText = buffIcons;
        ppeBuffsEl.style.display = 'block';
    } else {
        ppeBuffsEl.style.display = 'none';
    }
}

// === HIGHSCORE SYSTEM ===

// Calculate current score in real-time during gameplay
function calculateCurrentScore() {
    // Start with 5000 points
    let score = 5000;

    // Time penalty: lose 100 points every 10 seconds
    const elapsedTime = GAME.startTime ? Math.floor((Date.now() - GAME.startTime) / 1000) : 0;
    const currentTimePenaltyCount = Math.floor(elapsedTime / 10);
    const timePenalty = currentTimePenaltyCount * 100;
    score -= timePenalty;

    // Show floating indicator when time penalty increases (only during gameplay states)
    if (currentTimePenaltyCount > GAME.lastTimePenaltyCount && GAME.player &&
        (GAME.state === 'PLAY' || GAME.state === 'BOSS' || GAME.state === 'MECHA_BOSS')) {
        GAME.lastTimePenaltyCount = currentTimePenaltyCount;
        spawnFloatingText(GAME.player.x, GAME.player.y - 24, "-100", "#ef4444"); // Time penalty indicator
    }

    // Penalty for missed book throws: -200 each
    score -= (GAME.booksMissed || 0) * 200;

    // Penalty for hitting Simon: -500 each
    score -= (GAME.simonHitsCount || 0) * 500;

    // GAINS:
    // Hazards fixed: +200 points each
    score += (GAME.issuesFixed || 0) * 200;

    // Combat bonus: +50 per book that hit, +100 per ops pushed
    // booksFired tracks successful hits, so use that
    score += (GAME.booksFired || 0) * 50;
    score += (GAME.opsPushed || 0) * 100;

    // Lives remaining: +100 points each
    score += Math.max(0, GAME.lives || 0) * 100;

    // Bonus score from collectibles in yard level
    score += GAME.score || 0;

    // === PPE BUFF: Back Support Belt - Score Multiplier ===
    const scoreBuff = getPPEBuffValue('score');
    if (scoreBuff > 0) {
        score = Math.floor(score * (1 + scoreBuff));
    }

    // Minimum score is 0
    return Math.max(0, Math.floor(score));
}

// Calculate final score when game is won
function calculateFinalScore(bossDefeated) {
    let score = calculateCurrentScore();

    // Boss Kill bonus: +1000 points
    score += 1000;

    // Mecha Jeff bonus: +5000 points
    if (bossDefeated === "Mecha Jeff") {
        score += 5000;
    }

    return Math.floor(score);
}

// Fetch highscores from server
async function fetchHighscores() {
    try {
        const response = await fetch('/.netlify/functions/highscores');
        const data = await response.json();
        if (data.success) {
            GAME.highscores = data.highscores || [];
            GAME.highscoresLoaded = true;
        }
    } catch (e) {
        console.warn('Could not fetch highscores:', e);
        GAME.highscores = [];
    }
}

// Submit a new highscore to server with retry logic
async function submitHighscore(entry, retryCount = 0) {
    const MAX_RETRIES = 3;
    const RETRY_DELAYS = [1000, 2000, 4000]; // Exponential backoff

    try {
        const response = await fetch('/.netlify/functions/highscores', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(entry)
        });
        const data = await response.json();
        if (data.success) {
            GAME.highscores = data.highscores || [];
            GAME.highscoreSubmitted = true;
            return data;
        } else if (data.retryable && retryCount < MAX_RETRIES) {
            // Storage temporarily unavailable - retry with backoff
            console.log(`Highscore save retry ${retryCount + 1}/${MAX_RETRIES}...`);
            await new Promise(r => setTimeout(r, RETRY_DELAYS[retryCount]));
            return submitHighscore(entry, retryCount + 1);
        } else {
            // Server returned an error but we can still continue
            console.warn('Highscore submission failed:', data.error);
            GAME.highscores = data.highscores || [];
            return { success: false, submitted: false };
        }
    } catch (e) {
        if (retryCount < MAX_RETRIES) {
            // Network error - retry with backoff
            console.log(`Network retry ${retryCount + 1}/${MAX_RETRIES}...`);
            await new Promise(r => setTimeout(r, RETRY_DELAYS[retryCount]));
            return submitHighscore(entry, retryCount + 1);
        }
        console.warn('Could not submit highscore:', e);
        // Network error - allow player to continue anyway
        return { success: false, submitted: false, networkError: true };
    }
}

// Prepare highscore entry after winning
function prepareHighscoreEntry(bossDefeated) {
    const time = Math.floor((Date.now() - GAME.startTime) / 1000);
    const finalScore = calculateFinalScore(bossDefeated);

    GAME.pendingHighscore = {
        name: '',
        character: GAME.selectedChar,
        time: time,
        hazardsFixed: GAME.issuesFixed,
        booksFired: GAME.booksFired,
        opsPushed: GAME.opsPushed,
        booksMissed: GAME.booksMissed,
        simonHitsCount: GAME.simonHitsCount,
        livesRemaining: Math.max(0, GAME.lives),
        bossDefeated: bossDefeated,
        region: GAME.region,
        score: finalScore
    };

    GAME.lastDefeatedBoss = bossDefeated;
    GAME.nameEntry = '';
    GAME.nameEntryIndex = 0;
    GAME.highscoreSubmitted = false;
}

// Name entry character set
const NAME_ENTRY_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_- ';
let nameEntryCharIndex = 0;

// Handle name entry input
function handleNameEntryInput(key) {
    if (GAME.highscoreSubmitted) {
        // After submission, any key advances to credits/highscores
        if (key === 'space' || key === 'enter' || key === 'submit') {
            if (GAME.lastDefeatedBoss === 'Mecha Jeff') {
                GAME.state = 'HIGHSCORES';
            } else {
                GAME.state = 'CREDITS';
                GAME.stateTimer = 0; // Reset timer so credits start from beginning
                GAME.creditsStarted = false; // Ensure startCredits() is called
                updateMusicForState(); // Play credits music
            }
        }
        return;
    }

    if (key === 'left') {
        nameEntryCharIndex = (nameEntryCharIndex - 1 + NAME_ENTRY_CHARS.length) % NAME_ENTRY_CHARS.length;
        AudioSys.sfx.text();
    } else if (key === 'right') {
        nameEntryCharIndex = (nameEntryCharIndex + 1) % NAME_ENTRY_CHARS.length;
        AudioSys.sfx.text();
    } else if (key === 'up') {
        nameEntryCharIndex = (nameEntryCharIndex - 10 + NAME_ENTRY_CHARS.length) % NAME_ENTRY_CHARS.length;
        AudioSys.sfx.text();
    } else if (key === 'down') {
        nameEntryCharIndex = (nameEntryCharIndex + 10) % NAME_ENTRY_CHARS.length;
        AudioSys.sfx.text();
    } else if (key === 'space' || key === 'enter') {
        // Confirm current character or submit
        if (GAME.nameEntry.length < 5) {
            const selectedChar = NAME_ENTRY_CHARS[nameEntryCharIndex];
            GAME.nameEntry += selectedChar;
            AudioSys.sfx.fix();

            // Auto-submit when 5 characters reached
            if (GAME.nameEntry.length === 5) {
                submitPlayerHighscore();
            }
        }
    } else if (key === 'back') {
        // Delete last character
        if (GAME.nameEntry.length > 0) {
            GAME.nameEntry = GAME.nameEntry.slice(0, -1);
            AudioSys.sfx.hurt();
        }
    } else if (key === 'submit') {
        // Force submit with current name (if at least 1 char)
        if (GAME.nameEntry.length > 0) {
            submitPlayerHighscore();
        }
    }
}

// Submit player's highscore
async function submitPlayerHighscore() {
    if (!GAME.pendingHighscore || GAME.highscoreSubmitted) return;

    GAME.pendingHighscore.name = GAME.nameEntry.trim() || 'ANON';
    AudioSys.sfx.start();

    const result = await submitHighscore(GAME.pendingHighscore);
    // Always mark as submitted so player can continue, even if server failed
    GAME.highscoreSubmitted = true;
    if (result && result.success) {
        GAME.pendingHighscore.rank = result.rank;
    } else {
        // Server failed but we'll still let them continue
        // Mark as submitted without a rank
        GAME.pendingHighscore.rank = null;
        GAME.pendingHighscore.submissionFailed = true;
    }
}

// Draw name entry screen
function drawNameEntry() {
    const t = GAME.stateTimer;

    // Victory background gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#0a102a');
    gradient.addColorStop(0.5, '#0d1b4c');
    gradient.addColorStop(1, '#000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Animated stars
    for (let i = 0; i < 20; i++) {
        const x = (i * 37 + t * 0.5) % canvas.width;
        const y = (i * 61) % canvas.height;
        const twinkle = Math.sin(t * 0.1 + i) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${twinkle * 0.6})`;
        ctx.fillRect(x, y, 1, 1);
    }

    ctx.textAlign = 'center';

    // Title
    ctx.font = '12px "Press Start 2P"';
    ctx.fillStyle = '#ffd700';
    ctx.shadowColor = '#ff9900';
    ctx.shadowBlur = 10;
    ctx.fillText(getLocalizedText('new_high_score'), canvas.width / 2, 30);
    ctx.shadowBlur = 0;

    // Display score
    ctx.font = '16px "Press Start 2P"';
    ctx.fillStyle = '#fff';
    const score = GAME.pendingHighscore ? GAME.pendingHighscore.score : 0;
    ctx.fillText(score.toString(), canvas.width / 2, 55);

    // Stats display
    ctx.font = '6px "Press Start 2P"';
    ctx.fillStyle = '#94a3b8';
    const time = GAME.pendingHighscore ? GAME.pendingHighscore.time : 0;
    const mins = Math.floor(time / 60);
    const secs = time % 60;
    ctx.fillText(`TIME: ${mins}:${secs.toString().padStart(2, '0')}  CHAR: ${GAME.selectedChar.toUpperCase()}`, canvas.width / 2, 72);
    ctx.fillText(`BOSS: ${GAME.lastDefeatedBoss || 'Unknown'}`, canvas.width / 2, 84);

    if (GAME.highscoreSubmitted) {
        // Show submission confirmation
        ctx.font = '10px "Press Start 2P"';
        if (GAME.pendingHighscore && GAME.pendingHighscore.submissionFailed) {
            // Submission failed but player can continue
            ctx.fillStyle = '#f59e0b';
            ctx.fillText(getLocalizedText('score_saved'), canvas.width / 2, 110);
            ctx.font = '5px "Press Start 2P"';
            ctx.fillStyle = '#94a3b8';
            ctx.fillText(getLocalizedText('online_unavailable'), canvas.width / 2, 122);
        } else {
            ctx.fillStyle = '#22c55e';
            ctx.fillText(getLocalizedText('score_submitted'), canvas.width / 2, 110);
        }

        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = '#fff';
        ctx.fillText(`NAME: ${GAME.nameEntry}`, canvas.width / 2, 135);

        if (GAME.pendingHighscore && GAME.pendingHighscore.rank) {
            ctx.fillStyle = '#ffd700';
            ctx.fillText(`RANK: #${GAME.pendingHighscore.rank}`, canvas.width / 2, 150);
        }

        // Continue prompt
        const blink = Math.floor(t / 30) % 2 === 0;
        if (blink) {
            ctx.font = '7px "Press Start 2P"';
            ctx.fillStyle = '#666';
            ctx.fillText(getLocalizedText('space_tap_continue'), canvas.width / 2, 200);
        }
    } else {
        // Name entry prompt
        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = '#7dd3fc';
        ctx.fillText(getLocalizedText('enter_your_name'), canvas.width / 2, 100);
        ctx.font = '6px "Press Start 2P"';
        ctx.fillStyle = '#666';
        ctx.fillText(getLocalizedText('chars_max'), canvas.width / 2, 112);

        // Name display boxes
        const boxSize = 20;
        const totalWidth = 5 * boxSize + 4 * 4;
        const startX = (canvas.width - totalWidth) / 2;

        for (let i = 0; i < 5; i++) {
            const bx = startX + i * (boxSize + 4);
            const by = 122;

            // Box background
            ctx.fillStyle = i < GAME.nameEntry.length ? '#1e3a5f' : '#0a1525';
            ctx.fillRect(bx, by, boxSize, boxSize);

            // Box border
            ctx.strokeStyle = i === GAME.nameEntry.length ? '#ffd700' : '#3b82f6';
            ctx.lineWidth = i === GAME.nameEntry.length ? 2 : 1;
            ctx.strokeRect(bx, by, boxSize, boxSize);

            // Character in box
            if (i < GAME.nameEntry.length) {
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#fff';
                ctx.fillText(GAME.nameEntry[i], bx + boxSize / 2, by + 15);
            } else if (i === GAME.nameEntry.length) {
                // Show current selection with blink
                const blink = Math.floor(t / 15) % 2 === 0;
                if (blink) {
                    ctx.font = '12px "Press Start 2P"';
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText(NAME_ENTRY_CHARS[nameEntryCharIndex], bx + boxSize / 2, by + 15);
                }
            }
        }

        // Character selection wheel
        ctx.font = '8px "Press Start 2P"';
        const wheelY = 160;

        // Show surrounding characters
        for (let offset = -4; offset <= 4; offset++) {
            const idx = (nameEntryCharIndex + offset + NAME_ENTRY_CHARS.length) % NAME_ENTRY_CHARS.length;
            const charX = canvas.width / 2 + offset * 16;
            const isSelected = offset === 0;

            ctx.fillStyle = isSelected ? '#ffd700' : `rgba(148, 163, 184, ${1 - Math.abs(offset) * 0.2})`;
            ctx.font = isSelected ? '10px "Press Start 2P"' : '8px "Press Start 2P"';

            const char = NAME_ENTRY_CHARS[idx] === ' ' ? '_' : NAME_ENTRY_CHARS[idx];
            ctx.fillText(char, charX, wheelY);
        }

        // Selection indicator
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2 - 6, wheelY - 15);
        ctx.lineTo(canvas.width / 2 + 6, wheelY - 15);
        ctx.lineTo(canvas.width / 2, wheelY - 10);
        ctx.fill();

        // Controls hint
        ctx.font = '5px "Press Start 2P"';
        ctx.fillStyle = '#666';
        ctx.fillText('< > SELECT   SPACE ADD   BACK DEL', canvas.width / 2, 180);

        // Submit early option
        if (GAME.nameEntry.length > 0) {
            const blink = Math.floor(t / 30) % 2 === 0;
            if (blink) {
                ctx.font = '6px "Press Start 2P"';
                ctx.fillStyle = '#22c55e';
                ctx.fillText('[ENTER TO SUBMIT]', canvas.width / 2, 195);
            }
        }

        // Draw touch buttons for mobile
        drawNameEntryTouchButtons();
    }

    ctx.textAlign = 'left';
}

// Draw highscore table
function drawHighscores() {
    const t = GAME.stateTimer;

    // Dark background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#050510');
    gradient.addColorStop(0.5, '#0a1525');
    gradient.addColorStop(1, '#000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Animated grid lines
    ctx.strokeStyle = 'rgba(34, 211, 238, 0.1)';
    ctx.lineWidth = 1;
    const offset = (t * 0.5) % 16;
    for (let y = offset; y < canvas.height; y += 16) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }

    ctx.textAlign = 'center';

    // Title with glow
    ctx.font = '12px "Press Start 2P"';
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 10;
    ctx.fillStyle = '#ffd700';
    ctx.fillText(getLocalizedText('hall_of_compliance'), canvas.width / 2, 22);
    ctx.shadowBlur = 0;

    // Column headers
    ctx.font = '5px "Press Start 2P"';
    ctx.fillStyle = '#7dd3fc';
    ctx.textAlign = 'left';
    ctx.fillText(getLocalizedText('rank'), 8, 38);
    ctx.fillText(getLocalizedText('name'), 28, 38);
    ctx.fillText(getLocalizedText('score'), 70, 38);
    ctx.fillText(getLocalizedText('char'), 115, 38);
    ctx.fillText(getLocalizedText('time'), 160, 38);
    ctx.fillText(getLocalizedText('boss'), 195, 38);

    // Separator line
    ctx.fillStyle = '#3b82f6';
    ctx.fillRect(5, 42, canvas.width - 10, 1);

    // Highscore entries
    const entries = GAME.highscores.slice(0, 10);
    const rowHeight = 16;
    const startY = 55;

    entries.forEach((entry, i) => {
        const y = startY + i * rowHeight;
        const isNew = GAME.pendingHighscore && entry.date === GAME.pendingHighscore.date;

        // Highlight new entry
        if (isNew) {
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(5, y - 10, canvas.width - 10, rowHeight);
        }

        ctx.font = '6px "Press Start 2P"';

        // Rank
        const rankColors = ['#ffd700', '#c0c0c0', '#cd7f32'];
        ctx.fillStyle = i < 3 ? rankColors[i] : '#94a3b8';
        ctx.textAlign = 'left';
        ctx.fillText(`${i + 1}.`, 8, y);

        // Name
        ctx.fillStyle = isNew ? '#ffd700' : '#fff';
        ctx.fillText(entry.name || 'ANON', 28, y);

        // Score
        ctx.fillStyle = isNew ? '#ffd700' : '#22c55e';
        ctx.fillText(entry.score.toString(), 70, y);

        // Character (abbreviated)
        ctx.fillStyle = '#a855f7';
        const charAbbrev = (entry.character || '???').substring(0, 4).toUpperCase();
        ctx.fillText(charAbbrev, 115, y);

        // Time
        ctx.fillStyle = '#7dd3fc';
        const mins = Math.floor((entry.time || 0) / 60);
        const secs = (entry.time || 0) % 60;
        ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}`, 160, y);

        // Boss (abbreviated)
        ctx.fillStyle = '#f87171';
        const bossAbbrev = (entry.bossDefeated || '???').substring(0, 6);
        ctx.font = '5px "Press Start 2P"';
        ctx.fillText(bossAbbrev, 195, y);
    });

    // Empty slots
    for (let i = entries.length; i < 10; i++) {
        const y = startY + i * rowHeight;
        ctx.font = '6px "Press Start 2P"';
        ctx.fillStyle = '#333';
        ctx.textAlign = 'left';
        ctx.fillText(`${i + 1}.`, 8, y);
        ctx.fillText('---', 28, y);
        ctx.fillText('---', 70, y);
        ctx.fillText('---', 115, y);
        ctx.fillText('---', 160, y);
        ctx.fillText('---', 195, y);
    }

    // Continue prompt
    const blink = Math.floor(t / 30) % 2 === 0;
    if (blink) {
        ctx.textAlign = 'center';
        ctx.font = '6px "Press Start 2P"';
        ctx.fillStyle = '#666';
        ctx.fillText(getLocalizedText('space_tap_continue'), canvas.width / 2, 218);
    }

    ctx.textAlign = 'left';
}

// Store touch button positions for name entry
let nameEntryTouchButtons = {};

// Draw touch buttons for name entry (mobile only)
function drawNameEntryTouchButtons() {
    // Only show touch buttons on mobile devices
    if (!isMobileDevice) return;

    const btnW = 35;
    const btnH = 22;
    const btnY = 200;
    const gap = 8;

    // Calculate positions
    const leftBtn = { x: 20, y: btnY, w: btnW, h: btnH };
    const rightBtn = { x: 20 + btnW + gap, y: btnY, w: btnW, h: btnH };
    const addBtn = { x: canvas.width / 2 - btnW / 2, y: btnY, w: btnW, h: btnH };
    const delBtn = { x: canvas.width - 20 - btnW * 2 - gap, y: btnY, w: btnW, h: btnH };
    const submitBtn = { x: canvas.width - 20 - btnW, y: btnY, w: btnW, h: btnH };

    // Store for touch detection
    nameEntryTouchButtons = { left: leftBtn, right: rightBtn, add: addBtn, del: delBtn, submit: submitBtn };

    // Draw buttons
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'center';

    // Left arrow
    ctx.fillStyle = '#1e3a5f';
    ctx.fillRect(leftBtn.x, leftBtn.y, leftBtn.w, leftBtn.h);
    ctx.strokeStyle = '#3b82f6';
    ctx.strokeRect(leftBtn.x, leftBtn.y, leftBtn.w, leftBtn.h);
    ctx.fillStyle = '#fff';
    ctx.fillText('<', leftBtn.x + leftBtn.w / 2, leftBtn.y + 15);

    // Right arrow
    ctx.fillStyle = '#1e3a5f';
    ctx.fillRect(rightBtn.x, rightBtn.y, rightBtn.w, rightBtn.h);
    ctx.strokeStyle = '#3b82f6';
    ctx.strokeRect(rightBtn.x, rightBtn.y, rightBtn.w, rightBtn.h);
    ctx.fillStyle = '#fff';
    ctx.fillText('>', rightBtn.x + rightBtn.w / 2, rightBtn.y + 15);

    // Add character button
    ctx.fillStyle = '#1e4d3a';
    ctx.fillRect(addBtn.x, addBtn.y, addBtn.w, addBtn.h);
    ctx.strokeStyle = '#22c55e';
    ctx.strokeRect(addBtn.x, addBtn.y, addBtn.w, addBtn.h);
    ctx.fillStyle = '#22c55e';
    ctx.fillText('ADD', addBtn.x + addBtn.w / 2, addBtn.y + 15);

    // Delete button
    ctx.fillStyle = '#4d1e1e';
    ctx.fillRect(delBtn.x, delBtn.y, delBtn.w, delBtn.h);
    ctx.strokeStyle = '#ef4444';
    ctx.strokeRect(delBtn.x, delBtn.y, delBtn.w, delBtn.h);
    ctx.fillStyle = '#ef4444';
    ctx.fillText('DEL', delBtn.x + delBtn.w / 2, delBtn.y + 15);

    // Submit button (only if name has characters)
    if (GAME.nameEntry.length > 0) {
        ctx.fillStyle = '#4d3a1e';
        ctx.fillRect(submitBtn.x, submitBtn.y, submitBtn.w, submitBtn.h);
        ctx.strokeStyle = '#ffd700';
        ctx.strokeRect(submitBtn.x, submitBtn.y, submitBtn.w, submitBtn.h);
        ctx.fillStyle = '#ffd700';
        ctx.fillText('OK', submitBtn.x + submitBtn.w / 2, submitBtn.y + 15);
    }

    ctx.textAlign = 'left';
}

// Helper function to start portrait talking animation
function startPortraitAnimation(basePortrait, talkingPortrait) {
    // Stop any existing animation
    if (GAME.portraitAnimInterval) {
        clearInterval(GAME.portraitAnimInterval);
    }

    GAME.currentPortraitBase = basePortrait;
    GAME.currentPortraitTalking = talkingPortrait;
    GAME.portraitTalkPhase = false;

    const port = document.getElementById('portrait');
    const pCtx = port.getContext('2d');
    const pw = basePortrait.width || 48;
    const ph = basePortrait.height || 48;

    // Pre-draw the base portrait with black background to avoid flash
    pCtx.fillStyle = '#000';
    pCtx.fillRect(0, 0, 48, 48);
    pCtx.imageSmoothingEnabled = false;
    pCtx.drawImage(basePortrait, 0, 0, pw, ph, 0, 0, 48, 48);

    // Animate between normal and talking at 6 FPS (every ~166ms)
    GAME.portraitAnimInterval = setInterval(() => {
        GAME.portraitTalkPhase = !GAME.portraitTalkPhase;
        // Fill with black first, then draw portrait (prevents flash)
        pCtx.fillStyle = '#000';
        pCtx.fillRect(0, 0, 48, 48);
        pCtx.imageSmoothingEnabled = false;
        if (GAME.portraitTalkPhase && talkingPortrait) {
            const tw = talkingPortrait.width || 48;
            const th = talkingPortrait.height || 48;
            pCtx.drawImage(talkingPortrait, 0, 0, tw, th, 0, 0, 48, 48);
        } else {
            pCtx.drawImage(basePortrait, 0, 0, pw, ph, 0, 0, 48, 48);
        }
    }, 166);
}

// Helper function to stop portrait animation
function stopPortraitAnimation() {
    if (GAME.portraitAnimInterval) {
        clearInterval(GAME.portraitAnimInterval);
        GAME.portraitAnimInterval = null;
    }
    // Clear speaker tracking to prevent wrong portrait showing
    GAME.currentIntroSpeaker = null;
}

// Helper function to start INTRO portrait talking animation (larger, centered)
function startIntroPortraitAnimation(speaker) {
    // Stop any existing animation FIRST
    if (GAME.portraitAnimInterval) {
        clearInterval(GAME.portraitAnimInterval);
        GAME.portraitAnimInterval = null;
    }

    const basePortrait = GFX.introPortraits[speaker];
    const talkingPortrait = GFX.introPortraitsTalking[speaker];

    if (!basePortrait || !talkingPortrait) return;

    // Store in GAME so animation uses current values, not stale closure
    GAME.currentPortraitBase = basePortrait;
    GAME.currentPortraitTalking = talkingPortrait;
    GAME.portraitTalkPhase = false;
    GAME.currentIntroSpeaker = speaker;

    const port = document.getElementById('intro-portrait');
    const pCtx = port.getContext('2d');

    // Pre-draw the base portrait with black background
    pCtx.fillStyle = '#000';
    pCtx.fillRect(0, 0, 96, 96);
    pCtx.imageSmoothingEnabled = false;
    pCtx.drawImage(basePortrait, 0, 0);

    // Animate between normal and talking at 6 FPS (every ~166ms)
    // Read from GAME.current* each frame to use latest portraits
    GAME.portraitAnimInterval = setInterval(() => {
        // Safety check: don't draw if speaker changed or window hidden
        if (GAME.currentIntroSpeaker !== speaker ||
            document.getElementById('intro-portrait-window').style.display !== 'block') {
            clearInterval(GAME.portraitAnimInterval);
            GAME.portraitAnimInterval = null;
            return;
        }

        GAME.portraitTalkPhase = !GAME.portraitTalkPhase;

        // Use GAME.current* to always get the correct portraits
        const base = GAME.currentPortraitBase;
        const talking = GAME.currentPortraitTalking;

        if (!base) return;

        pCtx.fillStyle = '#000';
        pCtx.fillRect(0, 0, 96, 96);
        pCtx.imageSmoothingEnabled = false;
        if (GAME.portraitTalkPhase && talking) {
            pCtx.drawImage(talking, 0, 0);
        } else {
            pCtx.drawImage(base, 0, 0);
        }
    }, 166);
}

// Show intro portrait window (for intro conversation only)
function showIntroDialog(text, speaker, isAI = false) {
    // IMPORTANT: Stop any existing portrait animation FIRST to prevent flashing
    stopPortraitAnimation();

    // Hide regular dialog box
    document.getElementById('dialog-box').style.display = 'none';

    // Show intro window
    const window = document.getElementById('intro-portrait-window');
    const nameEl = document.getElementById('intro-speaker-name');
    const badge = document.getElementById('intro-gemini-badge');
    const textContent = document.getElementById('intro-text-content');
    const port = document.getElementById('intro-portrait');
    const pCtx = port.getContext('2d');

    window.style.display = 'block';
    nameEl.innerText = speaker;
    textContent.innerText = "";

    // Hide badge for intro window (name already shown in dedicated element)
    badge.style.display = 'none';

    // Store dialog text for typewriter effect
    GAME.state = 'DIALOG';
    GAME.dialogText = text;
    GAME.dialogVisible = "";

    // Draw portrait - clear canvas completely first to prevent old portrait showing
    pCtx.clearRect(0, 0, 96, 96);
    pCtx.fillStyle = '#000';
    pCtx.fillRect(0, 0, 96, 96);
    const portrait = GFX.introPortraits[speaker];
    if (portrait) {
        pCtx.imageSmoothingEnabled = false;
        pCtx.drawImage(portrait, 0, 0);
        // Start animation after portrait is drawn
        startIntroPortraitAnimation(speaker);
    }

    AudioSys.sfx.text();
    if (speaker) speakTTS(text, speaker);
}

// Show thinking state in intro window
function showIntroThinking(speaker) {
    // Stop any talking animation while thinking
    stopPortraitAnimation();

    // Hide regular dialog box
    document.getElementById('dialog-box').style.display = 'none';

    // Show intro window
    const window = document.getElementById('intro-portrait-window');
    const nameEl = document.getElementById('intro-speaker-name');
    const badge = document.getElementById('intro-gemini-badge');
    const textContent = document.getElementById('intro-text-content');
    const port = document.getElementById('intro-portrait');
    const pCtx = port.getContext('2d');

    window.style.display = 'block';
    nameEl.innerText = speaker;
    textContent.innerHTML = "<span class='loading-dots'>PROCESSING</span>";

    // Hide badge for intro window (name already shown in dedicated element)
    badge.style.display = 'none';

    GAME.state = 'DIALOG';
    GAME.dialogText = "";
    GAME.dialogVisible = "";

    // Draw portrait
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,96,96);
    const portrait = GFX.introPortraits[speaker];
    if (portrait) pCtx.drawImage(portrait, 0, 0);

    AudioSys.sfx.text();
}

// Close intro window
function closeIntroDialog() {
    stopPortraitAnimation();
    cancelTTS();
    AudioSys.sfx.step();
    document.getElementById('intro-portrait-window').style.display = 'none';
    GAME.state = GAME.nextState;

    // If transitioning to name entry for highscore, initialize
    if (GAME.state === 'NAME_ENTRY') {
        GAME.stateTimer = 0;
        nameEntryCharIndex = 0;
        return;
    }

    // If transitioning to credits, initialize immediately (before next draw call)
    if (GAME.state === 'CREDITS') {
        startCredits();
        return;
    }

    // Handle intro dialogue sequence - player responds to Simon in INTRO WINDOW
    if (GAME.state === 'INTRO_DIALOGUE_CONTINUE') {
        const currentGen = GAME.genId;

        showIntroThinking(GAME.selectedChar);
        GAME.nextState = 'PLAY'; // After player response, start the game

        // Get character personality for response
        const charData = CHAR_DATA[GAME.selectedChar] || {};
        const personality = charData.backstory || "a dedicated WHS coordinator";

        // Generate player's enthusiastic response (localized)
        const langInstPlayer = getLanguageInstruction();
        callGemini(`You are ${GAME.selectedChar}, ${personality}. Simon just explained your mission: find 5 safety hazards and dodge ops interruptions. Respond enthusiastically that you'll do your best not to disappoint him. Keep it short, in-character, and determined. Max 25 words. ${langInstPlayer}`, "player_response").then(text => {
            if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
                let finalText = text.replace(/\[.*?\]/g, GAME.selectedChar);
                showIntroDialog(finalText, GAME.selectedChar, true);
            }
        });
        return;
    }

    // Handle Jeff Bezos dialogue sequence - advance to next dialogue in throne room
    if (GAME.state === 'JEFF_DIALOGUE_CONTINUE') {
        bezosDialogueStep++;
        showNextBezosIntroDialogue();
        return;
    }

    // Handle BEZOS_DIALOGUE_NEXT for backwards compatibility
    if (GAME.state === 'BEZOS_DIALOGUE_NEXT') {
        bezosDialogueStep++;
        showNextBezosIntroDialogue();
        return;
    }
}

// Show performance evaluation using intro dialog with happy/disappointed Simon
function showPerformanceEvalIntroDialog(text, isWin) {
    // Hide regular dialog box
    document.getElementById('dialog-box').style.display = 'none';

    // Show intro window
    const window = document.getElementById('intro-portrait-window');
    const nameEl = document.getElementById('intro-speaker-name');
    const badge = document.getElementById('intro-gemini-badge');
    const textContent = document.getElementById('intro-text-content');
    const port = document.getElementById('intro-portrait');
    const pCtx = port.getContext('2d');

    window.style.display = 'block';
    nameEl.innerText = isWin ? getLocalizedText('performance_review') : getLocalizedText('exit_interview');
    textContent.innerText = "";

    // Hide badge for intro window (name already shown in dedicated element)
    badge.style.display = 'none';

    // Store dialog text for typewriter effect
    GAME.state = 'DIALOG';
    GAME.dialogText = text;
    GAME.dialogVisible = "";

    // Draw appropriate portrait (happy for win, disappointed for loss)
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,96,96);
    const portraitKey = isWin ? "Simon Happy" : "Simon Disappointed";
    const portrait = GFX.introPortraits[portraitKey];
    if (portrait) {
        pCtx.drawImage(portrait, 0, 0);
    }

    AudioSys.sfx.text();
    speakTTS(text.replace(/\n/g, ' '), "Simon");
}

function showDialog(text, speaker, portrait, isAI = false) {
    // IMPORTANT: Stop any existing portrait animation FIRST to prevent flashing
    stopPortraitAnimation();

    // Store previous state for background rendering during dialog
    // Don't overwrite if we're in the Bezos dialogue sequence (keep THRONE_CONFRONTATION)
    if (GAME.state !== 'DIALOG' && GAME.state !== 'BEZOS_DIALOGUE_NEXT' && GAME.state !== 'JEFF_DIALOGUE_CONTINUE') {
        GAME.dialogBackgroundState = GAME.state;
    }
    GAME.state = 'DIALOG'; GAME.dialogText = text; GAME.dialogVisible = "";
    GAME.hasHazardDetail = false; // No detail available for regular dialogs
    const box = document.getElementById('dialog-box'); const badge = document.getElementById('gemini-badge'); const port = document.getElementById('portrait'); const pCtx = port.getContext('2d');
    box.style.display = 'flex'; document.getElementById('text-content').innerText = "";
    // Show speaker name in badge with special color
    badge.style.display = speaker ? 'block' : 'none';
    badge.innerHTML = speaker ? speaker.toUpperCase() : "";
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,48,48);
    if (portrait) {
        // Scale portrait to 48x48 if needed (handles smaller boss sprites)
        pCtx.imageSmoothingEnabled = false;
        const pw = portrait.width || 48;
        const ph = portrait.height || 48;
        pCtx.drawImage(portrait, 0, 0, pw, ph, 0, 0, 48, 48);

        // Start talking animation if we have a talking variant
        let talkingPortrait = null;
        if (speaker === "Simon") {
            talkingPortrait = GFX.simonFaceTalking;
        } else if (GFX.charFacesTalking[speaker]) {
            talkingPortrait = GFX.charFacesTalking[speaker];
        }

        if (talkingPortrait) {
            startPortraitAnimation(portrait, talkingPortrait);
        }
    } else {
        pCtx.fillStyle='#fff'; pCtx.fillText("!", 10, 20);
    }
    AudioSys.sfx.text();
    if (speaker) speakTTS(text.replace(/\n/g, ' '), speaker);
}

// Show dialog with hazard detail option (press UP for regulatory info)
function showHazardDialog(text, speaker, portrait, isAI = false, hazard = null) {
    // IMPORTANT: Stop any existing portrait animation FIRST to prevent flashing
    stopPortraitAnimation();

    // Store previous state for background rendering during dialog
    if (GAME.state !== 'DIALOG' && GAME.state !== 'BEZOS_DIALOGUE_NEXT' && GAME.state !== 'JEFF_DIALOGUE_CONTINUE') {
        GAME.dialogBackgroundState = GAME.state;
    }
    GAME.state = 'DIALOG'; GAME.dialogText = text; GAME.dialogVisible = "";
    GAME.hasHazardDetail = !!hazard; // Enable detail option if hazard provided
    GAME.currentHazard = hazard;
    GAME.showingHazardDetail = false; // Not showing detail yet

    const box = document.getElementById('dialog-box'); const badge = document.getElementById('gemini-badge'); const port = document.getElementById('portrait'); const pCtx = port.getContext('2d');
    box.style.display = 'flex'; document.getElementById('text-content').innerText = "";
    badge.style.display = speaker ? 'block' : 'none';
    badge.innerHTML = speaker ? speaker.toUpperCase() : "";
    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,48,48);
    if (portrait) {
        pCtx.imageSmoothingEnabled = false;
        const pw = portrait.width || 48;
        const ph = portrait.height || 48;
        pCtx.drawImage(portrait, 0, 0, pw, ph, 0, 0, 48, 48);

        let talkingPortrait = null;
        if (speaker === "Simon") {
            talkingPortrait = GFX.simonFaceTalking;
        } else if (GFX.charFacesTalking[speaker]) {
            talkingPortrait = GFX.charFacesTalking[speaker];
        }

        if (talkingPortrait) {
            startPortraitAnimation(portrait, talkingPortrait);
        }
    } else {
        pCtx.fillStyle='#fff'; pCtx.fillText("!", 10, 20);
    }
    AudioSys.sfx.text();
    if (speaker) speakTTS(text.replace(/\n/g, ' '), speaker);
}

// Show hazard regulatory detail information in Audit Page modal
function showHazardDetail() {
    if (!GAME.currentHazard) return;

    AudioSys.sfx.select();
    GAME.showingHazardDetail = true;
    GAME.hasHazardDetail = false; // Disable further UP presses

    // Hide the regular dialog box
    document.getElementById('dialog-box').style.display = 'none';
    cancelTTS();

    const hazardName = GAME.currentHazard.data.name;
    const hazardType = GAME.currentHazard.data.type;
    const hazardRegion = GAME.currentHazard.data.region || GAME.region || 'US';
    const regionName = getRegionName();
    const safetyContext = getRegionSafetyContext();
    const langInst = getLanguageInstruction();

    // Initialize modal state with loading
    GAME.hazardModal = {
        loading: true,
        hazardName: hazardName,
        hazardType: hazardType,
        region: hazardRegion,
        regionName: regionName,
        regulation: '',
        title: '',
        summary: '',
        penalty: '',
        scrollOffset: 0,
        maxScroll: 0
    };

    // Switch to modal state
    GAME.previousState = GAME.state;
    GAME.state = 'HAZARD_DETAIL_MODAL';
    GAME.stateTimer = 0;

    // Build the AI prompt for regulatory information (Simon's dry humor personality)
    // IMPORTANT: Limit summary to ~100 words max for better readability
    let prompt;
    if (hazardRegion === 'MEU') {
        // Multi-country comparison mode for MEU
        prompt = `You are Simon, WHS Senior Regional Manager. Provide a brief regulatory summary for this warehouse hazard:

Hazard: "${hazardName}"

Respond with EXACTLY this format:
REGULATION: EU Multi-country
TITLE: ${hazardName}
SUMMARY: In 2-3 SHORT sentences (max 80 words total), explain why this is dangerous and the key safety rule. Be direct and practical.
PENALTY: Varies by country

Keep it simple and readable. Respond in English.`;
    } else {
        prompt = `You are Simon, WHS Senior Regional Manager. Provide brief regulatory info for this hazard:

Hazard: "${hazardName}"
Region: ${regionName}

Respond with EXACTLY this format:
REGULATION: [Specific regulation code for this region]
TITLE: [Short title]
SUMMARY: In 2-3 SHORT sentences (max 80 words total), explain why this is dangerous and what safety rules apply. Be direct.
PENALTY: [Typical fine amount]

${safetyContext}
Be specific but concise. For Germany cite DGUV. For Austria cite ASchG. For Netherlands cite Arbowet.
${langInst}`;
    }

    const currentGen = GAME.genId;
    const fallbackDetail = getHazardDetail(GAME.currentHazard);

    // Call Gemini AI for regulatory information
    callGemini(prompt, "hazard_regulation", { hazardName, hazardType, region: hazardRegion })
        .then(response => {
            if (GAME.genId !== currentGen || GAME.state !== 'HAZARD_DETAIL_MODAL') return;

            // Parse the response into structured data
            if (response && response !== "FALLBACK_USE_STATIC" &&
                response.includes('REGULATION:') && response.length > 50) {
                // Parse AI response
                const regMatch = response.match(/REGULATION:\s*(.+?)(?=\nTITLE:|$)/is);
                const titleMatch = response.match(/TITLE:\s*(.+?)(?=\nSUMMARY:|$)/is);
                const summaryMatch = response.match(/SUMMARY:\s*(.+?)(?=\nPENALTY:|$)/is);
                const penaltyMatch = response.match(/PENALTY:\s*(.+?)$/is);

                GAME.hazardModal.regulation = regMatch ? regMatch[1].trim() : 'N/A';
                GAME.hazardModal.title = titleMatch ? titleMatch[1].trim() : 'Safety Regulation';
                GAME.hazardModal.summary = summaryMatch ? summaryMatch[1].trim() : 'Follow established safety procedures.';
                GAME.hazardModal.penalty = penaltyMatch ? penaltyMatch[1].trim() : 'Varies by jurisdiction';
            } else if (fallbackDetail) {
                GAME.hazardModal.regulation = fallbackDetail.regulation;
                GAME.hazardModal.title = fallbackDetail.title;
                GAME.hazardModal.summary = fallbackDetail.detail;
                GAME.hazardModal.penalty = fallbackDetail.penalty;
            } else {
                GAME.hazardModal.regulation = 'General Safety Standards';
                GAME.hazardModal.title = 'Workplace Safety';
                GAME.hazardModal.summary = 'This hazard poses risks to worker safety. Follow established safety procedures and report concerns to your supervisor.';
                GAME.hazardModal.penalty = 'Varies by jurisdiction';
            }
            GAME.hazardModal.loading = false;

            // Speak regulation citation and summary (keep brief for max length)
            const reg = GAME.hazardModal.regulation;
            const lawQuote = reg && reg !== 'N/A' ? `Per ${reg}: ` : '';
            speakTTS(`${lawQuote}${GAME.hazardModal.summary}`, "Simon");
        })
        .catch(() => {
            if (GAME.genId !== currentGen || GAME.state !== 'HAZARD_DETAIL_MODAL') return;

            // Fallback to static details on error
            if (fallbackDetail) {
                GAME.hazardModal.regulation = fallbackDetail.regulation;
                GAME.hazardModal.title = fallbackDetail.title;
                GAME.hazardModal.summary = fallbackDetail.detail;
                GAME.hazardModal.penalty = fallbackDetail.penalty;
            } else {
                GAME.hazardModal.regulation = 'General Safety Standards';
                GAME.hazardModal.title = 'Workplace Safety';
                GAME.hazardModal.summary = 'This hazard poses risks to worker safety. Follow established safety procedures.';
                GAME.hazardModal.penalty = 'Varies by jurisdiction';
            }
            GAME.hazardModal.loading = false;

            // Speak regulation citation and summary (keep brief for max length)
            const reg = GAME.hazardModal.regulation;
            const lawQuote = reg && reg !== 'N/A' ? `Per ${reg}: ` : '';
            speakTTS(`${lawQuote}${GAME.hazardModal.summary}`, "Simon");
        });
}

// Close hazard detail modal and return to game
function closeHazardDetailModal() {
    GAME.showingHazardDetail = false;
    GAME.hazardModal = null;
    GAME.state = 'PLAY';
    GAME.nextState = 'PLAY';
    cancelTTS();
    AudioSys.sfx.select();
}

// Exit PPE Shop and return to game at saved position
function exitPPEShop() {
    if (GAME.lastPlayerPos) {
        GAME.player.x = GAME.lastPlayerPos.x;
        GAME.player.y = GAME.lastPlayerPos.y;
    }
    GAME.state = 'PLAY';
    GAME.nextState = 'PLAY';
    GAME.shopMessage = '';
    GAME.shopMessageTimer = 0;
    AudioSys.sfx.select();
    // Auto-save after exiting shop
    saveGameProgress();
}

// === SAVE/LOAD SYSTEM FOR PPE AND SAFETY POINTS ===
function saveGameProgress() {
    try {
        const saveData = {
            safetyPoints: GAME.safetyPoints,
            ppeUnlocked: GAME.ppeUnlocked,
            region: GAME.region,
            savedAt: Date.now()
        };
        localStorage.setItem('amzl_whs_quest_save', JSON.stringify(saveData));
    } catch (e) {
        console.warn('Could not save game progress:', e);
    }
}

function loadGameProgress() {
    try {
        const saveStr = localStorage.getItem('amzl_whs_quest_save');
        if (saveStr) {
            const saveData = JSON.parse(saveStr);
            if (saveData.safetyPoints !== undefined) GAME.safetyPoints = saveData.safetyPoints;
            if (Array.isArray(saveData.ppeUnlocked)) GAME.ppeUnlocked = saveData.ppeUnlocked;
            // Optionally restore region
            if (saveData.region && GAME.regionList.includes(saveData.region)) {
                GAME.region = saveData.region;
                GAME.regionIndex = GAME.regionList.indexOf(saveData.region);
            }
            console.log('Loaded save data:', saveData);
        }
    } catch (e) {
        console.warn('Could not load game progress:', e);
    }
}

// Clear save data (for debugging/reset)
function clearSaveData() {
    try {
        localStorage.removeItem('amzl_whs_quest_save');
        GAME.safetyPoints = 0;
        GAME.ppeUnlocked = [];
        console.log('Save data cleared');
    } catch (e) {
        console.warn('Could not clear save data:', e);
    }
}

// --- NEW FUNCTION: Show "Thinking" state ---
function showThinking(speaker, portrait) {
    // Store previous state for background rendering during dialog
    // Don't overwrite if we're in the Bezos dialogue sequence (keep THRONE_CONFRONTATION)
    if (GAME.state !== 'DIALOG' && GAME.state !== 'BEZOS_DIALOGUE_NEXT' && GAME.state !== 'JEFF_DIALOGUE_CONTINUE') {
        GAME.dialogBackgroundState = GAME.state;
    }

    // Stop any talking animation while thinking
    stopPortraitAnimation();

    GAME.state = 'DIALOG';
    GAME.dialogText = ""; // No typed text yet
    GAME.dialogVisible = "";
    const box = document.getElementById('dialog-box');
    const badge = document.getElementById('gemini-badge');
    const port = document.getElementById('portrait');
    const pCtx = port.getContext('2d');

    box.style.display = 'flex';
    document.getElementById('text-content').innerHTML = "<span class='loading-dots'>PROCESSING</span>"; // Loading animation

    badge.style.display = 'block';
    badge.innerText = speaker ? speaker.toUpperCase() : "";

    pCtx.fillStyle = '#000'; pCtx.fillRect(0,0,48,48);
    if (portrait) {
        // Scale portrait to 48x48 if needed (handles smaller boss sprites)
        pCtx.imageSmoothingEnabled = false;
        const pw = portrait.width || 48;
        const ph = portrait.height || 48;
        pCtx.drawImage(portrait, 0, 0, pw, ph, 0, 0, 48, 48);
    }

    AudioSys.sfx.text();
}

// === BEZOS CONFRONTATION DIALOGUE SYSTEM ===
// Uses INTRO dialog window (like Simon) for epic throne room confrontation
let bezosDialogueStep = 0;

function startBezosConfrontationDialogue() {
    bezosDialogueStep = 0;
    showNextBezosIntroDialogue();
}

function showNextBezosIntroDialogue() {
    const currentGen = GAME.genId;
    const scene = GAME.throneScene;
    const langInst = getLanguageInstruction();

    // Dialogue steps: Bezos taunts, player responds, Bezos transforms
    const dialoguePrompts = [
        {
            speaker: "Jeff Bezos",
            prompt: `You are Jeff Bezos, megalomaniac CEO sitting on your golden Amazon throne. A ${GAME.selectedChar} warehouse worker just survived your gauntlet. Deliver an arrogant opening taunt about how pathetic their attempt is. Reference Prime delivery or ownership principles. Max 25 words. ${langInst}`,
            category: "bezos_confrontation"
        },
        {
            speaker: GAME.selectedChar,
            prompt: `You are ${GAME.selectedChar}, a brave warehouse worker confronting evil Jeff Bezos. Deliver a defiant one-liner about ending his reign of terror over workers. Be heroic and determined. Max 20 words. ${langInst}`,
            category: "player_response"
        },
        {
            speaker: "Jeff Bezos",
            prompt: `You are Jeff Bezos, enraged that a worker dares challenge you. Announce your transformation into your TRUE FORM - Mecha Jeff. Be dramatic, megalomaniacal, and terrifying. Reference your ultimate power. Max 25 words. ${langInst}`,
            category: "bezos_transform"
        }
    ];

    if (bezosDialogueStep >= dialoguePrompts.length) {
        // All dialogues done, proceed to transformation
        stopPortraitAnimation();
        document.getElementById('intro-portrait-window').style.display = 'none';
        GAME.state = 'MECHA_TRANSFORM';
        GAME.stateTimer = 0;
        GAME.nextState = 'MECHA_TRANSFORM';
        GAME.dialogBackgroundState = null;
        return;
    }

    const step = dialoguePrompts[bezosDialogueStep];

    // IMPORTANT: Set background state to throne confrontation so it renders behind dialog
    GAME.dialogBackgroundState = 'THRONE_CONFRONTATION';

    // Show thinking state in intro window
    showIntroThinking(step.speaker);
    GAME.nextState = 'JEFF_DIALOGUE_CONTINUE';

    callGemini(step.prompt, step.category).then(text => {
        if (GAME.genId === currentGen) {
            let finalText = text.replace(/\[.*?\]/g, GAME.selectedChar);
            // Remove speaker name prefix if AI included it
            finalText = finalText.replace(/^JEFF BEZOS:?\s*/i, '').replace(/^Jeff Bezos:?\s*/i, '');
            showIntroDialog(finalText, step.speaker, true);
        }
    });
}

function closeDialog() {
    stopPortraitAnimation(); // Stop talking animation
    cancelTTS(); AudioSys.sfx.step(); document.getElementById('dialog-box').style.display = 'none';

    // Clear hazard detail state
    GAME.currentHazard = null;
    GAME.hasHazardDetail = false;
    GAME.showingHazardDetail = false;

    GAME.state = GAME.nextState;

    // If transitioning to credits, initialize immediately (before next draw call)
    if (GAME.state === 'CREDITS') {
        startCredits();
        return;
    }

    // Handle boss taunt player reply (LOCALIZED)
    if (GAME.state === 'BOSS_TAUNT_PLAYER_REPLY' && GAME.boss) {
        const currentGen = GAME.genId;
        const playerPortrait = GFX.charFaces[GAME.selectedChar]; // Use 48x48 face portrait, not 16x16 sprite
        const charData = CHAR_DATA[GAME.selectedChar] || {};
        const personality = charData.backstory || "a dedicated WHS coordinator";
        const langInstSnark = getLanguageInstruction();

        // Localized snarky hardcoded responses based on region
        const getSnarkyReplies = () => {
            const region = GAME.region;
            if (region === 'AT') {
                return [
                    "Oida, des soll mi erschreckn? I hab Schlimmeres w√§hrend Peak Season gsehn.",
                    "Gro√üe Reden f√ºr an, der gegen an Lagerarbeiter verliert.",
                    "Red weiter. Es hilft dir ned.",
                    "Oh nein, a Drohung. Wie originell.",
                    "Fertig? I hab Arbeit zum mochn.",
                    "Wow, wer is do verzweifelt?",
                    "Des is alles? Entt√§uschend.",
                    "Spar da den Vortrag. Mochn ma weiter.",
                    "Ernst jetzt? DES is dei Einsch√ºchterungstaktik?",
                    "I hab besseres Geschimpf vom Stapler gh√∂rt."
                ];
            } else if (region === 'DE') {
                return [
                    "Das soll mich erschrecken? Ich hab Schlimmeres w√§hrend Peak Season erlebt.",
                    "Gro√üe Worte f√ºr jemanden, der gegen einen Lagerarbeiter verliert.",
                    "Red weiter. Es hilft dir nicht.",
                    "Oh nein, eine Drohung. Wie originell.",
                    "Fertig? Ich hab Arbeit zu erledigen.",
                    "Wow, jemand ist verzweifelt.",
                    "Das ist alles? Entt√§uschend.",
                    "Spar dir die Rede. Machen wir weiter.",
                    "Ernsthaft? DAS ist deine Einsch√ºchterungstaktik?",
                    "Ich hab besseres Gerede vom Gabelstapler geh√∂rt."
                ];
            } else if (region === 'NL') {
                return [
                    "Moet dat me bang maken? Ik heb erger meegemaakt tijdens peak season.",
                    "Grote woorden voor iemand die verliest van een magazijnmedewerker.",
                    "Blijf praten. Het helpt je niet.",
                    "Oh nee, een dreiging. Hoe origineel.",
                    "Klaar? Ik heb werk te doen.",
                    "Wow, iemand is wanhopig.",
                    "Is dat alles? Teleurstellend.",
                    "Bespaar me het praatje. Laten we doorgaan.",
                    "Echt? DAT is je intimidatietactiek?",
                    "Ik heb betere praatjes gehoord van een heftruck."
                ];
            }
            // Default English (MEU or fallback)
            return [
                "Is that supposed to scare me? I've dealt with worse during peak season.",
                "Bold words for someone losing a fight to a warehouse worker.",
                "Keep talking. It's not helping your case.",
                "Oh no, a threat. How original.",
                "You done? I've got work to do.",
                "Wow, someone's desperate.",
                "That the best you've got? Disappointing.",
                "Save the speech. Let's just get this over with.",
                "Really? THAT'S your intimidation tactic?",
                "I've heard better trash talk from a forklift."
            ];
        };

        const snarkyReplies = getSnarkyReplies();

        showThinking(GAME.selectedChar, playerPortrait);
        GAME.nextState = 'BOSS'; // After player response, return to boss fight

        // 70% chance AI-generated, 30% chance hardcoded snarky reply
        if (Math.random() < 0.7) {
            // AI-generated snarky response based on boss taunt and player personality (LOCALIZED)
            const bossContext = GAME.boss.name === "SIMON" || GAME.boss.name === "MEGA SIMON" ?
                "Simon is your boss who questions your safety commitment" :
                `${GAME.boss.name} is an Amazon executive who underestimates you`;
            callGemini(`You are ${GAME.selectedChar}, ${personality}. ${bossContext}. The boss just taunted you. Respond with a snarky, defiant comeback that references their weakness and shows your confidence. Be witty, in-character, and use your unique personality. Max 20 words. ${langInstSnark}`, "player_snark").then(text => {
                if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
                    showDialog(text, GAME.selectedChar, playerPortrait, true);
                }
            });
        } else {
            // Hardcoded snarky reply (LOCALIZED)
            const reply = snarkyReplies[Math.floor(Math.random() * snarkyReplies.length)];
            setTimeout(() => {
                if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
                    showDialog(reply, GAME.selectedChar, playerPortrait, false);
                }
            }, 500);
        }
        return;
    }

    // Handle intro dialogue sequence - player responds to Simon in INTRO WINDOW
    if (GAME.state === 'INTRO_DIALOGUE_CONTINUE') {
        const currentGen = GAME.genId;

        showIntroThinking(GAME.selectedChar);
        GAME.nextState = 'PLAY'; // After player response, start the game

        // Get character personality for response
        const charData = CHAR_DATA[GAME.selectedChar] || {};
        const personality = charData.backstory || "a dedicated WHS coordinator";

        // Generate player's enthusiastic response (localized)
        const langInstPlayer2 = getLanguageInstruction();
        callGemini(`You are ${GAME.selectedChar}, ${personality}. Simon just explained your mission: find 5 safety hazards and dodge ops interruptions. Respond enthusiastically that you'll do your best not to disappoint him. Keep it short, in-character, and determined. Max 25 words. ${langInstPlayer2}`, "player_response").then(text => {
            if (GAME.state === 'DIALOG' && GAME.genId === currentGen) {
                let finalText = text.replace(/\[.*?\]/g, GAME.selectedChar);
                showIntroDialog(finalText, GAME.selectedChar, true);
            }
        });
        return;
    }

    // Handle Simon fake victory dialogue sequence
    if (GAME.state === 'SIMON_FAKE_VICTORY_CONTINUE' || GAME.state === 'SIMON_FAKE_VICTORY_TRANSFORM') {
        handleFakeVictoryDialogClose();
        return;
    }

    // Handle boss defeat cutscene dialogue sequence
    if (GAME.state === 'BOSS_DEFEAT_CUTSCENE_CONTINUE' || GAME.state === 'BOSS_DEFEAT_CUTSCENE_END') {
        handleDefeatCutsceneDialogClose();
        return;
    }

    // Handle Bezos dialogue sequence - now uses intro dialog system
    if (GAME.state === 'BEZOS_DIALOGUE_NEXT' || GAME.state === 'JEFF_DIALOGUE_CONTINUE') {
        bezosDialogueStep++;
        showNextBezosIntroDialogue();
        return;
    }

    // Handle BEZOS_ESCAPE dialogue sequence (snarky exchange)
    if (GAME.state === 'BEZOS_ESCAPE_DIALOGUE' && GAME.escapeScene) {
        // Advance to next escape dialogue
        const nextIndex = GAME.escapeScene.dialogueStep + 1;
        showBezosEscapeDialogue(nextIndex);
        return;
    }

    // Handle Mecha Jeff's defeat one-liner (after phase 0)
    if (GAME.state === 'BEZOS_ESCAPE_MECHA_LINE' && GAME.escapeScene) {
        // After Mecha Jeff's one-liner, proceed to explosion (phase 2)
        GAME.state = 'BEZOS_ESCAPE';
        GAME.escapeScene.phase = 2;
        GAME.escapeScene.phaseTimer = 0;
        GAME.escapeScene.explosionParticles = [];
        return;
    }

    // Handle Jeff's one-liner after transformation (after phase 3)
    if (GAME.state === 'BEZOS_ESCAPE_JEFF_LINE' && GAME.escapeScene) {
        // After Jeff's one-liner, proceed to running to rocket (phase 5)
        GAME.state = 'BEZOS_ESCAPE';
        GAME.escapeScene.phase = 5;
        GAME.escapeScene.phaseTimer = 0;
        // Reset Jeff position for the run
        GAME.escapeScene.jeffX = GAME.escapeScene.startJeffX || canvas.width / 2;
        GAME.escapeScene.jeffY = canvas.height - 70;
        return;
    }

    // Handle BEZOS_ESCAPE dialogue continuation (Simon's congratulations)
    if (GAME.state === 'BEZOS_ESCAPE' && GAME.escapeScene && GAME.escapeScene.phase === 8) {
        // Continue phase 8 animation after Simon's dialog
        GAME.stateTimer = GAME.escapeScene.phaseTimer || 0;
        return;
    }

    if (GAME.state === 'VISITOR_SPLASH') { showVisitorSplash(); return; }

    // Handle GAMEOVER_SPLASH - reset stateTimer for animation
    if (GAME.state === 'GAMEOVER_SPLASH') {
        GAME.stateTimer = 0;
        return;
    }

    // Only start yard level if not already initialized (prevents infinite loop)
    if (GAME.state === 'YARD_LEVEL' && !GAME.yard) { startYardLevel(); return; }
    if (GAME.state === 'MECHA_BOSS_INTRO') { beginMechaEncounter(); return; }
    if (GAME.state === 'CREDITS' && !GAME.creditsStarted) { startCredits(); return; }

    if (GAME.state === 'PLAY' && GAME.pendingBossIntro && !GAME.boss) {
        showVisitorSplash();
        return;
    }
    if (GAME.state === 'PLAY' && GAME.issuesFixed >= 5 && !GAME.boss && !GAME.pendingBossIntro) {
        queueVisitorSplash();
        showVisitorSplash();
        return;
    }

    updateMusicForState();
}

function updateMusicForState() {
    // Don't change music during dialogues - let current track continue
    if (GAME.state === 'DIALOG') return;

    let rate = 1;
    let track = 'title';

    // Title EE Productions - for LOGO intro screen (7 seconds, non-looping)
    if (GAME.state === 'LOGO') track = 'intro';
    // Pixel Reverie - for Menus (intro, story, title, how to play)
    else if (['INTRO', 'STORY', 'TITLE', 'HOWTO'].includes(GAME.state)) track = 'title';
    // Pixel Reverie - for character select screen (same as title/menus)
    else if (GAME.state === 'SELECT') track = 'title';
    // Pixel Warehouse Crawl - for warehouse gameplay
    else if (GAME.state === 'PLAY') track = 'ingame';
    // Level-Yard - for yard/outdoor level (only when actually in yard, not during Simon's safety tip)
    else if (GAME.state === 'YARD_LEVEL') track = 'yard';
    // YARD_INTRO - keep title music playing during Simon's safety tip dialog
    else if (GAME.state === 'YARD_INTRO') track = 'title';
    // Pixel Panic - for boss reveals (regular bosses only)
    else if (GAME.state === 'VISITOR_SPLASH') track = 'boss';
    // MEGA SIMON's theme - for Simon boss intro, fight, and transformation
    else if (['BOSS_INTRO', 'SIMON_MECHA_TRANSFORM', 'MECHA_SIMON_SPLASH'].includes(GAME.state) &&
             GAME.boss && (GAME.boss.name === 'MEGA SIMON' || GAME.boss.name === 'MECHA MEGA SIMON')) {
        track = 'megaSimon';
    }
    // Pixel Panic - for regular boss intros
    else if (GAME.state === 'BOSS_INTRO') track = 'boss';
    // MEGA SIMON's theme - for Simon fight and fake victory sequence
    else if ((GAME.state === 'BOSS' || GAME.state === 'SIMON_FAKE_VICTORY') &&
             GAME.boss && (GAME.boss.name === 'MEGA SIMON' || GAME.boss.name === 'MECHA MEGA SIMON')) {
        track = 'megaSimon';
    }
    // SNES BOSS FIGHT MUSIC - for regular boss fights (5 random bosses)
    else if (GAME.state === 'BOSS') track = 'snesBoss';
    // MECHA JEFF THEME - for Mecha Jeff fight (after transformation)
    else if (['MECHA_BOSS', 'MECHA_BOSS_INTRO', 'MECHA_TRANSFORM'].includes(GAME.state)) track = 'mechaJeff';
    // SNES BOSS FIGHT MUSIC - for throne confrontation (before transformation)
    else if (GAME.state === 'THRONE_CONFRONTATION') track = 'snesBoss';
    // Pixel Victory - for beating the game
    else if (GAME.state === 'BEZOS_ESCAPE') track = 'victory';
    // Game Over Symphony - for both Credits Scenes
    else if (GAME.state === 'CREDITS') track = 'credits';
    // WIN_SPLASH - don't change music (handled in winGame function)
    else if (GAME.state === 'WIN_SPLASH') return;
    // LOSE_SPLASH and GAMEOVER_SPLASH - play game over music (Game Over But Not Really track)
    else if (GAME.state === 'LOSE_SPLASH' || GAME.state === 'GAMEOVER_SPLASH') {
        track = 'menu';
        // Force music change even if currently playing
        if (MusicSys.currentName !== 'menu') {
            MusicSys.stop();
            MusicSys.currentName = null;
        }
    }

    MusicSys.play(track, rate);
}

function drawSnesSplash(isWin) {
    const t = GAME.stateTimer;
    const primary = isWin ? '#0d1b4c' : '#2d0a0f';
    const accent = isWin ? '#7dd3fc' : '#f87171';
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, isWin ? '#0a102a' : '#1a0408');
    gradient.addColorStop(0.5, primary);
    gradient.addColorStop(1, '#000');
    ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Moving scanlines
    for (let y = 0; y < canvas.height; y += 8) {
        const offset = Math.sin((t / 8) + y * 0.12) * 3;
        ctx.fillStyle = `rgba(255,255,255,${isWin ? 0.05 : 0.04})`;
        ctx.fillRect(offset, y, canvas.width, 2);
    }

    // Mode-7 style horizon lines
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height * 0.65);
    for (let i = 0; i < 18; i++) {
        const scale = (i + 1) / 18;
        const wave = Math.sin((t / 10) + i * 0.6) * 4;
        const w = canvas.width * (1.1 - scale * 0.6);
        const y = i * 12 + wave;
        ctx.strokeStyle = `${accent}80`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-w / 2, y);
        ctx.lineTo(w / 2, y);
        ctx.stroke();
    }
    ctx.restore();

    // Star glints
    for (let i = 0; i < 14; i++) {
        const x = (Math.sin((t + i * 13) / 6) * 0.5 + 0.5) * canvas.width;
        const y = (i * 37 + t * 2) % canvas.height;
        const alpha = 0.25 + ((i % 3) * 0.1);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillRect(x, y, 2, 2);
        ctx.fillRect(x - 2, y, 6, 1);
        ctx.fillRect(x, y - 2, 1, 6);
    }

    ctx.textAlign = 'center';
    ctx.fillStyle = '#000';
    ctx.font = '22px monospace';
    const text = isWin ? 'COMPLIANT!' : 'TERMINATED';
    const shadowOffsets = [[2,2],[-2,2],[2,-2],[-2,-2]];
    shadowOffsets.forEach(([dx, dy]) => ctx.fillText(text, canvas.width/2 + dx, canvas.height/2 - 50 + dy));

    ctx.fillStyle = accent;
    ctx.fillText(text, canvas.width/2, canvas.height/2 - 50);

    // Game Over: Just show loading message like WIN_SPLASH - full content shows in Simon's dialog

    ctx.font = '11px monospace';
    ctx.fillStyle = '#fef9c3';
    const sub = isWin ? getLocalizedText('calculating_score') : getLocalizedText('preparing_exit');
    ctx.fillText(sub, canvas.width/2, canvas.height/2 + 55);
    ctx.textAlign = 'start';
}

// Game Over splash screen - shown after Simon's review dialog
function drawGameOverSplash() {
    const t = GAME.stateTimer;

    // Dark red gradient background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#1a0408');
    gradient.addColorStop(0.5, '#2d0a0f');
    gradient.addColorStop(1, '#000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Moving scanlines
    for (let y = 0; y < canvas.height; y += 8) {
        const offset = Math.sin((t / 8) + y * 0.12) * 3;
        ctx.fillStyle = `rgba(255,255,255,0.04)`;
        ctx.fillRect(offset, y, canvas.width, 2);
    }

    // Flickering vignette effect
    const vignetteAlpha = 0.4 + Math.sin(t / 20) * 0.1;
    const vignette = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width * 0.8);
    vignette.addColorStop(0, 'rgba(0,0,0,0)');
    vignette.addColorStop(1, `rgba(0,0,0,${vignetteAlpha})`);
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.textAlign = 'center';

    // "GAME OVER" text with dramatic shadow
    const gameOverText = getLocalizedText('game_over');
    ctx.font = 'bold 28px monospace';
    const shadowOffsets = [[3,3],[-3,3],[3,-3],[-3,-3],[0,4],[0,-4],[4,0],[-4,0]];
    shadowOffsets.forEach(([dx, dy]) => {
        ctx.fillStyle = '#000';
        ctx.fillText(gameOverText, canvas.width/2 + dx, canvas.height/2 - 30 + dy);
    });

    // Pulsing red text
    const pulse = 0.7 + Math.sin(t / 10) * 0.3;
    ctx.fillStyle = `rgba(248, 113, 113, ${pulse})`;
    ctx.fillText(gameOverText, canvas.width/2, canvas.height/2 - 30);

    // Corporate message
    ctx.font = '10px monospace';
    ctx.fillStyle = '#fef9c3';
    const corporateMsg = GAME.corporateMessage || 'Employment optimized.';
    wrapText(ctx, `"${corporateMsg}"`, canvas.width/2, canvas.height/2 + 20, canvas.width - 40, 14);

    // Character defeat line
    if (GAME.characterDefeatLine) {
        ctx.fillStyle = '#94a3b8';
        ctx.font = '9px monospace';
        const charLine = `${GAME.selectedChar}: "${GAME.characterDefeatLine}"`;
        wrapText(ctx, charLine, canvas.width/2, canvas.height/2 + 60, canvas.width - 40, 12);
    }

    // Press space prompt (after short delay)
    if (t > 120) {
        const blink = Math.floor(t / 30) % 2 === 0;
        if (blink) {
            ctx.font = '10px monospace';
            ctx.fillStyle = '#666';
            ctx.fillText(getLocalizedText('press_space_short'), canvas.width/2, canvas.height - 20);
        }
    }

    ctx.textAlign = 'start';
}

// Helper function for word wrapping text
function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    let currentY = y;
    ctx.textAlign = 'center';

    for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line.trim(), x, currentY);
            line = words[n] + ' ';
            currentY += lineHeight;
        } else {
            line = testLine;
        }
    }
    ctx.fillText(line.trim(), x, currentY);
}

function drawYardLevel() {
    const y = GAME.yard;
    const camY = y ? y.cameraY || 0 : 0;
    const totalHeight = y ? y.height : canvas.height;
    const hallwayStart = y ? y.hallwayStart : 250;
    const hallwayEnd = y ? y.castleStart : 650;

    ctx.save();
    ctx.translate(0, -camY);

    // === MASSIVE THRONE ROOM AT TOP (safe zone - no weapons) ===
    const throneRoomHeight = hallwayStart;

    // Dark throne room background with gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, throneRoomHeight);
    skyGrad.addColorStop(0, '#020206');
    skyGrad.addColorStop(0.3, '#050510');
    skyGrad.addColorStop(0.6, '#0a0a18');
    skyGrad.addColorStop(1, '#0f0f22');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, canvas.width, throneRoomHeight);

    // === THRONE ROOM FLOOR TILES ===
    const floorStart = Math.floor(throneRoomHeight * 0.5);
    for (let ty = floorStart; ty < throneRoomHeight; ty += 16) {
        for (let tx = 0; tx < canvas.width; tx += 16) {
            const isEven = ((tx / 16) + (ty / 16)) % 2 === 0;
            ctx.fillStyle = isEven ? '#1a1a28' : '#252535';
            ctx.fillRect(tx, ty, 16, 16);
            ctx.fillStyle = isEven ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.01)';
            ctx.fillRect(tx + 1, ty + 1, 6, 6);
        }
    }

    // === RED CARPET LEADING TO THRONE ===
    const carpetWidth = 70;
    const carpetX = canvas.width / 2 - carpetWidth / 2;
    ctx.fillStyle = '#7f1d1d';
    ctx.fillRect(carpetX, 0, carpetWidth, throneRoomHeight);
    ctx.fillStyle = '#991b1b';
    ctx.fillRect(carpetX + 8, 0, carpetWidth - 16, throneRoomHeight);
    ctx.fillStyle = '#b45309';
    ctx.fillRect(carpetX, 0, 4, throneRoomHeight);
    ctx.fillRect(carpetX + carpetWidth - 4, 0, 4, throneRoomHeight);
    ctx.fillStyle = '#fbbf24';
    for (let py = 20; py < throneRoomHeight; py += 40) {
        ctx.fillRect(carpetX + 22, py, 26, 3);
        ctx.fillRect(carpetX + 27, py + 6, 16, 3);
    }

    if (y) {
        const animFrame = y.jeffAnimFrame || 0;

        // === AMAZON WALL BANNERS ===
        const bannerY = 20;
        // Left banner with Amazon logo
        ctx.fillStyle = '#4a1010';
        ctx.fillRect(40, bannerY, 35, 70);
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(44, bannerY + 5, 27, 60);
        ctx.fillStyle = '#4a1010';
        ctx.beginPath();
        ctx.moveTo(44, bannerY + 40); ctx.quadraticCurveTo(57, bannerY + 55, 71, bannerY + 37);
        ctx.lineTo(71, bannerY + 42); ctx.quadraticCurveTo(57, bannerY + 60, 44, bannerY + 47); ctx.fill();

        // Right banner
        ctx.fillStyle = '#4a1010';
        ctx.fillRect(canvas.width - 75, bannerY, 35, 70);
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(canvas.width - 71, bannerY + 5, 27, 60);
        ctx.fillStyle = '#4a1010';
        ctx.beginPath();
        ctx.moveTo(canvas.width - 71, bannerY + 40); ctx.quadraticCurveTo(canvas.width - 58, bannerY + 55, canvas.width - 44, bannerY + 37);
        ctx.lineTo(canvas.width - 44, bannerY + 42); ctx.quadraticCurveTo(canvas.width - 58, bannerY + 60, canvas.width - 71, bannerY + 47); ctx.fill();

        // === ELEVATED THRONE PLATFORM ===
        const throneX = canvas.width / 2;
        const throneY = 45;

        // Stepped platform
        ctx.fillStyle = '#1a1520';
        ctx.fillRect(throneX - 80, 118, 160, 12);
        ctx.fillStyle = '#201828';
        ctx.fillRect(throneX - 70, 106, 140, 14);
        ctx.fillStyle = '#281e30';
        ctx.fillRect(throneX - 60, 94, 120, 14);

        // === MASSIVE GOLDEN THRONE ===
        ctx.fillStyle = '#2d1810';
        ctx.fillRect(throneX - 55, throneY - 25, 110, 75);
        ctx.fillStyle = '#4a2818';
        ctx.fillRect(throneX - 50, throneY - 20, 100, 65);
        ctx.fillStyle = '#5a3520';
        ctx.fillRect(throneX - 45, throneY - 15, 90, 55);

        // Throne spires
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(throneX - 52, throneY - 50, 12, 40);
        ctx.fillRect(throneX + 40, throneY - 50, 12, 40);
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(throneX - 52, throneY - 50);
        ctx.lineTo(throneX - 46, throneY - 70);
        ctx.lineTo(throneX - 40, throneY - 50);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(throneX + 40, throneY - 50);
        ctx.lineTo(throneX + 46, throneY - 70);
        ctx.lineTo(throneX + 52, throneY - 50);
        ctx.fill();
        ctx.fillStyle = '#dc2626';
        ctx.fillRect(throneX - 49, throneY - 45, 6, 6);
        ctx.fillRect(throneX + 43, throneY - 45, 6, 6);

        // Amazon logo on throne (glowing and pulsing)
        const logoPulse = Math.sin(animFrame * 0.08) * 0.2 + 0.8;
        ctx.fillStyle = `rgba(255, 153, 0, ${logoPulse})`;
        ctx.fillRect(throneX - 25, throneY, 50, 22);
        ctx.fillStyle = '#ffb347';
        ctx.fillRect(throneX - 20, throneY + 3, 40, 16);
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.moveTo(throneX - 15, throneY + 14);
        ctx.quadraticCurveTo(throneX, throneY + 24, throneX + 15, throneY + 11);
        ctx.lineTo(throneX + 20, throneY + 14);
        ctx.quadraticCurveTo(throneX, throneY + 30, throneX - 18, throneY + 17);
        ctx.fill();

        // Ornate throne armrests
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(throneX - 48, throneY + 30, 14, 25);
        ctx.fillRect(throneX + 34, throneY + 30, 14, 25);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(throneX - 45, throneY + 33, 8, 19);
        ctx.fillRect(throneX + 37, throneY + 33, 8, 19);

        // === MENACING GLOW BEHIND BEZOS ===
        const jeffX = canvas.width / 2 - 24;
        const jeffY = throneY + 5;
        const bobY = Math.sin(animFrame * 0.04) * 2;

        const glowSize = 60 + Math.sin(animFrame * 0.06) * 10;
        const glowGrad = ctx.createRadialGradient(jeffX + 24, jeffY + 24 + bobY, 8, jeffX + 24, jeffY + 24 + bobY, glowSize);
        glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.7)');
        glowGrad.addColorStop(0.3, 'rgba(220, 38, 38, 0.4)');
        glowGrad.addColorStop(0.6, 'rgba(139, 0, 0, 0.2)');
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(jeffX + 24, jeffY + 24 + bobY, glowSize, 0, Math.PI * 2);
        ctx.fill();

        // === DRAW BEZOS ON THRONE ===
        ctx.drawImage(GFX.jeffYard, jeffX, jeffY + bobY);

        // === AMBIENT PARTICLES ===
        for (let i = 0; i < 5; i++) {
            const px = (animFrame * 0.3 + i * 50) % canvas.width;
            const py = 30 + Math.sin(animFrame * 0.02 + i * 2) * 40;
            ctx.fillStyle = 'rgba(255, 200, 100, 0.3)';
            ctx.fillRect(px, py, 2, 2);
        }

        // === "SAFE ZONE" indicator at throne room boundary ===
        ctx.fillStyle = '#22c55e';
        ctx.font = '6px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('THRONE ROOM', canvas.width / 2, throneRoomHeight - 8);
        ctx.textAlign = 'left';
    }

    // === LONG SECURITY HALLWAY (dangerous zone with lasers/drones) ===
    const hallwayBgGrad = ctx.createLinearGradient(0, throneRoomHeight, 0, hallwayEnd);
    hallwayBgGrad.addColorStop(0, '#0a0a18');
    hallwayBgGrad.addColorStop(0.5, '#0f1020');
    hallwayBgGrad.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = hallwayBgGrad;
    ctx.fillRect(0, throneRoomHeight, canvas.width, hallwayEnd - throneRoomHeight);

    // Hallway floor - industrial metal grating
    for (let ty = throneRoomHeight; ty < hallwayEnd; ty += 12) {
        for (let tx = 0; tx < canvas.width; tx += 12) {
            ctx.fillStyle = (tx + ty) % 24 === 0 ? '#1a1a28' : '#151522';
            ctx.fillRect(tx, ty, 11, 11);
            // Grating details
            ctx.fillStyle = 'rgba(255,255,255,0.02)';
            ctx.fillRect(tx + 2, ty + 2, 3, 3);
        }
    }

    // Hallway walls (sides) with red alert lighting
    if (y) {
        const animFrame = y.jeffAnimFrame || 0;
        const alertPulse = Math.sin(animFrame * 0.1) * 0.3 + 0.5;

        // Left wall
        ctx.fillStyle = '#1f1f35';
        ctx.fillRect(0, throneRoomHeight, 25, hallwayEnd - throneRoomHeight);
        // Right wall
        ctx.fillRect(canvas.width - 25, throneRoomHeight, 25, hallwayEnd - throneRoomHeight);

        // Red alert strips on walls
        ctx.fillStyle = `rgba(220, 38, 38, ${alertPulse})`;
        for (let wy = throneRoomHeight + 20; wy < hallwayEnd - 20; wy += 60) {
            ctx.fillRect(2, wy, 4, 30);
            ctx.fillRect(canvas.width - 6, wy, 4, 30);
        }

        // "DANGER" signs along hallway
        ctx.fillStyle = '#dc2626';
        ctx.font = '5px "Press Start 2P"';
        ctx.textAlign = 'center';
        for (let signY = throneRoomHeight + 50; signY < hallwayEnd - 50; signY += 100) {
            ctx.fillText('‚ö†', 12, signY);
            ctx.fillText('‚ö†', canvas.width - 12, signY);
        }
        ctx.textAlign = 'left';
    }

    // Warning stripes at throne room / hallway boundary
    ctx.fillStyle = '#facc15';
    for (let x = 0; x < canvas.width; x += 16) {
        ctx.fillRect(x, throneRoomHeight, 8, 5);
    }
    ctx.fillStyle = '#0f0f0f';
    for (let x = 8; x < canvas.width; x += 16) {
        ctx.fillRect(x, throneRoomHeight, 8, 5);
    }

    // Warning stripes at hallway / yard boundary
    ctx.fillStyle = '#facc15';
    for (let x = 0; x < canvas.width; x += 16) {
        ctx.fillRect(x, hallwayEnd - 5, 8, 5);
    }
    ctx.fillStyle = '#0f0f0f';
    for (let x = 8; x < canvas.width; x += 16) {
        ctx.fillRect(x, hallwayEnd - 5, 8, 5);
    }

    // curbs and dock edges (at bottom of yard)
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0, totalHeight - 18, canvas.width, 18);
    ctx.fillStyle = '#334155'; ctx.fillRect(0, totalHeight - 22, canvas.width, 4);
    ctx.fillStyle = '#64748b'; for (let x=0; x<canvas.width; x+=14) ctx.fillRect(x, totalHeight - 16, 8, 3);

    // === WAREHOUSE-STYLE YARD FLOOR TILES (between lanes) ===
    if (y) {
        const animFrame = y.jeffAnimFrame || 0;
        // Draw concrete floor between vehicle lanes
        for (let ty = hallwayEnd; ty < totalHeight - 60; ty += 16) {
            for (let tx = 0; tx < canvas.width; tx += 16) {
                // Check if not inside a lane band
                let inLane = false;
                y.lanes.forEach(lane => {
                    if (ty > lane.y - 22 && ty < lane.y + 22) inLane = true;
                });
                if (!inLane) {
                    // Concrete floor tiles with variation
                    const shade = ((tx + ty) / 16 % 2 === 0) ? 0 : 8;
                    ctx.fillStyle = `rgb(${55 + shade}, ${65 + shade}, ${81 + shade})`;
                    ctx.fillRect(tx, ty, 16, 16);
                    // Tile texture
                    ctx.fillStyle = 'rgba(255,255,255,0.03)';
                    ctx.fillRect(tx + 1, ty + 1, 6, 6);
                    // Occasional crack/stain
                    if ((tx * ty) % 127 < 8) {
                        ctx.fillStyle = 'rgba(0,0,0,0.1)';
                        ctx.fillRect(tx + 4, ty + 4, 8, 1);
                    }
                }
            }
        }

        // Safety lines on yard floor (5S markings)
        ctx.fillStyle = '#facc15';
        for (let zoneY = hallwayEnd + 40; zoneY < totalHeight - 80; zoneY += 60) {
            // Pedestrian crossing markers
            for (let x = 0; x < canvas.width; x += 24) {
                ctx.fillRect(x + 4, zoneY, 12, 3);
            }
        }
    }

    // lane bands and markings
    if (y) {
        ctx.setLineDash([8, 10]);
        ctx.strokeStyle = '#facc15'; ctx.lineWidth = 2;
        y.lanes.forEach(lane => {
            // Road surface with asphalt texture
            ctx.fillStyle = '#0f172a'; ctx.fillRect(0, lane.y - 22, canvas.width, 44);
            ctx.fillStyle = '#111827'; ctx.fillRect(0, lane.y - 18, canvas.width, 36);
            // Asphalt texture
            for (let tx = 0; tx < canvas.width; tx += 8) {
                const texAlpha = 0.02 + Math.random() * 0.03;
                ctx.fillStyle = `rgba(255,255,255,${texAlpha})`;
                ctx.fillRect(tx, lane.y - 16 + Math.random() * 30, 4, 2);
            }
            // Center lane marker
            ctx.beginPath(); ctx.moveTo(0, lane.y); ctx.lineTo(canvas.width, lane.y); ctx.stroke();
            // Edge lines
            ctx.fillStyle = '#1e293b'; ctx.fillRect(0, lane.y - 22, canvas.width, 2);
            ctx.fillStyle = '#1e293b'; ctx.fillRect(0, lane.y + 20, canvas.width, 2);
            // Direction arrows on road
            if (lane.dir === 1) {
                ctx.fillStyle = '#374151';
                ctx.beginPath();
                ctx.moveTo(50, lane.y - 8); ctx.lineTo(66, lane.y); ctx.lineTo(50, lane.y + 8); ctx.fill();
                ctx.beginPath();
                ctx.moveTo(150, lane.y - 8); ctx.lineTo(166, lane.y); ctx.lineTo(150, lane.y + 8); ctx.fill();
            } else {
                ctx.fillStyle = '#374151';
                ctx.beginPath();
                ctx.moveTo(90, lane.y + 8); ctx.lineTo(74, lane.y); ctx.lineTo(90, lane.y - 8); ctx.fill();
                ctx.beginPath();
                ctx.moveTo(200, lane.y + 8); ctx.lineTo(184, lane.y); ctx.lineTo(200, lane.y - 8); ctx.fill();
            }
        });
        ctx.setLineDash([]);
    }

    // palettes at bottom of yard
    ctx.fillStyle = '#f97316'; for (let x=10; x<canvas.width; x+=60) ctx.fillRect(x, totalHeight - 36, 8, 16);
    ctx.fillStyle = '#9ca3af'; for (let x=6; x<canvas.width; x+=50) ctx.fillRect(x, totalHeight - 48, 14, 6);

    if (y) {
        const animFrame = y.jeffAnimFrame || 0;

        // Draw static hazards (puddles, debris) - ENHANCED
        if (y.staticHazards) {
            y.staticHazards.forEach(h => {
                if (h.type === 'puddle') {
                    // Oil/water puddle with rainbow oil sheen effect
                    const shimmer = Math.sin(GAME.ticks * 0.05 + h.x) * 0.15;

                    // Outer dark ring
                    ctx.fillStyle = 'rgba(15, 23, 42, 0.7)';
                    ctx.beginPath();
                    ctx.ellipse(h.x + 12, h.y + 8, 20, 10, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Main water/oil puddle
                    ctx.fillStyle = 'rgba(30, 64, 175, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(h.x + 12, h.y + 8, 18, 8, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Oil sheen rainbow effect
                    const oilGradient = ctx.createRadialGradient(h.x + 8, h.y + 4, 2, h.x + 12, h.y + 8, 16);
                    oilGradient.addColorStop(0, `rgba(147, 51, 234, ${0.3 + shimmer})`);
                    oilGradient.addColorStop(0.3, `rgba(59, 130, 246, ${0.25 + shimmer})`);
                    oilGradient.addColorStop(0.5, `rgba(16, 185, 129, ${0.2 + shimmer})`);
                    oilGradient.addColorStop(0.7, `rgba(245, 158, 11, ${0.25 + shimmer})`);
                    oilGradient.addColorStop(1, `rgba(239, 68, 68, ${0.15})`);
                    ctx.fillStyle = oilGradient;
                    ctx.beginPath();
                    ctx.ellipse(h.x + 12, h.y + 8, 16, 7, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Light reflection highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(h.x + 8, h.y + 4, 6, 3, -0.3, 0, Math.PI * 2);
                    ctx.fill();

                    // Ripple effect
                    const ripple = (GAME.ticks * 0.03 + h.y) % 1;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 * (1 - ripple)})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(h.x + 12, h.y + 8, 8 + ripple * 10, 4 + ripple * 4, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    // Warning sign
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(h.x + 6, h.y - 12, 12, 10);
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(h.x + 7, h.y - 11, 10, 8);
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = '6px "Press Start 2P"';
                    ctx.fillText('!', h.x + 10, h.y - 5);
                    // Sign post
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(h.x + 10, h.y - 2, 2, 4);

                } else if (h.type === 'debris') {
                    // Enhanced debris pile with varied pieces
                    const pieces = [
                        { ox: 0, oy: 10, w: 8, h: 6, color: '#57534e' },
                        { ox: 6, oy: 6, w: 10, h: 10, color: '#78716c' },
                        { ox: 14, oy: 8, w: 8, h: 8, color: '#a8a29e' },
                        { ox: 4, oy: 2, w: 6, h: 6, color: '#d6d3d1' },
                        { ox: 10, oy: 4, w: 4, h: 4, color: '#e7e5e4' },
                    ];

                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(h.x + 12, h.y + 18, 14, 4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw debris pieces with 3D effect
                    pieces.forEach(p => {
                        // Dark side
                        ctx.fillStyle = '#44403c';
                        ctx.fillRect(h.x + p.ox, h.y + p.oy + 2, p.w, p.h);
                        // Main piece
                        ctx.fillStyle = p.color;
                        ctx.fillRect(h.x + p.ox, h.y + p.oy, p.w, p.h);
                        // Highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.2)';
                        ctx.fillRect(h.x + p.ox, h.y + p.oy, p.w, 2);
                    });

                    // Scattered small debris
                    ctx.fillStyle = '#78716c';
                    ctx.fillRect(h.x - 4, h.y + 14, 3, 2);
                    ctx.fillRect(h.x + 22, h.y + 12, 2, 3);
                    ctx.fillStyle = '#a8a29e';
                    ctx.fillRect(h.x + 2, h.y + 16, 2, 2);

                    // Caution tape
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(h.x - 2, h.y + 8, 28, 2);
                    ctx.fillStyle = '#1f2937';
                    for (let t = 0; t < 7; t++) {
                        ctx.fillRect(h.x - 2 + t * 4, h.y + 8, 2, 2);
                    }
                }
            });
        }

        // Draw forklift zone warnings
        if (y.forkliftZones) {
            y.forkliftZones.forEach(zone => {
                if (zone.active || zone.timer < 40) {
                    const pulse = Math.sin(GAME.ticks * 0.2) * 0.3 + 0.5;
                    ctx.fillStyle = `rgba(234, 179, 8, ${pulse * 0.3})`;
                    ctx.fillRect(0, zone.y - 15, canvas.width, 30);
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(0, zone.y);
                    ctx.lineTo(canvas.width, zone.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
        }

        // === DRAW ENHANCED DOCK ATMOSPHERE (warehouse-style) ===

        // === WAREHOUSE OVERHEAD LIGHTING ===
        // Draw overhead warehouse lights with light cones
        const lightSpacing = 80;
        for (let lx = 40; lx < canvas.width; lx += lightSpacing) {
            for (let ly = hallwayEnd + 60; ly < totalHeight - 100; ly += 120) {
                const flicker = Math.sin(GAME.ticks * 0.1 + lx + ly) * 0.1 + 0.9;

                // Light cone (soft gradient)
                const lightGrad = ctx.createRadialGradient(lx, ly, 0, lx, ly + 40, 50);
                lightGrad.addColorStop(0, `rgba(255, 251, 235, ${0.15 * flicker})`);
                lightGrad.addColorStop(0.5, `rgba(255, 251, 235, ${0.08 * flicker})`);
                lightGrad.addColorStop(1, 'rgba(255, 251, 235, 0)');
                ctx.fillStyle = lightGrad;
                ctx.beginPath();
                ctx.moveTo(lx - 30, ly);
                ctx.lineTo(lx - 45, ly + 80);
                ctx.lineTo(lx + 45, ly + 80);
                ctx.lineTo(lx + 30, ly);
                ctx.closePath();
                ctx.fill();

                // Light fixture housing
                ctx.fillStyle = '#374151';
                ctx.fillRect(lx - 12, ly - 8, 24, 8);
                ctx.fillStyle = '#4b5563';
                ctx.fillRect(lx - 10, ly - 6, 20, 4);

                // Light bulb/tube
                ctx.fillStyle = `rgba(255, 251, 235, ${flicker})`;
                ctx.fillRect(lx - 8, ly - 2, 16, 4);
                ctx.fillStyle = '#fff';
                ctx.fillRect(lx - 6, ly - 1, 12, 2);

                // Hanging chain
                ctx.fillStyle = '#6b7280';
                ctx.fillRect(lx - 1, ly - 16, 2, 8);
            }
        }

        // === FLOATING DUST PARTICLES IN YARD ===
        for (let d = 0; d < 20; d++) {
            const dustX = ((animFrame * 0.3 + d * 47) % canvas.width);
            const dustY = hallwayEnd + 30 + ((animFrame * 0.15 + d * 67) % (totalHeight - hallwayEnd - 80));
            const dustAlpha = Math.sin(animFrame * 0.04 + d * 0.7) * 0.2 + 0.25;
            const dustSize = 1 + (d % 3);
            ctx.fillStyle = `rgba(255, 255, 255, ${dustAlpha})`;
            ctx.fillRect(dustX, dustY, dustSize, dustSize);
        }

        // === DRAW BIRDS (3D atmosphere - flying over yard) ===
        if (y.birds && y.birds.length > 0) {
            y.birds.forEach(bird => {
                const wingUp = Math.sin(bird.wingPhase) > 0;
                const s = bird.scale;
                const bx = bird.x;
                const by = bird.y;

                // Bird shadow on ground (creates 3D depth effect)
                const shadowY = hallwayEnd + 80; // Shadow on yard floor
                const shadowScale = 0.4 + (1 - s) * 0.3; // Smaller shadow for "higher" birds
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.ellipse(bx, shadowY, 8 * shadowScale, 3 * shadowScale, 0, 0, Math.PI * 2);
                ctx.fill();

                // Bird body (darker = further away, creating depth)
                const shade = Math.floor(50 + s * 30);
                ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade + 10})`;

                // Body
                ctx.fillRect(bx - 4 * s, by - 2 * s, 8 * s, 4 * s);

                // Head
                ctx.fillRect(bx + (bird.vx > 0 ? 3 : -5) * s, by - 2 * s, 3 * s, 3 * s);

                // Beak
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(bx + (bird.vx > 0 ? 6 : -7) * s, by - 1 * s, 2 * s, 1 * s);

                // Wings (animated)
                ctx.fillStyle = `rgb(${shade - 10}, ${shade - 10}, ${shade})`;
                if (wingUp) {
                    // Wings up
                    ctx.fillRect(bx - 2 * s, by - 6 * s, 4 * s, 4 * s);
                } else {
                    // Wings down
                    ctx.fillRect(bx - 5 * s, by + 1 * s, 10 * s, 2 * s);
                }

                // Tail
                ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
                ctx.fillRect(bx + (bird.vx > 0 ? -6 : 4) * s, by - 1 * s, 3 * s, 2 * s);
            });
        }

        // Draw pallet stacks (warehouse atmosphere) - ENHANCED
        if (y.palletStacks) {
            y.palletStacks.forEach((pallet, idx) => {
                const stackHeight = (idx % 3) + 1; // Vary stack heights

                // Shadow under pallet
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(pallet.x + 10, pallet.y + 18, 12, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wooden pallet base with detail
                ctx.fillStyle = '#78350f';
                ctx.fillRect(pallet.x - 2, pallet.y + 12, 24, 6);
                // Pallet slats
                ctx.fillStyle = '#92400e';
                ctx.fillRect(pallet.x, pallet.y + 12, 20, 2);
                ctx.fillRect(pallet.x, pallet.y + 16, 20, 2);
                // Pallet support blocks
                ctx.fillStyle = '#5c2d0e';
                ctx.fillRect(pallet.x, pallet.y + 14, 4, 4);
                ctx.fillRect(pallet.x + 8, pallet.y + 14, 4, 4);
                ctx.fillRect(pallet.x + 16, pallet.y + 14, 4, 4);
                // Wood grain texture
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(pallet.x + 3, pallet.y + 13, 14, 1);

                // Stack of boxes
                for (let s = 0; s < stackHeight; s++) {
                    const boxY = pallet.y - s * 10;
                    const boxShade = 1 - s * 0.15;

                    // Box shadow on box below
                    if (s > 0) {
                        ctx.fillStyle = 'rgba(0,0,0,0.15)';
                        ctx.fillRect(pallet.x + 1, boxY + 10, 18, 2);
                    }

                    // Main box with 3D effect
                    ctx.fillStyle = `rgb(${Math.floor(194 * boxShade)}, ${Math.floor(65 * boxShade)}, ${Math.floor(12 * boxShade)})`;
                    ctx.fillRect(pallet.x + 1, boxY, 18, 12);

                    // Box front face (lighter)
                    ctx.fillStyle = `rgb(${Math.floor(234 * boxShade)}, ${Math.floor(88 * boxShade)}, ${Math.floor(12 * boxShade)})`;
                    ctx.fillRect(pallet.x + 2, boxY + 1, 16, 10);

                    // Box top face (even lighter for 3D)
                    ctx.fillStyle = `rgb(${Math.floor(249 * boxShade)}, ${Math.floor(115 * boxShade)}, ${Math.floor(22 * boxShade)})`;
                    ctx.fillRect(pallet.x + 2, boxY, 14, 3);

                    // Amazon smile tape
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(pallet.x + 5, boxY + 4, 10, 3);
                    ctx.fillStyle = '#ff9900';
                    ctx.fillRect(pallet.x + 6, boxY + 5, 8, 1);
                    // Arrow/smile
                    ctx.fillRect(pallet.x + 11, boxY + 6, 3, 1);

                    // Fragile sticker on some boxes
                    if ((idx + s) % 4 === 0) {
                        ctx.fillStyle = '#dc2626';
                        ctx.fillRect(pallet.x + 3, boxY + 7, 6, 3);
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(pallet.x + 4, boxY + 8, 1, 1);
                    }

                    // Barcode label
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(pallet.x + 12, boxY + 7, 5, 3);
                    ctx.fillStyle = '#000';
                    for (let b = 0; b < 4; b++) {
                        ctx.fillRect(pallet.x + 12 + b, boxY + 8, 1, 1);
                    }
                }

                // Shrink wrap effect on tall stacks
                if (stackHeight > 1) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(pallet.x + 1, pallet.y - (stackHeight - 1) * 10, 18, stackHeight * 10 + 12);
                    // Wrap bands
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
                    ctx.fillRect(pallet.x, pallet.y - (stackHeight - 1) * 10 + 2, 20, 2);
                    ctx.fillRect(pallet.x, pallet.y + 6, 20, 2);
                }
            });
        }

        // Draw dock workers (warehouse-style NPCs) - ENHANCED
        if (y.dockWorkers) {
            y.dockWorkers.forEach(worker => {
                const walkPhase = Math.sin((GAME.ticks + worker.x) * 0.15);
                const breathe = Math.sin((GAME.ticks + worker.y) * 0.08) * 0.5;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(worker.x, worker.y + 14, 6, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs with walking animation
                ctx.fillStyle = '#1e3a8a';
                const legOffset = walkPhase * 2;
                ctx.fillRect(worker.x - 3 - legOffset, worker.y + 9, 3, 5);
                ctx.fillRect(worker.x + legOffset, worker.y + 9, 3, 5);
                // Boots
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(worker.x - 4 - legOffset, worker.y + 13, 4, 2);
                ctx.fillRect(worker.x - 1 + legOffset, worker.y + 13, 4, 2);

                // Body
                ctx.fillStyle = '#374151'; // Dark shirt
                ctx.fillRect(worker.x - 4, worker.y, 8, 10);

                // Safety vest with reflective strips
                ctx.fillStyle = '#ca8a04';
                ctx.fillRect(worker.x - 4, worker.y + 1, 3, 8);
                ctx.fillRect(worker.x + 1, worker.y + 1, 3, 8);
                ctx.fillStyle = '#eab308';
                ctx.fillRect(worker.x - 4, worker.y + 2, 2, 6);
                ctx.fillRect(worker.x + 2, worker.y + 2, 2, 6);
                // Reflective stripes
                ctx.fillStyle = '#d4d4d4';
                ctx.fillRect(worker.x - 4, worker.y + 3, 1, 4);
                ctx.fillRect(worker.x + 3, worker.y + 3, 1, 4);
                ctx.fillRect(worker.x - 3, worker.y + 1, 6, 1);
                ctx.fillRect(worker.x - 3, worker.y + 7, 6, 1);

                // Arms
                ctx.fillStyle = '#374151';
                ctx.fillRect(worker.x - 6, worker.y + 1, 2, 6);
                ctx.fillRect(worker.x + 4, worker.y + 1, 2, 6);
                // Hands
                ctx.fillStyle = '#f5d0b0';
                ctx.fillRect(worker.x - 6, worker.y + 6, 2, 2);
                ctx.fillRect(worker.x + 4, worker.y + 6, 2, 2);

                // Head with more detail
                ctx.fillStyle = '#d4a574';
                ctx.fillRect(worker.x - 3, worker.y - 6 + breathe, 6, 7);
                // Hair/skin tone variation
                ctx.fillStyle = '#c4956c';
                ctx.fillRect(worker.x - 2, worker.y - 5 + breathe, 4, 2);
                // Eyes
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(worker.x - 2, worker.y - 4 + breathe, 1, 1);
                ctx.fillRect(worker.x + 1, worker.y - 4 + breathe, 1, 1);

                // Hard hat with details
                ctx.fillStyle = '#d97706';
                ctx.fillRect(worker.x - 4, worker.y - 9 + breathe, 8, 4);
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(worker.x - 3, worker.y - 8 + breathe, 6, 2);
                // Hard hat brim
                ctx.fillStyle = '#b45309';
                ctx.fillRect(worker.x - 5, worker.y - 6 + breathe, 10, 1);
                // Hard hat logo
                ctx.fillStyle = '#ff9900';
                ctx.fillRect(worker.x - 1, worker.y - 8 + breathe, 2, 2);

                // ID badge
                ctx.fillStyle = '#fff';
                ctx.fillRect(worker.x + 1, worker.y + 2, 3, 4);
                ctx.fillStyle = '#3b82f6';
                ctx.fillRect(worker.x + 1, worker.y + 2, 3, 2);

                // === SPEECH BUBBLE FOR CHIT-CHAT ===
                if (worker.banterText && worker.banterLife > 0) {
                    const bubbleAlpha = Math.min(1, worker.banterLife / 30); // Fade out
                    ctx.save();
                    ctx.globalAlpha = bubbleAlpha;

                    // Measure text for bubble sizing
                    ctx.font = '5px "Press Start 2P"';
                    const textWidth = ctx.measureText(worker.banterText).width;
                    const bubbleW = textWidth + 8;
                    const bubbleH = 12;
                    const bubbleX = worker.x - bubbleW / 2;
                    const bubbleY = worker.y - 22 + breathe;

                    // Speech bubble background
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(bubbleX, bubbleY, bubbleW, bubbleH);

                    // Bubble border
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(bubbleX - 1, bubbleY, 1, bubbleH);
                    ctx.fillRect(bubbleX + bubbleW, bubbleY, 1, bubbleH);
                    ctx.fillRect(bubbleX, bubbleY - 1, bubbleW, 1);
                    ctx.fillRect(bubbleX, bubbleY + bubbleH, bubbleW, 1);

                    // Bubble tail
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(worker.x - 2, bubbleY + bubbleH, 4, 3);
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(worker.x - 3, bubbleY + bubbleH, 1, 3);
                    ctx.fillRect(worker.x + 2, bubbleY + bubbleH, 1, 3);

                    // Text
                    ctx.fillStyle = '#1f2937';
                    ctx.textAlign = 'center';
                    ctx.fillText(worker.banterText, worker.x, bubbleY + 8);
                    ctx.textAlign = 'left';

                    ctx.restore();
                }
            });
        }

        // Draw vehicles - ENHANCED with shadows and details
        y.vehicles.forEach(v => {
            const sprite = v.type === 'van' ? GFX.van : GFX.truck;
            const vWidth = v.type === 'van' ? 40 : 60;
            const vHeight = v.type === 'van' ? 24 : 28;

            // Vehicle shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.beginPath();
            ctx.ellipse(v.x + vWidth/2, v.y + vHeight + 4, vWidth/2 + 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Draw the vehicle sprite
            ctx.drawImage(sprite, v.x, v.y);

            // Add headlight glow if moving towards player (direction dependent)
            if (v.dir && v.dir < 0) {
                ctx.fillStyle = 'rgba(255, 251, 235, 0.4)';
                ctx.beginPath();
                ctx.arc(v.x + 4, v.y + vHeight/2, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Exhaust puff effect (subtle animation)
            if (v.type === 'truck' && GAME.ticks % 20 < 10) {
                const puffX = v.dir && v.dir > 0 ? v.x - 8 : v.x + vWidth + 2;
                const puffAlpha = 0.2 - (GAME.ticks % 20) * 0.015;
                ctx.fillStyle = `rgba(156, 163, 175, ${puffAlpha})`;
                ctx.beginPath();
                ctx.arc(puffX, v.y + vHeight - 4, 4 + (GAME.ticks % 20) * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // === DRAW YARD PACKAGE COLLECTIBLES - ENHANCED ===
        if (y.yardPackages) {
            y.yardPackages.forEach(pkg => {
                if (pkg.collected) return;
                const bob = Math.sin(pkg.bobTimer) * 4;
                const glow = Math.sin(pkg.glowTimer) * 0.3 + 0.7;
                const rotate = Math.sin(pkg.bobTimer * 0.5) * 0.1;
                const scale = 1 + Math.sin(pkg.glowTimer * 2) * 0.05;

                ctx.save();
                ctx.translate(pkg.x + 8, pkg.y + 8 + bob);
                ctx.rotate(rotate);
                ctx.scale(scale, scale);

                // Outer glow effect (multiple layers)
                const glowColor = pkg.type === 'prime' ? [255, 153, 0] : [34, 197, 94];
                for (let g = 3; g > 0; g--) {
                    ctx.fillStyle = `rgba(${glowColor[0]}, ${glowColor[1]}, ${glowColor[2]}, ${glow * 0.15 * (4 - g)})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8 + g * 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(0, 10 - bob, 8, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Package box
                if (pkg.type === 'prime') {
                    // Prime package (golden/orange) with 3D effect
                    // Bottom/side shadow
                    ctx.fillStyle = '#78350f';
                    ctx.fillRect(-7, -5, 16, 16);

                    // Main box body
                    ctx.fillStyle = '#92400e';
                    ctx.fillRect(-8, -6, 16, 14);
                    ctx.fillStyle = '#c2410c';
                    ctx.fillRect(-7, -5, 14, 12);
                    ctx.fillStyle = '#ea580c';
                    ctx.fillRect(-6, -4, 12, 10);

                    // Top face (lighter)
                    ctx.fillStyle = '#f97316';
                    ctx.fillRect(-6, -6, 10, 3);

                    // Prime logo tape
                    ctx.fillStyle = '#ff9900';
                    ctx.fillRect(-5, -2, 10, 5);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(-4, -1, 8, 3);

                    // Amazon smile arrow
                    ctx.fillStyle = '#ffb84d';
                    ctx.beginPath();
                    ctx.moveTo(-4, 1);
                    ctx.quadraticCurveTo(0, 3, 4, 1);
                    ctx.lineTo(5, 2);
                    ctx.lineTo(4, 2);
                    ctx.quadraticCurveTo(0, 4, -4, 2);
                    ctx.fill();

                    // Star sparkles (multiple)
                    const sparkle = Math.floor(animFrame / 6) % 4;
                    ctx.fillStyle = '#fff';
                    if (sparkle === 0) {
                        ctx.fillRect(5, -8, 3, 3);
                        ctx.fillRect(6, -9, 1, 5);
                        ctx.fillRect(5, -8, 3, 1);
                    } else if (sparkle === 1) {
                        ctx.fillRect(-9, -4, 2, 2);
                    } else if (sparkle === 2) {
                        ctx.fillRect(7, 2, 2, 2);
                    }

                    // Prime badge
                    ctx.fillStyle = '#1e3a8a';
                    ctx.fillRect(-3, 3, 6, 3);
                    ctx.fillStyle = '#60a5fa';
                    ctx.font = '3px "Press Start 2P"';
                    ctx.fillText('P', -2, 5);

                } else {
                    // Standard package (cardboard) with 3D effect
                    // Bottom/side shadow
                    ctx.fillStyle = '#5c2d0e';
                    ctx.fillRect(-7, -5, 16, 16);

                    // Main box body
                    ctx.fillStyle = '#78350f';
                    ctx.fillRect(-8, -6, 16, 14);
                    ctx.fillStyle = '#92400e';
                    ctx.fillRect(-7, -5, 14, 12);
                    ctx.fillStyle = '#a16207';
                    ctx.fillRect(-6, -4, 12, 10);

                    // Top face (lighter)
                    ctx.fillStyle = '#b45309';
                    ctx.fillRect(-6, -6, 10, 3);

                    // Cardboard texture lines
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    ctx.fillRect(-5, -3, 10, 1);
                    ctx.fillRect(-5, 1, 10, 1);

                    // Tape cross pattern
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(-2, -4, 4, 10);
                    ctx.fillRect(-5, -1, 10, 3);
                    ctx.fillStyle = '#f59e0b';
                    ctx.fillRect(-1, -3, 2, 8);
                    ctx.fillRect(-4, 0, 8, 1);

                    // Barcode sticker
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(2, 2, 5, 4);
                    ctx.fillStyle = '#000';
                    for (let b = 0; b < 4; b++) {
                        ctx.fillRect(3 + b, 3, 1, 2);
                    }

                    // Green checkmark for "standard delivery"
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(-6, 3, 3, 3);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-5, 4, 1, 1);
                }

                ctx.restore();
            });
        }

        // Draw forklifts - ENHANCED
        if (y.forklifts) {
            y.forklifts.forEach(f => {
                const bounce = Math.sin(GAME.ticks * 0.2 + f.x) * 0.5;
                const forkX = f.dir === 1 ? f.x + 24 : f.x - 12;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                ctx.beginPath();
                ctx.ellipse(f.x + 14, f.y + 20, 18, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Forklift mast (vertical support for forks)
                ctx.fillStyle = '#4b5563';
                ctx.fillRect(f.dir === 1 ? f.x + 22 : f.x + 4, f.y - 8, 4, 24);
                ctx.fillStyle = '#6b7280';
                ctx.fillRect(f.dir === 1 ? f.x + 23 : f.x + 5, f.y - 6, 2, 20);

                // Forks with 3D effect
                ctx.fillStyle = '#4b5563';
                ctx.fillRect(forkX, f.y + 14, 14, 4);
                ctx.fillRect(forkX, f.y + 8, 14, 4);
                ctx.fillStyle = '#6b7280';
                ctx.fillRect(forkX + 1, f.y + 14, 12, 2);
                ctx.fillRect(forkX + 1, f.y + 8, 12, 2);
                // Fork tips
                ctx.fillStyle = '#9ca3af';
                ctx.fillRect(f.dir === 1 ? forkX + 11 : forkX, f.y + 14, 3, 3);
                ctx.fillRect(f.dir === 1 ? forkX + 11 : forkX, f.y + 8, 3, 3);

                // Main body base (counterweight)
                ctx.fillStyle = '#b45309';
                ctx.fillRect(f.x - 2, f.y + 4 + bounce, 32, 14);
                ctx.fillStyle = '#d97706';
                ctx.fillRect(f.x, f.y + 6 + bounce, 28, 10);

                // Body with gradient effect
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(f.x + 2, f.y + bounce, 24, 14);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(f.x + 4, f.y + 2 + bounce, 20, 4);

                // Operator cage with safety bars
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(f.x + 4, f.y - 6 + bounce, 12, 14);
                ctx.fillStyle = '#374151';
                ctx.fillRect(f.x + 5, f.y - 5 + bounce, 10, 12);
                // Cage bars
                ctx.fillStyle = '#4b5563';
                ctx.fillRect(f.x + 4, f.y - 6 + bounce, 1, 14);
                ctx.fillRect(f.x + 9, f.y - 6 + bounce, 1, 14);
                ctx.fillRect(f.x + 14, f.y - 6 + bounce, 1, 14);
                ctx.fillRect(f.x + 4, f.y - 6 + bounce, 12, 1);

                // Operator (driver) silhouette
                ctx.fillStyle = '#1e3a8a'; // Blue uniform
                ctx.fillRect(f.x + 6, f.y + 2 + bounce, 6, 6);
                ctx.fillStyle = '#d4a574'; // Head
                ctx.fillRect(f.x + 7, f.y - 2 + bounce, 4, 4);
                // Hard hat
                ctx.fillStyle = '#fff';
                ctx.fillRect(f.x + 6, f.y - 4 + bounce, 6, 2);

                // Steering wheel
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(f.x + 12, f.y + 3 + bounce, 4, 4);
                ctx.fillStyle = '#374151';
                ctx.fillRect(f.x + 13, f.y + 4 + bounce, 2, 2);

                // Wheels with rubber tires
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(f.x + 2, f.y + 14, 8, 6);
                ctx.fillRect(f.x + 18, f.y + 14, 8, 6);
                // Tire treads
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(f.x + 3, f.y + 15, 6, 4);
                ctx.fillRect(f.x + 19, f.y + 15, 6, 4);
                // Wheel hubs
                ctx.fillStyle = '#6b7280';
                ctx.fillRect(f.x + 4, f.y + 16, 4, 2);
                ctx.fillRect(f.x + 20, f.y + 16, 4, 2);

                // Warning beacon with strobe effect
                const lightPulse = Math.sin(GAME.ticks * 0.3) > 0;
                const lightIntensity = Math.sin(GAME.ticks * 0.3) * 0.5 + 0.5;
                // Beacon base
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(f.x + 11, f.y - 6 + bounce, 6, 4);
                // Beacon light
                ctx.fillStyle = lightPulse ? '#ef4444' : '#7f1d1d';
                ctx.fillRect(f.x + 12, f.y - 8 + bounce, 4, 4);
                // Light glow
                if (lightPulse) {
                    ctx.fillStyle = `rgba(239, 68, 68, ${lightIntensity * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(f.x + 14, f.y - 6 + bounce, 8, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Headlights
                ctx.fillStyle = '#fef3c7';
                ctx.fillRect(f.dir === 1 ? f.x + 24 : f.x + 2, f.y + 8 + bounce, 3, 3);
                // Headlight glow
                ctx.fillStyle = 'rgba(254, 243, 199, 0.3)';
                ctx.beginPath();
                ctx.arc(f.dir === 1 ? f.x + 25 : f.x + 3, f.y + 10 + bounce, 5, 0, Math.PI * 2);
                ctx.fill();

                // Amazon logo on side
                ctx.fillStyle = '#ff9900';
                ctx.fillRect(f.x + 16, f.y + 7 + bounce, 6, 4);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(f.x + 17, f.y + 8 + bounce, 4, 2);
            });
        }

        // === HALLWAY SECTION HAZARDS RENDERING ===
        // Entrance archway at the bottom of hallway leading to yard
        if (y.castleStart) {
            const castleY = y.castleStart;

            // Entrance archway from yard to hallway
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, castleY - 60, canvas.width, 60);
            ctx.fillStyle = '#2d2d44';
            ctx.fillRect(canvas.width / 2 - 40, castleY - 45, 80, 45);
            ctx.fillStyle = '#3d3d5c';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, castleY - 45, 40, Math.PI, 0);
            ctx.fill();
            ctx.textAlign = 'left';

            // Draw hallway platforms
            if (y.castlePlatforms) {
                y.castlePlatforms.forEach(p => {
                    // Platform glow
                    ctx.fillStyle = 'rgba(14, 165, 233, 0.3)';
                    ctx.fillRect(p.x - 2, p.y - 2, p.w + 4, 12);
                    // Platform body
                    ctx.fillStyle = '#38bdf8';
                    ctx.fillRect(p.x, p.y, p.w, 8);
                    ctx.fillStyle = '#0ea5e9';
                    ctx.fillRect(p.x + 2, p.y + 2, p.w - 4, 4);
                    // Platform edges
                    ctx.fillStyle = '#7dd3fc';
                    ctx.fillRect(p.x, p.y, 4, 8);
                    ctx.fillRect(p.x + p.w - 4, p.y, 4, 8);
                });
            }

            // Draw laser barriers
            if (y.castleLaserBarriers) {
                y.castleLaserBarriers.forEach(barrier => {
                    if (barrier.active) {
                        // Active laser - dangerous
                        const pulse = Math.sin(GAME.ticks * 0.3) * 0.2 + 0.8;
                        ctx.fillStyle = `rgba(239, 68, 68, ${pulse * 0.3})`;
                        ctx.fillRect(30, barrier.y - 10, canvas.width - 60, 20);
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(30, barrier.y - 3, canvas.width - 60, 6);
                        ctx.fillStyle = '#fca5a5';
                        ctx.fillRect(30, barrier.y - 1, canvas.width - 60, 2);
                        // Emitter nodes
                        ctx.fillStyle = '#dc2626';
                        ctx.fillRect(26, barrier.y - 6, 8, 12);
                        ctx.fillRect(canvas.width - 34, barrier.y - 6, 8, 12);
                    } else {
                        // Inactive - safe to pass
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                        ctx.fillRect(30, barrier.y - 2, canvas.width - 60, 4);
                        ctx.fillStyle = '#166534';
                        ctx.fillRect(26, barrier.y - 6, 8, 12);
                        ctx.fillRect(canvas.width - 34, barrier.y - 6, 8, 12);
                    }
                });
            }

            // Draw guard turrets - ENHANCED with better visual feedback
            if (y.castleGuards) {
                y.castleGuards.forEach(guard => {
                    const dirX = guard.x < canvas.width / 2 ? 1 : -1;
                    const charging = guard.fireTimer > guard.fireRate - 20;
                    const chargeProgress = charging ? (guard.fireTimer - (guard.fireRate - 20)) / 20 : 0;
                    const aboutToFire = guard.fireTimer > guard.fireRate - 5;

                    // Wall mount bracket
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(guard.x - 2, guard.y + 2, 20, 4);
                    ctx.fillRect(guard.x - 2, guard.y + 10, 20, 4);

                    // Turret base with metallic effect
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(guard.x, guard.y, 16, 16);
                    ctx.fillStyle = '#4b5563';
                    ctx.fillRect(guard.x + 1, guard.y + 1, 14, 14);
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(guard.x + 2, guard.y + 2, 12, 12);
                    // Metallic highlight
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillRect(guard.x + 3, guard.y + 3, 4, 2);

                    // Turret barrel with detail
                    const barrelX = dirX === 1 ? guard.x + 14 : guard.x - 10;
                    ctx.fillStyle = '#4b5563';
                    ctx.fillRect(barrelX, guard.y + 4, 12, 8);
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(barrelX + 1, guard.y + 5, 10, 6);
                    // Barrel bore
                    ctx.fillStyle = '#1f2937';
                    const boreX = dirX === 1 ? barrelX + 10 : barrelX;
                    ctx.fillRect(boreX, guard.y + 6, 2, 4);
                    // Barrel rings
                    ctx.fillStyle = '#4b5563';
                    ctx.fillRect(barrelX + 3, guard.y + 4, 2, 8);
                    ctx.fillRect(barrelX + 7, guard.y + 4, 2, 8);

                    // Charging glow effect
                    if (charging) {
                        ctx.fillStyle = `rgba(239, 68, 68, ${chargeProgress * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(guard.x + 8, guard.y + 8, 12 + chargeProgress * 4, 0, Math.PI * 2);
                        ctx.fill();

                        // Barrel charge glow
                        ctx.fillStyle = `rgba(251, 191, 36, ${chargeProgress * 0.6})`;
                        ctx.fillRect(boreX - 1, guard.y + 5, 4, 6);
                    }

                    // Warning light with pulsing effect
                    const lightPulse = aboutToFire ? Math.sin(GAME.ticks * 0.5) * 0.3 + 0.7 : 1;
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(guard.x + 5, guard.y - 4, 6, 6);
                    ctx.fillStyle = charging ? `rgba(239, 68, 68, ${lightPulse})` : '#22c55e';
                    ctx.fillRect(guard.x + 6, guard.y - 3, 4, 4);

                    // Light glow
                    if (charging) {
                        ctx.fillStyle = `rgba(239, 68, 68, ${chargeProgress * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(guard.x + 8, guard.y - 1, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Sensor eye
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(guard.x + 6, guard.y + 6, 4, 4);
                    ctx.fillStyle = charging ? '#fbbf24' : '#ef4444';
                    ctx.fillRect(guard.x + 7, guard.y + 7, 2, 2);

                    // "SECURITY" label
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = '3px "Press Start 2P"';
                    ctx.fillText('‚ö°', guard.x + 5, guard.y + 20);
                });
            }

            // Draw castle projectiles - ENHANCED
            if (y.castleProjectiles) {
                y.castleProjectiles.forEach(proj => {
                    // Projectile trail
                    ctx.fillStyle = 'rgba(251, 191, 36, 0.3)';
                    const trailDir = proj.vx > 0 ? -1 : 1;
                    ctx.fillRect(proj.x + trailDir * 4, proj.y - 2, 12, 4);
                    ctx.fillStyle = 'rgba(251, 191, 36, 0.15)';
                    ctx.fillRect(proj.x + trailDir * 12, proj.y - 1, 8, 2);

                    // Main projectile body
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(proj.x - 5, proj.y - 4, 10, 8);
                    ctx.fillStyle = '#f59e0b';
                    ctx.fillRect(proj.x - 4, proj.y - 3, 8, 6);
                    // Core
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(proj.x - 2, proj.y - 1, 4, 2);

                    // Glow effect
                    ctx.fillStyle = 'rgba(251, 191, 36, 0.4)';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Draw patrol drones
            if (y.castleDrones) {
                y.castleDrones.forEach(drone => {
                    const pulse = Math.sin(drone.pulseTimer * 0.15) * 2;
                    // Drone body
                    ctx.fillStyle = '#22d3ee';
                    ctx.fillRect(drone.x - 8 - pulse/2, drone.y - 8 - pulse/2, 16 + pulse, 16 + pulse);
                    ctx.fillStyle = '#0ea5e9';
                    ctx.fillRect(drone.x - 5, drone.y - 5, 10, 10);
                    // Eye
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(drone.x - 2, drone.y - 2, 4, 4);
                    // Propellers
                    const propPhase = Math.floor(drone.pulseTimer / 2) % 2;
                    ctx.fillStyle = '#94a3b8';
                    if (propPhase === 0) {
                        ctx.fillRect(drone.x - 14, drone.y - 2, 6, 4);
                        ctx.fillRect(drone.x + 8, drone.y - 2, 6, 4);
                    } else {
                        ctx.fillRect(drone.x - 2, drone.y - 14, 4, 6);
                        ctx.fillRect(drone.x - 2, drone.y + 8, 4, 6);
                    }
                });
            }

            // === ENHANCED ATMOSPHERE: Security Cameras ===
            const animFrame = y.jeffAnimFrame || 0;
            const camAngle = Math.sin(animFrame * 0.02) * 0.5;

            // Draw security cameras on walls (hallway section)
            for (let camY = throneRoomHeight + 60; camY < hallwayEnd - 60; camY += 120) {
                // Left wall camera
                ctx.save();
                ctx.translate(20, camY);
                ctx.rotate(camAngle);
                ctx.drawImage(GFX.securityCamera, -8, -8);
                // Recording light blink
                if (Math.floor(animFrame / 15) % 2 === 0) {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(-7, -1, 3, 3);
                }
                ctx.restore();

                // Right wall camera (flipped)
                ctx.save();
                ctx.translate(canvas.width - 20, camY);
                ctx.scale(-1, 1);
                ctx.rotate(-camAngle);
                ctx.drawImage(GFX.securityCamera, -8, -8);
                if (Math.floor(animFrame / 15) % 2 === 0) {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(-7, -1, 3, 3);
                }
                ctx.restore();
            }

            // === ENHANCED ATMOSPHERE: Floating Dust Particles ===
            for (let i = 0; i < 15; i++) {
                const dustX = ((animFrame * 0.5 + i * 37) % canvas.width);
                const dustY = throneRoomHeight + ((animFrame * 0.2 + i * 53) % (hallwayEnd - throneRoomHeight));
                const dustAlpha = Math.sin(animFrame * 0.05 + i) * 0.15 + 0.2;
                ctx.fillStyle = `rgba(255, 255, 255, ${dustAlpha})`;
                ctx.fillRect(dustX, dustY, 2, 2);
            }
        }
    }

    // === THRONE ROOM: Wall Torches ===
    if (y) {
        const animFrame = y.jeffAnimFrame || 0;
        const flameFlicker = Math.sin(animFrame * 0.2) * 2;

        // Left side torches
        for (let torchY = 50; torchY < throneRoomHeight - 30; torchY += 80) {
            ctx.save();
            ctx.translate(15, torchY);
            // Flame glow
            const glowSize = 20 + flameFlicker;
            const glowGrad = ctx.createRadialGradient(6, 0, 2, 6, 0, glowSize);
            glowGrad.addColorStop(0, 'rgba(255, 150, 50, 0.5)');
            glowGrad.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
            glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(6, 0, glowSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.drawImage(GFX.wallTorch, 0, -5);
            ctx.restore();
        }

        // Right side torches
        for (let torchY = 50; torchY < throneRoomHeight - 30; torchY += 80) {
            ctx.save();
            ctx.translate(canvas.width - 27, torchY);
            const glowSize = 20 + flameFlicker;
            const glowGrad = ctx.createRadialGradient(6, 0, 2, 6, 0, glowSize);
            glowGrad.addColorStop(0, 'rgba(255, 150, 50, 0.5)');
            glowGrad.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
            glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(6, 0, glowSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.drawImage(GFX.wallTorch, 0, -5);
            ctx.restore();
        }
    }

    // Draw player
    if (GAME.player.iframe > 0 && GAME.player.iframe % 6 < 3) {
        ctx.globalAlpha = 0.5;
    }
    ctx.drawImage(GFX.chars[GAME.selectedChar], GAME.player.x, GAME.player.y);
    ctx.globalAlpha = 1;

    // Goal text
    ctx.fillStyle = '#facc15';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('GOAL', 8, 8);

    ctx.restore();

    // Progress indicator (fixed position, not scrolling)
    if (y) {
        const progress = 1 - (y.playerY / y.height);
        const barWidth = 8;
        const barHeight = canvas.height - 40;
        const barX = canvas.width - 14;
        const barY = 20;

        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

        // Track
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // Progress fill
        const fillHeight = barHeight * progress;
        const gradient = ctx.createLinearGradient(0, barY + barHeight - fillHeight, 0, barY + barHeight);
        gradient.addColorStop(0, '#22c55e');
        gradient.addColorStop(1, '#16a34a');
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY + barHeight - fillHeight, barWidth, fillHeight);

        // Player marker
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(barX - 3, barY + barHeight - fillHeight - 2, barWidth + 6, 4);

        // Labels
        ctx.fillStyle = '#facc15';
        ctx.font = '4px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('JEFF', barX + barWidth / 2, barY - 4);
        ctx.fillStyle = '#22c55e';
        ctx.fillText('START', barX + barWidth / 2, barY + barHeight + 10);
        ctx.textAlign = 'left';
    }

    // === SECURITY ACTIVATION FLASH MESSAGE ===
    if (y && y.securityActivationTimer && y.securityActivationTimer > 0) {
        y.securityActivationTimer--;
        const secText = getLocalizedSecurityActivation();
        const t = y.securityActivationTimer;

        // Full screen red flash at the start
        if (t > 160) {
            const flashAlpha = (t - 160) / 20 * 0.4;
            ctx.fillStyle = `rgba(220, 38, 38, ${flashAlpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Semi-transparent dark overlay
        const overlayAlpha = Math.min(0.7, (180 - t) / 30);
        ctx.fillStyle = `rgba(0, 0, 0, ${overlayAlpha * 0.5})`;
        ctx.fillRect(0, canvas.height / 2 - 35, canvas.width, 70);

        // Warning border
        const borderFlash = Math.floor(t / 10) % 2 === 0 ? '#dc2626' : '#ff9900';
        ctx.fillStyle = borderFlash;
        ctx.fillRect(0, canvas.height / 2 - 35, canvas.width, 3);
        ctx.fillRect(0, canvas.height / 2 + 32, canvas.width, 3);

        // Main title
        ctx.save();
        ctx.textAlign = 'center';
        const shake = Math.sin(t * 0.5) * 2;
        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = '#dc2626';
        ctx.fillText(secText.title, canvas.width / 2 + shake, canvas.height / 2 - 5);

        // Subtitle
        ctx.font = '5px "Press Start 2P"';
        ctx.fillStyle = '#ff9900';
        ctx.fillText(secText.subtitle, canvas.width / 2, canvas.height / 2 + 15);
        ctx.restore();
    }
}

function drawMechaBattle() {
    const m = GAME.mecha;

    // === CASTLE THRONE ROOM BACKGROUND ===
    // Base castle wall color - changes when enraged
    let wallColor = '#1a1a2e';
    let accentColor = '#2a2a40';
    if (m && m.enraged) {
        const pulse = Math.sin(GAME.ticks * 0.1) * 0.15;
        wallColor = `rgb(${Math.floor(40 + pulse * 30)}, ${Math.floor(15 + pulse * 10)}, ${Math.floor(25 + pulse * 15)})`;
        accentColor = `rgb(${Math.floor(60 + pulse * 20)}, ${Math.floor(25 + pulse * 10)}, ${Math.floor(35 + pulse * 10)})`;
    }

    // Castle wall background
    ctx.fillStyle = wallColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Stone brick pattern
    ctx.fillStyle = accentColor;
    for (let ty = 0; ty < canvas.height; ty += 16) {
        for (let tx = 0; tx < canvas.width; tx += 20) {
            const offset = (Math.floor(ty / 16) % 2) * 10;
            ctx.fillRect(tx + offset, ty, 18, 14);
        }
    }

    // Castle pillars on sides
    ctx.fillStyle = '#151525';
    ctx.fillRect(0, 0, 24, canvas.height);
    ctx.fillRect(canvas.width - 24, 0, 24, canvas.height);
    ctx.fillStyle = '#252538';
    ctx.fillRect(4, 0, 16, canvas.height);
    ctx.fillRect(canvas.width - 20, 0, 16, canvas.height);

    // Pillar decorations
    ctx.fillStyle = '#ff9900';
    for (let py = 20; py < canvas.height; py += 40) {
        ctx.fillRect(8, py, 8, 6);
        ctx.fillRect(canvas.width - 16, py, 8, 6);
    }

    // Throne room banners
    ctx.fillStyle = '#dc2626';
    ctx.fillRect(40, 0, 20, 50);
    ctx.fillRect(canvas.width - 60, 0, 20, 50);
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(44, 20, 12, 8);
    ctx.fillRect(canvas.width - 56, 20, 12, 8);
    // Banner tips
    ctx.beginPath();
    ctx.moveTo(40, 50); ctx.lineTo(50, 65); ctx.lineTo(60, 50); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(canvas.width - 60, 50); ctx.lineTo(canvas.width - 50, 65); ctx.lineTo(canvas.width - 40, 50); ctx.fill();

    // Castle window arches with ominous glow
    const windowGlow = m && m.enraged ? 'rgba(220, 38, 38, 0.4)' : 'rgba(14, 165, 233, 0.3)';
    ctx.fillStyle = windowGlow;
    ctx.fillRect(80, 10, 30, 25);
    ctx.fillRect(canvas.width - 110, 10, 30, 25);
    ctx.beginPath();
    ctx.arc(95, 10, 15, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(canvas.width - 95, 10, 15, Math.PI, 0);
    ctx.fill();

    // Throne room floor with perspective tiles
    const floorGradient = ctx.createLinearGradient(0, 35, 0, canvas.height);
    floorGradient.addColorStop(0, '#1f1f35');
    floorGradient.addColorStop(1, '#0f0f20');
    ctx.fillStyle = floorGradient;
    ctx.fillRect(0, 35, canvas.width, canvas.height - 35);

    // Floor tile grid with perspective effect
    ctx.strokeStyle = m && m.enraged ? '#4a1515' : '#2d2d48';
    ctx.lineWidth = 1;
    for (let x = 24; x < canvas.width - 24; x += 24) {
        ctx.beginPath();
        ctx.moveTo(x, 35);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 35; y < canvas.height; y += 18) {
        ctx.beginPath();
        ctx.moveTo(24, y);
        ctx.lineTo(canvas.width - 24, y);
        ctx.stroke();
    }

    // Golden carpet runner in center
    ctx.fillStyle = m && m.enraged ? '#7f1d1d' : '#92400e';
    ctx.fillRect(canvas.width / 2 - 30, 35, 60, canvas.height - 35);
    ctx.fillStyle = m && m.enraged ? '#dc2626' : '#f59e0b';
    ctx.fillRect(canvas.width / 2 - 26, 35, 52, canvas.height - 35);
    // Carpet pattern
    ctx.fillStyle = m && m.enraged ? '#7f1d1d' : '#b45309';
    for (let cy = 45; cy < canvas.height; cy += 30) {
        ctx.fillRect(canvas.width / 2 - 20, cy, 40, 8);
    }

    // Arena edge glow line
    ctx.fillStyle = m && m.enraged ? '#dc2626' : '#ff9900';
    ctx.fillRect(24, 33, canvas.width - 48, 3);

    // === ENHANCED ATMOSPHERE: Wall Torches with Animated Flames ===
    const flameFlicker = Math.sin(GAME.ticks * 0.2) * 2;
    const flameColor = m && m.enraged ? 'rgba(220, 50, 50, ' : 'rgba(255, 150, 50, ';

    // Left pillar torches
    for (let ty = 60; ty < canvas.height - 40; ty += 70) {
        ctx.save();
        ctx.translate(18, ty);
        // Torch glow
        const glowSize = 18 + flameFlicker;
        const glowGrad = ctx.createRadialGradient(0, 0, 2, 0, 0, glowSize);
        glowGrad.addColorStop(0, flameColor + '0.6)');
        glowGrad.addColorStop(0.5, flameColor + '0.2)');
        glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();
        // Torch sprite
        ctx.drawImage(GFX.wallTorch, -6, -10);
        ctx.restore();
    }

    // Right pillar torches
    for (let ty = 60; ty < canvas.height - 40; ty += 70) {
        ctx.save();
        ctx.translate(canvas.width - 18, ty);
        const glowSize = 18 + flameFlicker;
        const glowGrad = ctx.createRadialGradient(0, 0, 2, 0, 0, glowSize);
        glowGrad.addColorStop(0, flameColor + '0.6)');
        glowGrad.addColorStop(0.5, flameColor + '0.2)');
        glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.drawImage(GFX.wallTorch, -6, -10);
        ctx.restore();
    }

    // === ENHANCED ATMOSPHERE: Floating Ember Particles ===
    for (let i = 0; i < 10; i++) {
        const emberX = ((GAME.ticks * 0.3 + i * 31) % (canvas.width - 50)) + 25;
        const emberY = canvas.height - ((GAME.ticks * 0.5 + i * 23) % (canvas.height - 60)) - 20;
        const emberAlpha = Math.sin(GAME.ticks * 0.1 + i * 0.5) * 0.3 + 0.4;
        ctx.fillStyle = m && m.enraged ? `rgba(255, 100, 50, ${emberAlpha})` : `rgba(255, 200, 100, ${emberAlpha})`;
        ctx.fillRect(emberX, emberY, 2, 2);
    }

    // === ENHANCED ATMOSPHERE: Floor Dust Swirls (when enraged) ===
    if (m && m.enraged) {
        for (let i = 0; i < 8; i++) {
            const dustX = ((GAME.ticks * 0.8 + i * 41) % (canvas.width - 60)) + 30;
            const dustY = canvas.height - 30 + Math.sin(GAME.ticks * 0.1 + i) * 10;
            const dustAlpha = Math.sin(GAME.ticks * 0.05 + i * 0.7) * 0.2 + 0.2;
            ctx.fillStyle = `rgba(100, 50, 50, ${dustAlpha})`;
            ctx.fillRect(dustX, dustY, 3, 2);
            ctx.fillRect(dustX + 4, dustY - 2, 2, 2);
        }
    }

    // Phase transition overlay
    if (m && m.phaseTransition) {
        const alpha = Math.min(0.6, m.transitionTimer / 30);
        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Phase name announcement
        if (m.transitionTimer > 20) {
            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillStyle = '#ff9900';
            const shake = Math.sin(m.transitionTimer * 0.5) * 2;
            ctx.fillText(m.phaseNames[m.currentPhase], canvas.width / 2 + shake, canvas.height / 2 - 10);
            ctx.font = '6px "Press Start 2P"';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(m.phaseTaunts[m.currentPhase], canvas.width / 2, canvas.height / 2 + 10);
            ctx.restore();
        }
    }

    // Draw boss with enrage glow and animated sprite
    if (m) {
        // Enrage aura - larger and more intense
        if (m.enraged && m.enrageFlash < 10) {
            ctx.fillStyle = 'rgba(220, 38, 38, 0.4)';
            ctx.beginPath();
            ctx.arc(m.x + 32, m.y + 32, 50 + Math.sin(GAME.ticks * 0.1) * 8, 0, Math.PI * 2);
            ctx.fill();
            // Electric arcs when enraged
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                const angle = (GAME.ticks * 0.1 + i * 2) % (Math.PI * 2);
                const dist = 40 + Math.sin(GAME.ticks * 0.2 + i) * 10;
                ctx.beginPath();
                ctx.moveTo(m.x + 32, m.y + 32);
                ctx.lineTo(m.x + 32 + Math.cos(angle) * dist, m.y + 32 + Math.sin(angle) * dist);
                ctx.stroke();
            }
        }

        // Prime Reactor glow effect (always on)
        const reactorGlow = Math.sin(GAME.ticks * 0.08) * 0.2 + 0.4;
        ctx.fillStyle = `rgba(255, 153, 0, ${reactorGlow})`;
        ctx.beginPath();
        ctx.arc(m.x + 32, m.y + 46, 20 + Math.sin(GAME.ticks * 0.1) * 3, 0, Math.PI * 2);
        ctx.fill();

        // Use animated frame based on game ticks
        const animFrame = Math.floor(GAME.ticks / 10) % 4;
        if (GFX.mechaJeffFrames && GFX.mechaJeffFrames[animFrame]) {
            ctx.drawImage(GFX.mechaJeffFrames[animFrame], m.x, m.y);
        } else {
            ctx.drawImage(GFX.mechaJeff, m.x, m.y);
        }

        // Eye targeting lasers when attacking
        if (m.currentPhase === 3 || (m.enraged && GAME.ticks % 30 < 15)) {
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(m.x + 27, m.y + 20);
            ctx.lineTo(GAME.player.x + 8, GAME.player.y + 8);
            ctx.moveTo(m.x + 37, m.y + 20);
            ctx.lineTo(GAME.player.x + 8, GAME.player.y + 8);
            ctx.stroke();
        }
    }

    // Draw player
    if (GAME.player.iframe > 0 && GAME.player.iframe % 6 < 3) {
        ctx.globalAlpha = 0.5;
    }
    ctx.drawImage(GFX.chars[GAME.selectedChar], GAME.player.x, GAME.player.y);
    ctx.globalAlpha = 1;

    if (m) {
        // Draw shadows (package warning indicators)
        m.shadows.forEach(s => {
            const pulse = Math.sin(s.timer * 0.2) * 0.3 + 0.5;
            ctx.fillStyle = `rgba(239, 68, 68, ${pulse})`;
            ctx.beginPath();
            ctx.ellipse(s.x + 8, canvas.height - 16, 12 - s.timer * 0.15, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            // Warning X
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(s.x + 2, canvas.height - 22);
            ctx.lineTo(s.x + 14, canvas.height - 10);
            ctx.moveTo(s.x + 14, canvas.height - 22);
            ctx.lineTo(s.x + 2, canvas.height - 10);
            ctx.stroke();
        });

        // Draw projectiles
        m.projectiles.forEach(pr => {
            if (pr.type === 'missile') {
                // Draw trail
                if (pr.trail) {
                    for (let i = 0; i < pr.trail.length; i++) {
                        const t = pr.trail[i];
                        const alpha = i / pr.trail.length * 0.6;
                        ctx.fillStyle = `rgba(255, 100, 50, ${alpha})`;
                        ctx.fillRect(t.x + 3, t.y + 3, 4, 4);
                    }
                }
                // Missile body
                ctx.fillStyle = '#dc2626';
                ctx.fillRect(pr.x, pr.y, 10, 10);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(pr.x + 2, pr.y + 2, 6, 6);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(pr.x + 4, pr.y + 4, 2, 2);
            }
            if (pr.type === 'drone') {
                const pulse = Math.sin((pr.pulseTimer || 0) * 0.1) * 2;
                ctx.fillStyle = '#22d3ee';
                ctx.fillRect(pr.x - pulse/2, pr.y - pulse/2, 12 + pulse, 12 + pulse);
                ctx.fillStyle = '#0ea5e9';
                ctx.fillRect(pr.x + 2, pr.y + 2, 8, 8);
                // Propeller animation
                ctx.fillStyle = '#ffffff';
                const propAngle = (pr.pulseTimer || 0) % 4;
                if (propAngle < 2) {
                    ctx.fillRect(pr.x - 3, pr.y + 5, 4, 2);
                    ctx.fillRect(pr.x + 11, pr.y + 5, 4, 2);
                } else {
                    ctx.fillRect(pr.x + 4, pr.y - 3, 4, 2);
                    ctx.fillRect(pr.x + 4, pr.y + 13, 4, 2);
                }
            }
            if (pr.type === 'box') {
                ctx.save();
                ctx.translate(pr.x + 7, pr.y + 7);
                ctx.rotate(pr.rotation || 0);
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(-7, -7, 14, 14);
                ctx.fillStyle = '#92400e';
                ctx.fillRect(-5, 3, 10, 2);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(-5, -5, 10, 3);
                ctx.restore();
            }
            if (pr.type === 'shockwave') {
                ctx.fillStyle = '#a855f7';
                ctx.beginPath();
                ctx.arc(pr.x, pr.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#e879f9';
                ctx.beginPath();
                ctx.arc(pr.x, pr.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // Draw beams (laser grid)
        m.beams.forEach(beam => {
            if (beam.telegraph > 0) {
                // Telegraph warning line
                const pulse = Math.sin(beam.telegraph * 0.3) * 0.2 + 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.fillRect(beam.x, 35, 14, canvas.height - 35);
                // Warning text
                ctx.fillStyle = '#ff0000';
                ctx.font = '4px "Press Start 2P"';
                ctx.fillText('!', beam.x + 5, 50);
            } else {
                // Active beam
                ctx.fillStyle = 'rgba(14, 165, 233, 0.6)';
                ctx.fillRect(beam.x - 2, 35, 18, canvas.height - 35);
                ctx.fillStyle = '#38bdf8';
                ctx.fillRect(beam.x + 2, 35, 10, canvas.height - 35);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(beam.x + 5, 35, 4, canvas.height - 35);
            }
        });
    }

    // Draw player projectiles (attacks)
    GAME.projectiles.forEach(proj => {
        if (proj.type === 'attack') {
            const sprite = (GFX.attacks && GFX.attacks[proj.owner]) ? GFX.attacks[proj.owner] : GFX.book;
            // Glow effect behind projectile
            ctx.fillStyle = proj.color || '#00ffff';
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.arc(proj.x + 6, proj.y + 6, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            // Draw the projectile sprite
            ctx.drawImage(sprite, proj.x, proj.y);
        }
    });

    // Particles
    GAME.particles.forEach(p => {
        const alpha = p.alpha || (p.life / 50);
        ctx.globalAlpha = Math.min(1, alpha);
        if (p.sparkle) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(p.x - 1, p.y, 3, 1);
            ctx.fillRect(p.x, p.y - 1, 1, 3);
        }
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size || 2, p.size || 2);
        ctx.globalAlpha = 1;
    });

    // Floating texts with fade out and shrink effect
    GAME.floatingTexts.forEach(t => {
        const lifePercent = t.life / GAME_CONSTANTS.FLOATING_TEXT_LIFE;

        // Fade out slowly in the last 30% of life
        let alpha = 1.0;
        if (lifePercent < 0.3) {
            alpha = lifePercent / 0.3; // Smooth fade out
        }

        // Shrink gradually from 100% to 70% size over entire lifetime
        const scale = 0.7 + (lifePercent * 0.3);
        const baseFontSize = 6;
        const fontSize = Math.max(4, Math.floor(baseFontSize * scale));

        ctx.save();
        ctx.globalAlpha = Math.max(0.1, Math.min(1, alpha)); // Keep minimum visibility
        ctx.fillStyle = t.color;
        ctx.font = `${fontSize}px "Press Start 2P"`;
        ctx.textAlign = 'center';
        ctx.fillText(t.text, t.x, t.y);
        ctx.restore();
    });
}

// === THRONE CONFRONTATION CUTSCENE ===
function drawThroneConfrontation() {
    const t = GAME.stateTimer;
    const scene = GAME.throneScene;
    if (!scene) return;

    // Dark throne room background
    const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGrad.addColorStop(0, '#050510');
    bgGrad.addColorStop(0.3, '#0a0a18');
    bgGrad.addColorStop(0.7, '#1a1a2e');
    bgGrad.addColorStop(1, '#0b1224');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Dramatic torchlight flicker
    const flickerIntensity = 0.1 + Math.sin(t * 0.15) * 0.05;
    ctx.fillStyle = `rgba(255, 120, 40, ${flickerIntensity})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw the massive throne in the center-top
    const throneX = canvas.width / 2;
    const throneY = 40;

    // Throne backing - massive golden structure
    ctx.fillStyle = '#2d1810';
    ctx.fillRect(throneX - 60, throneY - 15, 120, 80);
    ctx.fillStyle = '#4a2818';
    ctx.fillRect(throneX - 55, throneY - 10, 110, 70);

    // Throne spires (taller, more imposing)
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(throneX - 58, throneY - 40, 10, 35);
    ctx.fillRect(throneX + 48, throneY - 40, 10, 35);
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.moveTo(throneX - 58, throneY - 40);
    ctx.lineTo(throneX - 53, throneY - 55);
    ctx.lineTo(throneX - 48, throneY - 40);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(throneX + 48, throneY - 40);
    ctx.lineTo(throneX + 53, throneY - 55);
    ctx.lineTo(throneX + 58, throneY - 40);
    ctx.fill();

    // Amazon logo on throne (glowing and pulsing)
    const logoPulse = Math.sin(t * 0.08) * 0.2 + 0.8;
    ctx.fillStyle = `rgba(255, 153, 0, ${logoPulse})`;
    ctx.fillRect(throneX - 25, throneY + 5, 50, 20);
    ctx.fillStyle = '#ffb347';
    ctx.fillRect(throneX - 20, throneY + 8, 40, 14);
    // Amazon arrow/smile
    ctx.fillStyle = '#ff6600';
    ctx.beginPath();
    ctx.moveTo(throneX - 15, throneY + 18);
    ctx.quadraticCurveTo(throneX, throneY + 28, throneX + 15, throneY + 15);
    ctx.lineTo(throneX + 20, throneY + 18);
    ctx.quadraticCurveTo(throneX, throneY + 32, throneX - 18, throneY + 20);
    ctx.fill();

    // Ornate throne armrests
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(throneX - 52, throneY + 40, 16, 25);
    ctx.fillRect(throneX + 36, throneY + 40, 16, 25);

    // Menacing glow behind Bezos
    const glowSize = 60 + Math.sin(t * 0.06) * 10;
    const glowGrad = ctx.createRadialGradient(throneX, throneY + 45, 10, throneX, throneY + 45, glowSize);
    glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.6)');
    glowGrad.addColorStop(0.4, 'rgba(220, 38, 38, 0.3)');
    glowGrad.addColorStop(0.7, 'rgba(139, 0, 0, 0.15)');
    glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(throneX, throneY + 45, glowSize, 0, Math.PI * 2);
    ctx.fill();

    // Draw Jeff Bezos on throne (larger, more imposing)
    const jeffBob = Math.sin(t * 0.04) * 2;
    ctx.save();
    ctx.translate(throneX, throneY + 35 + jeffBob);
    ctx.scale(1.5, 1.5);
    ctx.drawImage(GFX.jeffYard, -24, -24);
    ctx.restore();

    // Draw player character at bottom facing Bezos
    const playerY = canvas.height - 50;
    const playerX = canvas.width / 2;
    const playerBob = Math.sin(t * 0.06) * 1;
    ctx.save();
    ctx.translate(playerX, playerY + playerBob);
    ctx.scale(1.3, 1.3);
    ctx.drawImage(GFX.chars[GAME.selectedChar], -8, -8);
    ctx.restore();

    // VS text or confrontation indicator during phase 0 (quick zoom)
    if (scene.phase === 0) {
        ctx.fillStyle = '#dc2626';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        const vsFlash = Math.sin(t * 0.1) > 0 ? '#ff4444' : '#dc2626';
        ctx.fillStyle = vsFlash;
        ctx.fillText('VS', canvas.width / 2, canvas.height / 2 - 10);

        // Show "Press Space to Continue" after initial animation
        if (GAME.stateTimer >= 40) {
            ctx.font = '8px "Press Start 2P"';
            const spaceFlash = Math.sin(t * 0.15) > 0 ? '#fbbf24' : '#ff9900';
            ctx.fillStyle = spaceFlash;
            ctx.fillText('‚ñº PRESS SPACE TO CONFRONT ‚ñº', canvas.width / 2, canvas.height - 30);
        }
    }

    // Note: Dialogue is now handled by showDialog system (no slow typewriter)

    ctx.textAlign = 'left';
}

// === MECHA TRANSFORMATION CUTSCENE ===
function drawMechaTransform() {
    const t = GAME.stateTimer;

    // Dark dramatic background
    ctx.fillStyle = '#050508';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Lightning flashes
    if (t % 30 < 5 || (t > 60 && t % 20 < 3) || (t > 120 && t % 15 < 4)) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Dramatic lines radiating from center
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
    for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2 + t * 0.02;
        const len = 50 + Math.sin(t * 0.1 + i) * 30;
        ctx.strokeStyle = i % 2 === 0 ? '#ff9900' : '#dc2626';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
        ctx.stroke();
    }
    ctx.restore();

    // Phase 1: Power surge (frames 0-80)
    if (t < 80) {
        const scale = 1 + Math.sin(t * 0.2) * 0.1;
        const shakeX = (Math.random() - 0.5) * (t / 20);
        const shakeY = (Math.random() - 0.5) * (t / 20);

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
        ctx.scale(scale, scale);
        ctx.drawImage(GFX.jeffYard, -24 + shakeX, -24 + shakeY);
        ctx.restore();

        // Warning text
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        const warningFlash = Math.sin(t * 0.15) > 0;
        if (warningFlash) {
            ctx.fillText('!! WARNING !!', canvas.width / 2, 180);
        }
        ctx.fillStyle = '#ff9900';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('TRANSFORMATION', canvas.width / 2, 195);
    }
    // Phase 2: Transformation (frames 80-160)
    else if (t < 160) {
        const progress = (t - 80) / 80;
        const shakeIntensity = 10 + progress * 20;

        // Intense shaking
        const shakeX = (Math.random() - 0.5) * shakeIntensity;
        const shakeY = (Math.random() - 0.5) * shakeIntensity;

        // Morphing between sprites
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);

        // Glowing energy effect
        const glowGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 80);
        glowGrad.addColorStop(0, `rgba(255, 153, 0, ${0.8 - progress * 0.3})`);
        glowGrad.addColorStop(0.5, `rgba(220, 38, 38, ${0.5})`);
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 80, 0, Math.PI * 2);
        ctx.fill();

        // Draw morphing sprites
        if (progress < 0.5) {
            ctx.globalAlpha = 1 - progress * 2;
            ctx.drawImage(GFX.jeffYard, -24 + shakeX, -24 + shakeY);
        }
        ctx.globalAlpha = Math.min(1, progress * 2);
        ctx.drawImage(GFX.mechaBezos, -24 + shakeX, -24 + shakeY);
        ctx.globalAlpha = 1;

        ctx.restore();

        // Text
        const texts = ['NOW WITNESS...', 'TRUE POWER...', 'FINAL FORM!'];
        const textIdx = Math.min(2, Math.floor(progress * 3));
        ctx.fillStyle = progress > 0.7 ? '#ff4444' : '#ff9900';
        ctx.font = '11px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(texts[textIdx], canvas.width / 2, 185);
    }
    // Phase 3: Mecha Reveal (frames 160+)
    else {
        const revealProgress = Math.min(1, (t - 160) / 60);

        // Epic glow
        const glowGrad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2 - 20, 20, canvas.width / 2, canvas.height / 2 - 20, 100);
        glowGrad.addColorStop(0, 'rgba(220, 38, 38, 0.6)');
        glowGrad.addColorStop(0.5, 'rgba(255, 153, 0, 0.3)');
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2 - 20, 100, 0, Math.PI * 2);
        ctx.fill();

        // Mecha Bezos revealed
        const scale = 1 + Math.sin(t * 0.1) * 0.05;
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 20);
        ctx.scale(scale, scale);
        ctx.drawImage(GFX.mechaJeff, -32, -32);
        ctx.restore();

        // Title text
        ctx.fillStyle = '#ff4444';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('MECHA JEFF BEZOS', canvas.width / 2, 175);

        ctx.fillStyle = '#ff9900';
        ctx.font = '9px monospace';
        ctx.fillText('AUTOMATION PROTOCOL ACTIVATED', canvas.width / 2, 195);

        // Continue prompt after delay
        if (t > 200) {
            ctx.fillStyle = '#fff';
            ctx.font = '8px "Press Start 2P"';
            const blink = Math.sin(t * 0.15) > 0;
            if (blink) ctx.fillText('[PRESS SPACE]', canvas.width / 2, 215);
        }
    }

    ctx.textAlign = 'left';
}

// === SIMON MECHA TRANSFORMATION CUTSCENE ===
function drawSimonMechaTransform() {
    const t = GAME.stateTimer;

    // Dark dramatic background with WHS colors
    ctx.fillStyle = '#080808';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Red warning flashes
    if (t % 25 < 4 || (t > 50 && t % 18 < 3) || (t > 100 && t % 12 < 4)) {
        ctx.fillStyle = 'rgba(220, 38, 38, 0.25)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Dramatic lines radiating from center (WHS gold and red)
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2 - 15);
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 + t * 0.025;
        const len = 40 + Math.sin(t * 0.12 + i) * 25;
        ctx.strokeStyle = i % 2 === 0 ? '#eab308' : '#dc2626';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
        ctx.stroke();
    }
    ctx.restore();

    // Phase 1: Power surge (frames 0-70)
    if (t < 70) {
        const scale = 1 + Math.sin(t * 0.18) * 0.12;
        const shakeX = (Math.random() - 0.5) * (t / 15);
        const shakeY = (Math.random() - 0.5) * (t / 15);

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 15);
        ctx.scale(scale, scale);
        // Draw Mega Simon sprite (32x32)
        ctx.drawImage(GFX.simonBoss, -16 + shakeX, -16 + shakeY);
        ctx.restore();

        // Warning text
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        const warningFlash = Math.sin(t * 0.18) > 0;
        if (warningFlash) {
            ctx.fillText('!! DANGER !!', canvas.width / 2, 175);
        }
        ctx.fillStyle = '#eab308';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('SAFETY PROTOCOL', canvas.width / 2, 190);
        ctx.fillText('INITIATING', canvas.width / 2, 202);
    }
    // Phase 2: Transformation (frames 70-140)
    else if (t < 140) {
        const progress = (t - 70) / 70;
        const shakeIntensity = 8 + progress * 15;

        // Intense shaking
        const shakeX = (Math.random() - 0.5) * shakeIntensity;
        const shakeY = (Math.random() - 0.5) * shakeIntensity;

        // Morphing between sprites
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 15);

        // Glowing energy effect (WHS colors)
        const glowGrad = ctx.createRadialGradient(0, 0, 8, 0, 0, 70);
        glowGrad.addColorStop(0, `rgba(234, 179, 8, ${0.85 - progress * 0.25})`);
        glowGrad.addColorStop(0.5, `rgba(220, 38, 38, ${0.5})`);
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 70, 0, Math.PI * 2);
        ctx.fill();

        // Draw morphing sprites - fade from Simon to Mecha Simon
        if (progress < 0.5) {
            ctx.globalAlpha = 1 - progress * 2;
            ctx.drawImage(GFX.simonBoss, -16 + shakeX, -16 + shakeY);
        }
        ctx.globalAlpha = Math.min(1, progress * 2);
        // Mecha Simon is 48x48
        ctx.drawImage(GFX.mechaMegaSimon, -24 + shakeX, -24 + shakeY);
        ctx.globalAlpha = 1;

        ctx.restore();

        // Text
        const texts = ['INITIATING...', 'UPGRADE...', 'COMPLETE!'];
        const textIdx = Math.min(2, Math.floor(progress * 3));
        ctx.fillStyle = progress > 0.7 ? '#ff4444' : '#eab308';
        ctx.font = '11px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(texts[textIdx], canvas.width / 2, 185);
    }
    // Phase 3: Mecha Reveal (frames 140+)
    else {
        const revealProgress = Math.min(1, (t - 140) / 50);

        // Epic glow
        const glowGrad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2 - 15, 15, canvas.width / 2, canvas.height / 2 - 15, 90);
        glowGrad.addColorStop(0, 'rgba(220, 38, 38, 0.65)');
        glowGrad.addColorStop(0.5, 'rgba(234, 179, 8, 0.35)');
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2 - 15, 90, 0, Math.PI * 2);
        ctx.fill();

        // Mecha Mega Simon revealed with pulse
        const scale = 1 + Math.sin(t * 0.08) * 0.04;
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2 - 15);
        ctx.scale(scale, scale);
        ctx.drawImage(GFX.mechaMegaSimon, -24, -24);
        ctx.restore();

        // Title text
        ctx.fillStyle = '#dc2626';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('MECHA MEGA', canvas.width / 2, 168);
        ctx.fillText('SIMON', canvas.width / 2, 183);

        ctx.fillStyle = '#eab308';
        ctx.font = '8px monospace';
        ctx.fillText('ULTIMATE WHS AUTHORITY', canvas.width / 2, 198);

        // Continue prompt after delay (or when text is ready)
        if (t > 180 && GAME.simonTransformTextFetched) {
            ctx.fillStyle = '#fff';
            ctx.font = '8px "Press Start 2P"';
            const blink = Math.sin(t * 0.15) > 0;
            if (blink) ctx.fillText('[PRESS SPACE]', canvas.width / 2, 215);
        } else if (t > 180) {
            // Show loading if text not ready yet
            ctx.fillStyle = '#888';
            ctx.font = '7px monospace';
            ctx.fillText('SYNCING PROTOCOL...', canvas.width / 2, 215);
        }
    }

    ctx.textAlign = 'left';
}

// === MECHA MEGA SIMON SPLASH SCREEN ===
function drawMechaSimonSplash() {
    const t = GAME.stateTimer;

    // Dark dramatic background with WHS/Amazon colors
    ctx.fillStyle = '#080008';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Red warning flashes
    if (t % 40 < 5) {
        ctx.fillStyle = 'rgba(220, 38, 38, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Dramatic radiating lines (gold and red - WHS colors)
    ctx.save();
    ctx.translate(canvas.width / 2, 100);
    for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2 + t * 0.02;
        const len = 80 + Math.sin(t * 0.1 + i) * 30;
        ctx.strokeStyle = i % 2 === 0 ? 'rgba(234, 179, 8, 0.6)' : 'rgba(220, 38, 38, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
        ctx.stroke();
    }
    ctx.restore();

    // Epic glow behind sprite
    const glowGrad = ctx.createRadialGradient(canvas.width / 2, 100, 10, canvas.width / 2, 100, 80);
    glowGrad.addColorStop(0, 'rgba(220, 38, 38, 0.7)');
    glowGrad.addColorStop(0.4, 'rgba(234, 179, 8, 0.4)');
    glowGrad.addColorStop(0.7, 'rgba(139, 0, 0, 0.2)');
    glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(canvas.width / 2, 100, 80, 0, Math.PI * 2);
    ctx.fill();

    // Mecha Mega Simon sprite (pulsing)
    const scale = 1.8 + Math.sin(t * 0.08) * 0.1;
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.translate(canvas.width / 2, 100);
    ctx.scale(scale, scale);
    ctx.drawImage(GFX.mechaMegaSimon, -24, -24);
    ctx.restore();

    // Title text with shadow effect
    ctx.textAlign = 'center';

    // "ULTIMATE THREAT" warning
    ctx.fillStyle = '#dc2626';
    ctx.font = '10px "Press Start 2P"';
    const flashWarning = Math.sin(t * 0.12) > 0;
    if (flashWarning) {
        ctx.fillText('!! ULTIMATE THREAT !!', canvas.width / 2, 28);
    }

    // Main title
    ctx.fillStyle = '#000';
    ctx.font = '14px "Press Start 2P"';
    ctx.fillText('MECHA MEGA', canvas.width / 2 + 1, 165);
    ctx.fillText('SIMON', canvas.width / 2 + 1, 182);
    ctx.fillStyle = '#dc2626';
    ctx.fillText('MECHA MEGA', canvas.width / 2, 164);
    ctx.fillText('SIMON', canvas.width / 2, 181);

    // Subtitle
    ctx.fillStyle = '#eab308';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('THE ULTIMATE WHS AUTHORITY', canvas.width / 2, 198);

    // Attack description
    ctx.fillStyle = '#ff9900';
    ctx.font = '7px monospace';
    ctx.fillText('ATTACK: COMPLIANCE ANNIHILATION', canvas.width / 2, 212);

    // Performance review warning
    ctx.fillStyle = '#ff4444';
    ctx.font = '6px monospace';
    const reviewFlash = Math.sin(t * 0.1) > 0;
    if (reviewFlash) {
        ctx.fillText('Your performance review awaits...', canvas.width / 2, 225);
    }

    // Continue prompt
    if (t > 60) {
        ctx.fillStyle = '#fff';
        ctx.font = '8px "Press Start 2P"';
        const blink = Math.sin(t * 0.15) > 0;
        if (blink) ctx.fillText('[PRESS SPACE]', canvas.width / 2, 240);
    }

    ctx.textAlign = 'left';
}

// === BEZOS ESCAPE SEQUENCE (Localized) ===
// Mecha Jeff's defeat one-liner (shown right after defeat)
const MECHA_JEFF_DEFEAT_LINES = {
    EN: "CRITICAL... SYSTEM... FAILURE! But you haven't won yet, worker ant! My TRUE form awaits...",
    AT: "KRITISCHER... SYSTEM... AUSFALL! Aber du hast no ned gwonnen, Hacklerameise! Meine WAHRE Form wartet...",
    DE: "KRITISCHER... SYSTEM... AUSFALL! Aber du hast noch nicht gewonnen, Arbeiterameise! Meine WAHRE Form wartet...",
    NL: "KRITIEKE... SYSTEEM... FOUT! Maar je hebt nog niet gewonnen, werkiermier! Mijn WARE vorm wacht..."
};

function getMechaJeffDefeatLine() {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
    return {
        speaker: "Mecha Jeff",
        portrait: "mechaJeff",
        text: MECHA_JEFF_DEFEAT_LINES[region] || MECHA_JEFF_DEFEAT_LINES.EN
    };
}

// Jeff Bezos one-liner after transforming back (shown after de-mecha transformation)
const JEFF_TRANSFORM_LINES = {
    EN: "Ugh! That mecha suit cost more than your entire BLOODLINE! No matter... I have a BACKUP plan!",
    AT: "Pfui! Der Mecha-Anzug hat mehr kost als deine ganze BLUTLINIE! Egal... i hab an BACKUP-Plan!",
    DE: "Pfui! Der Mecha-Anzug hat mehr gekostet als deine ganze BLUTLINIE! Egal... ich habe einen BACKUP-Plan!",
    NL: "Bah! Dat mechapak kostte meer dan je hele BLOEDLIJN! Maakt niet uit... ik heb een BACK-UP plan!"
};

function getJeffTransformLine() {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
    return {
        speaker: "Jeff Bezos",
        portrait: "jeffYard",
        text: JEFF_TRANSFORM_LINES[region] || JEFF_TRANSFORM_LINES.EN
    };
}

// Snarky dialogue exchange during/after rocket escape (Localized)
const BEZOS_ESCAPE_TEXTS = {
    EN: [
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Ha! You think this is over? I've got a rocket for EXACTLY this situation! Customer obsession includes ME escaping!" },
        { speaker: "player", portrait: "player", text: "Running away? That's NOT very 'Day One' of you, Bezos! What happened to 'bias for action'?" },
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "I'm not running, I'm PIVOTING! To space! Where there are no unions, no bathroom breaks, and NO SAFETY COORDINATORS!" },
        { speaker: "player", portrait: "player", text: "Go on then! We'll send the safety violations to orbit! Workers 1, Billionaire Bald Guy 0!" },
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "This isn't goodbye... it's 'See you in the next Prime Day'! BEZOS AWAAAAAY!", final: true }
    ],
    AT: [
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Ha! Glaubst des is vorbei? I hab a Rakete f√ºr GENAU so a Situation! Kundenobsession schlie√üt MEIN Entkommen ein!" },
        { speaker: "player", portrait: "player", text: "Wegrennen? Des is ned sehr 'Tag Eins' von dir, Bezos! Wos is mit 'Bias for Action' passiert?" },
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "I renn ned, i PIVOTIER! Ins Weltall! Wo's ka Gewerkschaften, ka Klopausen und KA SICHERHEITSKOORDINATOREN gibt!" },
        { speaker: "player", portrait: "player", text: "Dann hau ab! Mir schicken die Sicherheitsverst√∂√üe in die Umlaufbahn! Hackler 1, Milliard√§rs-Glatzkopf 0!" },
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Des is ka Abschied... es is 'Bis zum n√§chsten Prime Day'! BEZOS ABFLUUUUG!", final: true }
    ],
    DE: [
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Ha! Glaubst du das ist vorbei? Ich habe eine Rakete f√ºr GENAU diese Situation! Kundenobsession schlie√üt MEIN Entkommen ein!" },
        { speaker: "player", portrait: "player", text: "Wegrennen? Das ist NICHT sehr 'Tag Eins' von dir, Bezos! Was ist mit 'Bias for Action' passiert?" },
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Ich renne nicht, ich PIVOTIERE! Ins Weltall! Wo es keine Gewerkschaften, keine Toilettenpausen und KEINE SICHERHEITSKOORDINATOREN gibt!" },
        { speaker: "player", portrait: "player", text: "Dann hau ab! Wir schicken die Sicherheitsverst√∂√üe in die Umlaufbahn! Arbeiter 1, Milliard√§rs-Glatzkopf 0!" },
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Das ist kein Abschied... es ist 'Bis zum n√§chsten Prime Day'! BEZOS ABFLUUUUG!", final: true }
    ],
    NL: [
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Ha! Denk je dat dit voorbij is? Ik heb een raket voor PRECIES deze situatie! Klantobsessie omvat MIJN ontsnapping!" },
        { speaker: "player", portrait: "player", text: "Wegrennen? Dat is NIET erg 'Dag E√©n' van je, Bezos! Wat is er met 'bias for action' gebeurd?" },
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Ik ren niet, ik PIVOT! Naar de ruimte! Waar geen vakbonden zijn, geen toiletpauzes, en GEEN VEILIGHEIDSCO√ñRDINATOREN!" },
        { speaker: "player", portrait: "player", text: "Ga dan maar! We sturen de veiligheidsovertredingen naar de baan! Werkers 1, Miljardair Kale Kerel 0!" },
        { speaker: "Jeff Bezos", portrait: "jeffYard", text: "Dit is geen afscheid... het is 'Tot de volgende Prime Day'! BEZOS WEEEEEG!", final: true }
    ]
};

function getBezosEscapeDialogues() {
    const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
    const texts = BEZOS_ESCAPE_TEXTS[region] || BEZOS_ESCAPE_TEXTS.EN;
    // Replace "player" speaker with actual selected character
    return texts.map(d => ({
        ...d,
        speaker: d.speaker === "player" ? (GAME?.selectedChar || "Player") : d.speaker
    }));
}

function updateBezosEscape() {
    GAME.stateTimer++;
    const scene = GAME.escapeScene;
    if (!scene) return;

    scene.phaseTimer = (scene.phaseTimer || 0) + 1;
    const t = scene.phaseTimer;

    // Phase 0: Mecha sparks and shakes (90 frames), then show Mecha Jeff's one-liner
    if (scene.phase === 0) {
        if (t >= 90) {
            scene.phase = 1;
            scene.phaseTimer = 0;
            // Show Mecha Jeff's defeat one-liner
            GAME.dialogBackgroundState = 'BEZOS_ESCAPE';
            const defeatLine = getMechaJeffDefeatLine();
            showDialog(defeatLine.text, defeatLine.speaker, GFX.mechaJeff, true);
            GAME.nextState = 'BEZOS_ESCAPE_MECHA_LINE';
        }
    }
    // Phase 1: Waiting for Mecha Jeff dialogue to finish (handled by dialogue system)
    // Phase 2: Mecha explodes dramatically (200 frames)
    else if (scene.phase === 2) {
        // Generate explosion particles
        if (t < 60 && t % 5 === 0) {
            for (let i = 0; i < 5; i++) {
                scene.explosionParticles.push({
                    x: scene.jeffX + (Math.random() - 0.5) * 40,
                    y: scene.jeffY + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6 - 2,
                    life: 60 + Math.random() * 40,
                    color: Math.random() > 0.5 ? '#ff9900' : '#dc2626',
                    size: 4 + Math.random() * 6
                });
            }
            if (t % 15 === 0) AudioSys.sfx.bossHit();
        }
        // Update particles
        scene.explosionParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1;
            p.life--;
            p.size *= 0.98;
        });
        scene.explosionParticles = scene.explosionParticles.filter(p => p.life > 0);

        if (t >= 200) {
            scene.phase = 3;
            scene.phaseTimer = 0;
            scene.transformProgress = 0;
        }
    }
    // Phase 3: Slow transformation back to regular Jeff (250 frames)
    else if (scene.phase === 3) {
        scene.transformProgress = Math.min(1, t / 220);

        // Steam/smoke particles during transformation
        if (t % 8 === 0 && t < 180) {
            scene.explosionParticles.push({
                x: scene.jeffX + (Math.random() - 0.5) * 30,
                y: scene.jeffY,
                vx: (Math.random() - 0.5) * 1,
                vy: -1 - Math.random() * 2,
                life: 40 + Math.random() * 30,
                color: '#888888',
                size: 8 + Math.random() * 8
            });
        }
        // Update particles
        scene.explosionParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            p.size *= 0.97;
        });
        scene.explosionParticles = scene.explosionParticles.filter(p => p.life > 0);

        if (t >= 250) {
            scene.phase = 4;
            scene.phaseTimer = 0;
            // Show Jeff's one-liner after transformation
            GAME.dialogBackgroundState = 'BEZOS_ESCAPE';
            const transformLine = getJeffTransformLine();
            showDialog(transformLine.text, transformLine.speaker, GFX.jeffYard, true);
            GAME.nextState = 'BEZOS_ESCAPE_JEFF_LINE';
        }
    }
    // Phase 4: Waiting for Jeff's dialogue to finish (handled by dialogue system)
    // Phase 5: Show throne room backdrop, Jeff runs to rocket (350 frames - longer)
    else if (scene.phase === 5) {
        // Move Jeff toward the big centered rocket (slower movement)
        const targetX = scene.rocketX - 20; // Left of the rocket
        const targetY = scene.rocketY + 60; // Near bottom of rocket
        scene.jeffX += (targetX - scene.jeffX) * 0.018; // Slower movement
        scene.jeffY += (targetY - scene.jeffY) * 0.018;

        if (t >= 350) {
            scene.phase = 6;
            scene.phaseTimer = 0;
            // Initialize camera for phase 6
            scene.cameraZoom = 1.0;
            scene.cameraY = 0;
        }
    }
    // Phase 6: Epic rocket launch sequence (900 frames total - longer and slower)
    else if (scene.phase === 6) {
        // Sub-phases: 0-90 = boarding, 91-240 = countdown, 241+ = launch

        // Initialize countdown if not started
        if (t === 1) {
            scene.launchCountdown = 5; // Longer countdown from 5
            scene.countdownTimer = 0;
        }

        // Boarding phase (first 90 frames - longer)
        if (t <= 90 && !scene.rocketLaunched) {
            scene.jeffVisible = true;
            // Jeff moves toward rocket hatch (slower)
            const hatchX = scene.rocketX + 32;
            const hatchY = scene.rocketY + 50;
            scene.jeffX += (hatchX - scene.jeffX) * 0.05;
            scene.jeffY += (hatchY - scene.jeffY) * 0.05;
        }
        // Countdown phase (frames 91-300 - longer countdown)
        else if (t > 90 && t <= 300 && !scene.rocketLaunched) {
            scene.jeffVisible = false; // Jeff is inside
            scene.countdownTimer++;
            // Update countdown every 42 frames (about 0.7 seconds each)
            if (scene.countdownTimer >= 42 && scene.launchCountdown > 0) {
                scene.launchCountdown--;
                scene.countdownTimer = 0;
                AudioSys.sfx.bossHit(); // Countdown beep
            }
            // Camera starts zooming out slightly (slower)
            scene.cameraZoom = Math.max(0.7, scene.cameraZoom - 0.002);
        }
        // Launch phase (frames 301+)
        else if (t > 300) {
            if (!scene.rocketLaunched) {
                scene.rocketLaunched = true;
                scene.rocketVelocity = 0.3; // Start slower
                AudioSys.sfx.bossIntro(); // Big launch sound
                // Initialize stars for space
                scene.stars = [];
                for (let i = 0; i < 100; i++) {
                    scene.stars.push({
                        x: Math.random() * canvas.width * 2,
                        y: Math.random() * 2000 - 2000, // Stars above the screen
                        size: Math.random() * 2 + 1,
                        twinkle: Math.random() * Math.PI * 2
                    });
                }
            }

            // Rocket acceleration - starts slow, then speeds up (slower overall)
            const launchTime = t - 300;
            scene.rocketVelocity = 0.3 + launchTime * 0.012; // Slower acceleration
            scene.rocketY -= scene.rocketVelocity;

            // Camera follows the rocket
            scene.followingRocket = true;
            // Camera target follows rocket, keeping it in lower third of screen
            scene.cameraTargetY = scene.rocketY - canvas.height * 0.6;
            // Smooth camera follow (slower)
            scene.cameraY += (scene.cameraTargetY - scene.cameraY) * 0.05;

            // Continue zooming out as rocket goes higher (slower)
            if (launchTime < 300) {
                scene.cameraZoom = Math.max(0.4, scene.cameraZoom - 0.001);
            }

            // Transition to space when rocket is high enough
            if (scene.rocketY < -700) {
                scene.inSpace = true;
            }

            // End phase when rocket is far in space (longer flight)
            if (scene.rocketY < -2000 || launchTime >= 600) {
                scene.phase = 7;
                scene.dialogueStep = 0;
                scene.phaseTimer = 0;
                // Reset camera for dialogue
                scene.cameraY = 0;
                scene.cameraZoom = 1.0;
                scene.followingRocket = false;
                // Start snarky dialogue exchange
                showBezosEscapeDialogue(0);
            }
        }
    }
    // Phase 7: Dialogue exchange (handled by dialogue system)
    // Phase 8: Simon joins player from warehouse entrance
    else if (scene.phase === 8) {
        if (!scene.simonJoined) {
            scene.simonJoined = true;
            scene.simonX = -30;
            scene.simonY = canvas.height - 45;
            MusicSys.play('victory');
        }
        // Simon walks in from left (slower)
        if (scene.simonX < canvas.width / 2 - 50) {
            scene.simonX += 0.8; // Slower walk
        }
        // After Simon arrives and some time passes, go to credits (much longer - 600 frames)
        if (t >= 600) {
            GAME.state = 'CREDITS';
            GAME.stateTimer = 0;
            GAME.creditsType = 'mecha';
            GAME.creditsStarted = false; // Ensure startCredits() is called
            updateMusicForState(); // Play credits music
        }
    }
}

// Localized Simon congratulations after Bezos defeat
const SIMON_BEZOS_CONGRATS = {
    EN: 'OUTSTANDING! You actually did it! You defeated the corporate overlord himself! This calls for a celebration... and possibly a promotion. The warehouse is finally safe from maniacal billionaire tyranny!',
    AT: 'HERVORRAGEND! Du hast es tats√§chlich gschafft! Du hast den Konzernherrn pers√∂nlich besiegt! Des verdient a Feier... und vielleicht a Bef√∂rderung. Das Lager is endlich sicher vor wahnsinniger Milliard√§rstyrannei!',
    DE: 'HERVORRAGEND! Du hast es tats√§chlich geschafft! Du hast den Konzernherren pers√∂nlich besiegt! Das verdient eine Feier... und vielleicht eine Bef√∂rderung. Das Lager ist endlich sicher vor wahnsinniger Milliard√§rstyrannei!',
    NL: 'UITSTEKEND! Je hebt het echt gedaan! Je hebt de bedrijfsoverlord zelf verslagen! Dit vraagt om een feestje... en misschien een promotie. Het magazijn is eindelijk veilig voor waanzinnige miljardairstirannie!'
};

function showBezosEscapeDialogue(index) {
    const dialogues = getBezosEscapeDialogues();

    if (index >= dialogues.length) {
        // All dialogues done, move to Simon joining (phase 8)
        GAME.escapeScene.phase = 8;
        GAME.escapeScene.phaseTimer = 0;
        // Show Simon's congratulations (localized)
        const region = (typeof GAME !== 'undefined' && GAME.region) ? GAME.region : 'EN';
        const congratsText = SIMON_BEZOS_CONGRATS[region] || SIMON_BEZOS_CONGRATS.EN;
        GAME.dialogBackgroundState = 'BEZOS_ESCAPE';
        showDialog(congratsText, 'Simon', GFX.simonFaceLarge, false);
        GAME.nextState = 'BEZOS_ESCAPE'; // Stay in escape to continue animation
        return;
    }

    const dialogue = dialogues[index];
    let portrait = GFX.jeffYard;
    if (dialogue.portrait === 'player') {
        portrait = GFX.chars[GAME.selectedChar];
    }

    GAME.dialogBackgroundState = 'BEZOS_ESCAPE';
    showDialog(dialogue.text, dialogue.speaker, portrait, true);
    GAME.escapeScene.dialogueStep = index;
    GAME.nextState = 'BEZOS_ESCAPE_DIALOGUE'; // Special state for escape dialogue continuation
}

function advanceBezosEscapeDialogue() {
    const scene = GAME.escapeScene;
    if (!scene) return;

    // Close current dialog
    stopPortraitAnimation();
    document.getElementById('dialog-box').style.display = 'none';
    TTSSys.cancel();

    // Move to next dialogue
    const nextIndex = scene.dialogueStep + 1;
    showBezosEscapeDialogue(nextIndex);
}

function drawBezosEscape() {
    const t = GAME.stateTimer;
    const scene = GAME.escapeScene;
    if (!scene) return;

    const pt = scene.phaseTimer || 0;

    // Draw throne room backdrop for phases 0-7 (keep throne room during dialogue)
    if (scene.phase <= 7) {
        drawThroneRoomBackdrop(t);
    } else {
        // After dialogue, switch to victory scene for Simon joining
        drawVictoryBackdrop(t);
    }

    // Phase 0: Mecha sparks and shakes (defeated but still standing)
    if (scene.phase === 0) {
        const shake = Math.sin(pt * 0.5) * (4 + pt * 0.05);

        // Warning sparks flying off
        for (let i = 0; i < 8; i++) {
            const sparkAngle = (i / 8) * Math.PI * 2 + pt * 0.1;
            const sparkDist = 20 + Math.sin(pt * 0.3 + i) * 10;
            const sx = scene.jeffX + Math.cos(sparkAngle) * sparkDist;
            const sy = scene.jeffY + Math.sin(sparkAngle) * sparkDist;
            ctx.fillStyle = pt % 4 < 2 ? '#ff9900' : '#ffff00';
            ctx.globalAlpha = 0.6 + Math.sin(pt * 0.5 + i) * 0.4;
            ctx.fillRect(sx - 2, sy - 2, 4, 4);
        }
        ctx.globalAlpha = 1;

        // Damaged Mecha Jeff shaking
        ctx.save();
        ctx.translate(scene.jeffX + shake, scene.jeffY);
        // Flickering/damage effect
        if (pt % 6 < 4) {
            ctx.globalAlpha = 0.8;
            ctx.drawImage(GFX.mechaJeff, -32, -32);
        }
        ctx.restore();

        // Damage indicators
        ctx.fillStyle = '#ff4444';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('CRITICAL DAMAGE', canvas.width / 2, 30);
        ctx.fillStyle = '#ff9900';
        ctx.font = '8px "Press Start 2P"';
        const warningFlash = pt % 30 < 15 ? 'WARNING' : 'SYSTEM FAILURE';
        ctx.fillText(warningFlash, canvas.width / 2, 48);
    }
    // Phase 1: Waiting for Mecha dialogue (still show damaged mecha)
    else if (scene.phase === 1) {
        const shake = Math.sin(pt * 0.3) * 3;
        ctx.save();
        ctx.translate(scene.jeffX + shake, scene.jeffY);
        ctx.globalAlpha = 0.9;
        ctx.drawImage(GFX.mechaJeff, -32, -32);
        ctx.restore();

        // Continuous sparks
        for (let i = 0; i < 5; i++) {
            const sx = scene.jeffX + (Math.random() - 0.5) * 50;
            const sy = scene.jeffY + (Math.random() - 0.5) * 50;
            ctx.fillStyle = Math.random() > 0.5 ? '#ff9900' : '#ffff00';
            ctx.globalAlpha = 0.7;
            ctx.fillRect(sx - 1, sy - 1, 3, 3);
        }
        ctx.globalAlpha = 1;
    }
    // Phase 2: Mecha explodes dramatically
    else if (scene.phase === 2) {
        const progress = Math.min(1, pt / 180);

        // Explosion core
        if (pt < 100) {
            const coreSize = 30 + progress * 80;
            const coreGrad = ctx.createRadialGradient(scene.jeffX, scene.jeffY, 0, scene.jeffX, scene.jeffY, coreSize);
            coreGrad.addColorStop(0, 'rgba(255, 255, 255, ' + (1 - progress) + ')');
            coreGrad.addColorStop(0.3, 'rgba(255, 200, 50, ' + (0.8 - progress * 0.5) + ')');
            coreGrad.addColorStop(0.6, 'rgba(255, 100, 0, ' + (0.6 - progress * 0.4) + ')');
            coreGrad.addColorStop(1, 'rgba(200, 0, 0, 0)');
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(scene.jeffX, scene.jeffY, coreSize, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw explosion particles
        scene.explosionParticles.forEach(p => {
            ctx.globalAlpha = Math.min(1, p.life / 30);
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        });
        ctx.globalAlpha = 1;

        // Screen flash
        if (pt < 30 && pt % 8 < 4) {
            ctx.fillStyle = 'rgba(255, 255, 255, ' + (0.6 - pt * 0.02) + ')';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Mecha fading out (first half only)
        if (pt < 60) {
            ctx.save();
            ctx.translate(scene.jeffX, scene.jeffY);
            ctx.globalAlpha = Math.max(0, 1 - pt / 50);
            const scale = 1 + pt * 0.01;
            ctx.scale(scale, scale);
            ctx.drawImage(GFX.mechaJeff, -32, -32);
            ctx.restore();
        }

        // Text
        ctx.fillStyle = '#ff4444';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('MECHA DESTROYED', canvas.width / 2, 30);

        if (pt > 100) {
            ctx.fillStyle = '#ffcc00';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText('FORM DESTABILIZING...', canvas.width / 2, 50);
        }
    }
    // Phase 3: Slow transformation back to regular Jeff
    else if (scene.phase === 3) {
        const progress = scene.transformProgress || 0;

        // Transformation energy field
        const fieldSize = 50 - progress * 20;
        const fieldGrad = ctx.createRadialGradient(scene.jeffX, scene.jeffY, 0, scene.jeffX, scene.jeffY, fieldSize);
        fieldGrad.addColorStop(0, 'rgba(100, 200, 255, ' + (0.3 - progress * 0.2) + ')');
        fieldGrad.addColorStop(0.5, 'rgba(50, 150, 255, ' + (0.2 - progress * 0.15) + ')');
        fieldGrad.addColorStop(1, 'rgba(0, 100, 200, 0)');
        ctx.fillStyle = fieldGrad;
        ctx.beginPath();
        ctx.arc(scene.jeffX, scene.jeffY, fieldSize, 0, Math.PI * 2);
        ctx.fill();

        // Steam/smoke particles
        scene.explosionParticles.forEach(p => {
            ctx.globalAlpha = Math.min(0.6, p.life / 40);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Morphing sprites with smooth transition
        ctx.save();
        ctx.translate(scene.jeffX, scene.jeffY);

        // Mecha fading out
        if (progress < 0.6) {
            ctx.globalAlpha = Math.max(0, 1 - progress * 1.8);
            const mechaScale = 1 - progress * 0.3;
            ctx.scale(mechaScale, mechaScale);
            ctx.drawImage(GFX.mechaJeff, -32, -32);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.translate(scene.jeffX, scene.jeffY);
        }

        // Jeff fading in
        if (progress > 0.3) {
            ctx.globalAlpha = Math.min(1, (progress - 0.3) / 0.6);
            const jeffScale = 0.7 + progress * 0.3;
            ctx.scale(jeffScale, jeffScale);
            ctx.drawImage(GFX.jeffYard, -24, -24);
        }
        ctx.restore();

        // Text progression
        ctx.fillStyle = '#22d3ee';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';
        if (progress < 0.3) {
            ctx.fillText('REVERTING...', canvas.width / 2, 30);
        } else if (progress < 0.7) {
            ctx.fillText('TRANSFORMATION...', canvas.width / 2, 30);
        } else {
            ctx.fillStyle = '#ff9900';
            ctx.fillText('BEZOS RETURNS!', canvas.width / 2, 30);
        }
    }
    // Phase 4: Waiting for Jeff's dialogue
    else if (scene.phase === 4) {
        // Jeff standing (post-transformation)
        ctx.drawImage(GFX.jeffYard, scene.jeffX - 24, scene.jeffY - 24);

        // Residual steam
        for (let i = 0; i < 3; i++) {
            const smokeX = scene.jeffX + Math.sin(t * 0.05 + i * 2) * 15;
            const smokeY = scene.jeffY - 30 - i * 12;
            ctx.fillStyle = `rgba(150, 150, 150, ${0.2 - i * 0.05})`;
            ctx.beginPath();
            ctx.arc(smokeX, smokeY, 6 + i * 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    // Phase 5: Jeff runs to rocket (throne room with rocket visible)
    else if (scene.phase === 5) {
        // Draw rocket on platform (bigger rocket now)
        ctx.drawImage(GFX.escapeRocket, scene.rocketX, scene.rocketY);

        // "SECRET ESCAPE POD" label
        ctx.fillStyle = '#ff9900';
        ctx.font = '8px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('BEZOS ESCAPE POD', scene.rocketX + 32, scene.rocketY - 12);

        // Jeff running animation
        const runFrame = Math.floor(pt / 8) % 2;
        ctx.save();
        ctx.translate(scene.jeffX, scene.jeffY + (runFrame * 3));
        // Face right (toward rocket)
        ctx.scale(-1, 1);
        ctx.drawImage(GFX.jeffYard, -24, -24);
        ctx.restore();

        // Running dust clouds
        if (pt % 12 === 0) {
            ctx.fillStyle = 'rgba(150, 150, 150, 0.4)';
            ctx.beginPath();
            ctx.arc(scene.jeffX - 20, scene.jeffY + 20, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Text
        ctx.fillStyle = '#fbbf24';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('TACTICAL RETREAT!', canvas.width / 2, 30);
        ctx.fillStyle = '#888';
        ctx.font = '7px monospace';
        ctx.fillText('"To the secret escape pod!"', canvas.width / 2, 45);
    }
    // Phase 6: Epic rocket launch with camera follow
    else if (scene.phase === 6) {
        const launchTime = Math.max(0, pt - 180);

        // Apply camera transform for zoom and follow
        ctx.save();

        // Calculate zoom center (center of screen)
        const zoomCenterX = canvas.width / 2;
        const zoomCenterY = canvas.height / 2;

        // Apply zoom and camera follow
        ctx.translate(zoomCenterX, zoomCenterY);
        ctx.scale(scene.cameraZoom || 1, scene.cameraZoom || 1);
        ctx.translate(-zoomCenterX, -zoomCenterY - (scene.cameraY || 0));

        // Draw space background (gradient from blue to black) when in upper atmosphere
        if (scene.followingRocket) {
            const spaceProgress = Math.min(1, Math.max(0, -scene.rocketY / 1000));

            // Sky gradient - blue to dark blue to black
            const gradient = ctx.createLinearGradient(0, scene.cameraY - 500, 0, scene.cameraY + canvas.height);
            gradient.addColorStop(0, `rgba(0, 0, 20, ${spaceProgress})`);
            gradient.addColorStop(0.3, `rgba(10, 20, 60, ${spaceProgress * 0.8})`);
            gradient.addColorStop(0.6, `rgba(30, 60, 120, ${spaceProgress * 0.5})`);
            gradient.addColorStop(1, `rgba(100, 150, 200, ${spaceProgress * 0.3})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, scene.cameraY - 1000, canvas.width * 2, 3000);

            // Draw stars (when getting into space)
            if (scene.stars && spaceProgress > 0.2) {
                for (const star of scene.stars) {
                    const twinkle = Math.sin(t * 0.1 + star.twinkle) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * spaceProgress})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y + scene.cameraY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw Earth horizon curving away (when high enough)
            if (spaceProgress > 0.5) {
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height + 800 + scene.cameraY, 900, Math.PI, 2 * Math.PI);
                ctx.fill();
                // Atmosphere glow
                ctx.strokeStyle = `rgba(135, 206, 250, ${spaceProgress * 0.6})`;
                ctx.lineWidth = 20;
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height + 800 + scene.cameraY, 910, Math.PI, 2 * Math.PI);
                ctx.stroke();
            }
        }

        // Draw the big rocket
        ctx.drawImage(GFX.escapeRocket, scene.rocketX, scene.rocketY);

        // Boarding phase - Jeff running to rocket
        if (pt <= 60 && !scene.rocketLaunched) {
            ctx.drawImage(GFX.jeffYard, scene.jeffX - 12, scene.jeffY - 12);
            ctx.fillStyle = '#ff9900';
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('BOARDING...', canvas.width / 2, 30 + (scene.cameraY || 0));
        }
        // Countdown phase
        else if (pt > 60 && pt <= 180 && !scene.rocketLaunched) {
            // Countdown display
            const countdown = scene.launchCountdown !== undefined ? scene.launchCountdown : 3;

            // Big countdown number
            ctx.fillStyle = countdown === 0 ? '#22c55e' : '#ff4444';
            ctx.font = '32px "Press Start 2P"';
            ctx.textAlign = 'center';
            const countText = countdown === 0 ? 'LAUNCH!' : countdown.toString();
            ctx.fillText(countText, canvas.width / 2, canvas.height / 2 - 20 + (scene.cameraY || 0));

            // Warning flashing
            if (t % 20 < 10) {
                ctx.fillStyle = '#ff9900';
                ctx.font = '8px "Press Start 2P"';
                ctx.fillText('T-MINUS', canvas.width / 2, canvas.height / 2 - 50 + (scene.cameraY || 0));
            }

            // Rocket rumble/vibration
            ctx.drawImage(GFX.escapeRocket, scene.rocketX + (Math.random() - 0.5) * 2, scene.rocketY);

            // Pre-launch smoke
            for (let i = 0; i < 5; i++) {
                const smokeX = scene.rocketX + 32 + (Math.random() - 0.5) * 40;
                const smokeY = scene.rocketY + 120 + Math.random() * 20;
                ctx.fillStyle = `rgba(200, 200, 200, ${0.4 - i * 0.08})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, 10 + Math.random() * 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        // Launch phase - rocket flying with massive flames
        else if (scene.rocketLaunched) {
            // Screen shake during initial launch
            const shakeAmount = Math.max(0, 8 - launchTime * 0.02);
            if (shakeAmount > 0) {
                ctx.translate((Math.random() - 0.5) * shakeAmount, (Math.random() - 0.5) * shakeAmount);
            }

            // Massive rocket flames (3 engines worth)
            const flameIntensity = Math.min(1, launchTime / 30);
            for (let engine = 0; engine < 3; engine++) {
                const engineX = scene.rocketX + 25 + engine * 7;
                for (let i = 0; i < 15; i++) {
                    const flameY = scene.rocketY + 128 + i * 12;
                    const flameWidth = (30 - i * 1.8) * flameIntensity;
                    const colors = ['#ffffff', '#ffffaa', '#ffff00', '#ffcc00', '#ff9900', '#ff6600', '#ff3300', '#cc0000'];
                    ctx.fillStyle = colors[Math.min(i, colors.length - 1)];
                    ctx.globalAlpha = (0.95 - i * 0.06) * flameIntensity;
                    const wobble = Math.sin(t * 0.8 + i * 0.5 + engine) * (4 + i * 0.3);
                    ctx.fillRect(engineX - flameWidth/2 + wobble, flameY, flameWidth, 12);
                }
            }
            ctx.globalAlpha = 1;

            // Massive smoke/exhaust trail
            for (let i = 0; i < 40; i++) {
                const smokeY = scene.rocketY + 180 + i * 20;
                const smokeX = scene.rocketX + 32 + Math.sin(t * 0.05 + i * 0.3) * (15 + i * 0.8);
                const smokeSize = 15 + i * 2.5;
                ctx.fillStyle = `rgba(180, 180, 180, ${0.6 - i * 0.015})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw rocket on top of flames
            ctx.drawImage(GFX.escapeRocket, scene.rocketX, scene.rocketY);
        }

        ctx.restore(); // End camera transform

        // HUD elements (not affected by camera)
        ctx.fillStyle = '#ff4444';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';

        if (scene.rocketLaunched) {
            ctx.fillText('BEZOS ESCAPES!', canvas.width / 2, 25);
            ctx.fillStyle = '#ff9900';
            ctx.font = '8px monospace';
            ctx.fillText('"To infinity and tax evasion!"', canvas.width / 2, 42);

            // Altitude indicator
            const altitude = Math.max(0, Math.floor(-scene.rocketY / 10));
            ctx.fillStyle = '#00ff00';
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'right';
            ctx.fillText(`ALT: ${altitude}km`, canvas.width - 10, 20);

            // Speed indicator
            const speed = Math.floor((scene.rocketVelocity || 0) * 100);
            ctx.fillText(`SPD: ${speed}m/s`, canvas.width - 10, 32);
        }
    }
    // Phase 7: Dialogue exchange with animated wide view of rocket in space
    else if (scene.phase === 7) {
        // Initialize space view animation state
        if (!scene.spaceViewInit) {
            scene.spaceViewInit = true;
            scene.spaceRocketY = 60; // Start position in the upper part of screen
            scene.spaceRocketScale = 0.5; // Starting scale (will shrink)
            scene.spaceStars = [];
            for (let i = 0; i < 80; i++) {
                scene.spaceStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.7,
                    size: Math.random() * 2 + 0.5,
                    twinkle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.5 + 0.1
                });
            }
        }

        // Draw epic space backdrop over throne room ceiling
        ctx.save();

        // Dark space gradient at the top (through the blasted ceiling)
        const spaceGrad = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);
        spaceGrad.addColorStop(0, '#000010');
        spaceGrad.addColorStop(0.3, '#050520');
        spaceGrad.addColorStop(0.6, '#0a0a30');
        spaceGrad.addColorStop(1, 'rgba(15, 15, 40, 0.8)');
        ctx.fillStyle = spaceGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height * 0.65);

        // Animated twinkling stars
        for (const star of scene.spaceStars) {
            star.twinkle += 0.05;
            const twinkle = Math.sin(star.twinkle) * 0.4 + 0.6;
            ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw Earth horizon curving at the bottom of the space view
        const earthY = canvas.height * 0.55;
        ctx.fillStyle = '#1e40af';
        ctx.beginPath();
        ctx.arc(canvas.width / 2, earthY + 400, 420, Math.PI, 2 * Math.PI);
        ctx.fill();

        // Atmosphere glow around Earth
        const atmosGrad = ctx.createRadialGradient(
            canvas.width / 2, earthY + 400, 400,
            canvas.width / 2, earthY + 400, 450
        );
        atmosGrad.addColorStop(0, 'rgba(135, 206, 250, 0)');
        atmosGrad.addColorStop(0.5, 'rgba(135, 206, 250, 0.4)');
        atmosGrad.addColorStop(1, 'rgba(135, 206, 250, 0)');
        ctx.fillStyle = atmosGrad;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, earthY + 400, 450, Math.PI, 2 * Math.PI);
        ctx.fill();

        // Animate rocket moving upward and shrinking
        scene.spaceRocketY -= 0.3; // Slowly moving up
        scene.spaceRocketScale = Math.max(0.1, scene.spaceRocketScale - 0.001); // Slowly shrinking

        const rocketCenterX = canvas.width / 2 + 30;
        const rocketDrawY = scene.spaceRocketY;
        const scale = scene.spaceRocketScale;

        // Draw rocket flames (scaled)
        const flameColors = ['#ffffff', '#ffff00', '#ff9900', '#ff6600', '#ff3300'];
        for (let i = 0; i < 5; i++) {
            const flameY = rocketDrawY + (20 + i * 8) * scale;
            const flameWidth = (12 - i * 2) * scale;
            const wobble = Math.sin(t * 0.8 + i * 0.5) * (2 * scale);
            ctx.fillStyle = flameColors[i];
            ctx.globalAlpha = 0.9 - i * 0.15;
            ctx.fillRect(rocketCenterX - flameWidth/2 + wobble, flameY, flameWidth, 8 * scale);
        }
        ctx.globalAlpha = 1;

        // Draw scaled rocket (simplified when small)
        if (scale > 0.3) {
            // Draw actual rocket sprite scaled
            ctx.save();
            ctx.translate(rocketCenterX, rocketDrawY);
            ctx.scale(scale, scale);
            ctx.drawImage(GFX.escapeRocket, -32, -64);
            ctx.restore();
        } else {
            // Very small rocket - just a simple shape
            ctx.fillStyle = '#e5e7eb';
            const rocketH = Math.max(4, 20 * scale);
            const rocketW = Math.max(2, 8 * scale);
            ctx.fillRect(rocketCenterX - rocketW/2, rocketDrawY - rocketH, rocketW, rocketH);
            ctx.fillStyle = '#1e40af';
            ctx.beginPath();
            ctx.moveTo(rocketCenterX, rocketDrawY - rocketH - 4 * scale);
            ctx.lineTo(rocketCenterX - rocketW/2, rocketDrawY - rocketH);
            ctx.lineTo(rocketCenterX + rocketW/2, rocketDrawY - rocketH);
            ctx.closePath();
            ctx.fill();
        }

        // Smoke trail behind rocket
        for (let i = 0; i < 12; i++) {
            const trailY = rocketDrawY + (30 + i * 15) * scale;
            const trailX = rocketCenterX + Math.sin(t * 0.05 + i * 0.4) * (5 + i * 0.5);
            const trailSize = (8 - i * 0.5) * scale;
            if (trailSize > 0.5) {
                ctx.fillStyle = `rgba(200, 200, 200, ${0.4 - i * 0.03})`;
                ctx.beginPath();
                ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.restore();

        // Player character looking up at the sky
        ctx.drawImage(GFX.chars[GAME.selectedChar], canvas.width / 2 - 40, canvas.height - 55);

        // HUD - altitude indicator continues
        const altitude = Math.floor(1500 + pt * 2);
        ctx.fillStyle = '#00ff00';
        ctx.font = '6px "Press Start 2P"';
        ctx.textAlign = 'right';
        ctx.fillText(`ALT: ${altitude}km`, canvas.width - 10, 20);
    }
    // Phase 8: Simon joins
    else if (scene.phase === 8) {
        // Fading rocket trail (almost gone)
        const trailX = canvas.width - 40;
        for (let i = 0; i < 4; i++) {
            const trailY = 8 + i * 4;
            ctx.fillStyle = `rgba(255, 153, 0, ${0.2 - i * 0.04})`;
            ctx.fillRect(trailX - 1, trailY, 2, 3);
        }

        // Player character
        ctx.drawImage(GFX.chars[GAME.selectedChar], 90, canvas.height - 50);

        // Simon walking in
        if (scene.simonX !== undefined) {
            ctx.drawImage(GFX.simon, scene.simonX, scene.simonY);
        }

        // Victory text
        ctx.fillStyle = '#22c55e';
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('VICTORY!', canvas.width / 2, 40);

        ctx.fillStyle = '#fbbf24';
        ctx.font = '8px "Press Start 2P"';
        const celebrateText = scene.simonX >= canvas.width / 2 - 50 ?
            'THE WAREHOUSE IS SAFE!' : 'Simon approaches...';
        ctx.fillText(celebrateText, canvas.width / 2, 58);

        // Confetti particles
        for (let i = 0; i < 25; i++) {
            const confettiX = (i * 47 + t * 2.5) % canvas.width;
            const confettiY = (i * 31 + t * 2) % canvas.height;
            const colors = ['#ff9900', '#22c55e', '#3b82f6', '#fbbf24', '#ec4899'];
            ctx.fillStyle = colors[i % colors.length];
            ctx.fillRect(confettiX, confettiY, 4, 4);
        }
    }

    ctx.textAlign = 'left';
    ctx.globalAlpha = 1;
}

// Draw throne room backdrop for escape sequence - AMAZON THEMED
function drawThroneRoomBackdrop(t) {
    // Dark Amazon-themed gradient (orange tinted dark)
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#0a0508');
    grad.addColorStop(0.4, '#150810');
    grad.addColorStop(0.7, '#1a0a12');
    grad.addColorStop(1, '#0d0608');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Subtle Amazon orange ambient glow
    const ambientGlow = Math.sin(t * 0.02) * 0.02 + 0.04;
    ctx.fillStyle = `rgba(255, 153, 0, ${ambientGlow})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Amazon-themed pillars on sides (orange accents)
    ctx.fillStyle = '#2a1a10';
    ctx.fillRect(0, 20, 24, canvas.height - 20);
    ctx.fillRect(canvas.width - 24, 20, 24, canvas.height - 20);

    // Amazon orange stripe on pillars
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(20, 20, 4, canvas.height - 20);
    ctx.fillRect(canvas.width - 24, 20, 4, canvas.height - 20);

    // Pillar details with Prime blue accents
    ctx.fillStyle = '#00a8e1';
    ctx.fillRect(5, 25, 10, 5);
    ctx.fillRect(canvas.width - 15, 25, 10, 5);

    // Golden Amazon trim on pillars
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(0, 18, 26, 3);
    ctx.fillRect(canvas.width - 26, 18, 26, 3);

    // PRIME banners on pillars
    ctx.fillStyle = '#00a8e1';
    ctx.font = '5px "Press Start 2P"';
    ctx.save();
    ctx.translate(12, 80);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('PRIME', 0, 0);
    ctx.restore();
    ctx.save();
    ctx.translate(canvas.width - 8, 80);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('PRIME', 0, 0);
    ctx.restore();

    // Amazon package stacks decorating the sides
    for (let i = 0; i < 3; i++) {
        // Left side packages
        const pkgY = canvas.height - 55 - i * 18;
        ctx.fillStyle = '#8b6914';
        ctx.fillRect(28, pkgY, 16, 14);
        ctx.fillStyle = '#a67c00';
        ctx.fillRect(30, pkgY + 2, 12, 10);
        // Amazon smile on package
        ctx.strokeStyle = '#232f3e';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(32, pkgY + 8);
        ctx.quadraticCurveTo(36, pkgY + 12, 40, pkgY + 7);
        ctx.stroke();

        // Right side packages
        ctx.fillStyle = '#8b6914';
        ctx.fillRect(canvas.width - 44, pkgY, 16, 14);
        ctx.fillStyle = '#a67c00';
        ctx.fillRect(canvas.width - 42, pkgY + 2, 12, 10);
        ctx.strokeStyle = '#232f3e';
        ctx.beginPath();
        ctx.moveTo(canvas.width - 40, pkgY + 8);
        ctx.quadraticCurveTo(canvas.width - 36, pkgY + 12, canvas.width - 32, pkgY + 7);
        ctx.stroke();
    }

    // Grand Amazon Throne in background
    const throneX = canvas.width / 2 - 25;
    const throneY = 55;

    // Throne back (cardboard box styled)
    ctx.fillStyle = '#5a4020';
    ctx.fillRect(throneX - 8, throneY - 25, 66, 55);
    ctx.fillStyle = '#8b6914';
    ctx.fillRect(throneX - 3, throneY - 20, 56, 45);

    // Amazon orange trim on throne
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(throneX - 3, throneY - 22, 56, 4);
    ctx.fillRect(throneX - 3, throneY + 22, 56, 4);

    // Throne seat (Prime blue cushion)
    ctx.fillStyle = '#00a8e1';
    ctx.fillRect(throneX + 5, throneY - 8, 40, 25);
    ctx.fillStyle = '#0090c5';
    ctx.fillRect(throneX + 8, throneY - 5, 34, 19);

    // Large Amazon smile logo on throne (pulsing)
    const logoPulse = Math.sin(t * 0.08) * 0.15 + 0.85;
    ctx.fillStyle = `rgba(255, 153, 0, ${logoPulse})`;
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('a', throneX + 25, throneY + 8);
    // Amazon smile arrow
    ctx.strokeStyle = `rgba(255, 153, 0, ${logoPulse})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(throneX + 10, throneY + 12);
    ctx.quadraticCurveTo(throneX + 25, throneY + 22, throneX + 42, throneY + 10);
    ctx.stroke();

    // "FULFILLMENT CENTER" text above throne
    ctx.fillStyle = '#ff9900';
    ctx.font = '5px "Press Start 2P"';
    ctx.fillText('FULFILLMENT', throneX + 25, throneY - 30);
    ctx.fillText('CENTER', throneX + 25, throneY - 22);

    // Royal carpet/floor (Amazon branded)
    ctx.fillStyle = '#1a0a08';
    ctx.fillRect(0, canvas.height - 38, canvas.width, 38);

    // Orange carpet runner with smile pattern
    ctx.fillStyle = '#cc7a00';
    ctx.fillRect(canvas.width / 2 - 35, canvas.height - 38, 70, 38);
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(canvas.width / 2 - 30, canvas.height - 38, 60, 4);
    // Smile pattern on carpet
    ctx.strokeStyle = '#232f3e';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2 - 20, canvas.height - 15);
    ctx.quadraticCurveTo(canvas.width / 2, canvas.height - 5, canvas.width / 2 + 20, canvas.height - 18);
    ctx.stroke();

    // Torch lights styled as warehouse lights (Amazon orange flames)
    for (let i = 0; i < 2; i++) {
        const torchX = i === 0 ? 50 : canvas.width - 60;
        const flicker = Math.sin(t * 0.15 + i) * 3;

        // Industrial torch holder
        ctx.fillStyle = '#333';
        ctx.fillRect(torchX, 45, 10, 25);

        // Amazon orange flame
        ctx.fillStyle = '#ff9900';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffcc00';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Floating Prime delivery drones in background
    for (let i = 0; i < 2; i++) {
        const droneX = 60 + i * (canvas.width - 120);
        const droneY = 100 + Math.sin(t * 0.05 + i * 2) * 8;
        ctx.fillStyle = '#444';
        ctx.fillRect(droneX - 6, droneY, 12, 6);
        ctx.fillStyle = '#00a8e1';
        ctx.fillRect(droneX - 3, droneY + 1, 6, 4);
        // Rotor blur
        ctx.fillStyle = `rgba(100, 100, 100, ${0.3 + Math.sin(t * 0.5 + i) * 0.2})`;
        ctx.fillRect(droneX - 10, droneY - 2, 8, 2);
        ctx.fillRect(droneX + 2, droneY - 2, 8, 2);
    }

    ctx.textAlign = 'left';
}

// Draw victory backdrop for Simon joining - STAY IN AMAZON THEMED THRONE ROOM
function drawVictoryBackdrop(t) {
    // Keep the Amazon throne room backdrop (post-battle calm with victory atmosphere)
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#0a0508');
    grad.addColorStop(0.4, '#150810');
    grad.addColorStop(0.7, '#1a0a12');
    grad.addColorStop(1, '#0d0608');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Victory glow effect (celebratory Amazon orange/gold tint)
    const victoryGlow = Math.sin(t * 0.03) * 0.05 + 0.12;
    ctx.fillStyle = `rgba(255, 153, 0, ${victoryGlow})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Amazon-themed pillars on sides (matching throne room)
    ctx.fillStyle = '#2a1a10';
    ctx.fillRect(0, 20, 24, canvas.height - 20);
    ctx.fillRect(canvas.width - 24, 20, 24, canvas.height - 20);

    // Amazon orange stripe on pillars
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(20, 20, 4, canvas.height - 20);
    ctx.fillRect(canvas.width - 24, 20, 4, canvas.height - 20);

    // Pillar details with Prime blue accents
    ctx.fillStyle = '#00a8e1';
    ctx.fillRect(5, 25, 10, 5);
    ctx.fillRect(canvas.width - 15, 25, 10, 5);

    // Golden Amazon trim on pillars
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(0, 18, 26, 3);
    ctx.fillRect(canvas.width - 26, 18, 26, 3);

    // Scattered packages on sides (some knocked over from battle)
    for (let i = 0; i < 3; i++) {
        const pkgY = canvas.height - 55 - i * 18;
        // Left side packages (some tilted)
        ctx.save();
        ctx.translate(36, pkgY + 7);
        ctx.rotate(Math.sin(i * 0.5) * 0.2);
        ctx.fillStyle = '#8b6914';
        ctx.fillRect(-8, -7, 16, 14);
        ctx.fillStyle = '#a67c00';
        ctx.fillRect(-6, -5, 12, 10);
        ctx.restore();

        // Right side packages
        ctx.save();
        ctx.translate(canvas.width - 36, pkgY + 7);
        ctx.rotate(-Math.sin(i * 0.7) * 0.15);
        ctx.fillStyle = '#8b6914';
        ctx.fillRect(-8, -7, 16, 14);
        ctx.fillStyle = '#a67c00';
        ctx.fillRect(-6, -5, 12, 10);
        ctx.restore();
    }

    // Empty Amazon Throne in background (Bezos escaped!)
    const throneX = canvas.width / 2 - 25;
    const throneY = 55;

    // Throne back (cardboard box styled - slightly damaged)
    ctx.fillStyle = '#5a4020';
    ctx.fillRect(throneX - 8, throneY - 25, 66, 55);
    ctx.fillStyle = '#8b6914';
    ctx.fillRect(throneX - 3, throneY - 20, 56, 45);

    // Amazon orange trim on throne
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(throneX - 3, throneY - 22, 56, 4);
    ctx.fillRect(throneX - 3, throneY + 22, 56, 4);

    // Throne seat (Prime blue cushion - empty)
    ctx.fillStyle = '#00a8e1';
    ctx.fillRect(throneX + 5, throneY - 8, 40, 25);
    ctx.fillStyle = '#0090c5';
    ctx.fillRect(throneX + 8, throneY - 5, 34, 19);

    // Dimmed Amazon smile logo on empty throne
    ctx.fillStyle = 'rgba(255, 153, 0, 0.4)';
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('a', throneX + 25, throneY + 8);
    // Dimmed smile arrow
    ctx.strokeStyle = 'rgba(255, 153, 0, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(throneX + 10, throneY + 12);
    ctx.quadraticCurveTo(throneX + 25, throneY + 22, throneX + 42, throneY + 10);
    ctx.stroke();

    // "VACANT - WORKER VICTORY!" sign on throne (blinking)
    if (Math.sin(t * 0.1) > 0) {
        ctx.fillStyle = '#22c55e';
        ctx.font = '5px "Press Start 2P"';
        ctx.fillText('WORKER VICTORY!', throneX + 25, throneY - 30);
    } else {
        ctx.fillStyle = '#ff9900';
        ctx.font = '5px "Press Start 2P"';
        ctx.fillText('POSITION VACANT', throneX + 25, throneY - 30);
    }

    // Royal carpet/floor (Amazon branded)
    ctx.fillStyle = '#1a0a08';
    ctx.fillRect(0, canvas.height - 38, canvas.width, 38);

    // Orange carpet runner
    ctx.fillStyle = '#cc7a00';
    ctx.fillRect(canvas.width / 2 - 35, canvas.height - 38, 70, 38);
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(canvas.width / 2 - 30, canvas.height - 38, 60, 4);

    // Victory confetti particles (Amazon themed colors)
    for (let i = 0; i < 20; i++) {
        const confettiX = (i * 37 + t * 0.6) % canvas.width;
        const confettiY = (i * 53 + t * 0.4) % (canvas.height - 45);
        const colors = ['#ff9900', '#ffd700', '#00a8e1', '#22c55e', '#fff'];
        ctx.fillStyle = colors[i % colors.length];
        ctx.globalAlpha = 0.7 + Math.sin(t * 0.1 + i) * 0.3;
        ctx.fillRect(confettiX, confettiY, 3 + (i % 2), 3 + (i % 3));
    }
    ctx.globalAlpha = 1;

    // Celebratory warehouse lights (Amazon orange flames - bigger for victory)
    for (let i = 0; i < 2; i++) {
        const torchX = i === 0 ? 50 : canvas.width - 60;
        const flicker = Math.sin(t * 0.2 + i) * 4;

        // Industrial torch holder
        ctx.fillStyle = '#333';
        ctx.fillRect(torchX, 45, 10, 25);

        // Celebratory bright Amazon orange flame
        ctx.fillStyle = '#ff9900';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(torchX + 5, 40 + flicker, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Celebratory Prime drones doing victory loops
    for (let i = 0; i < 2; i++) {
        const droneAngle = t * 0.03 + i * Math.PI;
        const droneX = canvas.width / 2 + Math.cos(droneAngle) * 60 * (i === 0 ? 1 : -1);
        const droneY = 90 + Math.sin(droneAngle * 2) * 15;
        ctx.fillStyle = '#444';
        ctx.fillRect(droneX - 6, droneY, 12, 6);
        ctx.fillStyle = '#22c55e'; // Victory green instead of Prime blue
        ctx.fillRect(droneX - 3, droneY + 1, 6, 4);
        // Rotor blur
        ctx.fillStyle = `rgba(100, 100, 100, ${0.4 + Math.sin(t * 0.5 + i) * 0.2})`;
        ctx.fillRect(droneX - 10, droneY - 2, 8, 2);
        ctx.fillRect(droneX + 2, droneY - 2, 8, 2);
    }

    ctx.textAlign = 'left';
}

function drawCredits() {
    const t = GAME.stateTimer;
    const isMecha = GAME.creditsType === 'mecha';

    // Fade in effect
    const fadeIn = Math.min(1, t / 60);
    ctx.globalAlpha = fadeIn;

    // Helper function to draw gold trophy
    function drawTrophy(x, y, scale, glowAmount) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);

        // Trophy glow effect
        if (glowAmount > 0) {
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = glowAmount;
        }

        // Trophy cup body (gold gradient)
        const cupGrad = ctx.createLinearGradient(-15, -30, 15, 10);
        cupGrad.addColorStop(0, '#ffd700');
        cupGrad.addColorStop(0.3, '#ffec8b');
        cupGrad.addColorStop(0.5, '#ffd700');
        cupGrad.addColorStop(0.7, '#daa520');
        cupGrad.addColorStop(1, '#b8860b');
        ctx.fillStyle = cupGrad;

        // Cup shape
        ctx.beginPath();
        ctx.moveTo(-18, -25);
        ctx.quadraticCurveTo(-20, -5, -12, 5);
        ctx.lineTo(-6, 10);
        ctx.lineTo(6, 10);
        ctx.lineTo(12, 5);
        ctx.quadraticCurveTo(20, -5, 18, -25);
        ctx.lineTo(-18, -25);
        ctx.fill();

        // Cup rim highlight
        ctx.fillStyle = '#ffec8b';
        ctx.fillRect(-16, -27, 32, 4);

        // Cup handles
        ctx.strokeStyle = '#daa520';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(-20, -12, 8, -Math.PI/2, Math.PI/2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(20, -12, 8, Math.PI/2, -Math.PI/2);
        ctx.stroke();

        // Trophy stem
        ctx.fillStyle = '#daa520';
        ctx.fillRect(-4, 10, 8, 12);

        // Trophy base
        ctx.fillStyle = '#b8860b';
        ctx.fillRect(-14, 22, 28, 6);
        ctx.fillStyle = '#8b7355';
        ctx.fillRect(-16, 28, 32, 4);

        // Star on trophy
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('‚òÖ', 0, -8);

        ctx.shadowBlur = 0;
        ctx.restore();
    }

    if (isMecha) {
        // === ULTRA FANCY MECHA CREDITS ===
        // Epic gradient background with animated aurora
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a0020');
        grad.addColorStop(0.2, '#1a0050');
        grad.addColorStop(0.4, '#2a0070');
        grad.addColorStop(0.6, '#1a0050');
        grad.addColorStop(0.8, '#0a0030');
        grad.addColorStop(1, '#050010');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Aurora effect
        for (let i = 0; i < 5; i++) {
            const auroraY = Math.sin(t * 0.02 + i) * 30 + canvas.height * 0.3;
            const auroraGrad = ctx.createLinearGradient(0, auroraY - 20, 0, auroraY + 20);
            auroraGrad.addColorStop(0, 'rgba(255,0,255,0)');
            auroraGrad.addColorStop(0.5, `rgba(${150 + i*20},0,255,${0.1 + Math.sin(t*0.05+i)*0.05})`);
            auroraGrad.addColorStop(1, 'rgba(255,0,255,0)');
            ctx.fillStyle = auroraGrad;
            ctx.fillRect(0, auroraY - 20, canvas.width, 40);
        }

        // Animated star field (more stars, more colors)
        for (let i = 0; i < 80; i++) {
            const x = (i * 47 + t * 0.5) % canvas.width;
            const y = (i * 73 + t * 0.2) % canvas.height;
            const twinkle = Math.sin(t * 0.08 + i * 0.7) * 0.5 + 0.5;
            const colors = ['#ffd700', '#ff6600', '#ff00ff', '#00ffff'];
            ctx.fillStyle = colors[i % colors.length].replace(')', `,${twinkle * 0.8})`).replace('rgb', 'rgba').replace('#', 'rgba(');
            // Simple color with alpha
            ctx.globalAlpha = twinkle * 0.8 * fadeIn;
            ctx.fillStyle = colors[i % colors.length];
            ctx.fillRect(x, y, 2, 2);
            ctx.globalAlpha = fadeIn;
        }

        // Animated golden border with pulsing glow
        const borderGlow = 0.5 + Math.sin(t * 0.05) * 0.3;
        ctx.strokeStyle = `rgba(255,215,0,${borderGlow})`;
        ctx.lineWidth = 4;
        ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
        ctx.strokeStyle = `rgba(255,0,255,${borderGlow * 0.5})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(8, 8, canvas.width - 16, canvas.height - 16);
        ctx.strokeStyle = `rgba(0,255,255,${borderGlow * 0.3})`;
        ctx.lineWidth = 1;
        ctx.strokeRect(12, 12, canvas.width - 24, canvas.height - 24);

        // GIANT TROPHY in center (appears first, then scrolls up with credits)
        const trophyStartY = canvas.height / 2 - 20;
        const trophyScrollY = trophyStartY - t * 0.3;
        if (trophyScrollY > -60 && trophyScrollY < canvas.height + 60) {
            const trophyGlow = 20 + Math.sin(t * 0.1) * 10;
            drawTrophy(canvas.width / 2, trophyScrollY, 2.0, trophyGlow);

            // "ULTIMATE SAFETY CHAMPION" text below trophy
            const textY = trophyScrollY + 75;
            if (textY > 0 && textY < canvas.height) {
                ctx.textAlign = 'center';
                ctx.font = 'bold 11px monospace';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 10 + Math.sin(t * 0.15) * 5;
                ctx.fillStyle = '#ffd700';
                ctx.fillText('ULTIMATE', canvas.width / 2, textY);
                ctx.fillStyle = '#ff6600';
                ctx.fillText('SAFETY CHAMPION', canvas.width / 2, textY + 14);
                ctx.shadowBlur = 0;
            }
        }

        // Big congratulations header with intense glow
        ctx.textAlign = 'center';
        ctx.font = 'bold 16px monospace';
        const glowIntensity = 0.5 + Math.sin(t * 0.1) * 0.3;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 20 * glowIntensity;
        ctx.fillStyle = '#ffd700';
        ctx.fillText('CONGRATULATIONS!', canvas.width / 2, 30);
        ctx.font = 'bold 12px monospace';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 15 * glowIntensity;
        ctx.fillStyle = '#ff6600';
        ctx.fillText('MECHA JEFF DEFEATED!', canvas.width / 2, 48);
        ctx.shadowBlur = 0;

        // Subtitle with glow
        ctx.font = '9px monospace';
        ctx.fillStyle = '#aaa';
        ctx.fillText('The Warehouse is Finally Safe', canvas.width / 2, 64);

    } else {
        // === NORMAL CREDITS ===
        // Dark blue background with subtle gradient
        const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        bgGrad.addColorStop(0, '#0f172a');
        bgGrad.addColorStop(0.5, '#1e293b');
        bgGrad.addColorStop(1, '#0f172a');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(6, 6, canvas.width - 12, canvas.height - 12);

        // Golden border for victory
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);

        // GOLD TROPHY in center (scrolls with credits)
        const trophyStartY = canvas.height / 2 - 10;
        const trophyScrollY = trophyStartY - t * 0.25;
        if (trophyScrollY > -50 && trophyScrollY < canvas.height + 50) {
            const trophyGlow = 10 + Math.sin(t * 0.1) * 5;
            drawTrophy(canvas.width / 2, trophyScrollY, 1.5, trophyGlow);

            // "SAFETY CHAMPION" text below trophy
            const textY = trophyScrollY + 60;
            if (textY > 0 && textY < canvas.height) {
                ctx.textAlign = 'center';
                ctx.font = 'bold 10px monospace';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#ffd700';
                ctx.fillText('SAFETY CHAMPION', canvas.width / 2, textY);
                ctx.shadowBlur = 0;
            }
        }

        // Congratulations header
        ctx.textAlign = 'center';
        ctx.font = 'bold 14px monospace';
        ctx.fillStyle = '#eab308';
        ctx.fillText('CONGRATULATIONS!', canvas.width / 2, 28);
        ctx.font = '10px monospace';
        ctx.fillStyle = '#22d3ee';
        ctx.fillText('SURPRISE VISITOR DEFEATED!', canvas.width / 2, 44);

        // Subtitle
        ctx.font = '8px monospace';
        ctx.fillStyle = '#888';
        ctx.fillText('Safety Audit Complete', canvas.width / 2, 58);
    }

    // Credits list - 35 positions all by Erwin Esener
    const credits = [
        'Executive Producer',
        'Director',
        'Lead Developer',
        'Senior Programmer',
        'Game Designer',
        'Level Designer',
        'Art Director',
        'Lead Artist',
        'Character Designer',
        'Background Artist',
        'Pixel Art Specialist',
        'Animation Director',
        'UI/UX Designer',
        'Sound Director',
        'Music Composer',
        'Sound Effects Designer',
        'Audio Engineer',
        'Quality Assurance Lead',
        'Lead Tester',
        'Bug Hunter',
        'Narrative Designer',
        'Dialogue Writer',
        'Localization Manager',
        'Marketing Director',
        'Community Manager',
        'Technical Director',
        'Engine Developer',
        'Tool Programmer',
        'DevOps Engineer',
        'Project Manager',
        'Producer',
        'Catering',
        'Coffee Maker',
        'Moral Support',
        'Everything Else'
    ];

    // Scrolling credits (offset to appear after trophy)
    const scrollSpeed = isMecha ? 0.3 : 0.25;
    const creditsOffset = isMecha ? 200 : 150; // Start credits lower to show trophy first
    const startY = canvas.height + creditsOffset - t * scrollSpeed;
    const lineHeight = isMecha ? 20 : 18;

    ctx.font = isMecha ? '9px monospace' : '8px monospace';

    credits.forEach((role, i) => {
        const y = startY + i * lineHeight;
        if (y > 70 && y < canvas.height - 20) {
            if (isMecha) {
                // Fancy golden text with role and rainbow shimmer
                const shimmer = Math.sin(t * 0.1 + i * 0.3) * 0.2;
                ctx.fillStyle = `rgb(${255}, ${215 + shimmer * 40}, ${shimmer * 100})`;
                ctx.fillText(role + ':', canvas.width / 2, y);
                ctx.fillStyle = '#fff';
                ctx.fillText('Erwin Esener', canvas.width / 2, y + 10);
            } else {
                // Simple white text
                ctx.fillStyle = '#ccc';
                ctx.fillText(role + ': Erwin Esener', canvas.width / 2, y);
            }
        }
    });

    // Final thank you message (appears after credits scroll)
    const thankYouY = startY + credits.length * lineHeight + 60;
    if (thankYouY > 70 && thankYouY < canvas.height - 20) {
        ctx.font = isMecha ? 'bold 14px monospace' : 'bold 12px monospace';
        ctx.shadowColor = isMecha ? '#ff00ff' : '#ffd700';
        ctx.shadowBlur = isMecha ? 15 : 8;
        ctx.fillStyle = isMecha ? '#ffd700' : '#eab308';
        ctx.fillText('THANKS FOR PLAYING!', canvas.width / 2, thankYouY);
        ctx.shadowBlur = 0;
        if (isMecha) {
            ctx.font = '10px monospace';
            ctx.fillStyle = '#ff6600';
            ctx.fillText('You are the Ultimate Safety Champion!', canvas.width / 2, thankYouY + 18);
            ctx.font = '8px monospace';
            ctx.fillStyle = '#00ffff';
            ctx.fillText('Amazon Warehouses are Finally Safe!', canvas.width / 2, thankYouY + 32);
        }
    }

    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';

    // Skip prompt
    if (GAME.stateTimer > 600) {
        ctx.fillStyle = '#94a3b8';
        ctx.font = '8px monospace';
        ctx.fillText('[SPACE TO CONTINUE]', 8, canvas.height - 10);
    }
}

function draw() {
    if (GAME.state === 'LOSE_SPLASH') { drawSnesSplash(false); return; }
    if (GAME.state === 'WIN_SPLASH') { drawSnesSplash(true); return; }
    if (GAME.state === 'GAMEOVER_SPLASH') { drawGameOverSplash(); return; }
    if (GAME.state === 'NAME_ENTRY') { drawNameEntry(); return; }
    if (GAME.state === 'HIGHSCORES') { drawHighscores(); return; }

    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
    let dxShake = 0, dyShake = 0;
    if (GAME.shake > 0) { dxShake = (Math.random() - 0.5) * GAME.shake; dyShake = (Math.random() - 0.5) * GAME.shake; }
    ctx.save(); ctx.translate(dxShake, dyShake);

    if (GAME.state === 'PRESS_START') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated starfield background
        for (let i = 0; i < 30; i++) {
            let seed = i * 234.567;
            let x = ((seed * 9301 + 49297) % 233280) / 910;
            let y = ((seed * 1234 + 8765) % 233280) / 1040;
            let speed = (i % 3) + 1;
            let starY = (y + GAME.stateTimer * speed * 0.15) % 224;
            let brightness = Math.sin(GAME.stateTimer * 0.06 + i) * 0.25 + 0.4;
            ctx.fillStyle = `rgba(100, 180, 255, ${brightness})`;
            ctx.fillRect(x, starY, 1, 1);
        }

        // Background gradient glow
        let hue = (GAME.stateTimer * 0.3) % 360;
        let gradient = ctx.createRadialGradient(128, 100, 0, 128, 100, 100);
        gradient.addColorStop(0, `hsla(${hue}, 50%, 20%, 0.25)`);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.textAlign = 'center';

        // Region selection title
        ctx.font = 'bold 10px monospace';
        ctx.fillStyle = '#88ccff';
        ctx.fillText(getLocalizedText('select_your_region'), canvas.width / 2, 35);

        // Region options
        const regions = GAME.regionList;
        const startY = 55;
        const spacing = 28;

        regions.forEach((region, idx) => {
            const y = startY + idx * spacing;
            const isSelected = idx === GAME.regionIndex;

            // Selection highlight
            if (isSelected) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.12)';
                ctx.fillRect(45, y - 10, canvas.width - 90, 22);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 1;
                ctx.strokeRect(45, y - 10, canvas.width - 90, 22);

                // Animated arrows
                const arrowPulse = Math.sin(GAME.stateTimer * 0.12) * 2;
                ctx.fillStyle = '#ffd700';
                ctx.font = '10px monospace';
                ctx.fillText('‚ñ∂', 35 - arrowPulse, y + 3);
                ctx.fillText('‚óÄ', canvas.width - 35 + arrowPulse, y + 3);
            }

            // Flag colors
            const flagColors = {
                'DE': ['#000000', '#dd0000', '#ffcc00'],
                'AT': ['#ed2939', '#ffffff', '#ed2939'],
                'NL': ['#ae1c28', '#ffffff', '#21468b'],
                'MEU': ['#003399', '#ffcc00', '#003399'] // EU flag colors (used for star color)
            };
            const colors = flagColors[region] || ['#003399', '#ffcc00', '#003399'];
            const flagX = canvas.width / 2 - 70;

            // MEU gets EU flag with stars instead of stripes
            if (region === 'MEU') {
                // EU blue background
                ctx.fillStyle = '#003399';
                ctx.fillRect(flagX, y - 4, 14, 12);
                // Draw golden stars in circle pattern
                ctx.fillStyle = '#ffcc00';
                const starCenterX = flagX + 7;
                const starCenterY = y + 2;
                const starRadius = 4;
                for (let s = 0; s < 12; s++) {
                    const angle = (s * 30 - 90) * Math.PI / 180;
                    const sx = starCenterX + Math.cos(angle) * starRadius;
                    const sy = starCenterY + Math.sin(angle) * starRadius;
                    ctx.fillRect(sx - 0.5, sy - 0.5, 1, 1);
                }
            } else {
                colors.forEach((color, ci) => {
                    ctx.fillStyle = color;
                    ctx.fillRect(flagX, y - 4 + ci * 4, 14, 4);
                });
            }

            // Region code and name
            ctx.font = isSelected ? 'bold 10px monospace' : '9px monospace';
            ctx.fillStyle = isSelected ? '#ffd700' : '#888888';
            ctx.fillText(region, canvas.width / 2 - 35, y + 4);

            ctx.font = isSelected ? '9px monospace' : '8px monospace';
            ctx.fillStyle = isSelected ? '#ffffff' : '#666666';
            ctx.fillText(GAME.regionNames[region], canvas.width / 2 + 25, y + 4);
        });

        // Divider line
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
        ctx.beginPath();
        ctx.moveTo(60, 145);
        ctx.lineTo(canvas.width - 60, 145);
        ctx.stroke();

        // Pulsing "PRESS SPACEBAR" text
        const pulse = 0.5 + Math.abs(Math.sin(GAME.stateTimer * 0.06)) * 0.5;
        ctx.font = 'bold 11px monospace';
        ctx.fillStyle = `rgba(255, 215, 0, ${pulse})`;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 8;
        ctx.fillText(getLocalizedText('press_spacebar'), canvas.width / 2, 165);
        ctx.shadowBlur = 0;

        ctx.font = '7px monospace';
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillText(getLocalizedText('region_select_hint'), canvas.width / 2, 180);

        ctx.font = '6px monospace';
        ctx.fillStyle = 'rgba(136, 204, 255, 0.6)';
        ctx.fillText(getLocalizedText('learn_safety_regulations'), canvas.width / 2, 195);

        ctx.textAlign = 'start';
        ctx.restore();
        return;
    }
    if (GAME.state === 'LOGO') {
        // Extended to 420 frames (7 seconds) for title-eeproductions.mp3
        let alpha = 1.0;
        if(GAME.stateTimer < 30) alpha = GAME.stateTimer / 30;
        if(GAME.stateTimer > 380) alpha = (420 - GAME.stateTimer) / 40;

        // SNES-style starfield background effect
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, 256, 224);
        for(let i = 0; i < 30; i++) {
            let seed = i * 123.456;
            let x = ((seed * 9301 + 49297) % 233280) / 910;
            let y = ((seed * 1234 + 8765) % 233280) / 1040;
            let speed = (i % 3) + 1;
            let starY = (y + GAME.stateTimer * speed * 0.3) % 224;
            let brightness = Math.sin(GAME.stateTimer * 0.1 + i) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255,255,255,${brightness * alpha})`;
            ctx.fillRect(x, starY, 1, 1);
        }

        // Color cycling effect for background glow
        let hue = (GAME.stateTimer * 2) % 360;
        let gradient = ctx.createRadialGradient(128, 112, 0, 128, 112, 150);
        gradient.addColorStop(0, `hsla(${hue}, 70%, 30%, ${alpha * 0.3})`);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 224);

        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        let offset = Math.max(0, 100 - GAME.stateTimer * 2);

        // Draw logo with chromatic aberration effect
        if(GAME.stateTimer > 60 && GAME.stateTimer < 90) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = alpha * 0.3;
            ctx.drawImage(GFX.logo, 28 - offset - 2, 90);
            ctx.globalAlpha = alpha * 0.3;
            ctx.drawImage(GFX.logo, 28 - offset + 2, 90);
            ctx.globalCompositeOperation = 'source-over';
        }

        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        ctx.drawImage(GFX.logo, 28 - offset, 90);

        // Enhanced text with color cycling
        if (GAME.stateTimer > 80) {
            let textHue = (GAME.stateTimer * 3) % 60 + 180; // Cycle through blue-cyan range
            ctx.fillStyle = '#fff';
            ctx.font = '10px monospace';
            ctx.fillText("ERWIN ESENER", 80, 105);

            // Color cycling on PRODUCTIONS text
            let prodHue = (GAME.stateTimer * 5) % 60 + 30; // Cycle through yellow-orange range
            ctx.fillStyle = `hsl(${prodHue}, 90%, 50%)`;
            ctx.font = '14px monospace';
            ctx.fillText("PRODUCTIONS", 80, 125);

            // Add sparkle effects
            for(let i = 0; i < 5; i++) {
                let sparkleTime = (GAME.stateTimer - 80 - i * 15) % 120;
                if(sparkleTime < 20) {
                    let sparkleAlpha = sparkleTime < 10 ? sparkleTime / 10 : (20 - sparkleTime) / 10;
                    ctx.globalAlpha = sparkleAlpha * alpha;
                    ctx.fillStyle = '#fff';
                    let sx = 75 + i * 30 + Math.sin(GAME.stateTimer * 0.1 + i) * 3;
                    let sy = 100 + Math.cos(GAME.stateTimer * 0.15 + i) * 10;
                    ctx.fillRect(sx, sy, 2, 2);
                    ctx.fillRect(sx - 3, sy, 1, 1);
                    ctx.fillRect(sx + 3, sy, 1, 1);
                    ctx.fillRect(sx, sy - 3, 1, 1);
                    ctx.fillRect(sx, sy + 3, 1, 1);
                }
            }
        }

        // White flash effect
        if(GAME.stateTimer > 60 && GAME.stateTimer < 65) {
            ctx.globalAlpha = 1.0;
            ctx.fillStyle='white';
            ctx.fillRect(0,0,256,224);
        }

        // SNES-style scanlines
        ctx.globalAlpha = 0.15;
        for(let y = 0; y < 224; y += 2) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, y, 256, 1);
        }

        ctx.restore(); return;
    }
    if (GAME.state === 'INTRO') {
        const t = GAME.stateTimer;

        // Premium animated background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.3, '#0a1525');
        grad.addColorStop(0.6, '#0f172a');
        grad.addColorStop(1, '#0a0a18');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated particles (floating packages)
        for (let i = 0; i < 15; i++) {
            const x = (i * 41 + t * 0.2) % canvas.width;
            const y = (i * 53 + Math.sin(t * 0.02 + i) * 5) % canvas.height;
            const alpha = 0.2 + Math.sin(t * 0.05 + i) * 0.15;
            ctx.fillStyle = `rgba(251, 191, 36, ${alpha})`;
            ctx.fillRect(x, y, 3, 3);
        }

        // Animated grid lines
        const offset = (t * 0.8) % 32;
        for (let i = -1; i < 16; i++) {
            const y = i * 16 + offset;
            ctx.strokeStyle = `rgba(34, 211, 238, ${0.08 + (y / canvas.height) * 0.1})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        // Panel background with glow
        ctx.shadowColor = '#ff9900';
        ctx.shadowBlur = 15;
        ctx.fillStyle = 'rgba(10, 10, 20, 0.85)';
        ctx.fillRect(15, 25, canvas.width - 30, canvas.height - 55);
        ctx.shadowBlur = 0;

        // Panel border
        ctx.strokeStyle = '#ff9900';
        ctx.lineWidth = 2;
        ctx.strokeRect(15, 25, canvas.width - 30, canvas.height - 55);
        ctx.strokeStyle = '#7c2d12';
        ctx.lineWidth = 1;
        ctx.strokeRect(17, 27, canvas.width - 34, canvas.height - 59);

        // Title with glow effect - uses dynamic warehouse code
        ctx.textAlign = 'center';
        const glowIntensity = Math.sin(t * 0.08) * 0.3 + 0.7;
        ctx.shadowColor = '#ff9900';
        ctx.shadowBlur = 12 * glowIntensity;
        ctx.font = '12px "Press Start 2P"';
        const warehouseCode = getWarehouseCode();
        ctx.fillStyle = '#7c2d12';
        ctx.fillText(warehouseCode, canvas.width / 2 + 2, 52);
        ctx.fillStyle = '#ea580c';
        ctx.fillText(warehouseCode, canvas.width / 2 + 1, 51);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText(warehouseCode, canvas.width / 2, 50);
        ctx.shadowBlur = 0;

        // Subtitle
        ctx.shadowColor = '#22d3ee';
        ctx.shadowBlur = 6;
        ctx.fillStyle = '#22d3ee';
        ctx.font = '5px "Press Start 2P"';
        ctx.fillText('DELIVERY STATION', canvas.width / 2, 65);
        ctx.shadowBlur = 0;

        // Decorative line
        ctx.fillStyle = '#ff9900';
        ctx.fillRect(40, 75, canvas.width - 80, 2);
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(60, 79, canvas.width - 120, 1);

        // Story text with styling
        ctx.textAlign = 'left';
        ctx.font = '6px "Press Start 2P"';

        ctx.fillStyle = '#94a3b8';
        ctx.fillText('Ops Managers obsess over', 30, 100);
        ctx.fillStyle = '#ef4444';
        ctx.fillText('rates.', 175, 100);

        ctx.fillStyle = '#94a3b8';
        ctx.fillText('They throw', 30, 118);
        ctx.fillStyle = '#f97316';
        ctx.fillText('Crazy Requests.', 100, 118);

        ctx.fillStyle = '#94a3b8';
        ctx.fillText('You must protect', 30, 136);
        ctx.fillStyle = '#22c55e';
        ctx.fillText('Safety.', 145, 136);

        ctx.fillStyle = '#94a3b8';
        ctx.fillText('Stop runners.', 30, 154);
        ctx.fillStyle = '#22d3ee';
        ctx.fillText('Fix hazards.', 120, 154);

        // Animated prompt
        ctx.textAlign = 'center';
        const blink = Math.sin(t * 0.12) > 0;
        if (blink) {
            ctx.fillStyle = '#fff';
            ctx.font = '6px "Press Start 2P"';
            ctx.fillText('[SPACE TO SKIP]', canvas.width / 2, 195);
        }

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'STORY') {
        const t = GAME.stateTimer;

        // Premium animated background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.3, '#0a1525');
        grad.addColorStop(0.6, '#0f172a');
        grad.addColorStop(1, '#0a0a18');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated stars
        for (let i = 0; i < 20; i++) {
            const x = (i * 37 + t * 0.15) % canvas.width;
            const y = (i * 47) % canvas.height;
            const twinkle = Math.sin(t * 0.08 + i * 0.5) * 0.4 + 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.5})`;
            ctx.fillRect(x, y, 1, 1);
        }

        // Animated vertical grid lines (data stream effect)
        for (let i = 0; i < 17; i++) {
            const x = i * 16;
            const animOffset = (t * 0.5 + i * 10) % 30;
            ctx.strokeStyle = `rgba(34, 211, 238, ${0.05 + Math.sin(t * 0.03 + i) * 0.03})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        // Panel background with blue glow
        ctx.shadowColor = '#3b82f6';
        ctx.shadowBlur = 15;
        ctx.fillStyle = 'rgba(10, 15, 30, 0.9)';
        ctx.fillRect(15, 20, canvas.width - 30, canvas.height - 45);
        ctx.shadowBlur = 0;

        // Panel border (blue theme for mission)
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2;
        ctx.strokeRect(15, 20, canvas.width - 30, canvas.height - 45);
        ctx.strokeStyle = '#1d4ed8';
        ctx.lineWidth = 1;
        ctx.strokeRect(17, 22, canvas.width - 34, canvas.height - 49);

        // Title with glow effect
        ctx.textAlign = 'center';
        const glowIntensity = Math.sin(t * 0.08) * 0.3 + 0.7;
        ctx.shadowColor = '#3b82f6';
        ctx.shadowBlur = 12 * glowIntensity;
        ctx.font = '10px "Press Start 2P"';
        ctx.fillStyle = '#1d4ed8';
        ctx.fillText('MISSION BRIEFING', canvas.width / 2 + 1, 42);
        ctx.fillStyle = '#60a5fa';
        ctx.fillText('MISSION BRIEFING', canvas.width / 2, 41);
        ctx.shadowBlur = 0;

        // Decorative lines
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(35, 52, canvas.width - 70, 2);
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(50, 56, canvas.width - 100, 1);

        // Amazon-style badge for Simon
        const badgeX = 20, badgeY = 62, badgeW = 50, badgeH = 70;

        // Badge outer border (orange/amber like Amazon badge)
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(badgeX, badgeY, badgeW, badgeH);

        // Badge inner background (blue like Amazon badge)
        ctx.fillStyle = '#1e3a5f';
        ctx.fillRect(badgeX + 3, badgeY + 3, badgeW - 6, badgeH - 6);

        // "WHS" header on badge
        ctx.fillStyle = '#f59e0b';
        ctx.font = 'bold 7px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('WHS', badgeX + badgeW / 2, badgeY + 12);

        // Portrait area (white background)
        const portraitX = badgeX + 10, portraitY = badgeY + 16, portraitSize = 30;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(portraitX, portraitY, portraitSize, portraitSize);

        // Draw Simon's portrait if available
        if (GFX.simonFace) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(GFX.simonFace, portraitX + 2, portraitY + 2, portraitSize - 4, portraitSize - 4);
            ctx.restore();
        } else {
            // Fallback: draw a simple face placeholder
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(portraitX + 8, portraitY + 6, 14, 18);
            ctx.fillStyle = '#333';
            ctx.fillRect(portraitX + 10, portraitY + 10, 3, 3);
            ctx.fillRect(portraitX + 17, portraitY + 10, 3, 3);
            ctx.fillRect(portraitX + 12, portraitY + 18, 6, 2);
        }

        // "Simon" name on badge
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 5px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Simon', badgeX + badgeW / 2, badgeY + 54);

        // Title on badge
        ctx.fillStyle = '#94a3b8';
        ctx.font = '4px monospace';
        ctx.fillText('Snr. Regional Mgr', badgeX + badgeW / 2, badgeY + 62);

        // Barcode effect at bottom
        ctx.fillStyle = '#000';
        for (let i = 0; i < 12; i++) {
            const barW = (i % 3 === 0) ? 2 : 1;
            ctx.fillRect(badgeX + 10 + i * 3, badgeY + badgeH - 8, barW, 5);
        }

        // Badge lanyard hole
        ctx.fillStyle = '#1e3a5f';
        ctx.beginPath();
        ctx.arc(badgeX + badgeW / 2, badgeY - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#0a1525';
        ctx.beginPath();
        ctx.arc(badgeX + badgeW / 2, badgeY - 2, 2, 0, Math.PI * 2);
        ctx.fill();

        // Mission text
        ctx.textAlign = 'left';
        ctx.font = '7px "Press Start 2P"';
        ctx.fillStyle = '#94a3b8';
        ctx.fillText('Simon asks you to:', 78, 95);

        // Mission objectives with bullet styling (positioned right of badge)
        ctx.font = '6px "Press Start 2P"';
        const objX = 78;

        ctx.fillStyle = '#22c55e';
        ctx.fillText('>', objX, 110);
        ctx.fillStyle = '#e2e8f0';
        ctx.fillText('Do the safety audit', objX + 10, 110);

        ctx.fillStyle = '#f97316';
        ctx.fillText('>', objX, 124);
        ctx.fillStyle = '#e2e8f0';
        ctx.fillText('Dodge Ops requests', objX + 10, 124);

        ctx.fillStyle = '#a855f7';
        ctx.fillText('>', objX, 138);
        ctx.fillStyle = '#e2e8f0';
        ctx.fillText('Push back with rules', objX + 10, 138);

        ctx.fillStyle = '#ef4444';
        ctx.fillText('>', objX, 152);
        ctx.fillStyle = '#e2e8f0';
        ctx.fillText('Deal with "visitors"', objX + 10, 152);

        // Animated prompt
        ctx.textAlign = 'center';
        const blink = Math.sin(t * 0.12) > 0;
        if (blink) {
            ctx.fillStyle = '#fff';
            ctx.font = '7px "Press Start 2P"';
            ctx.fillText('[PRESS SPACE]', canvas.width / 2, 198);
        }

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'TITLE') {
        const t = GAME.stateTimer;

        // Premium animated background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.3, '#0a1525');
        grad.addColorStop(0.6, '#0f172a');
        grad.addColorStop(1, '#0a0a18');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated stars
        for (let i = 0; i < 30; i++) {
            const x = (i * 37 + t * 0.3) % canvas.width;
            const y = (i * 61) % canvas.height;
            const twinkle = Math.sin(t * 0.1 + i) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255,255,255,${twinkle * 0.6})`;
            ctx.fillRect(x, y, 1, 1);
        }

        // Animated grid lines with perspective
        const offset = (t * 1.2) % 32;
        ctx.strokeStyle = 'rgba(34, 211, 238, 0.15)';
        ctx.lineWidth = 1;
        for (let i = -1; i < 16; i++) {
            const y = i * 16 + offset;
            const alpha = 0.1 + (y / canvas.height) * 0.2;
            ctx.strokeStyle = `rgba(34, 211, 238, ${alpha})`;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        for (let i = 0; i < 17; i++) {
            ctx.strokeStyle = 'rgba(34, 211, 238, 0.1)';
            ctx.beginPath();
            ctx.moveTo(i * 16, 0);
            ctx.lineTo(i * 16, canvas.height);
            ctx.stroke();
        }

        // Warehouse silhouette at bottom
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(0, 180, canvas.width, 44);
        ctx.fillStyle = '#1a1a2e';
        for (let i = 0; i < 8; i++) {
            ctx.fillRect(i * 32 + 4, 185, 24, 35);
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(i * 32 + 8, 190, 16, 12);
            ctx.fillStyle = '#1a1a2e';
        }

        ctx.textAlign = 'center';

        // Title glow effect
        const glowIntensity = Math.sin(t * 0.08) * 0.3 + 0.7;
        ctx.shadowColor = '#ff9900';
        ctx.shadowBlur = 15 * glowIntensity;

        // Title with multiple layers
        const titleText = getLocalizedText('game_title');
        ctx.font = '16px "Press Start 2P"';
        ctx.fillStyle = '#7c2d12';
        ctx.fillText(titleText, canvas.width / 2 + 2, 44);
        ctx.fillStyle = '#ea580c';
        ctx.fillText(titleText, canvas.width / 2 + 1, 43);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText(titleText, canvas.width / 2, 42);
        ctx.shadowBlur = 0;

        // Subtitle with glow
        ctx.shadowColor = '#22d3ee';
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#22d3ee';
        ctx.font = '7px "Press Start 2P"';
        ctx.fillText(getLocalizedText('game_subtitle'), canvas.width / 2, 60);
        ctx.shadowBlur = 0;

        // Animated character showcase
        const charIdx = Math.floor(t / 90) % 5;
        const chars = ['Carrie', 'Nevena', 'Joao', 'Roman', 'Erwin'];
        const charName = chars[charIdx];
        const charBounce = Math.sin(t * 0.15) * 3;
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(GFX.chars[charName], canvas.width / 2 - 16, 85 + charBounce, 32, 32);
        ctx.restore();

        // Animated prompt with pulse
        ctx.textAlign = 'center';
        const blink = Math.sin(t * 0.12) > 0;
        const pulseScale = 1 + Math.sin(t * 0.1) * 0.05;
        if (blink) {
            ctx.fillStyle = '#fff';
            ctx.font = '9px "Press Start 2P"';
            ctx.fillText(getLocalizedText('press_spacebar'), canvas.width / 2, 160);
        }

        // Highscore hint
        ctx.fillStyle = '#ffd700';
        ctx.font = '6px "Press Start 2P"';
        ctx.fillText(getLocalizedText('highscores_hint'), canvas.width / 2, 175);

        // Decorative lines
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(40, 182, 176, 2);
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(60, 186, 136, 1);

        // Credits with style
        ctx.fillStyle = '#64748b';
        ctx.font = '7px monospace';
        ctx.fillText(getLocalizedText('created_by'), canvas.width / 2, 200);
        ctx.fillStyle = '#475569';
        ctx.font = '6px monospace';
        ctx.fillText(getLocalizedText('copyright'), canvas.width / 2, 220);

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'HOWTO') {
        const t = GAME.stateTimer;

        // Premium animated background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.3, '#0a1525');
        grad.addColorStop(0.6, '#0f172a');
        grad.addColorStop(1, '#0a0a18');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated particles
        for (let i = 0; i < 12; i++) {
            const x = (i * 43 + t * 0.25) % canvas.width;
            const y = (i * 37 + Math.sin(t * 0.015 + i) * 8) % canvas.height;
            const alpha = 0.15 + Math.sin(t * 0.04 + i) * 0.1;
            ctx.fillStyle = `rgba(34, 211, 238, ${alpha})`;
            ctx.fillRect(x, y, 2, 2);
        }

        // Panel background with gold glow
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 10;
        ctx.fillStyle = 'rgba(10, 10, 20, 0.95)';
        ctx.fillRect(8, 8, canvas.width - 16, canvas.height - 20);
        ctx.shadowBlur = 0;

        // Panel border
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.strokeRect(8, 8, canvas.width - 16, canvas.height - 20);
        ctx.strokeStyle = '#92400e';
        ctx.lineWidth = 1;
        ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 24);

        // Title with glow effect
        ctx.textAlign = 'center';
        const glowIntensity = Math.sin(t * 0.08) * 0.3 + 0.7;
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 10 * glowIntensity;
        ctx.font = '10px "Press Start 2P"';
        const howToPlayTitle = getLocalizedText('how_to_play');
        ctx.fillStyle = '#92400e';
        ctx.fillText(howToPlayTitle, canvas.width / 2 + 1, 24);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText(howToPlayTitle, canvas.width / 2, 23);
        ctx.shadowBlur = 0;

        // Decorative line under title
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(20, 30, canvas.width - 40, 1);

        ctx.textAlign = 'left';

        // === LEFT COLUMN: CONTROLS ===
        const leftCol = 16;
        const rightCol = canvas.width / 2 + 8;

        // CONTROLS header
        ctx.fillStyle = '#22d3ee';
        ctx.font = '6px "Press Start 2P"';
        ctx.fillText(getLocalizedText('controls'), leftCol, 44);

        // Control key boxes with descriptions
        const drawKeyBox = (x, y, key, desc) => {
            ctx.fillStyle = 'rgba(34, 211, 238, 0.12)';
            ctx.fillRect(x, y, 40, 12);
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, 40, 12);
            ctx.fillStyle = '#22d3ee';
            ctx.font = '5px "Press Start 2P"';
            ctx.fillText(key, x + 3, y + 9);
            ctx.fillStyle = '#94a3b8';
            ctx.font = '6px monospace';
            ctx.fillText(desc, x + 44, y + 9);
        };

        drawKeyBox(leftCol, 50, 'W A S D', 'Move');
        drawKeyBox(leftCol, 66, 'SPACE', 'Attack/Interact');
        drawKeyBox(leftCol, 82, 'ARROWS', 'Menu navigation');
        drawKeyBox(leftCol, 98, 'UP', 'Hazard details');

        // === OBJECTIVE header ===
        ctx.fillStyle = '#22d3ee';
        ctx.font = '6px "Press Start 2P"';
        ctx.fillText(getLocalizedText('objective'), leftCol, 120);

        ctx.fillStyle = '#f0f0ff';
        ctx.font = '6px monospace';
        ctx.fillText(getLocalizedText('objective_text_1'), leftCol + 2, 132);
        ctx.fillText(getLocalizedText('objective_text_2'), leftCol + 2, 142);
        ctx.fillText(getLocalizedText('objective_text_3'), leftCol + 2, 152);

        // === RIGHT COLUMN: TIPS & ENEMIES ===
        // TIPS header
        ctx.fillStyle = '#22d3ee';
        ctx.font = '6px "Press Start 2P"';
        ctx.fillText(getLocalizedText('tips'), rightCol, 44);

        ctx.fillStyle = '#fbbf24';
        ctx.font = '6px monospace';
        const tips = [
            '> Walk into hazards to fix',
            '> Throw books at ops mgrs',
            '> Avoid ops manager requests',
            '> Find secret fire exit!'
        ];
        tips.forEach((tip, i) => {
            ctx.fillText(tip, rightCol + 2, 56 + i * 11);
        });

        // ENEMIES header
        ctx.fillStyle = '#22d3ee';
        ctx.font = '6px "Press Start 2P"';
        ctx.fillText(getLocalizedText('watch_out_for'), rightCol, 105);

        // Enemy icons with descriptions
        ctx.fillStyle = '#ef4444';
        ctx.font = '6px monospace';
        ctx.fillText(getLocalizedText('ops_managers_desc'), rightCol + 2, 117);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText(getLocalizedText('runners_desc'), rightCol + 2, 129);
        ctx.fillStyle = '#a855f7';
        ctx.fillText(getLocalizedText('bosses_desc'), rightCol + 2, 141);

        // PPE SHOP hint
        ctx.fillStyle = '#22d3ee';
        ctx.font = '6px "Press Start 2P"';
        ctx.fillText(getLocalizedText('ppe_shop'), rightCol, 158);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '6px monospace';
        ctx.fillText(getLocalizedText('find_safety_cage'), rightCol + 2, 170);
        ctx.fillText(getLocalizedText('unlock_ppe_buffs'), rightCol + 2, 180);

        // Animated prompt at bottom
        ctx.textAlign = 'center';
        const blink = Math.sin(t * 0.12) > 0;
        if (blink) {
            ctx.fillStyle = '#fff';
            ctx.font = '7px "Press Start 2P"';
            ctx.fillText(getLocalizedText('space_to_continue'), canvas.width / 2, 206);
        }
        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    // === HAZARD DETAIL MODAL (Revamped with Talking Simon) ===
    if (GAME.state === 'HAZARD_DETAIL_MODAL' && GAME.hazardModal) {
        const t = GAME.stateTimer;
        const modal = GAME.hazardModal;

        // Semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Modal frame - generous padding for readability
        const mX = 12, mY = 10, mW = canvas.width - 24, mH = canvas.height - 20;

        // Main panel background with subtle gradient
        const bgGrad = ctx.createLinearGradient(mX, mY, mX, mY + mH);
        bgGrad.addColorStop(0, '#1a1a2e');
        bgGrad.addColorStop(1, '#0f0f1a');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(mX, mY, mW, mH);

        // Gold border with glow
        ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
        ctx.shadowBlur = 12;
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        ctx.strokeRect(mX, mY, mW, mH);
        ctx.shadowBlur = 0;

        // === SIMON TALKING PORTRAIT (large, centered at top) ===
        const portraitSize = 56;
        const portraitX = canvas.width / 2 - portraitSize / 2;
        const portraitY = mY + 10;

        // Portrait background with gold border
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(portraitX - 4, portraitY - 4, portraitSize + 8, portraitSize + 8);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(portraitX - 4, portraitY - 4, portraitSize + 8, portraitSize + 8);

        // Draw Simon talking (animate mouth)
        ctx.imageSmoothingEnabled = false;
        const useTalking = !modal.loading && Math.sin(t * 0.3) > 0;
        const simonSprite = useTalking && GFX.simonFaceTalking ? GFX.simonFaceTalking : GFX.simonFaceLarge;
        if (simonSprite) {
            ctx.drawImage(simonSprite, portraitX, portraitY, portraitSize, portraitSize);
        }

        // "SIMON" name badge below portrait
        crispText('SIMON', canvas.width / 2, portraitY + portraitSize + 12, '8px monospace', '#ffd700', 'center');

        // === HAZARD NAME HEADER (prominent, golden) ===
        const headerY = portraitY + portraitSize + 28;
        const hazardNameDisplay = modal.hazardName.length > 28 ? modal.hazardName.substring(0, 28) + '...' : modal.hazardName;
        crispText(hazardNameDisplay, canvas.width / 2, headerY, '8px monospace', '#22d3ee', 'center');

        // Regulation citation (smaller, below header)
        if (!modal.loading && modal.regulation) {
            const regText = modal.regulation.length > 35 ? modal.regulation.substring(0, 35) + '...' : modal.regulation;
            crispText(regText, canvas.width / 2, headerY + 14, '6px monospace', '#6b7280', 'center');
        }

        // === CONTENT AREA (80% width, centered) ===
        const contentY = headerY + 28;
        const contentW = Math.floor(mW * 0.8);
        const contentX = mX + Math.floor((mW - contentW) / 2);

        if (modal.loading) {
            // Loading animation
            const dots = '.'.repeat((Math.floor(t / 15) % 4));
            crispText(getLocalizedText('loading').replace('...', '') + dots, canvas.width / 2, contentY + 40, '10px monospace', '#f0f0ff', 'center');
        } else {
            // === SUMMARY TEXT (main content, with scrolling) ===
            const wrapTextLines = (text, maxChars) => {
                const words = text.split(' '); const lines = []; let line = '';
                words.forEach(word => {
                    const candidate = line.length ? line + ' ' + word : word;
                    if (candidate.length > maxChars) { if (line) lines.push(line); line = word; }
                    else { line = candidate; }
                });
                if (line) lines.push(line);
                return lines;
            };

            // Full summary text - wrap at 48 chars per line
            const summaryLines = wrapTextLines(modal.summary, 48);
            const lineHeight = 11;
            const maxVisibleLines = 8;
            const scrollOffset = modal.scrollOffset || 0;
            const visibleLines = summaryLines.slice(scrollOffset, scrollOffset + maxVisibleLines);

            // Draw summary lines in content area
            visibleLines.forEach((line, i) => {
                crispText(line, contentX, contentY + i * lineHeight, '7px monospace', '#e0e0f0', 'left');
            });

            // Update max scroll
            modal.maxScroll = Math.max(0, summaryLines.length - maxVisibleLines);

            // Scroll indicator (only if needed)
            if (summaryLines.length > maxVisibleLines) {
                const scrollY = contentY + maxVisibleLines * lineHeight + 4;
                if (scrollOffset > 0) {
                    crispText('\u25B2', mX + mW - 16, contentY - 4, '6px monospace', '#ffd700', 'left');
                }
                if (scrollOffset < modal.maxScroll) {
                    crispText('\u25BC', mX + mW - 16, scrollY - 8, '6px monospace', '#ffd700', 'left');
                }
            }
        }

        // === FOOTER (simple, clean) ===
        const footerY = mY + mH - 18;
        ctx.fillStyle = 'rgba(20, 20, 40, 0.9)';
        ctx.fillRect(mX + 6, footerY, mW - 12, 14);

        const blink = Math.sin(t * 0.15) > 0;
        const footerColor = blink ? '#ffd700' : '#6b5308';
        crispText('[SPACE] ' + getLocalizedText('close_short'), canvas.width / 2, footerY + 10, '6px monospace', footerColor, 'center');

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    // === PPE VENDING MACHINE DIALOG (Conversation Style) ===
    if (GAME.state === 'PPE_DIALOG') {
        const t = GAME.stateTimer;
        ctx.save();

        // Semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Main dialog box (Conversation style like dialog-box)
        const boxX = 8, boxY = 16, boxW = canvas.width - 16, boxH = 205;

        // Main panel background (gradient feel)
        ctx.fillStyle = '#0a1628';
        ctx.fillRect(boxX, boxY, boxW, boxH);

        // Inner gradient effect
        const gradient = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxH);
        gradient.addColorStop(0, 'rgba(10, 22, 40, 0.95)');
        gradient.addColorStop(1, 'rgba(6, 16, 32, 0.98)');
        ctx.fillStyle = gradient;
        ctx.fillRect(boxX + 2, boxY + 2, boxW - 4, boxH - 4);

        // Gold border (conversation style)
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxW, boxH);

        // Outer glow effect
        ctx.shadowColor = 'rgba(255, 215, 0, 0.4)';
        ctx.shadowBlur = 15;
        ctx.strokeRect(boxX, boxY, boxW, boxH);
        ctx.shadowBlur = 0;

        // Draw vending machine sprite (portrait area)
        const portraitX = boxX + 10;
        const portraitY = boxY + 12;
        const portraitSize = 64;

        // Portrait background
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(portraitX, portraitY, portraitSize, portraitSize);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(portraitX, portraitY, portraitSize, portraitSize);

        if (GFX.vendingMachineLarge) {
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(GFX.vendingMachineLarge, portraitX + 8, portraitY + 8, 48, 48);
        }

        // Label under portrait
        crispText('PPE VENDOR', portraitX + portraitSize / 2, portraitY + portraitSize + 10, '6px monospace', '#ffd700', 'center');

        // Content area (to the right of vending machine)
        const contentX = portraitX + portraitSize + 14;
        const contentY = boxY + 16;

        // Title (golden, conversation style)
        crispText(getLocalizedText('ppe_vending'), contentX, contentY + 4, '9px monospace', '#ffd700', 'left');
        crispText(getLocalizedText('ppe_machine'), contentX + 10, contentY + 18, '9px monospace', '#ffd700', 'left');

        // Info text (conversation style with #f0f0ff)
        crispText(getLocalizedText('spend_safety_points'), contentX, contentY + 36, '7px monospace', '#f0f0ff', 'left');
        crispText(getLocalizedText('protective_equipment'), contentX, contentY + 48, '7px monospace', '#f0f0ff', 'left');
        crispText(getLocalizedText('each_item_grants'), contentX, contentY + 62, '7px monospace', '#94a3b8', 'left');
        crispText(getLocalizedText('permanent_buff'), contentX, contentY + 74, '7px monospace', '#94a3b8', 'left');

        // Safety Points display (highlighted)
        crispText(getLocalizedText('sp_short') + ': ' + GAME.safetyPoints, contentX, contentY + 92, '8px monospace', '#22d3ee', 'left');

        // Menu options (conversation style)
        const menuY = boxY + 125;
        const localizedOptions = [getLocalizedText('select_items'), getLocalizedText('leave')];
        localizedOptions.forEach((opt, i) => {
            const isSelected = GAME.ppeDialogChoice === i;
            const optY = menuY + i * 22;

            if (isSelected) {
                // Selection highlight (gold tint)
                ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.fillRect(contentX - 4, optY - 8, 140, 18);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(contentX - 4, optY - 8, 140, 18);

                // Blinking arrow
                const blink = Math.sin(t * 0.15) > 0;
                const arrowColor = blink ? '#ffd700' : '#92400e';
                crispText('\u25B6', contentX, optY + 5, '10px monospace', arrowColor, 'left');
            }

            const optColor = isSelected ? '#fff' : '#64748b';
            crispText(opt, contentX + 16, optY + 4, '8px monospace', optColor, 'left');

            // Store button coordinates for touch detection
            if (!GAME.ppeDialogButtons) GAME.ppeDialogButtons = [];
            GAME.ppeDialogButtons[i] = { x: contentX - 4, y: optY - 8, w: 140, h: 18 };
        });

        // Footer controls (conversation style)
        ctx.fillStyle = 'rgba(31, 41, 55, 0.9)';
        ctx.fillRect(boxX + 4, boxY + boxH - 16, boxW - 8, 12);
        const blink = Math.sin(t * 0.12) > 0;
        const footerColor = blink ? '#ffd700' : '#64748b';
        crispText(getLocalizedText('controls_select_confirm_leave'), canvas.width / 2, boxY + boxH - 7, '6px monospace', footerColor, 'center');

        ctx.restore();
        return;
    }
    // === QUARTERMASTER'S SAFETY LOCKER (PPE SHOP - Conversation Style) ===
    if (GAME.state === 'PPE_SHOP') {
        const t = GAME.stateTimer;
        const idx = GAME.ppeShopIndex;
        const itemsPerPage = 4;
        const pageStart = Math.floor(idx / itemsPerPage) * itemsPerPage;

        // Semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Main panel (Conversation style)
        const panelX = 6, panelY = 4, panelW = canvas.width - 12, panelH = canvas.height - 8;

        // Main panel background (gradient feel)
        ctx.fillStyle = '#0a1628';
        ctx.fillRect(panelX, panelY, panelW, panelH);

        // Inner gradient effect
        const gradient = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelH);
        gradient.addColorStop(0, 'rgba(10, 22, 40, 0.95)');
        gradient.addColorStop(1, 'rgba(6, 16, 32, 0.98)');
        ctx.fillStyle = gradient;
        ctx.fillRect(panelX + 2, panelY + 2, panelW - 4, panelH - 4);

        // Gold border (conversation style)
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        ctx.strokeRect(panelX, panelY, panelW, panelH);

        // Outer glow effect
        ctx.shadowColor = 'rgba(255, 215, 0, 0.4)';
        ctx.shadowBlur = 15;
        ctx.strokeRect(panelX, panelY, panelW, panelH);
        ctx.shadowBlur = 0;

        // Header bar (golden themed)
        ctx.fillStyle = 'rgba(120, 80, 20, 0.6)';
        ctx.fillRect(panelX + 4, panelY + 4, panelW - 8, 24);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 1;
        ctx.strokeRect(panelX + 4, panelY + 4, panelW - 8, 24);

        // Title (conversation style)
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd700';
        ctx.font = '8px monospace';
        ctx.fillText(getLocalizedText('safety_locker'), canvas.width / 2, panelY + 18);

        // Safety Points display
        ctx.fillStyle = '#22d3ee';
        ctx.font = '8px monospace';
        ctx.fillText(getLocalizedText('safety_points') + ': ' + GAME.safetyPoints, canvas.width / 2, panelY + 36);

        ctx.textAlign = 'left';

        // Item list area
        const listY = panelY + 44;
        const itemHeight = 32;
        const itemsVisible = 4;

        for (let i = 0; i < itemsVisible; i++) {
            const itemIdx = pageStart + i;
            if (itemIdx >= PPE_ITEMS.length) break;

            const item = PPE_ITEMS[itemIdx];
            const y = listY + i * itemHeight;
            const isSelected = itemIdx === idx;
            const isOwned = GAME.ppeUnlocked.includes(item.id);
            const isAction = item.isAction;
            const isPremium = item.cost >= 5000 && !isAction;

            // Row background (conversation style colors)
            if (isAction) {
                ctx.fillStyle = isSelected ? 'rgba(168, 85, 247, 0.4)' : 'rgba(88, 28, 135, 0.5)';
            } else if (isPremium) {
                ctx.fillStyle = isSelected ? 'rgba(255, 215, 0, 0.3)' : 'rgba(120, 80, 20, 0.4)';
            } else {
                ctx.fillStyle = isSelected ? 'rgba(255, 215, 0, 0.15)' : (i % 2 === 0 ? 'rgba(20, 40, 60, 0.5)' : 'rgba(15, 30, 50, 0.5)');
            }
            ctx.fillRect(panelX + 6, y, panelW - 12, itemHeight - 2);

            // Selection highlight (gold themed)
            if (isSelected) {
                if (isAction) {
                    ctx.strokeStyle = '#a855f7';
                } else if (isPremium) {
                    ctx.strokeStyle = '#ffd700';
                } else {
                    ctx.strokeStyle = '#ffd700';
                }
                ctx.lineWidth = 2;
                ctx.strokeRect(panelX + 6, y, panelW - 12, itemHeight - 2);

                // Selection arrow
                const arrowPulse = Math.sin(t * 0.15) > 0;
                ctx.fillStyle = arrowPulse ? '#ffd700' : '#92400e';
                ctx.font = '10px monospace';
                ctx.fillText('\u25B6', panelX + 10, y + 18);
            }

            // Item name (conversation style colors)
            if (isAction) {
                ctx.fillStyle = isSelected ? '#e879f9' : '#c084fc';
            } else if (isPremium) {
                ctx.fillStyle = isOwned ? '#22c55e' : (isSelected ? '#ffd700' : '#fbbf24');
            } else {
                ctx.fillStyle = isOwned ? '#22c55e' : (isSelected ? '#fff' : '#f0f0ff');
            }
            ctx.font = '8px monospace';
            ctx.fillText(item.name, panelX + 26, y + 12);

            // Description
            if (isAction) {
                ctx.fillStyle = isSelected ? '#f0abfc' : '#a855f7';
            } else if (isPremium) {
                ctx.fillStyle = isOwned ? '#86efac' : (isSelected ? '#fde68a' : '#d97706');
            } else {
                ctx.fillStyle = isOwned ? '#86efac' : (isSelected ? '#94a3b8' : '#64748b');
            }
            ctx.font = '8px monospace';
            ctx.fillText(item.desc, panelX + 26, y + 24);

            // Cost or OWNED badge
            ctx.textAlign = 'right';
            if (isAction) {
                const returnCount = GAME.ppeUnlocked.length;
                ctx.fillStyle = returnCount > 0 ? '#581c87' : '#3f3f46';
                ctx.fillRect(panelW - 46, y + 6, 42, 16);
                ctx.strokeStyle = returnCount > 0 ? '#a855f7' : '#71717a';
                ctx.lineWidth = 1;
                ctx.strokeRect(panelW - 46, y + 6, 42, 16);
                ctx.fillStyle = returnCount > 0 ? '#e879f9' : '#a1a1aa';
                ctx.font = '8px monospace';
                ctx.fillText(returnCount > 0 ? returnCount + ' ' + getLocalizedText('items_short') : getLocalizedText('empty'), panelW - 8, y + 17);
            } else if (isOwned) {
                ctx.fillStyle = '#166534';
                ctx.fillRect(panelW - 46, y + 6, 42, 16);
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 1;
                ctx.strokeRect(panelW - 46, y + 6, 42, 16);
                ctx.fillStyle = '#22c55e';
                ctx.font = '8px monospace';
                ctx.fillText(getLocalizedText('owned'), panelW - 8, y + 17);
            } else {
                const canAfford = GAME.safetyPoints >= item.cost;
                ctx.fillStyle = canAfford ? (isPremium ? '#78350f' : '#713f12') : '#7f1d1d';
                ctx.fillRect(panelW - 46, y + 6, 42, 16);
                ctx.strokeStyle = canAfford ? '#ffd700' : '#ef4444';
                ctx.lineWidth = 1;
                ctx.strokeRect(panelW - 46, y + 6, 42, 16);
                ctx.fillStyle = canAfford ? '#ffd700' : '#ef4444';
                ctx.font = '8px monospace';
                ctx.fillText(item.cost, panelW - 8, y + 17);
            }
            ctx.textAlign = 'left';
        }

        // Pagination indicator
        const totalPages = Math.ceil(PPE_ITEMS.length / itemsVisible);
        const currentPage = Math.floor(idx / itemsVisible) + 1;
        ctx.textAlign = 'center';
        ctx.fillStyle = '#94a3b8';
        ctx.font = '7px monospace';
        const pageY = listY + itemsVisible * itemHeight + 6;

        if (currentPage > 1) {
            ctx.fillStyle = '#ffd700';
            ctx.fillText('\u25C0 ' + getLocalizedText('prev'), panelX + 50, pageY);
        }
        ctx.fillStyle = '#94a3b8';
        ctx.fillText(getLocalizedText('page') + ' ' + currentPage + '/' + totalPages, canvas.width / 2, pageY);
        if (currentPage < totalPages) {
            ctx.fillStyle = '#ffd700';
            ctx.fillText(getLocalizedText('next') + ' \u25B6', panelW - 40, pageY);
        }

        // Controls footer (conversation style) - full width since exit is now a list item
        ctx.fillStyle = 'rgba(31, 41, 55, 0.9)';
        ctx.fillRect(panelX + 4, panelY + panelH - 18, panelW - 8, 14);

        const blink = Math.sin(t * 0.12) > 0;
        ctx.fillStyle = blink ? '#ffd700' : '#64748b';
        ctx.font = '6px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('\u25B2\u25BC ' + getLocalizedText('scroll') + ' | SPACE', canvas.width / 2, panelY + panelH - 9);

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'SELECT') {
        const t = GAME.stateTimer;
        const frameX = 14, frameY = 22, frameW = 228, frameH = 180;

        // Background gradient
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.5, '#0a1525');
        grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated background particles
        for (let i = 0; i < 20; i++) {
            const x = (i * 31 + t * 0.2) % canvas.width;
            const y = (i * 47 + t * 0.1) % canvas.height;
            ctx.fillStyle = `rgba(251, 191, 36, ${0.1 + Math.sin(t * 0.05 + i) * 0.1})`;
            ctx.fillRect(x, y, 2, 2);
        }

        // Main frame with glow
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(frameX, frameY, frameW, frameH);
        ctx.shadowBlur = 0;

        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.strokeRect(frameX, frameY, frameW, frameH);
        ctx.strokeStyle = '#92400e';
        ctx.strokeRect(frameX + 2, frameY + 2, frameW - 4, frameH - 4);

        // Inner panel
        ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
        ctx.fillRect(frameX + 6, frameY + 35, frameW - 12, frameH - 50);

        ctx.textAlign = 'center';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#fbbf24';
        ctx.font = '11px "Press Start 2P"';
        ctx.fillText(getLocalizedText('select_coordinator'), frameX + frameW / 2, frameY + 18);
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#64748b';
        ctx.font = '7px monospace';
        ctx.fillText(getLocalizedText('arrows_browse'), frameX + frameW / 2, frameY + 30);

        let name = GAME.charList[GAME.charIndex]; let data = CHAR_DATA[name];
        const portraitX = frameX + 18, portraitY = frameY + 46;
        ctx.fillStyle = '#000'; ctx.fillRect(portraitX - 2, portraitY - 2, 56, 56);
        ctx.strokeStyle = '#333'; ctx.strokeRect(portraitX - 4, portraitY - 4, 60, 60);
        ctx.save(); ctx.imageSmoothingEnabled = false; ctx.drawImage(GFX.chars[name], portraitX, portraitY, 52, 52); ctx.restore();

        ctx.fillStyle='#eab308'; ctx.font='12px monospace';
        ctx.fillText("< " + name + " >", frameX + frameW / 2, frameY + 54);

        ctx.textAlign = 'left';
        ctx.font='8px monospace'; ctx.fillStyle='#00ffff';
        const textStartX = portraitX + 70; const textStartY = frameY + 70;
        ctx.fillText("ROLE: " + data.role, textStartX, textStartY);

        const wrapText = (text, maxChars = 30) => {
            const words = text.split(' '); const lines = []; let line = '';
            words.forEach(word => { const candidate = line.length ? line + ' ' + word : word; if (candidate.length > maxChars) { lines.push(line); line = word; } else { line = candidate; } });
            if (line) lines.push(line); return lines;
        };
        const backstoryLines = wrapText(data.backstory, 30).slice(0, 3);
        ctx.fillStyle='#fff'; backstoryLines.forEach((l, idx) => ctx.fillText(l, textStartX, textStartY + 14 + idx * 12));

        ctx.fillStyle='#ff00ff';
        ctx.fillText("ATTACK: " + data.attack, frameX + 18, frameY + frameH - 45);

        // Display unique ability
        ctx.fillStyle='#22d3ee';
        ctx.fillText("ABILITY: " + data.ability, frameX + 18, frameY + frameH - 32);
        ctx.fillStyle='#94a3b8'; ctx.font='7px monospace';
        ctx.fillText(data.abilityDesc, frameX + 18, frameY + frameH - 20);

        ctx.textAlign = 'center';
        ctx.fillStyle='#888'; ctx.font='10px monospace';
        ctx.fillText("PRESS SPACE", frameX + frameW / 2, frameY + frameH - 12);
        ctx.restore(); return;
    }
    if (GAME.state === 'YARD_INTRO') {
        // Dark gradient background
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a0a14');
        grad.addColorStop(0.5, '#1a1a2e');
        grad.addColorStop(1, '#0f172a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Warning stripes
        ctx.fillStyle = '#facc15';
        for (let i = 0; i < canvas.width; i += 24) {
            ctx.fillRect(i, 0, 12, 6);
            ctx.fillRect(i + 12, canvas.height - 6, 12, 6);
        }

        // Title
        ctx.fillStyle = '#ff9900';
        ctx.font = '16px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('THE YARD', canvas.width / 2, 50);

        // Subtitle
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px "Press Start 2P"';
        ctx.fillText('DANGER ZONE', canvas.width / 2, 70);

        // Instructions
        ctx.fillStyle = '#f0f0ff';
        ctx.font = '9px monospace';
        ctx.fillText('You sneak through the fire exit', canvas.width / 2, 100);
        ctx.fillText('into the Amazon logistics yard.', canvas.width / 2, 115);

        ctx.fillStyle = '#facc15';
        ctx.fillText('Dodge DSP vans and semis!', canvas.width / 2, 140);
        ctx.fillText('Reach the top without getting hit!', canvas.width / 2, 155);

        ctx.fillStyle = '#ef4444';
        ctx.font = '8px monospace';
        ctx.fillText('WARNING: Vehicles WILL reset you!', canvas.width / 2, 175);

        // Prompt
        ctx.fillStyle = '#00ffff';
        ctx.font = '9px "Press Start 2P"';
        const blink = Math.sin(GAME.stateTimer * 0.1) > 0;
        if (blink) ctx.fillText('[PRESS SPACE TO RUN]', canvas.width / 2, 205);

        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'YARD_LEVEL') { drawYardLevel(); ctx.restore(); return; }
    if (GAME.state === 'VISITOR_SPLASH') {
        const t = GAME.stateTimer;
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a0f2e');
        gradient.addColorStop(1, '#2a1b44');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let y = -20; y < canvas.height + 20; y += 12) {
            const offset = (t * 2) % 24;
            ctx.fillStyle = y % 24 === 0 ? 'rgba(255,215,0,0.08)' : 'rgba(255,255,255,0.05)';
            ctx.fillRect(((t * 3) + y * 2) % canvas.width, y + offset, canvas.width, 6);
        }

        ctx.save();
        ctx.translate(canvas.width / 2, 90);
        ctx.textAlign = 'center';
        const wobble = 1 + Math.sin(t / 10) * 0.05;
        ctx.scale(wobble, wobble);
        ctx.fillStyle = '#000';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.fillText("SURPRISE VISITOR!", 0, 0);
        ctx.fillStyle = '#eab308';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 8;
        ctx.fillText("SURPRISE VISITOR!", -2, -2);
        ctx.restore();

        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd166';
        ctx.font = '8px monospace';
        ctx.fillText("An unannounced Visitor is stepping onto the floor...", canvas.width / 2, 148);
        ctx.fillStyle = '#fff';
        ctx.fillText("Simon braces: tighten PPE, breathe, and stand tall.", canvas.width / 2, 166);

        ctx.fillStyle = '#ff00ff';
        ctx.font = '10px monospace';
        ctx.fillText("[PRESS SPACE TO CONTINUE]", canvas.width / 2, 204);
        ctx.textAlign = 'left';
        ctx.restore(); return;
    }
    if (GAME.state === 'MECHA_BOSS_INTRO' && GAME.mecha) {
        ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#eab308'; ctx.font = '16px monospace'; ctx.fillText('MECHA JEFF RISES', 30, 40);
        ctx.drawImage(GFX.mechaJeff, 92, 60, 72, 72);
        ctx.fillStyle = '#fff'; ctx.font = '9px monospace';
        ctx.fillText('Prime Drone Swarm', 20, 150);
        ctx.fillText('2-Day Shipping Storm', 20, 166);
        ctx.fillText('Orbital Beam Audit', 20, 182);
        ctx.fillStyle = '#9ca3af'; ctx.fillText('[PRESS SPACE TO DEFY]', 60, 206);
        ctx.restore(); return;
    }
    if (GAME.state === 'MECHA_BOSS') { drawMechaBattle(); ctx.restore(); return; }
    if (GAME.state === 'THRONE_CONFRONTATION') { drawThroneConfrontation(); ctx.restore(); return; }
    // Draw throne room background during dialog if we came from throne confrontation
    if (GAME.state === 'DIALOG' && GAME.dialogBackgroundState === 'THRONE_CONFRONTATION') {
        drawThroneConfrontation();
        ctx.restore();
        return;
    }
    // Draw escape scene background during dialog if we came from bezos escape
    if (GAME.state === 'DIALOG' && GAME.dialogBackgroundState === 'BEZOS_ESCAPE') {
        drawBezosEscape();
        ctx.restore();
        return;
    }
    // Draw boss defeat cutscene background during dialog
    if (GAME.state === 'DIALOG' && GAME.dialogBackgroundState === 'BOSS_DEFEAT_CUTSCENE') {
        // Dark dramatic background
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw the boss arena tiles dimmed
        const cx = GAME.camera.x; const cy = GAME.camera.y;
        ctx.globalAlpha = 0.4;
        for (let y = 0; y < MAP_H; y++) {
            for (let x = 0; x < MAP_W; x++) {
                const tile = GAME.map[y][x];
                const dx = x * TILE_SIZE - cx; const dy = y * TILE_SIZE - cy;
                if (dx < -16 || dx > 272 || dy < -16 || dy > 272) continue;
                if (tile === 0) {
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(dx, dy, TILE_SIZE, TILE_SIZE);
                }
            }
        }
        ctx.globalAlpha = 1;

        // Draw defeated boss (large centered sprite like in phase 0)
        if (GAME.boss && GAME.defeatCutscene) {
            const t = GAME.defeatCutscene.timer;
            const bossSprite = GAME.defeatCutscene.bossSprite || 'boss_manager';
            const defeatedImg = GFX.bossDefeated && GFX.bossDefeated[bossSprite]
                ? GFX.bossDefeated[bossSprite]
                : (GFX.bossDefeated ? GFX.bossDefeated.boss_manager : null);

            // Center the boss in the screen (same as BOSS_DEFEAT_CUTSCENE state)
            const bossX = 96;
            const bossY = 60;

            // Subtle pulsing glow behind boss
            const glowPulse = Math.sin(t * 0.1) * 0.2 + 0.8;
            const glowGrad = ctx.createRadialGradient(128, 92, 10, 128, 92, 50);
            glowGrad.addColorStop(0, `rgba(255, 68, 68, ${glowPulse * 0.4})`);
            glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(0, 0, 256, 180);

            ctx.globalAlpha = 1;
            if (defeatedImg) {
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(defeatedImg, bossX, bossY, 64, 64);
                ctx.restore();
            } else {
                const bossImg = GAME.boss.sprite && GFX[GAME.boss.sprite] ? GFX[GAME.boss.sprite] : GFX.boss_manager;
                ctx.drawImage(bossImg, bossX, bossY, 64, 64);
            }
            ctx.globalAlpha = 1;
        }

        // Draw player character
        if (GAME.player) {
            const px = GAME.player.x - cx;
            const py = GAME.player.y - cy;
            const charImg = GFX.chars[GAME.selectedChar] || GFX.chars.Carrie;
            ctx.drawImage(charImg, px, py, 16, 16);
        }

        // Draw defeat cutscene effects
        if (GAME.defeatCutscene) {
            drawDefeatCutscene();
        }

        // Continue updating the cutscene animation during dialog
        if (GAME.defeatCutscene) {
            updateDefeatCutscene();
        }

        ctx.restore();
        return;
    }
    if (GAME.state === 'MECHA_TRANSFORM') { drawMechaTransform(); ctx.restore(); return; }
    if (GAME.state === 'SIMON_MECHA_TRANSFORM') { drawSimonMechaTransform(); ctx.restore(); return; }
    if (GAME.state === 'MECHA_SIMON_SPLASH') { drawMechaSimonSplash(); ctx.restore(); return; }
    // Boss defeat cutscene - draw dramatic background with overlay effects
    if (GAME.state === 'BOSS_DEFEAT_CUTSCENE') {
        // Epic dark dramatic background with gradient
        const bgGrad = ctx.createRadialGradient(128, 128, 20, 128, 128, 180);
        bgGrad.addColorStop(0, '#1a1a2e');
        bgGrad.addColorStop(0.5, '#0f0f1a');
        bgGrad.addColorStop(1, '#050508');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Animated dramatic lines radiating from center
        if (GAME.defeatCutscene && GAME.defeatCutscene.phase === 0) {
            const t = GAME.defeatCutscene.timer;
            ctx.save();
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + t * 0.02;
                const pulse = Math.sin(t * 0.1 + i) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(255, 68, 68, ${pulse * 0.3})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(128, 100);
                ctx.lineTo(128 + Math.cos(angle) * 200, 100 + Math.sin(angle) * 200);
                ctx.stroke();
            }
            ctx.restore();
        }

        // Draw the boss arena tiles very dimmed
        const cx = GAME.camera.x; const cy = GAME.camera.y;
        ctx.globalAlpha = 0.2;
        for (let y = 0; y < MAP_H; y++) {
            for (let x = 0; x < MAP_W; x++) {
                const tile = GAME.map[y][x];
                const dx = x * TILE_SIZE - cx; const dy = y * TILE_SIZE - cy;
                if (dx < -16 || dx > 272 || dy < -16 || dy > 272) continue;
                if (tile === 0) {
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(dx, dy, TILE_SIZE, TILE_SIZE);
                }
            }
        }
        ctx.globalAlpha = 1;

        // Draw EPIC defeated boss (larger 64x64 sprite, centered, with dramatic effects)
        if (GAME.boss && GAME.defeatCutscene) {
            const t = GAME.defeatCutscene.timer;
            const phase = GAME.defeatCutscene.phase;

            // Get the larger defeated sprite
            const bossSprite = GAME.defeatCutscene.bossSprite || 'boss_manager';
            const defeatedImg = GFX.bossDefeated && GFX.bossDefeated[bossSprite]
                ? GFX.bossDefeated[bossSprite]
                : (GFX.bossDefeated ? GFX.bossDefeated.boss_manager : null);

            // Center the boss in the screen
            const bossX = 96; // Center 64px sprite in 256px canvas
            const bossY = 60;

            // Dramatic pulsing glow behind boss
            const glowPulse = Math.sin(t * 0.1) * 0.3 + 0.7;
            const glowGrad = ctx.createRadialGradient(128, 92, 10, 128, 92, 60);
            glowGrad.addColorStop(0, `rgba(255, 68, 68, ${glowPulse * 0.5})`);
            glowGrad.addColorStop(0.5, `rgba(255, 107, 107, ${glowPulse * 0.3})`);
            glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(0, 0, 256, 200);

            // Flash effect on defeat
            if (phase === 0) {
                const flashAlpha = Math.sin(t * 0.3) * 0.3 + 0.5;
                ctx.globalAlpha = flashAlpha;
            }

            // Draw the large defeated boss sprite
            if (defeatedImg) {
                // Slight shake effect during intro
                const shakeX = phase === 0 ? (Math.random() - 0.5) * 4 : 0;
                const shakeY = phase === 0 ? (Math.random() - 0.5) * 4 : 0;

                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(defeatedImg, bossX + shakeX, bossY + shakeY, 64, 64);
                ctx.restore();
            } else {
                // Fallback to regular sprite but bigger
                const bossImg = GAME.boss.sprite && GFX[GAME.boss.sprite] ? GFX[GAME.boss.sprite] : GFX.boss_manager;
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(bossImg, bossX, bossY, 64, 64);
                ctx.restore();
            }
            ctx.globalAlpha = 1;

            // Dramatic "DEFEATED" frame/border
            if (phase === 0) {
                const frameAlpha = Math.sin(t * 0.15) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(255, 215, 0, ${frameAlpha})`;
                ctx.lineWidth = 3;
                ctx.strokeRect(bossX - 8, bossY - 8, 80, 80);

                // Corner accents
                ctx.fillStyle = `rgba(255, 215, 0, ${frameAlpha})`;
                ctx.fillRect(bossX - 12, bossY - 12, 8, 3);
                ctx.fillRect(bossX - 12, bossY - 12, 3, 8);
                ctx.fillRect(bossX + 68, bossY - 12, 8, 3);
                ctx.fillRect(bossX + 73, bossY - 12, 3, 8);
                ctx.fillRect(bossX - 12, bossY + 65, 8, 3);
                ctx.fillRect(bossX - 12, bossY + 60, 3, 8);
                ctx.fillRect(bossX + 68, bossY + 65, 8, 3);
                ctx.fillRect(bossX + 73, bossY + 60, 3, 8);
            }
        }

        // Draw player character (victorious pose position)
        if (GAME.player) {
            const px = 200; // Position player to the right
            const py = 110;
            const charImg = GFX.chars[GAME.selectedChar] || GFX.chars.Carrie;
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            // Draw player slightly larger
            ctx.drawImage(charImg, px, py, 24, 24);
            ctx.restore();
        }

        drawDefeatCutscene();
        ctx.restore();
        return;
    }
    if (GAME.state === 'BEZOS_ESCAPE') { updateBezosEscape(); drawBezosEscape(); ctx.restore(); return; }
    if (GAME.state === 'CREDITS') { drawCredits(); ctx.restore(); return; }
    if (GAME.state === 'BOSS_INTRO' && GAME.boss) {
        ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#eab308'; ctx.font = '16px monospace'; ctx.fillText("WARNING", 80, 50);
        ctx.fillStyle = '#ff0000'; ctx.font = '12px monospace'; ctx.fillText(GAME.boss.name.toUpperCase(), 20, 90);
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace'; ctx.fillText(GAME.boss.title, 20, 110);
        ctx.fillStyle = '#888'; ctx.fillText(GAME.boss.desc, 20, 130);
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        const portraitFrameX = 170, portraitFrameY = 70, portraitSize = 88;
        ctx.fillStyle = '#000';
        ctx.fillRect(portraitFrameX - 4, portraitFrameY - 4, portraitSize + 8, portraitSize + 8);
        ctx.strokeStyle = '#444';
        ctx.strokeRect(portraitFrameX - 6, portraitFrameY - 6, portraitSize + 12, portraitSize + 12);
        const bossSprite = (GAME.boss.sprite && GFX[GAME.boss.sprite]) ? GFX[GAME.boss.sprite] : GFX.boss_manager;
        ctx.drawImage(bossSprite, portraitFrameX, portraitFrameY, portraitSize, portraitSize);
        ctx.restore();
        ctx.fillStyle = '#eab308'; ctx.fillText("ATTACK: " + GAME.boss.attackName, 20, 160);
        ctx.fillStyle = '#fff'; ctx.fillText("[PRESS SPACE TO FIGHT]", 50, 200); ctx.restore(); return;
    }

    // Bezos intro screen
    if (GAME.state === 'BEZOS_INTRO' && GAME.boss) {
        ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Dramatic lines
        for (let i = 0; i < 10; i++) {
            ctx.strokeStyle = `rgba(255, 153, 0, ${0.3 - i * 0.03})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(128, 112);
            const angle = (GAME.stateTimer * 0.05 + i * 0.3) % (Math.PI * 2);
            ctx.lineTo(128 + Math.cos(angle) * 200, 112 + Math.sin(angle) * 200);
            ctx.stroke();
        }

        ctx.fillStyle = '#ff9900'; ctx.font = '16px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText("FINAL BOSS", 128, 40);
        ctx.fillStyle = '#ff0000'; ctx.font = '14px "Press Start 2P"';
        ctx.fillText("MECHA JEFF BEZOS", 128, 70);
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace';
        ctx.fillText("AUTOMATION PROTOCOL ACTIVATED", 128, 90);

        // Boss sprite
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(GFX.mechaBezos, 104, 100, 48, 48);
        ctx.restore();

        ctx.fillStyle = '#eab308'; ctx.font = '8px monospace';
        ctx.fillText("PRIME MISSILES READY", 128, 170);
        ctx.fillStyle = '#fff';
        ctx.fillText("[PRESS SPACE]", 128, 200);
        ctx.textAlign = 'left';
        ctx.restore();
        return;
    }

    // Bezos boss fight rendering
    if (GAME.state === 'BEZOS_BOSS') {
        // Space background - changes color when enraged
        const bgColor = GAME.boss && GAME.boss.enraged ? '#140a0a' : '#0a0a14';
        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 256, 224);

        // Stars
        for (let i = 0; i < 50; i++) {
            const x = (i * 37) % 256;
            const y = (i * 61) % 224;
            ctx.fillStyle = GAME.boss && GAME.boss.enraged ? '#ff6666' : '#fff';
            ctx.fillRect(x, y, 1, 1);
        }

        // === FALLING PACKAGES ===
        if (GAME.boss && GAME.boss.fallingPackages) {
            GAME.boss.fallingPackages.forEach(pkg => {
                // Package shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(pkg.x + 2, 210, 10, 4);
                // Package
                ctx.fillStyle = '#a16207';
                ctx.fillRect(pkg.x, pkg.y, pkg.w, pkg.h);
                ctx.fillStyle = '#78350f';
                ctx.fillRect(pkg.x + 2, pkg.y + 2, pkg.w - 4, pkg.h - 4);
                // Amazon smile
                ctx.fillStyle = '#ff9900';
                ctx.fillRect(pkg.x + 3, pkg.y + 6, 6, 2);
                ctx.fillRect(pkg.x + 8, pkg.y + 6, 2, 4);
            });
        }

        // === SHOCKWAVE EFFECT ===
        if (GAME.boss && GAME.boss.shockwaveTimer > 0) {
            const progress = 1 - (GAME.boss.shockwaveTimer / 30);
            const radius = progress * 80;
            const alpha = 1 - progress;
            ctx.strokeStyle = `rgba(255, 153, 0, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(GAME.boss.x + 24, GAME.boss.y + 24, radius, 0, Math.PI * 2);
            ctx.stroke();
            GAME.boss.shockwaveTimer--;
        }

        // Boss
        if (GAME.boss) {
            // Enrage glow effect
            if (GAME.boss.enraged) {
                const glowPulse = Math.sin(GAME.ticks * 0.15) * 10 + 30;
                const glowGrad = ctx.createRadialGradient(
                    GAME.boss.x + 24, GAME.boss.y + 24, 10,
                    GAME.boss.x + 24, GAME.boss.y + 24, glowPulse
                );
                glowGrad.addColorStop(0, 'rgba(255, 0, 0, 0.4)');
                glowGrad.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
                glowGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(GAME.boss.x + 24, GAME.boss.y + 24, glowPulse, 0, Math.PI * 2);
                ctx.fill();
            }

            // Dash trail effect
            if (GAME.boss.dashTarget) {
                ctx.fillStyle = 'rgba(255, 153, 0, 0.3)';
                for (let i = 0; i < 3; i++) {
                    const trailX = GAME.boss.x - (GAME.boss.dashTarget.x - GAME.boss.x) * 0.1 * i;
                    const trailY = GAME.boss.y - (GAME.boss.dashTarget.y - GAME.boss.y) * 0.1 * i;
                    ctx.globalAlpha = 0.3 - i * 0.1;
                    ctx.drawImage(GFX.mechaBezos, trailX, trailY);
                }
                ctx.globalAlpha = 1;
            }

            ctx.drawImage(GFX.mechaBezos, GAME.boss.x, GAME.boss.y);

            // Boss attack indicator
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'center';
            if (GAME.boss.attackPhase === 0) {
                ctx.fillStyle = '#ff9900';
                ctx.fillText('MISSILES', GAME.boss.x + 24, GAME.boss.y - 8);
            } else if (GAME.boss.attackPhase === 1) {
                ctx.fillStyle = '#00ffff';
                ctx.fillText('LASER SWEEP', GAME.boss.x + 24, GAME.boss.y - 8);
            } else if (GAME.boss.attackPhase === 2) {
                ctx.fillStyle = '#ff00ff';
                ctx.fillText('DRONE SWARM', GAME.boss.x + 24, GAME.boss.y - 8);
            }
        }

        // Drones
        GAME.entities.forEach(e => {
            if (e.type === 'drone') {
                ctx.drawImage(GFX.drone, e.x, e.y);
            }
        });

        // Player
        const p = GAME.player;
        if (p.iframe % 4 < 2) {
            ctx.drawImage(GFX.chars[GAME.selectedChar], p.x, p.y);
        }

        // Projectiles
        GAME.projectiles.forEach(proj => {
            if (proj.type === 'bezos_missile') {
                ctx.drawImage(GFX.bezosProj, proj.x, proj.y);
            } else if (proj.type === 'bezos_laser') {
                // Render laser beam
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillRect(proj.x - 2, proj.y - 2, 6, 6);
                ctx.shadowBlur = 0;
            } else if (proj.type === 'attack') {
                const sprite = (GFX.attacks && GFX.attacks[proj.owner]) ? GFX.attacks[proj.owner] : GFX.book;
                ctx.drawImage(sprite, proj.x, proj.y);
            }
        });

        ctx.restore();
        return;
    }

    // Bezos victory screen
    if (GAME.state === 'BEZOS_WIN') {
        // Victory gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a4d1a');
        gradient.addColorStop(1, '#0a1a0a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Fireworks effect
        for (let i = 0; i < 20; i++) {
            const x = (i * 31 + GAME.stateTimer * 2) % 256;
            const y = (i * 47 + GAME.stateTimer * 3) % 224;
            const colors = ['#ff9900', '#ffd700', '#ff6b6b', '#4ecdc4'];
            ctx.fillStyle = colors[i % colors.length];
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.textAlign = 'center';
        ctx.font = '16px "Press Start 2P"';
        ctx.fillStyle = '#ffd700';
        ctx.fillText("CONGRATULATIONS!", 128, 40);

        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = '#fff';
        ctx.fillText("YOU DEFEATED", 128, 70);
        ctx.fillText("MECHA JEFF BEZOS!", 128, 90);

        // Digitized face (using character sprite as placeholder)
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        const faceSize = 64;
        ctx.fillStyle = '#000';
        ctx.fillRect(96, 100, faceSize, faceSize);
        ctx.drawImage(GFX.chars[GAME.selectedChar], 96, 100, faceSize, faceSize);
        ctx.restore();

        ctx.font = '10px "Press Start 2P"';
        ctx.fillStyle = '#00ff00';
        ctx.fillText("TRUE HERO OF WHS!", 128, 175);

        // Credits
        ctx.font = '8px monospace';
        ctx.fillStyle = '#888';
        const creditsY = 190;
        ctx.fillText("CREDITS:", 128, creditsY);
        const credits = ["Director: Erwin Esener", "Producer: Erwin Esener", "Lead Dev: Erwin Esener", "Art: Erwin Esener", "Music: Erwin Esener"];
        credits.forEach((credit, i) => {
            ctx.fillText(credit, 128, creditsY + 12 + i * 10);
        });

        ctx.textAlign = 'left';
        ctx.restore();
        return;
    }

    const cx = Math.floor(GAME.camera.x); const cy = Math.floor(GAME.camera.y);
    let sx = Math.floor(cx/TILE_SIZE); let ex = sx + 17; let sy = Math.floor(cy/TILE_SIZE); let ey = sy + 15;
    for(let y=sy; y<=ey; y++) {
        for(let x=sx; x<=ex; x++) {
            if(x>=0 && x<MAP_W && y>=0 && y<MAP_H) {
                let t = GAME.map[y][x]; let dx = x*TILE_SIZE - cx; let dy = y*TILE_SIZE - cy;
                if (t===0) ctx.drawImage(GFX.floor, dx, dy); if (t===1) ctx.drawImage(GFX.wall, dx, dy);
                if (t===2) { ctx.drawImage(GFX.floor, dx, dy); ctx.drawImage(GFX.shelf, dx, dy); }
                if (t===3) {
                    ctx.drawImage(GFX.wall, dx, dy);
                    ctx.drawImage(GFX.door, dx, dy);
                    // Glow effect when door is accessible (4+ hazards cleared)
                    if (GAME.issuesFixed >= 4 && GAME.fireExitDoor) {
                        const pulse = Math.sin(GAME.ticks * 0.1) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(255, 215, 0, ${pulse * 0.4})`;
                        ctx.fillRect(dx - 2, dy - 2, 20, 20);
                    }
                }
                // Quartermaster's Safety Cage area (tile type 4) - just floor, cage drawn separately
                if (t===4) {
                    ctx.drawImage(GFX.floor, dx, dy);
                }
            }
        }
    }

    // Draw 5S floor markings (Amazon warehouse style)
    // Main horizontal walkways
    const walkwayY1 = 10; // Upper walkway
    const walkwayY2 = MAP_H - 8; // Lower walkway
    for (let x = 3; x < MAP_W - 3; x++) {
        const dx1 = x * TILE_SIZE - cx;
        const dy1 = walkwayY1 * TILE_SIZE - cy;
        const dy2 = walkwayY2 * TILE_SIZE - cy;
        if (dx1 > -20 && dx1 < 270) {
            if (dy1 > -20 && dy1 < 250) ctx.drawImage(GFX.floor5sLineH, dx1, dy1);
            if (dy2 > -20 && dy2 < 250) ctx.drawImage(GFX.floor5sLineH, dx1, dy2);
        }
    }
    // Main vertical walkways (aisles)
    const walkwayX1 = 6; // Left aisle
    const walkwayX2 = MAP_W - 6; // Right aisle
    for (let y = 4; y < MAP_H - 4; y++) {
        const dx1 = walkwayX1 * TILE_SIZE - cx;
        const dx2 = walkwayX2 * TILE_SIZE - cx;
        const dy = y * TILE_SIZE - cy;
        if (dy > -20 && dy < 250) {
            if (dx1 > -20 && dx1 < 270) ctx.drawImage(GFX.floor5sLineV, dx1, dy);
            if (dx2 > -20 && dx2 < 270) ctx.drawImage(GFX.floor5sLineV, dx2, dy);
        }
    }
    // Hazard tape near fire exit door
    if (GAME.fireExitDoor) {
        const doorX = GAME.fireExitDoor.x;
        const doorY = GAME.fireExitDoor.y;
        for (let i = -2; i <= 2; i++) {
            const hx = (doorX + i) * TILE_SIZE - cx;
            const hy = (doorY + 1) * TILE_SIZE - cy;
            if (hx > -20 && hx < 270 && hy > -20 && hy < 250) {
                ctx.drawImage(GFX.floor5sHazard, hx, hy);
            }
        }
    }
    // Equipment zone near PPE vending machine
    if (GAME.ppeVendingMachine) {
        const vmX = Math.floor(GAME.ppeVendingMachine.x / TILE_SIZE);
        const vmY = Math.floor(GAME.ppeVendingMachine.y / TILE_SIZE);
        const ex = vmX * TILE_SIZE - cx;
        const ey = (vmY + 1) * TILE_SIZE - cy;
        if (ex > -20 && ex < 270 && ey > -20 && ey < 250) {
            ctx.drawImage(GFX.floor5sEquip, ex, ey);
        }
    }

    GAME.clutter.forEach(c => { let img = GFX.clutter[c.type]; if(img) ctx.drawImage(img, c.x-cx, c.y-cy); });

    // Draw Amazon DVI1 Austria warehouse signs
    const signPositions = [
        { x: 5, y: 1, gfx: GFX.signAmazon },
        { x: Math.floor(MAP_W/2), y: 1, gfx: GFX.signDVI1 },
        { x: MAP_W - 7, y: 1, gfx: GFX.signAustria },
        { x: 8, y: 6, gfx: GFX.signINBOUND },
        { x: MAP_W - 12, y: 6, gfx: GFX.signOUTBOUND },
        { x: Math.floor(MAP_W/3), y: Math.floor(MAP_H/2), gfx: GFX.signPICKING },
        { x: Math.floor(MAP_W*2/3), y: Math.floor(MAP_H/2), gfx: GFX.signPACKING },
        { x: Math.floor(MAP_W/2), y: MAP_H - 4, gfx: GFX.signSHIPPING }
    ];
    signPositions.forEach(sign => {
        if (sign.gfx) {
            const sx = sign.x * TILE_SIZE - cx;
            const sy = sign.y * TILE_SIZE - cy;
            if (sx > -50 && sx < 270 && sy > -20 && sy < 250) {
                ctx.drawImage(sign.gfx, sx, sy);
            }
        }
    });

    // Draw aisle markers
    ['A','B','C','D'].forEach((row, i) => {
        [1,2,3,4].forEach(num => {
            const ax = (8 + i * 12) * TILE_SIZE - cx;
            const ay = (4 + num * 7) * TILE_SIZE - cy;
            const marker = GFX['aisle' + row + num];
            if (marker && ax > -20 && ax < 270 && ay > -20 && ay < 250) {
                ctx.drawImage(marker, ax, ay);
            }
        });
    });

    // === DRAW QUARTERMASTER'S SAFETY CAGE ===
    if (GAME.quartermasterDoor) {
        const cageX = GAME.quartermasterDoor.x - TILE_SIZE - cx;
        const cageY = GAME.quartermasterDoor.y - TILE_SIZE - cy;

        if (cageX > -60 && cageX < 280 && cageY > -60 && cageY < 260) {
            ctx.save();
            // Draw cage with pulsing glow effect
            const pulse = Math.sin(GAME.ticks * 0.06) * 0.4 + 0.6;
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 10 * pulse;
            ctx.drawImage(GFX.quartermasterDoor, cageX, cageY);
            ctx.shadowBlur = 0;

            // Draw floating "UPGRADES" indicator above the cage
            if (GFX.ppeIndicator) {
                const bobOffset = Math.sin(GAME.ticks * 0.1) * 3;
                const indicatorX = cageX + 8;
                const indicatorY = cageY - 18 + bobOffset;
                ctx.globalAlpha = 0.8 + Math.sin(GAME.ticks * 0.08) * 0.2;
                ctx.drawImage(GFX.ppeIndicator, indicatorX, indicatorY);
                ctx.globalAlpha = 1;
            }
            ctx.restore();
        }
    }

    // === PPE BUFF: AR Helmet - Auto-tag hazards with glowing outline ===
    const hasHazardReveal = hasPPEBuff('hazard_reveal');
    GAME.activeIssues.forEach(h => {
        if(!h.fixed) {
            const hx = h.x - cx;
            const hy = h.y - cy;

            // AR Helmet effect: glowing outline around hazards
            if (hasHazardReveal) {
                const pulse = Math.sin(GAME.ticks * 0.15) * 0.3 + 0.7;
                ctx.save();
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 8 * pulse;
                ctx.strokeStyle = `rgba(0, 255, 0, ${pulse})`;
                ctx.lineWidth = 2;
                ctx.strokeRect(hx - 2, hy - 2, 20, 20);
                // Draw distance indicator
                const dist = Math.hypot(h.x - GAME.player.x, h.y - GAME.player.y);
                if (dist < 150) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '5px monospace';
                    ctx.fillText('!', hx + 6, hy - 4);
                }
                ctx.restore();
            }

            let img = GFX.hazards[h.data.type] || GFX.hazards.box;
            ctx.drawImage(img, hx, hy);
        }
    });

    // === WAREHOUSE ATMOSPHERE RENDERING ===
    if (GAME.state === 'PLAY' || GAME.state === 'BOSS') {
        // Draw conveyor belts with animated texture
        const conveyorOffset = (GAME.ticks * 0.5) % 8;
        GAME.conveyorBelts.forEach(belt => {
            const dx = belt.x - cx;
            const dy = belt.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.conveyorBelt, dx, dy);
                // Animated belt line
                ctx.fillStyle = '#555';
                const lineOffset = belt.dir > 0 ? conveyorOffset : -conveyorOffset;
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(dx + ((lineOffset + i * 8) % 16), dy + 7, 3, 2);
                }
            }
        });

        // Draw packages on conveyors
        GAME.packages.forEach(pkg => {
            const dx = pkg.x - cx;
            const dy = pkg.y - cy;
            if (dx > -20 && dx < 272 && dy > -20 && dy < 240) {
                const sprite = pkg.type === 'small' ? GFX.packageSmall : GFX.packageLarge;
                ctx.drawImage(sprite, dx, dy);
            }
        });

        // Draw pallet stacks (static)
        GAME.palletStacks.forEach(pallet => {
            const dx = pallet.x - cx;
            const dy = pallet.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.palletStack, dx, dy);
            }
        });

        // Draw sorting stations
        GAME.sortStations.forEach(station => {
            const dx = station.x - cx;
            const dy = station.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                ctx.drawImage(GFX.sortStation, dx, dy);
            }
        });

        // Draw warehouse zone signs
        GAME.warehouseSigns.forEach(sign => {
            const dx = sign.x - cx;
            const dy = sign.y - cy;
            if (dx > -16 && dx < 272 && dy > -16 && dy < 240) {
                if (sign.type === 'pick') ctx.drawImage(GFX.signPick, dx, dy);
                else if (sign.type === 'pack') ctx.drawImage(GFX.signPack, dx, dy);
                else if (sign.type === 'ship') ctx.drawImage(GFX.signShip, dx, dy);
            }
        });

        // Draw cart workers
        GAME.cartWorkers.forEach(worker => {
            const dx = worker.x - cx;
            const dy = worker.y - cy;
            if (dx > -24 && dx < 272 && dy > -20 && dy < 240) {
                ctx.save();
                if (worker.dir < 0) {
                    // Flip horizontally when going left
                    ctx.translate(dx + 10, dy);
                    ctx.scale(-1, 1);
                    ctx.drawImage(GFX.cartWorker, -10, 0);
                } else {
                    ctx.drawImage(GFX.cartWorker, dx, dy);
                }
                ctx.restore();
            }
        });
    }

    let renderList = [GAME.player, ...GAME.entities, ...GAME.projectiles];
    if (GAME.state === 'BOSS' && GAME.boss) renderList.push(GAME.boss);
    renderList.sort((a,b) => a.y - b.y);

    // Performance: Cache screen bounds for visibility culling
    const screenPadding = 32; // Extra padding for large sprites
    const screenLeft = -screenPadding;
    const screenRight = canvas.width + screenPadding;
    const screenTop = -screenPadding;
    const screenBottom = canvas.height + screenPadding;

    // Draw footprints (under entities/player)
    // Note: Erwin doesn't leave footprints (he's in a Tesla!)
    for (const fp of GAME.footprints) {
        const fpx = fp.x - cx;
        const fpy = fp.y - cy;
        if (fpx < screenLeft || fpx > screenRight || fpy < screenTop || fpy > screenBottom) continue;
        const alpha = Math.max(0, fp.life / fp.maxLife) * 0.4;
        ctx.fillStyle = `rgba(40, 40, 40, ${alpha})`;
        // Draw as small shoe prints
        ctx.fillRect(fpx - 2, fpy, 2, 3);
        ctx.fillRect(fpx + 1, fpy, 2, 3);
    }

    renderList.forEach(e => {
        let dx = Math.floor(e.x - cx); let dy = Math.floor(e.y - cy);
        // Performance: Skip offscreen entities
        if (dx < screenLeft || dx > screenRight || dy < screenTop || dy > screenBottom) return;

        if (e.maxHp) {
            let img = (e.sprite && GFX[e.sprite]) ? GFX[e.sprite] : GFX.boss_manager;
            if (e.name === "SIMON") img = GFX.simonBoss;
            if (e.name === "MEGA SIMON") img = GFX.simonBoss;
            if (e.name === "MECHA MEGA SIMON" || e.isMecha) img = GFX.mechaMegaSimon;
            // Draw Mecha Mega Simon larger (48x48) vs normal bosses (32x32)
            const bossSize = (e.isMecha || e.name === "MECHA MEGA SIMON") ? 48 : 32;

            // üî• DESPERATION MODE: Pulsing red glow effect!
            if (e.desperationMode) {
                const glowPulse = Math.sin(GAME.ticks * 0.2) * 8 + 24;
                const glowGrad = ctx.createRadialGradient(
                    dx + 16, dy + 16, 8,
                    dx + 16, dy + 16, glowPulse
                );
                glowGrad.addColorStop(0, 'rgba(255, 0, 0, 0.5)');
                glowGrad.addColorStop(0.5, 'rgba(255, 69, 0, 0.3)');
                glowGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = glowGrad;
                ctx.fillRect(dx - glowPulse, dy - glowPulse, bossSize + glowPulse * 2, bossSize + glowPulse * 2);
            }

            ctx.drawImage(img, dx - (bossSize - 32)/2, dy - (bossSize - 32)/2, bossSize, bossSize);
        } else {
            if (e.type === 'simon') {
                ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(dx+8, dy+14, 6, 3, 0, 0, Math.PI*2); ctx.fill();
                ctx.drawImage(GFX.simon, dx, dy);
            }
            else if (e.type === 'ops') {
                // AR Helmet effect: Tag OPS managers with red glow
                if (hasHazardReveal) {
                    const pulse = Math.sin(GAME.ticks * 0.15) * 0.3 + 0.7;
                    ctx.save();
                    ctx.shadowColor = '#ff4444';
                    ctx.shadowBlur = 8 * pulse;
                    ctx.strokeStyle = `rgba(255, 68, 68, ${pulse})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(dx - 2, dy - 2, 20, 20);
                    // Distance-based "!" indicator
                    const dist = Math.hypot(e.x - GAME.player.x, e.y - GAME.player.y);
                    if (dist < 120) {
                        ctx.fillStyle = '#ff4444';
                        ctx.font = '6px monospace';
                        ctx.fillText('!', dx + 6, dy - 4);
                    }
                    ctx.restore();
                }
                ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(dx+8, dy+14, 6, 3, 0, 0, Math.PI*2); ctx.fill();
                ctx.drawImage(GFX.ops, dx, dy);
            }
            else if (e.type === 'assoc') {
                ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(dx+8, dy+14, 6, 3, 0, 0, Math.PI*2); ctx.fill();
                ctx.drawImage(GFX.assoc, dx, dy);
            }
            else if (e.type === 'runner') {
                // AR Helmet effect: Tag runners with orange glow
                if (hasHazardReveal) {
                    const pulse = Math.sin(GAME.ticks * 0.15) * 0.3 + 0.7;
                    ctx.save();
                    ctx.shadowColor = '#ff9900';
                    ctx.shadowBlur = 8 * pulse;
                    ctx.strokeStyle = `rgba(255, 153, 0, ${pulse})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(dx - 2, dy - 2, 20, 20);
                    // Distance-based "!" indicator
                    const dist = Math.hypot(e.x - GAME.player.x, e.y - GAME.player.y);
                    if (dist < 120) {
                        ctx.fillStyle = '#ff9900';
                        ctx.font = '6px monospace';
                        ctx.fillText('!', dx + 6, dy - 4);
                    }
                    ctx.restore();
                }
                ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(dx+8, dy+14, 6, 3, 0, 0, Math.PI*2); ctx.fill();
                ctx.drawImage(GFX.runner, dx, dy);
            }
            else if (e === GAME.player) {
                // Player sprite (16x16 with built-in shadow)
                if (e.iframe%4 < 2) ctx.drawImage(GFX.chars[GAME.selectedChar], dx, dy);
                // Cooldown bar for 16x16 sprite
                if (e.cooldown > 0) {
                    ctx.fillStyle = '#555'; ctx.fillRect(dx, dy-6, 16, 3);
                    ctx.fillStyle = '#00ffff'; ctx.fillRect(dx, dy-6, 16 * (1 - e.cooldown/Math.max(1, e.cooldownMax || 120)), 3);
                }
                // Ready indicator for 16x16 sprite
                else { ctx.fillStyle = '#00ff00'; ctx.fillRect(dx+6, dy-8, 4, 4); }
            }
            else if (e.type === 'attack') {
                const sprite = (GFX.attacks && GFX.attacks[e.owner]) ? GFX.attacks[e.owner] : GFX.book;
                ctx.drawImage(sprite, dx+2, dy+4);
            }
            else if (e.type === 'book') ctx.drawImage(GFX.book, dx, dy);
            else if (e.type === 'req') { if (e.boss) ctx.drawImage(GFX.bossProj, dx, dy); else ctx.drawImage(GFX.req, dx, dy); }
        }
    });

    // Performance: Batch particle rendering with visibility checks
    const particles = GAME.particles;
    const particleLen = particles.length;
    for (let i = 0; i < particleLen; i++) {
        const p = particles[i];
        const px = p.x - cx;
        const py = p.y - cy;
        // Skip offscreen particles
        if (px < -10 || px > canvas.width + 10 || py < -10 || py > canvas.height + 10) continue;

        const alpha = p.alpha || (p.life / 50);
        ctx.globalAlpha = Math.min(1, alpha);
        if (p.sparkle) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(px - 1, py, 3, 1);
            ctx.fillRect(px, py - 1, 1, 3);
        }
        ctx.fillStyle = p.color;
        ctx.fillRect(px, py, p.size || 2, p.size || 2);
    }
    ctx.globalAlpha = 1;

    // Render Floating Text with fade out and shrink effect
    ctx.textAlign = 'center';
    const texts = GAME.floatingTexts;
    const textsLen = texts.length;
    for (let i = 0; i < textsLen; i++) {
        const t = texts[i];
        const dx = Math.floor(t.x - cx);
        const dy = Math.floor(t.y - cy);
        // Skip offscreen texts
        if (dx < -50 || dx > canvas.width + 50 || dy < -20 || dy > canvas.height + 20) continue;

        const lifePercent = t.life / GAME_CONSTANTS.FLOATING_TEXT_LIFE;

        // Fade out slowly in the last 30% of life
        let alpha = 1.0;
        if (lifePercent < 0.3) {
            alpha = lifePercent / 0.3; // Smooth fade out
        }

        // Shrink gradually from 100% to 70% size over entire lifetime
        const scale = 0.7 + (lifePercent * 0.3);
        const baseFontSize = 8;
        const fontSize = Math.max(5, Math.floor(baseFontSize * scale));

        ctx.save();
        ctx.globalAlpha = Math.max(0.1, Math.min(1, alpha));
        ctx.font = `${fontSize}px "Press Start 2P"`;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeText(t.text, dx, dy);
        ctx.fillStyle = t.color;
        ctx.fillText(t.text, dx, dy);
        ctx.restore();
    }
    ctx.textAlign = 'left'; // Reset

    // === WAREHOUSE EVENT: ENERGY CUTOFF - Flashlight effect ===
    if (GAME.flashlightMode && GAME.state === 'PLAY') {
        const px = GAME.player.x - cx + 8;
        const py = GAME.player.y - cy + 8;
        const radius = GAME.flashlightRadius || 45;

        // Create dark overlay with circular cutout
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Cut out the flashlight circle using composite operation
        ctx.globalCompositeOperation = 'destination-out';
        const gradient = ctx.createRadialGradient(px, py, 0, px, py, radius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();

        // Add flickering emergency light effect
        if (Math.random() < 0.03) {
            ctx.fillStyle = 'rgba(255, 50, 50, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }

    // === WAREHOUSE EVENT: Warning Overlay ===
    if (GAME.warehouseEvent && GAME.warehouseEvent.warningPhase === 1 && GAME.state === 'PLAY') {
        const ev = GAME.warehouseEvent;
        const t = ev.warningTimer;

        // Dark overlay that fades in
        const fadeIn = Math.min(1, t / 30);
        ctx.fillStyle = `rgba(0, 0, 0, ${fadeIn * 0.7})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Warning text
        ctx.save();
        ctx.textAlign = 'center';

        // Main warning - pulsing
        const pulse = Math.sin(t * 0.2) * 0.3 + 0.7;
        ctx.globalAlpha = pulse;
        ctx.font = '12px "Press Start 2P"';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 4;
        const warningText = getLocalizedEventText(ev.type, 'warning');
        ctx.strokeText(warningText, canvas.width / 2, canvas.height / 2 - 15);
        ctx.fillStyle = '#ff9900';
        ctx.fillText(warningText, canvas.width / 2, canvas.height / 2 - 15);

        // Subtitle
        ctx.globalAlpha = fadeIn;
        ctx.font = '7px "Press Start 2P"';
        const subtitleText = getLocalizedEventText(ev.type, 'subtitle');
        ctx.strokeText(subtitleText, canvas.width / 2, canvas.height / 2 + 10);
        ctx.fillStyle = '#ffffff';
        ctx.fillText(subtitleText, canvas.width / 2, canvas.height / 2 + 10);

        ctx.textAlign = 'left';
        ctx.globalAlpha = 1;
        ctx.restore();
    }

    // === WAREHOUSE EVENT: Active Event Indicator (bottom center) ===
    if (GAME.warehouseEvent && GAME.warehouseEvent.active && GAME.state === 'PLAY') {
        const ev = GAME.warehouseEvent;
        const remaining = Math.ceil((ev.type.duration - ev.timer) / 60);

        ctx.save();
        ctx.font = '6px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;

        const eventName = getLocalizedEventText(ev.type, 'warning');
        const timerText = `${eventName}: ${remaining}s`;

        // Draw at bottom center, above the footer area
        ctx.strokeText(timerText, canvas.width / 2, canvas.height - 8);
        ctx.fillStyle = '#ff9900';
        ctx.fillText(timerText, canvas.width / 2, canvas.height - 8);

        ctx.textAlign = 'left';
        ctx.restore();
    }

    // === FIRE DRILL: Screen flash effect ===
    if (GAME.fireDrillActive && GAME.state === 'PLAY') {
        if (GAME.warehouseEvent && GAME.warehouseEvent.timer % 15 < 8) {
            ctx.fillStyle = 'rgba(255, 100, 50, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }

    if (GAME.flash > 0) { ctx.globalAlpha = GAME.flash / 10; ctx.fillStyle = 'white'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.globalAlpha = 1.0; }

    // üî• DESPERATION MODE - Full screen red pulse effect
    if (GAME.state === 'BOSS' && GAME.boss && GAME.boss.desperationMode) {
        const pulse = Math.sin(GAME.ticks * 0.1) * 0.5 + 0.5; // Pulsing value between 0 and 1
        ctx.globalAlpha = pulse * 0.15; // Max 15% opacity for red overlay
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1.0;
    }

    // üî• DESPERATION MODE WARNING - Pulsing text below boss health bar
    if (GAME.state === 'BOSS' && GAME.boss && GAME.boss.desperationMode) {
        const pulse = Math.sin(GAME.ticks * 0.15) * 0.3 + 0.7; // Pulsing alpha between 0.4 and 1.0
        ctx.globalAlpha = pulse;
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeText("* DESPERATION MODE! *", canvas.width / 2, 60);
        ctx.fillStyle = '#ff0000';
        ctx.fillText("* DESPERATION MODE! *", canvas.width / 2, 60);
        ctx.globalAlpha = 1.0;
        ctx.textAlign = 'left';
    }

    ctx.restore();
}

function updateCamera() {
    GAME.camera.x = Math.max(0, Math.min(GAME.player.x - 120, MAP_W*TILE_SIZE - 256));
    GAME.camera.y = Math.max(0, Math.min(GAME.player.y - 100, MAP_H*TILE_SIZE - 224));
}

// Frame rate independence - target 60 FPS
let lastFrameTime = performance.now();
const TARGET_FPS = 60;
const TARGET_FRAME_TIME = 1000 / TARGET_FPS;

function loop() {
    const now = performance.now();
    const elapsed = now - lastFrameTime;

    // Only update game logic when enough time has passed (targeting 60 FPS)
    if (elapsed >= TARGET_FRAME_TIME) {
        // Handle multiple frames if we're running behind (but cap at 3 to prevent spiral)
        const framesToRun = Math.min(Math.floor(elapsed / TARGET_FRAME_TIME), 3);
        for (let i = 0; i < framesToRun; i++) {
            update();
        }
        lastFrameTime = now - (elapsed % TARGET_FRAME_TIME);
    }

    draw();
    requestAnimationFrame(loop);
}

// Wait for fonts to load before starting the game
// This ensures Press Start 2P is available for canvas rendering
document.fonts.ready.then(() => {
    // Double-check the Press Start 2P font is loaded
    document.fonts.load('12px "Press Start 2P"').then(() => {
        init();
    });
});
</script>
</body>
</html>
